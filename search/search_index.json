{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"support/","title":"eunomia-bpf","text":"<p>Mainpage: https://github.com/eunomia-bpf/eunomia-bpf Github Issue: https://github.com/eunomia-bpf/eunomia-bpf/issues</p>"},{"location":"support/#wasm-bpf","title":"wasm-bpf","text":"<p>Mainpage: https://github.com/eunomia-bpf/wasm-bpf Github Issue: https://github.com/eunomia-bpf/wasm-bpf/issues</p>"},{"location":"support/#email","title":"Email","text":"<p>team@eunomia.dev</p>"},{"location":"architecture/","title":"Project Architecture","text":"<p>we have a loader library, a compile toolchain, and some additional tools like cli and a custom metrics exporter.</p> <p></p>"},{"location":"architecture/#an-bpf-loader-rs-library","title":"An bpf-loader-rs library","text":"<p>A wrapper of main functions of libbpf-rs, provide the ability to dynamically load eBPF code to the kernel and run it with a simple JSON and a few API.</p> <p>see bpf-loader-rs for details.</p> <p>A simple cli interface is provided for bpf-loader library, which you can use it to start any eBPF program from a url in a command. You can download it from release.</p> <p>see examples for more examples.</p>"},{"location":"architecture/#a-library-to-load-and-operate-ebpf-program-from-a-wasm-module","title":"A library to load and operate eBPF program from a WASM module","text":"<p>Use the <code>eunomia-bpf</code> library to load <code>eBPF</code> program from a <code>WASM</code> module, you can write a WASM module to operate the eBPF program or process the data in user space <code>WASM</code> runtime. The idea is simple:</p> <ol> <li>compile the kernel eBPF code skeleton to the <code>JSON</code> format with <code>eunomia-cc</code> toolchain</li> <li>embed the <code>JSON</code> data in the <code>WASM</code> module, and provide some API for operating the eBPF program skeleton</li> <li>load the <code>JSON</code> data from the <code>WASM</code> module and run the eBPF program skeleton with <code>eunomia-bpf</code> library</li> </ol> <p>You can have multiple <code>eBPF</code> program in a single <code>WASM</code> module.</p> <p>See wasm-runtime for details. In fact, <code>wasm-bpf</code> library only exports a few functions from <code>bpf-loader</code> library to the <code>VM</code>, so you can replace the <code>WASM</code> runtime with your own easily.</p> <p>For example, you can run an eBPF program with a WASM module for an URL:</p> <pre><code>sudo ./ecli run https://eunomia-bpf.github.io/eunomia-bpf/sigsnoop/app.wasm\n</code></pre> <p>You can also generate a WASM program template for eBPF or build WASM module with <code>compiler</code> container:</p> <pre><code># for x86_64 and aarch64\ndocker run -it -v `pwd`/:/src/ ghcr.io/eunomia-bpf/ecc-`uname -m`:latest gen-wasm-skel # generate WASM app template for eBPF\ndocker run -it -v `pwd`/:/src/ ghcr.io/eunomia-bpf/ecc-`uname -m`:latest build-wasm    # Build WASM module\n</code></pre> <p>see sigsnoop example for more detail.</p>"},{"location":"architecture/#a-compile-toolchain-to-help-you-generate-pre-compiled-ebpf-data","title":"A compile toolchain to help you generate pre compiled eBPF data","text":"<p>The toolchain can be used as a docker to generate pre-compiled eBPF data in one command:</p> <p>see the compile toolchains compiler for details.</p> <p>you can also simply use the ebpm-template repo as a template in github, just push to it and github action can help you compile CO-RE ebpf code!</p>"},{"location":"architecture/#other-related-projects","title":"other related projects","text":"<ul> <li> <p>LMP eBPF Hub: github.com/linuxkerneltravel/lmp</p> <p>a package manager for eBPF based on wasm modules</p> </li> <li> <p>bolipi online compiler &amp; runner: https://bolipi.com/ebpf/home/online</p> <p>an online compiler and runner for eBPF program newbies</p> </li> <li> <p>An Observability tool</p> <p>An prometheus and OpenTelemetry exporter for custom eBPF metrics, written in async rust: eunomia-exporter. You can compile it or download from release</p> </li> </ul>"},{"location":"blogs/","title":"Blog","text":"<p>Blogs about eunomia-bpf:</p> <ul> <li>Wasm-bpf: \u67b6\u8d77 Webassembly \u548c eBPF \u5185\u6838\u53ef\u7f16\u7a0b\u7684\u6865\u6881</li> <li>\u5728 WebAssembly \u4e2d\u4f7f\u7528 C/C++ \u548c libbpf \u7f16\u5199 eBPF \u7a0b\u5e8f</li> <li>\u5728 WebAssembly \u4e2d\u4f7f\u7528 Rust \u7f16\u5199 eBPF \u7a0b\u5e8f\u5e76\u53d1\u5e03 OCI \u955c\u50cf</li> <li>\u4f7f\u7528 ChatGPT \uff0c\u901a\u8fc7\u81ea\u7136\u8bed\u8a00\u7f16\u5199 eBPF \u7a0b\u5e8f\u548c\u8ffd\u8e2a Linux \u7cfb\u7edf</li> <li>\u5f53 Wasm \u9047\u89c1 eBPF \uff1a\u4f7f\u7528 WebAssembly \u7f16\u5199\u3001\u5206\u53d1\u3001\u52a0\u8f7d\u8fd0\u884c eBPF \u7a0b\u5e8f</li> <li>\u5982\u4f55\u5728 Linux \u663e\u5fae\u955c\uff08LMP\uff09\u9879\u76ee\u4e2d\u5f00\u542f eBPF \u4e4b\u65c5</li> <li>eunomia-bpf 0.3.0 \u53d1\u5e03\uff1a\u53ea\u9700\u7f16\u5199\u5185\u6838\u6001\u4ee3\u7801\uff0c\u8f7b\u677e\u6784\u5efa\u3001\u6253\u5305\u3001\u53d1\u5e03\u5b8c\u6574\u7684 eBPF \u5e94\u7528</li> <li>eunomia-bpf\uff1a\u5c55\u671b 2023\uff0c\u8ba9 eBPF \u63d2\u4e0a Wasm \u7684\u7fc5\u8180</li> <li>eBPF \u8fdb\u9636: \u5185\u6838\u65b0\u7279\u6027\u8fdb\u5c55\u4e00\u89c8</li> <li>ecli \u5728\u5b89\u5353 13 \u4e0a\u7684\u8fd0\u884c\u6d4b\u8bd5</li> </ul>"},{"location":"blogs/0_3_0-release.zh/","title":"eunomia-bpf 0.3.0 \u53d1\u5e03\uff1a\u53ea\u9700\u7f16\u5199\u5185\u6838\u6001\u4ee3\u7801\uff0c\u8f7b\u677e\u6784\u5efa\u3001\u6253\u5305\u3001\u53d1\u5e03\u5b8c\u6574\u7684 eBPF \u5e94\u7528","text":""},{"location":"blogs/0_3_0-release.zh/#httpszhuanlanzhihucomp589784295","title":"! https://zhuanlan.zhihu.com/p/589784295","text":""},{"location":"blogs/0_3_0-release.zh/#eunomia-bpf","title":"eunomia-bpf \u7b80\u4ecb","text":"<p>eBPF \u6e90\u4e8e BPF\uff0c\u672c\u8d28\u4e0a\u662f\u5904\u4e8e\u5185\u6838\u4e2d\u7684\u4e00\u4e2a\u9ad8\u6548\u4e0e\u7075\u6d3b\u7684\u865a\u62df\u673a\u7ec4\u4ef6\uff0c\u4ee5\u4e00\u79cd\u5b89\u5168\u7684\u65b9\u5f0f\u5728\u8bb8\u591a\u5185\u6838 hook \u70b9\u6267\u884c\u5b57\u8282\u7801\uff0c\u5f00\u53d1\u8005\u53ef\u57fa\u4e8e eBPF \u5f00\u53d1\u6027\u80fd\u5206\u6790\u5de5\u5177\u3001\u8f6f\u4ef6\u5b9a\u4e49\u7f51\u7edc\u3001\u5b89\u5168\u7b49\u8bf8\u591a\u573a\u666f\u3002\u4f46\u662f\uff0c\u76ee\u524d\u5bf9\u4e8e\u5f00\u53d1\u548c\u4f7f\u7528 eBPF \u5e94\u7528\u800c\u8a00\u8fd8\u53ef\u80fd\u5b58\u5728\u4e00\u4e9b\u4e0d\u591f\u65b9\u4fbf\u7684\u5730\u65b9\uff1a</p> <ul> <li>\u642d\u5efa\u548c\u5f00\u53d1 eBPF \u7a0b\u5e8f\u662f\u4e00\u4e2a\u95e8\u69db\u6bd4\u8f83\u9ad8\u3001\u6bd4\u8f83\u590d\u6742\u7684\u5de5\u4f5c\uff0c\u5fc5\u987b\u540c\u65f6\u5173\u6ce8\u5185\u6838\u6001\u548c\u7528\u6237\u6001\u4e24\u4e2a\u65b9\u9762\u7684\u4ea4\u4e92\u548c\u4fe1\u606f\u5904\u7406\uff0c\u6709\u65f6\u8fd8\u8981\u914d\u7f6e\u73af\u5883\u548c\u7f16\u5199\u5bf9\u5e94\u7684\u6784\u5efa\u811a\u672c\uff1b</li> <li>\u76ee\u524d\u4e0d\u540c\u7528\u6237\u6001\u8bed\u8a00\u5982 C\u3001Go\u3001Rust \u7b49\u7f16\u5199\u7684\u5de5\u5177\u96be\u4ee5\u517c\u5bb9\u3001\u96be\u4ee5\u7edf\u4e00\u7ba1\u7406\uff0c\u591a\u79cd\u5f00\u53d1\u751f\u6001\u96be\u4ee5\u6574\u5408\uff1a\u5982\u4f55\u8de8\u67b6\u6784\u3001\u8de8\u8bed\u8a00\u548c\u5185\u6838\u7248\u672c\uff0c\u4f7f\u7528\u6807\u51c6\u5316\u7684\u65b9\u5f0f\u65b9\u4fbf\u53c8\u5feb\u6377\u7684\u6253\u5305\u3001\u5206\u53d1\u3001\u53d1\u5e03\u4e8c\u8fdb\u5236 eBPF \u7a0b\u5e8f\uff0c\u540c\u65f6\u8fd8\u9700\u8981\u80fd\u5f88\u65b9\u4fbf\u5730\u52a8\u6001\u8c03\u6574 eBPF \u7a0b\u5e8f\u7684\u6302\u8f7d\u70b9\u3001\u53c2\u6570\u7b49\u7b49\uff1f</li> <li>\u5982\u4f55\u66f4\u65b9\u4fbf\u5730\u4f7f\u7528 eBPF \u7684\u5de5\u5177\uff1a\u6709\u6ca1\u6709\u53ef\u80fd\u4ece\u4e91\u7aef\u4e00\u884c\u547d\u4ee4\u62c9\u4e0b\u6765\u5c31\u4f7f\u7528\uff0c\u7c7b\u4f3c docker \u90a3\u6837\uff1f\u6216\u8005\u628a eBPF \u7a0b\u5e8f\u4f5c\u4e3a\u670d\u52a1\u8fd0\u884c\uff0c\u901a\u8fc7 HTTP \u8bf7\u6c42\u548c URL \u5373\u53ef\u70ed\u66f4\u65b0\u3001\u52a8\u6001\u63d2\u62d4\u8fd0\u884c\u4efb\u610f\u4e00\u4e2a eBPF \u7a0b\u5e8f\uff1f</li> </ul> <p>eunomia-bpf \u662f\u4e00\u4e2a\u5f00\u6e90\u7684 eBPF \u52a8\u6001\u52a0\u8f7d\u8fd0\u884c\u65f6\u548c\u5f00\u53d1\u5de5\u5177\u94fe\uff0c\u662f\u4e3a\u4e86\u7b80\u5316 eBPF \u7a0b\u5e8f\u7684\u5f00\u53d1\u3001\u6784\u5efa\u3001\u5206\u53d1\u3001\u8fd0\u884c\u800c\u8bbe\u8ba1\u7684\uff0c\u57fa\u4e8e libbpf \u7684 CO-RE \u8f7b\u91cf\u7ea7\u5f00\u53d1\u6846\u67b6\u3002</p> <p>\u4f7f\u7528 eunomia-bpf \uff0c\u53ef\u4ee5\uff1a</p> <ul> <li>\u5728\u7f16\u5199 eBPF \u7a0b\u5e8f\u6216\u5de5\u5177\u65f6\u53ea\u7f16\u5199\u5185\u6838\u6001\u4ee3\u7801\uff0c\u81ea\u52a8\u83b7\u53d6\u5185\u6838\u6001\u5bfc\u51fa\u4fe1\u606f\uff1b</li> <li>\u4f7f\u7528 Wasm \u8fdb\u884c\u7528\u6237\u6001\u4ea4\u4e92\u7a0b\u5e8f\u7684\u5f00\u53d1\uff0c\u5728 Wasm \u865a\u62df\u673a\u5185\u90e8\u63a7\u5236\u6574\u4e2a eBPF \u7a0b\u5e8f\u7684\u52a0\u8f7d\u548c\u6267\u884c\uff0c\u4ee5\u53ca\u5904\u7406\u76f8\u5173\u6570\u636e\uff1b</li> <li>eunomia-bpf \u53ef\u4ee5\u5c06\u9884\u7f16\u8bd1\u7684 eBPF \u7a0b\u5e8f\u6253\u5305\u4e3a\u901a\u7528\u7684 JSON \u6216 Wasm \u6a21\u5757\uff0c\u8de8\u67b6\u6784\u548c\u5185\u6838\u7248\u672c\u8fdb\u884c\u5206\u53d1\uff0c\u65e0\u9700\u91cd\u65b0\u7f16\u8bd1\u5373\u53ef\u52a8\u6001\u52a0\u8f7d\u8fd0\u884c\u3002</li> </ul> <p>eunomia-bpf \u7531\u4e00\u4e2a\u7f16\u8bd1\u5de5\u5177\u94fe\u548c\u4e00\u4e2a\u8fd0\u884c\u65f6\u5e93\u7ec4\u6210, \u5bf9\u6bd4\u4f20\u7edf\u7684 BCC\u3001\u539f\u751f libbpf \u7b49\u6846\u67b6\uff0c\u5927\u5e45\u7b80\u5316\u4e86 eBPF \u7a0b\u5e8f\u7684\u5f00\u53d1\u6d41\u7a0b\uff0c\u5728\u5927\u591a\u6570\u65f6\u5019\u53ea\u9700\u7f16\u5199\u5185\u6838\u6001\u4ee3\u7801\uff0c\u5373\u53ef\u8f7b\u677e\u6784\u5efa\u3001\u6253\u5305\u3001\u53d1\u5e03\u5b8c\u6574\u7684 eBPF \u5e94\u7528\uff0c\u540c\u65f6\u5185\u6838\u6001 eBPF \u4ee3\u7801\u4fdd\u8bc1\u548c\u4e3b\u6d41\u7684 libbpf, libbpfgo, libbpf-rs \u7b49\u5f00\u53d1\u6846\u67b6\u7684 100% \u517c\u5bb9\u6027\u3002\u9700\u8981\u7f16\u5199\u7528\u6237\u6001\u4ee3\u7801\u7684\u65f6\u5019\uff0c\u4e5f\u53ef\u4ee5\u501f\u52a9 Webassembly(Wasm) \u5b9e\u73b0\u901a\u8fc7\u591a\u79cd\u8bed\u8a00\u8fdb\u884c\u7528\u6237\u6001\u5f00\u53d1\u3002\u548c bpftrace \u7b49\u811a\u672c\u5de5\u5177\u76f8\u6bd4, eunomia-bpf \u4fdd\u7559\u4e86\u7c7b\u4f3c\u7684\u4fbf\u6377\u6027, \u540c\u65f6\u4e0d\u4ec5\u5c40\u9650\u4e8e trace \u65b9\u9762, \u53ef\u4ee5\u7528\u4e8e\u66f4\u591a\u7684\u573a\u666f, \u5982\u7f51\u7edc\u3001\u5b89\u5168\u7b49\u7b49\u3002</p> <ul> <li>eunomia-bpf \u9879\u76ee Github \u5730\u5740: https://github.com/eunomia-bpf/eunomia-bpf</li> <li>gitee \u955c\u50cf: https://gitee.com/anolis/eunomia</li> </ul> <p>\u6211\u4eec\u53d1\u5e03\u4e86\u6700\u65b0\u7684 0.3 \u7248\u672c, \u5bf9\u4e8e\u6574\u4f53\u7684\u5f00\u53d1\u548c\u4f7f\u7528\u6d41\u7a0b\u8fdb\u884c\u4e86\u4f18\u5316\uff0c\u540c\u65f6\u4e5f\u652f\u6301\u4e86\u66f4\u591a\u7684 eBPF \u7a0b\u5e8f\u548c maps \u7c7b\u578b\u3002</p>"},{"location":"blogs/0_3_0-release.zh/#_1","title":"\u8fd0\u884c\u65f6\u4f18\u5316\uff1a\u589e\u5f3a\u529f\u80fd\u6027, \u589e\u52a0\u591a\u79cd\u7a0b\u5e8f\u7c7b\u578b","text":"<ol> <li> <p>\u53ea\u9700\u7f16\u5199\u5185\u6838\u6001\u4ee3\u7801, \u5373\u53ef\u83b7\u5f97\u5bf9\u5e94\u7684\u8f93\u51fa\u4fe1\u606f, \u4ee5\u53ef\u8bfb\u3001\u89c4\u6574\u7684\u65b9\u5f0f\u6253\u5370\u5230\u6807\u51c6\u8f93\u51fa. \u4ee5\u4e00\u4e2a\u7b80\u5355\u7684 eBPF \u7a0b\u5e8f, \u8ddf\u8e2a\u6240\u6709 open \u7c7b\u578b\u7cfb\u7edf\u8c03\u7528\u7684 opensnoop \u4e3a\u4f8b:</p> <p>\u5934\u6587\u4ef6 opensnoop.h</p> <pre><code>#ifndef __OPENSNOOP_H\n#define __OPENSNOOP_H\n#define TASK_COMM_LEN 16\n#define NAME_MAX 255\n#define INVALID_UID ((uid_t)-1)\n// used for export event\nstruct event {\n/* user terminology for pid: */\nunsigned long long ts;\nint pid;\nint uid;\nint ret;\nint flags;\nchar comm[TASK_COMM_LEN];\nchar fname[NAME_MAX];\n};\n#endif /* __OPENSNOOP_H */\n</code></pre> <p>\u5185\u6838\u6001\u4ee3\u7801 opensnoop.bpf.c</p> <pre><code>#include &lt;vmlinux.h&gt;\n#include &lt;bpf/bpf_helpers.h&gt;\n#include \"opensnoop.h\"\nstruct args_t {\nconst char *fname;\nint flags;\n};\n/// Process ID to trace\nconst volatile int pid_target = 0;\n/// Thread ID to trace\nconst volatile int tgid_target = 0;\n/// @description User ID to trace\nconst volatile int uid_target = 0;\n/// @cmdarg {\"default\": false, \"short\": \"f\", \"long\": \"failed\"}\nconst volatile bool targ_failed = false;\nstruct {\n__uint(type, BPF_MAP_TYPE_HASH);\n__uint(max_entries, 10240);\n__type(key, u32);\n__type(value, struct args_t);\n} start SEC(\".maps\");\nstruct {\n__uint(type, BPF_MAP_TYPE_PERF_EVENT_ARRAY);\n__uint(key_size, sizeof(u32));\n__uint(value_size, sizeof(u32));\n} events SEC(\".maps\");\nstatic __always_inline bool valid_uid(uid_t uid) {\nreturn uid != INVALID_UID;\n}\nstatic __always_inline\nbool trace_allowed(u32 tgid, u32 pid)\n{\nu32 uid;\n/* filters */\nif (tgid_target &amp;&amp; tgid_target != tgid)\nreturn false;\nif (pid_target &amp;&amp; pid_target != pid)\nreturn false;\nif (valid_uid(uid_target)) {\nuid = (u32)bpf_get_current_uid_gid();\nif (uid_target != uid) {\nreturn false;\n}\n}\nreturn true;\n}\nSEC(\"tracepoint/syscalls/sys_enter_open\")\nint tracepoint__syscalls__sys_enter_open(struct trace_event_raw_sys_enter* ctx)\n{\nu64 id = bpf_get_current_pid_tgid();\n/* use kernel terminology here for tgid/pid: */\nu32 tgid = id &gt;&gt; 32;\nu32 pid = id;\n/* store arg info for later lookup */\nif (trace_allowed(tgid, pid)) {\nstruct args_t args = {};\nargs.fname = (const char *)ctx-&gt;args[0];\nargs.flags = (int)ctx-&gt;args[1];\nbpf_map_update_elem(&amp;start, &amp;pid, &amp;args, 0);\n}\nreturn 0;\n}\nSEC(\"tracepoint/syscalls/sys_enter_openat\")\nint tracepoint__syscalls__sys_enter_openat(struct trace_event_raw_sys_enter* ctx)\n{\nu64 id = bpf_get_current_pid_tgid();\n/* use kernel terminology here for tgid/pid: */\nu32 tgid = id &gt;&gt; 32;\nu32 pid = id;\n/* store arg info for later lookup */\nif (trace_allowed(tgid, pid)) {\nstruct args_t args = {};\nargs.fname = (const char *)ctx-&gt;args[1];\nargs.flags = (int)ctx-&gt;args[2];\nbpf_map_update_elem(&amp;start, &amp;pid, &amp;args, 0);\n}\nreturn 0;\n}\nstatic __always_inline\nint trace_exit(struct trace_event_raw_sys_exit* ctx)\n{\nstruct event event = {};\nstruct args_t *ap;\nint ret;\nu32 pid = bpf_get_current_pid_tgid();\nap = bpf_map_lookup_elem(&amp;start, &amp;pid);\nif (!ap)\nreturn 0; /* missed entry */\nret = ctx-&gt;ret;\nif (targ_failed &amp;&amp; ret &gt;= 0)\ngoto cleanup; /* want failed only */\n/* event data */\nevent.pid = bpf_get_current_pid_tgid() &gt;&gt; 32;\nevent.uid = bpf_get_current_uid_gid();\nbpf_get_current_comm(&amp;event.comm, sizeof(event.comm));\nbpf_probe_read_user_str(&amp;event.fname, sizeof(event.fname), ap-&gt;fname);\nevent.flags = ap-&gt;flags;\nevent.ret = ret;\n/* emit event */\nbpf_perf_event_output(ctx, &amp;events, BPF_F_CURRENT_CPU,\n&amp;event, sizeof(event));\ncleanup:\nbpf_map_delete_elem(&amp;start, &amp;pid);\nreturn 0;\n}\nSEC(\"tracepoint/syscalls/sys_exit_open\")\nint tracepoint__syscalls__sys_exit_open(struct trace_event_raw_sys_exit* ctx)\n{\nreturn trace_exit(ctx);\n}\nSEC(\"tracepoint/syscalls/sys_exit_openat\")\nint tracepoint__syscalls__sys_exit_openat(struct trace_event_raw_sys_exit* ctx)\n{\nreturn trace_exit(ctx);\n}\n/// Trace open family syscalls.\nchar LICENSE[] SEC(\"license\") = \"GPL\";\n</code></pre> <p>\u7f16\u8bd1\u8fd0\u884c:</p> <pre><code>$ ecc opensnoop.bpf.c opensnoop.h\nCompiling bpf object...\nGenerating export types...\nPacking ebpf object and config into package.json...\n$ sudo ecli examples/bpftools/opensnoop/package.json\nTIME     TS      PID     UID     RET     FLAGS   COMM    FNAME\n20:31:50  0      1       0       51      524288  systemd /proc/614/cgroup\n20:31:50  0      33182   0       25      524288  ecli    /etc/localtime\n20:31:53  0      754     0       6       0       irqbalance /proc/interrupts\n20:31:53  0      754     0       6       0       irqbalance /proc/stat\n20:32:03  0      754     0       6       0       irqbalance /proc/interrupts\n20:32:03  0      754     0       6       0       irqbalance /proc/stat\n20:32:03  0      632     0       7       524288  vmtoolsd /etc/mtab\n20:32:03  0      632     0       9       0       vmtoolsd /proc/devices\n$ sudo ecli examples/bpftools/opensnoop/package.json --pid_target 754\nTIME     TS      PID     UID     RET     FLAGS   COMM    FNAME\n20:34:13  0      754     0       6       0       irqbalance /proc/interrupts\n20:34:13  0      754     0       6       0       irqbalance /proc/stat\n20:34:23  0      754     0       6       0       irqbalance /proc/interrupts\n20:34:23  0      754     0       6       0       irqbalance /proc/stat\n</code></pre> <p>\u6216\u4f7f\u7528 docker \u7f16\u8bd1:</p> <pre><code>docker run -it -v `pwd`/:/src/ ghcr.io/eunomia-bpf/ecc-`uname -m`:latest\n</code></pre> <p>\u7f16\u8bd1\u53d1\u5e03\u540e, \u4e5f\u53ef\u4ee5\u8f7b\u677e\u4ece\u4e91\u7aef\u4e00\u884c\u547d\u4ee4\u542f\u52a8\u4efb\u610f eBPF \u7a0b\u5e8f, \u4f8b\u5982:</p> <pre><code>wget https://aka.pw/bpf-ecli -O ecli &amp;&amp; chmod +x ./ecli     # download the release from https://github.com/eunomia-bpf/eunomia-bpf/releases/latest/download/ecli\nsudo ./ecli https://eunomia-bpf.github.io/eunomia-bpf/sigsnoop/package.json # simply run a pre-compiled ebpf code from a url\nsudo ./ecli sigsnoop:latest # run with a name and download the latest version bpf tool from our repo\n</code></pre> <p>\u5b8c\u6574\u4ee3\u7801\u5728\u8fd9\u91cc: https://github.com/eunomia-bpf/eunomia-bpf/tree/master/examples/bpftools/opensnoop</p> </li> <li> <p>\u652f\u6301\u6839\u636e\u4ee3\u7801\u4e2d\u7684\u6ce8\u91ca\u4fe1\u606f\u81ea\u52a8\u751f\u6210\u7528\u6237\u6001\u547d\u4ee4\u884c\u53c2\u6570\u3002</p> <p>\u6bd4\u5982\u9700\u8981\u5b9e\u73b0\u4e00\u4e2a ebpf \u7a0b\u5e8f\u91cc\u9762\u7684 pid \u8fc7\u6ee4\u5668\uff0c\u53ea\u9700\u8981\u7f16\u5199\u5185\u6838\u6001\u4ee3\u7801\uff0c\u5728 eBPF \u4e2d\u58f0\u660e\u5168\u5c40\u53d8\u91cf\uff0c\u5373\u53ef\u81ea\u52a8\u751f\u6210\u547d\u4ee4\u884c\u53c2\u6570\uff1a</p> <pre><code>/// Process ID to trace\nconst volatile pid_t pid_target = 0;\n/// Thread ID to trace\nconst volatile pid_t tgid_target = 0;\n/// @description User ID to trace\nconst volatile uid_t uid_target = 0;\n/// @cmdarg {\"default\": false, \"short\": \"f\", \"long\": \"failed\"}\n/// @description target pid to trace\nconst volatile bool targ_failed = false;\n</code></pre> <p>\u6211\u4eec\u4f1a\u5c06\u6ce8\u91ca\u6587\u6863\u7684\u63cf\u8ff0\u4fe1\u606f\u63d0\u53d6\uff0c\u653e\u5728\u914d\u7f6e\u6587\u4ef6\u91cc\u9762\uff0c\u5e76\u4e14\u53d8\u6210 eBPF \u5e94\u7528\u7684\u547d\u4ee4\u884c\u53c2\u6570. \u4f7f\u7528\u65b9\u5f0f\u4ee5\u8ddf\u8e2a\u6240\u6709 open \u7cfb\u7edf\u8c03\u7528\u7684 opensnoop \u4e3a\u4f8b\uff1a</p> <pre><code>$ sudo ecli  examples/bpftools/opensnoop/package.json -h\nUsage: opensnoop_bpf [--help] [--version] [--verbose] [--pid_target VAR] [--tgid_target VAR] [--uid_target VAR] [--failed]\nTrace open family syscalls.\nOptional arguments:\n  -h, --help    shows help message and exits\n  -v, --version prints version information and exits\n  --verbose     prints libbpf debug information\n  --pid_target  Process ID to trace\n  --tgid_target Thread ID to trace\n$ sudo ecli examples/bpftools/opensnoop/package.json --pid_target 754\nTIME     TS      PID     UID     RET     FLAGS   COMM    FNAME\n20:34:13  0      754     0       6       0       irqbalance /proc/interrupts\n20:34:13  0      754     0       6       0       irqbalance /proc/stat\n20:34:23  0      754     0       6       0       irqbalance /proc/interrupts\n20:34:23  0      754     0       6       0       irqbalance /proc/stat\n</code></pre> </li> <li> <p>\u652f\u6301\u81ea\u52a8\u91c7\u96c6\u548c\u7efc\u5408\u975e ring buffer \u548c perf event \u7684 map\uff0c\u6bd4\u5982 hash map\uff0c\u6253\u5370\u51fa\u4fe1\u606f\u6216\u751f\u6210\u76f4\u65b9\u56fe\u3002</p> <p>\u4e4b\u524d\u4f7f\u7528 ring buffer \u548c perf event \u7684\u573a\u666f\u4f1a\u7a0d\u5fae\u53d7\u9650\uff0c\u56e0\u6b64\u9700\u8981\u6709\u4e00\u79cd\u65b9\u6cd5\u53ef\u4ee5\u81ea\u52a8\u4ece maps \u91cc\u9762\u91c7\u96c6\u6570\u636e\uff0c\u5728\u6e90\u4ee3\u7801\u91cc\u9762\u6dfb\u52a0\u6ce8\u91ca\u5373\u53ef\uff1a</p> <pre><code>/// @sample {\"interval\": 1000, \"type\" : \"log2_hist\"}\nstruct {\n__uint(type, BPF_MAP_TYPE_HASH);\n__uint(max_entries, MAX_ENTRIES);\n__type(key, u32);\n__type(value, struct hist);\n} hists SEC(\".maps\");\n</code></pre> <p>\u5c31\u4f1a\u6bcf\u9694\u4e00\u79d2\u53bb\u91c7\u96c6\u4e00\u6b21 counters \u91cc\u9762\u7684\u5185\u5bb9\uff08print_map\uff09\uff0c\u4ee5 runqlat \u4e3a\u4f8b\uff1a</p> <pre><code>$ sudo ecli examples/bpftools/runqlat/package.json -h\nUsage: runqlat_bpf [--help] [--version] [--verbose] [--filter_cg] [--targ_per_process] [--targ_per_thread] [--targ_per_pidns] [--targ_ms] [--targ_tgid VAR]\nSummarize run queue (scheduler) latency as a histogram.\nOptional arguments:\n  -h, --help            shows help message and exits\n  -v, --version         prints version information and exits\n  --verbose             prints libbpf debug information\n  --filter_cg           set value of bool variable filter_cg\n  --targ_per_process    set value of bool variable targ_per_process\n  --targ_per_thread     set value of bool variable targ_per_thread\n  --targ_per_pidns      set value of bool variable targ_per_pidns\n  --targ_ms             set value of bool variable targ_ms\n  --targ_tgid           set value of pid_t variable targ_tgid\nBuilt with eunomia-bpf framework.\nSee https://github.com/eunomia-bpf/eunomia-bpf for more information.\n$ sudo ecli examples/bpftools/runqlat/package.json\nkey =  4294967295\ncomm = rcu_preempt\n    (unit)              : count    distribution\n        0 -&gt; 1          : 9        |****                                    |\n        2 -&gt; 3          : 6        |**                                      |\n        4 -&gt; 7          : 12       |*****                                   |\n        8 -&gt; 15         : 28       |*************                           |\n       16 -&gt; 31         : 40       |*******************                     |\n       32 -&gt; 63         : 83       |****************************************|\n       64 -&gt; 127        : 57       |***************************             |\n      128 -&gt; 255        : 19       |*********                               |\n      256 -&gt; 511        : 11       |*****                                   |\n      512 -&gt; 1023       : 2        |                                        |\n     1024 -&gt; 2047       : 2        |                                        |\n     2048 -&gt; 4095       : 0        |                                        |\n     4096 -&gt; 8191       : 0        |                                        |\n     8192 -&gt; 16383      : 0        |                                        |\n    16384 -&gt; 32767      : 1        |                                        |\n$ sudo ecli examples/bpftools/runqlat/package.json --targ_per_process\nkey =  3189\ncomm = cpptools\n    (unit)              : count    distribution\n        0 -&gt; 1          : 0        |                                        |\n        2 -&gt; 3          : 0        |                                        |\n        4 -&gt; 7          : 0        |                                        |\n        8 -&gt; 15         : 1        |***                                     |\n       16 -&gt; 31         : 2        |*******                                 |\n       32 -&gt; 63         : 11       |****************************************|\n       64 -&gt; 127        : 8        |*****************************           |\n      128 -&gt; 255        : 3        |**********                              |\n</code></pre> <p>\u5b8c\u6574\u4ee3\u7801\u5728\u8fd9\u91cc: https://github.com/eunomia-bpf/eunomia-bpf/tree/master/examples/bpftools/runqlat</p> </li> <li> <p>\u6dfb\u52a0\u5bf9 uprobe, tc \u7b49\u591a\u79cd\u7c7b\u578b map \u7684\u652f\u6301, \u5141\u8bb8\u7528\u6807\u8bb0\u5b9e\u73b0\u6dfb\u52a0\u989d\u5916 attach \u4fe1\u606f, \u4f8b\u5982:</p> <pre><code>/// @tchook {\"ifindex\":1, \"attach_point\":\"BPF_TC_INGRESS\"}\n/// @tcopts {\"handle\":1,  \"priority\":1}\nSEC(\"tc\")\nint tc_ingress(struct __sk_buff *ctx)\n{\nvoid *data_end = (void *)(__u64)ctx-&gt;data_end;\nvoid *data = (void *)(__u64)ctx-&gt;data;\nstruct ethhdr *l2;\nstruct iphdr *l3;\nif (ctx-&gt;protocol != bpf_htons(ETH_P_IP))\nreturn TC_ACT_OK;\nl2 = data;\nif ((void *)(l2 + 1) &gt; data_end)\nreturn TC_ACT_OK;\nl3 = (struct iphdr *)(l2 + 1);\nif ((void *)(l3 + 1) &gt; data_end)\nreturn TC_ACT_OK;\nbpf_printk(\"Got IP packet: tot_len: %d, ttl: %d\", bpf_ntohs(l3-&gt;tot_len), l3-&gt;ttl);\nreturn TC_ACT_OK;\n}\n</code></pre> </li> </ol>"},{"location":"blogs/0_3_0-release.zh/#_2","title":"\u7f16\u8bd1\u65b9\u9762\uff1a\u7f16\u8bd1\u4f53\u9a8c\u4f18\u5316\u3001\u683c\u5f0f\u6539\u8fdb","text":"<ol> <li>\u5b8c\u5168\u91cd\u6784\u4e86\u7f16\u8bd1\u5de5\u5177\u94fe\u548c\u914d\u7f6e\u6587\u4ef6\u683c\u5f0f\uff0c\u56de\u5f52\u672c\u8d28\u7684\u914d\u7f6e\u6587\u4ef6 + ebpf \u5b57\u8282\u7801 .o \u7684\u5f62\u5f0f\uff0c\u4e0d\u5f3a\u5236\u6253\u5305\u6210 JSON \u683c\u5f0f\uff0c\u5bf9\u5206\u53d1\u4f7f\u7528\u548c\u4eba\u7c7b\u7f16\u8f91\u914d\u7f6e\u6587\u4ef6\u66f4\u53cb\u597d\uff0c\u540c\u65f6\u4e5f\u53ef\u4ee5\u66f4\u597d\u5730\u548c libbpf \u76f8\u5173\u5de5\u5177\u94fe\u517c\u5bb9;</li> <li>\u652f\u6301 JSON \u548c YAML \u4e24\u79cd\u5f62\u5f0f\u7684\u914d\u7f6e\u6587\u4ef6\uff08xxx.skel.yaml \u548c xxx.skel.json\uff09\uff0c\u6216\u6253\u5305\u6210 package.json \u548c package.yaml \u8fdb\u884c\u5206\u53d1;</li> <li>\u5c3d\u53ef\u80fd\u4f7f\u7528 BTF \u4fe1\u606f\u8868\u8fbe\u7b26\u53f7\u7c7b\u578b\uff0c\u5e76\u4e14\u628a BTF \u4fe1\u606f\u9690\u85cf\u5728\u4e8c\u8fdb\u5236\u6587\u4ef6\u4e2d\uff0c\u8ba9\u914d\u7f6e\u6587\u4ef6\u66f4\u53ef\u8bfb\u548c\u53ef\u7f16\u8f91\uff0c\u540c\u65f6\u590d\u7528 libbpf \u63d0\u4f9b\u7684 BTF \u5904\u7406\u673a\u5236\uff0c\u5b8c\u5584\u5bf9\u4e8e\u7c7b\u578b\u7684\u5904\u7406\uff1b</li> <li>\u652f\u6301\u66f4\u591a\u7684\u6570\u636e\u5bfc\u51fa\u7c7b\u578b\uff1aenum\u3001struct\u3001bool \u7b49\u7b49</li> <li>\u7f16\u8bd1\u90e8\u5206\u53ef\u4ee5\u4e0d\u4f9d\u8d56\u4e8e docker \u8fd0\u884c\uff0c\u53ef\u4ee5\u5b89\u88c5\u4e8c\u8fdb\u5236\u548c\u5934\u6587\u4ef6\u5230 ~/.eunomia\uff08\u5bf9\u5d4c\u5165\u5f0f\u6216\u8005\u56fd\u5185\u7f51\u7edc\u66f4\u53cb\u597d\uff0c\u66f4\u65b9\u4fbf\u4f7f\u7528\uff09\uff0c\u539f\u672c docker \u7684\u4f7f\u7528\u65b9\u5f0f\u8fd8\u662f\u53ef\u4ee5\u7ee7\u7eed\u4f7f\u7528\uff1b</li> <li>\u6587\u4ef6\u540d\u6ca1\u6709\u7279\u5b9a\u9650\u5236\uff0c\u4e0d\u9700\u8981\u4e00\u5b9a\u662f xxx.bpf.h \u548c xxx.bpf.c\uff0c\u53ef\u4ee5\u901a\u8fc7 ecc \u6307\u5b9a\u5f53\u524d\u76ee\u5f55\u4e0b\u9700\u8981\u7f16\u8bd1\u7684\u6587\u4ef6;</li> <li>\u628a example \u4e2d\u65e7\u7684 xxx.bpf.h \u5934\u6587\u4ef6\u4fee\u6539\u4e3a xxx.h\uff0c\u548c libbpf-tools \u548c libbpf-bootstrap \u4fdd\u6301\u4e00\u81f4\uff0c\u786e\u4fdd 0 \u4ee3\u7801\u4fee\u6539\u5373\u53ef\u590d\u7528 libbpf \u76f8\u5173\u4ee3\u7801\u751f\u6001\uff1b</li> <li>\u5927\u5e45\u5ea6\u4f18\u5316\u7f16\u8bd1\u901f\u5ea6\u548c\u51cf\u5c11\u7f16\u8bd1\u4f9d\u8d56\uff0c\u4f7f\u7528 Rust \u91cd\u6784\u4e86\u7f16\u8bd1\u5de5\u5177\u94fe\uff0c\u66ff\u6362\u539f\u5148\u7684 python \u811a\u672c;</li> </ol> <p>\u5728\u914d\u7f6e\u6587\u4ef6\u4e2d, \u53ef\u4ee5\u76f4\u63a5\u4fee\u6539 progs/attach \u63a7\u5236\u6302\u8f7d\u70b9\uff0cvariables/value \u63a7\u5236\u5168\u5c40\u53d8\u91cf\uff0cmaps/data \u63a7\u5236\u5728\u52a0\u8f7d ebpf \u7a0b\u5e8f\u65f6\u5f80 map \u91cc\u9762\u653e\u4ec0\u4e48\u6570\u636e\uff0cexport_types/members \u63a7\u5236\u5f80\u7528\u6237\u6001\u4f20\u8f93\u4ec0\u4e48\u6570\u636e\u683c\u5f0f\uff0c\u800c\u4e0d\u9700\u8981\u91cd\u65b0\u7f16\u8bd1 eBPF \u7a0b\u5e8f\u3002\u914d\u7f6e\u6587\u4ef6\u548c bpf.o \u4e8c\u8fdb\u5236\u662f\u914d\u5957\u7684\uff0c\u5e94\u8be5\u642d\u914d\u4f7f\u7528\uff0c\u6216\u8005\u6253\u5305\u6210\u4e00\u4e2a package.json/yaml \u5206\u53d1\u3002\u6253\u5305\u7684\u65f6\u5019\u4f1a\u8fdb\u884c\u538b\u7f29\uff0c\u4e00\u822c\u6765\u8bf4\u538b\u7f29\u540e\u7684\u914d\u7f6e\u6587\u4ef6\u548c\u4e8c\u8fdb\u5236\u5408\u8d77\u6765\u7684\u5927\u5c0f\u5728\u6570\u5341 kb \u3002</p> <p>\u914d\u7f6e\u6587\u4ef6\u4e3e\u4f8b:</p> <pre><code>bpf_skel:\ndata_sections:\n- name: .rodata\nvariables:\n- name: min_duration_ns\ntype: unsigned long long\nvalue: 100\nmaps:\n- ident: exec_start\nname: exec_start\ndata:\n- key: 123\nvalue: 456\n- ident: rb\nname: rb\n- ident: rodata\nmmaped: true\nname: client_b.rodata\nobj_name: client_bpf\nprogs:\n- attach: tp/sched/sched_process_exec\nlink: true\nname: handle_exec\nexport_types:\n- members:\n- name: pid\ntype: int\n- name: ppid\ntype: int\n- name: comm\ntype: char[16]\n- name: filename\ntype: char[127]\n- name: exit_event\ntype: bool\nname: event\ntype_id: 613\n</code></pre>"},{"location":"blogs/0_3_0-release.zh/#eunomia-bpf_1","title":"\u4e0b\u8f7d\u5b89\u88c5 eunomia-bpf","text":"<ul> <li> <p>Install the <code>ecli</code> tool for running eBPF program from the cloud:</p> <pre><code>$ wget https://aka.pw/bpf-ecli -O ecli &amp;&amp; chmod +x ./ecli\n$ ./ecli -h\nUsage: ecli [--help] [--version] [--json] [--no-cache] url-and-args\n....\n</code></pre> </li> <li> <p>Install the compiler-toolchain for compiling eBPF kernel code to a <code>config</code> file or <code>Wasm</code> module:</p> <pre><code>$ wget https://github.com/eunomia-bpf/eunomia-bpf/releases/latest/download/ecc &amp;&amp; chmod +x ./ecc\n$ ./ecc -h\neunomia-bpf compiler\nUsage: ecc [OPTIONS] &lt;SOURCE_PATH&gt; [EXPORT_EVENT_HEADER]\n....\n....\n</code></pre> </li> </ul> <p>or use the docker image for compile:</p> <pre><code>```bash\ndocker run -it -v `pwd`/:/src/ ghcr.io/eunomia-bpf/ecc-`uname -m`:latest # compile with docker. `pwd` should contains *.bpf.c files and *.h files.\n```\n</code></pre>"},{"location":"blogs/0_3_0-release.zh/#_3","title":"\u4e0b\u4e00\u6b65\u53d1\u5c55\u7684\u8ba1\u5212","text":"<ol> <li>\u548c\u66f4\u591a\u7684\u793e\u533a\u4f19\u4f34\u5408\u4f5c, \u5e76\u9010\u6b65\u5f62\u6210\u6807\u51c6\u5316\u7684, \u4f7f\u7528\u914d\u7f6e\u6587\u4ef6\u6216 Wasm \u4e8c\u8fdb\u5236\u8fdb\u884c\u6253\u5305\u5206\u53d1, \u4e00\u6b21\u7f16\u8bd1, \u5230\u5904\u8fd0\u884c\u7684 eBPF \u7a0b\u5e8f\u683c\u5f0f;</li> <li>\u548c LMP \u793e\u533a\u4e00\u8d77, \u5b8c\u5584\u57fa\u4e8e ORAS, OCI \u548c Wasm \u7684 eBPF \u7a0b\u5e8f\u5206\u53d1\u548c\u8fd0\u884c\u65f6\u6807\u51c6, \u8ba9\u4efb\u610f eBPF \u5e94\u7528\u5747\u53ef\u4ece\u4e91\u7aef\u4e00\u884c\u547d\u4ee4\u62c9\u4e0b\u6765\u76f4\u63a5\u8fd0\u884c, \u6216\u8f7b\u677e\u5d4c\u5165\u5176\u4ed6\u5e94\u7528\u4e2d\u4f7f\u7528, \u65e0\u9700\u5173\u6ce8\u67b6\u6784, \u5185\u6838\u7248\u672c\u7b49\u7ec6\u8282;</li> <li>\u5c1d\u8bd5\u548c Coolbpf \u793e\u533a\u4e00\u540c\u5b8c\u5584\u8fdc\u7a0b\u7f16\u8bd1, \u4f4e\u7248\u672c\u652f\u6301\u7684\u7279\u6027, \u4ee5\u53ca\u652f\u6301 RPC \u7684 libbpf \u5e93;</li> <li>\u5b8c\u5584\u7528\u6237\u6001 Wasm \u548c eBPF \u7a0b\u5e8f\u4e4b\u95f4\u7684\u4e92\u64cd\u4f5c\u6027, \u63a2\u7d22 WASI \u7684\u76f8\u5173\u6269\u5c55;</li> </ol>"},{"location":"blogs/0_3_0-release.zh/#_4","title":"\u53c2\u8003\u8d44\u6599","text":"<ol> <li>\u5f53 Wasm \u9047\u89c1 eBPF \uff1a\u4f7f\u7528 WebAssembly \u7f16\u5199\u3001\u5206\u53d1\u3001\u52a0\u8f7d\u8fd0\u884c eBPF \u7a0b\u5e8f</li> <li>\u5982\u4f55\u5728 Linux \u663e\u5fae\u955c\uff08LMP\uff09\u9879\u76ee\u4e2d\u5f00\u542f eBPF \u4e4b\u65c5\uff1f</li> <li>\u9f99\u8725\u793e\u533a eunomia-bpf \u9879\u76ee\u4e3b\u9875</li> <li>eunomia-bpf \u9879\u76ee\u6587\u6863</li> <li>LMP \u9879\u76ee</li> </ol>"},{"location":"blogs/0_3_0-release.zh/#_5","title":"\u6211\u4eec\u7684\u5fae\u4fe1\u7fa4","text":""},{"location":"blogs/GPTtrace.zh/","title":"\u4f7f\u7528 ChatGPT \uff0c\u901a\u8fc7\u81ea\u7136\u8bed\u8a00\u7f16\u5199 eBPF \u7a0b\u5e8f\u548c\u8ffd\u8e2a Linux \u7cfb\u7edf","text":"<p>eBPF \u662f\u4e00\u9879\u9769\u547d\u6027\u7684\u6280\u672f\uff0c\u8d77\u6e90\u4e8e Linux \u5185\u6838\uff0c\u53ef\u4ee5\u5728\u64cd\u4f5c\u7cfb\u7edf\u7684\u5185\u6838\u4e2d\u8fd0\u884c\u6c99\u76d2\u7a0b\u5e8f\u3002\u5b83\u88ab\u7528\u6765\u5b89\u5168\u548c\u6709\u6548\u5730\u6269\u5c55\u5185\u6838\u7684\u529f\u80fd\uff0c\u800c\u4e0d\u9700\u8981\u6539\u53d8\u5185\u6838\u7684\u6e90\u4ee3\u7801\u6216\u52a0\u8f7d\u5185\u6838\u6a21\u5757\u3002\u4eca\u5929\uff0ceBPF\u88ab\u5e7f\u6cdb\u7528\u4e8e\u5404\u7c7b\u573a\u666f\uff1a\u5728\u73b0\u4ee3\u6570\u636e\u4e2d\u5fc3\u548c\u4e91\u539f\u751f\u73af\u5883\u4e2d\uff0c\u53ef\u4ee5\u63d0\u4f9b\u9ad8\u6027\u80fd\u7684\u7f51\u7edc\u5305\u5904\u7406\u548c\u8d1f\u8f7d\u5747\u8861\uff1b\u4ee5\u975e\u5e38\u4f4e\u7684\u8d44\u6e90\u5f00\u9500\uff0c\u505a\u5230\u5bf9\u591a\u79cd\u7ec6\u7c92\u5ea6\u6307\u6807\u7684\u53ef\u89c2\u6d4b\u6027\uff0c\u5e2e\u52a9\u5e94\u7528\u7a0b\u5e8f\u5f00\u53d1\u4eba\u5458\u8ddf\u8e2a\u5e94\u7528\u7a0b\u5e8f\uff0c\u4e3a\u6027\u80fd\u6545\u969c\u6392\u9664\u63d0\u4f9b\u6d1e\u5bdf\u529b\uff1b\u4fdd\u969c\u5e94\u7528\u7a0b\u5e8f\u548c\u5bb9\u5668\u8fd0\u884c\u65f6\u7684\u5b89\u5168\u6267\u884c\uff0c\u7b49\u7b49\u3002eBPF \u5df2\u7ecf\u6210\u4e3a\u4e86\u4e00\u4e2a\u8d8a\u6765\u8d8a\u53d7\u6b22\u8fce\u7684\u6280\u672f\uff0c\u5b83\u53ef\u4ee5\u5e2e\u52a9\u6211\u4eec\u66f4\u52a0\u9ad8\u6548\u5730\u5bf9\u5185\u6838\u548c\u7528\u6237\u6001\u7684\u51e0\u4e4e\u6240\u6709\u5e94\u7528\u8fdb\u884c\u8ffd\u8e2a\u548c\u5206\u6790\u3002</p> <p>\u4f46\u662f\uff0ceBPF \u7684\u5f00\u53d1\uff0c\u6216\u8005\u8ffd\u8e2a\u5185\u6838\u4ea7\u751f\u7684\u5404\u7c7b\u4e8b\u4ef6\uff0c\u9700\u8981\u4e00\u5b9a\u7684\u4e13\u4e1a\u77e5\u8bc6\uff0c\u5bf9\u4e8e\u4e00\u4e9b\u4e0d\u719f\u6089\u8be5\u6280\u672f\u7684\u5f00\u53d1\u4eba\u5458\u6765\u8bf4\uff0c\u53ef\u80fd\u4f1a\u6709\u4e00\u5b9a\u7684\u56f0\u96be\u3002\u8fd9\u65f6\uff0c\u6211\u4eec\u7684 demo \u5de5\u5177 GPTtrace \u6240\u5e26\u6765\u7684\u4e00\u4e9b\u65b0\u7684\u601d\u8def\uff0c\u4e5f\u8bb8\u5c31\u53ef\u4ee5\u5e2e\u52a9\u4f60\u89e3\u51b3\u8fd9\u4e2a\u95ee\u9898\u3002\u5b83\u4f7f\u7528 ChatGPT \uff0c\u901a\u8fc7\u81ea\u7136\u8bed\u8a00\u7f16\u5199 eBPF \u7a0b\u5e8f\u548c\u8ffd\u8e2a Linux \u5185\u6838\uff1ahttps://github.com/eunomia-bpf/GPTtrace</p> <p>\u5982\u679c\u4f60\u662f\u4e00\u540d\u5f00\u53d1\u4eba\u5458\uff0c\u60f3\u8981\u66f4\u52a0\u9ad8\u6548\u5730\u8fdb\u884c\u8ffd\u8e2a\u548c\u5206\u6790\uff0c\u90a3\u4e48\u7c7b\u4f3c\u7684\u65b9\u6848\u7edd\u5bf9\u503c\u5f97\u5c1d\u8bd5\uff1a\u8fd9\u79cd ChatGPT \u548c eBPF \u6280\u672f\u7684\u7ed3\u5408\u5c06\u5728\u672a\u6765\u7684\u8f6f\u4ef6\u5f00\u53d1\u3001\u8c03\u8bd5\u3001\u4ee5\u53ca\u53ef\u89c2\u6d4b\u6027\u573a\u666f\u4e2d\u53d1\u6325\u66f4\u52a0\u91cd\u8981\u7684\u4f5c\u7528\uff0c\u540c\u65f6\u5b83\u53ef\u80fd\u4e5f\u4f1a\u5e26\u6765\u4e00\u79cd\u5168\u65b0\u7684\u3001\u4ea4\u4e92\u5f0f\u5730\u5b66\u4e60\u8303\u5f0f\u3002</p>"},{"location":"blogs/GPTtrace.zh/#_1","title":"\u6211\u4eec\u505a\u4e86\u54ea\u4e9b\u5c1d\u8bd5\uff1f","text":"<p>GPTtrace \u4f7f\u7528 ChatGPT \u6280\u672f\uff0c\u5141\u8bb8\u5f00\u53d1\u4eba\u5458\u901a\u8fc7\u81ea\u7136\u8bed\u8a00\u7f16\u5199 eBPF \u7a0b\u5e8f\u548c\u8ffd\u8e2a Linux \u5185\u6838\uff0c\u65e0\u9700\u4e8b\u5148\u4e86\u89e3\u8be5\u6280\u672f\u7684\u4e13\u4e1a\u77e5\u8bc6\u3002\u5b83\u4f7f\u5f97\u5f00\u53d1\u4eba\u5458\u53ef\u4ee5\u66f4\u5feb\u3001\u66f4\u51c6\u786e\u5730\u5b9a\u4f4d\u548c\u89e3\u51b3\u8f6f\u4ef6\u4e2d\u7684\u95ee\u9898\u3002\u4f8b\u5982\uff0c\u6839\u636e\u8fdb\u7a0b\u540d\u79f0\u7edf\u8ba1 Page Faults \u6b21\u6570\uff1a</p> <p></p> <p>\u6211\u4eec\u8fd8\u6709\u4e00\u4e2a\u89c6\u9891\u6f14\u793a\u4e0e\u8bb2\u89e3\uff0c\u53ef\u4ee5\u5728\u8fd9\u91cc\u89c2\u770b\uff1ahttps://www.bilibili.com/video/BV1oM411J7gp/</p>"},{"location":"blogs/GPTtrace.zh/#_2","title":"\u6211\u4eec\u662f\u600e\u6837\u505a\u5230\u7684\uff1f","text":"<p>\u6211\u4eec\u76ee\u524d\u7684\u601d\u8def\u662f\u901a\u8fc7\u9884\u8bad\u7ec3 eBPF \u7a0b\u5e8f\uff0c\u8ba9 ChatGPT \u5b66\u4f1a\u5982\u4f55\u7f16\u5199\u5404\u79cd eBPF \u7a0b\u5e8f\u6216 bpftrace \u7684 DSL\u3002\u5927\u6982\u5206\u4e3a\u8fd9\u51e0\u6b65\uff1a</p> <ol> <li>\u9884\u8bad\u7ec3 ebpf \u7a0b\u5e8f\uff0c\u5229\u7528\u4e00\u4e9b ebpf \u7684\u5f00\u53d1\u8d44\u6599\uff0c\u5148\u548c ChatGPT \u5bf9\u8bdd\u591a\u6b21\uff0c\u8ba9 ChatGPT \u901a\u8fc7\u5bf9\u8bdd\u4e0a\u4e0b\u6587\u5982\u4f55\u5199\u5404\u79cd eBPF \u7a0b\u5e8f\u6216\u8005 bpftrace \u7684 DSL\uff08\u5176\u5b9e\u6211\u4eec\u5728\u5341\u4e8c\u6708\u4efd\u5c31\u505a\u8fc7\u4e00\u4e9b\u7c7b\u4f3c\u7684\u5b9e\u8df5\uff0c\u4ea7\u51fa\u4e86\u4e00\u4efd\u6559\u7a0b\u6587\u6863\uff0c\u4f46\u6ca1\u6709\u628a\u5b83\u53d8\u6210\u4e00\u4efd\u5de5\u5177\uff1ahttps://github.com/eunomia-bpf/bpf-developer-tutorial\uff09\uff1b</li> <li>\u8c03\u7528 ChatGPT api\uff0c\u5e76\u628a\u8fd4\u56de\u7684\u7ed3\u679c\u89e3\u6790\u4e4b\u540e\u4f5c\u4e3a\u547d\u4ee4\u8f93\u5165 shell \u6267\u884c\uff0c\u6216\u8005\u5c06 eBPF \u7a0b\u5e8f\u5199\u5230\u6587\u4ef6\u91cc\u9762\u7f16\u8bd1\u8fd0\u884c</li> <li>\u5982\u679c\u7f16\u8bd1\u548c\u52a0\u8f7d\u62a5\u9519\uff0c\u628a\u5bf9\u5e94\u7684\u62a5\u9519\u4fe1\u606f\u8fd4\u56de\u7ed9 ChatGPT\uff0c\u8ba9\u5b83\u518d\u751f\u6210\u4e00\u4e2a\u65b0\u7684 eBPF \u7a0b\u5e8f\u6216\u8005\u547d\u4ee4</li> </ol> <p>\u6211\u4eec\u4f7f\u7528\u4e86 ChatGPT \u7684 Python API\uff0c\u82b1\u4e86\u4e00\u4e2a\u4e0b\u5348\u7b80\u5355\u5b9e\u73b0\u4e86\u8fd9\u4e2a\u5c0f\u73a9\u5177\uff0c\u5b83\u53ef\u4ee5\u4f7f\u7528\u4e2d\u6587\u6216\u8005\u82f1\u6587\u7b49\u591a\u79cd\u8bed\u8a00\u8f93\u5165\u4efb\u610f\u81ea\u7136\u8bed\u8a00\u7684\u63cf\u8ff0\uff0c\u4f8b\u5982 \u201c\u8ffd\u8e2a\u8fdb\u7a0b\u6253\u5f00\u7684\u6587\u4ef6\u201d \"Show per-second syscall rates\" \u7b49\u7b49\uff0c\u6b63\u786e\u7387\u4e0d\u662f 100%\uff0c\u4e0d\u8fc7\u5341\u6b21\u91cc\u9762\u5927\u6982\u5df2\u7ecf\u53ef\u4ee5\u6709\u4e03\u516b\u6b21\u53ef\u4ee5\u6b63\u786e\u8fdb\u884c\u8ffd\u8e2a\u4e86\uff0c\u9047\u5230\u62a5\u9519\u8fd8\u4f1a\u81ea\u884c\u8fdb\u884c\u4fee\u6b63\u548c\u8c03\u6574\u3002</p>"},{"location":"blogs/GPTtrace.zh/#_3","title":"\u8fdb\u4e00\u6b65\u7684\u4f18\u5316\uff1f","text":"<p>\u8fd9\u4e2a\u73a9\u5177\u9879\u76ee\u672c\u8eab\u53ea\u662f\u60f3\u5c55\u793a\u4e00\u4e0b\u53ef\u80fd\u6027\uff0c\u5f88\u5feb\u5e94\u8be5\u4f1a\u6709\u66f4\u597d\u7684\u7c7b\u4f3c ChatGPT \u8fd9\u6837\u7684\u7684 api\uff0c\u548c\u66f4\u901a\u7528\u7684\u8bad\u7ec3/\u6267\u884c\u6846\u67b6\u51fa\u6765\u7684\uff0c\u5e0c\u671b\u5b83\u80fd\u8d77\u5230\u629b\u7816\u5f15\u7389\u7684\u6548\u679c\u3002\u76ee\u524d\u770b\u8d77\u6765\u8fd8\u6709\u5f88\u591a\u53ef\u4ee5\u4f18\u5316\u7684\u7a7a\u95f4:</p> <ol> <li>\u80fd\u8054\u7f51\u641c\u7d22\u4e4b\u540e\uff0c\u8ba9\u8fd9\u4e2a\u5de5\u5177\u53bb\u83b7\u53d6 bcc/bpftrace \u4ed3\u5e93\u91cc\u9762\u7684\u793a\u4f8b\u7a0b\u5e8f\u5b66\u4e60\uff0c\u6548\u679c\u5e94\u8be5\u8fd8\u4f1a\u597d\u5f88\u591a;</li> <li>\u6216\u8005\u8ba9\u8fd9\u4e2a\u5e94\u7528\u81ea\u5df1\u80fd\u8054\u7f51\u641c\u7d22 Stack Overflow \u4e4b\u7c7b\u7684\u7ed3\u679c\uff0c\u67e5\u8be2\u5982\u4f55\u7f16\u5199 eBPF \u7a0b\u5e8f\uff0c\u7c7b\u4f3c\u65b0 Bing \u7684\u641c\u7d22\u65b9\u5f0f\uff1b</li> <li>\u63d0\u4f9b\u66f4\u591a\u9ad8\u8d28\u91cf\u7684\u6587\u6863\u548c\u6559\u7a0b\uff0c\u770b\u8d77\u6765\u8f93\u51fa\u7684\u51c6\u786e\u5ea6\u548c\u6559\u7a0b\u3001\u4ee3\u7801\u793a\u4f8b\u7684\u8d28\u91cf\u5bc6\u5207\u76f8\u5173\uff1b</li> <li>\u5176\u5b9e\u8fd8\u53ef\u4ee5\u591a\u6b21\u8c03\u7528\u5176\u4ed6\u5de5\u5177\u6267\u884c\u547d\u4ee4\u8fd4\u56de\u7ed3\u679c\uff0c\u6bd4\u5982\u8bf4 ChatGPT \u8f93\u51fa\u547d\u4ee4\uff0c\u7528 bpftrace \u67e5\u8be2\u4e00\u4e0b\u5f53\u524d\u5185\u6838\u7248\u672c\u548c\u652f\u6301\u7684 tracepoint\uff0c\u7136\u540e\u8fd4\u56de\u8f93\u51fa\uff08\u8fd9\u4e5f\u662f\u4e00\u6b21\u5bf9\u8bdd\uff09\uff0c\u518d\u7ed9\u51fa\u7a0b\u5e8f\uff0c\u6548\u679c\u5e94\u8be5\u8fd8\u8981\u597d\u4e0d\u5c11</li> </ol> <p>\u77ed\u671f\u6765\u770b\uff0c\u6211\u4eec\u5e0c\u671b\u5c1d\u8bd5\u57fa\u4e8e\u8fd9\u4e2a\u5de5\u5177\u6784\u5efa\u4e00\u4e2a\u4ea4\u4e92\u5f0f\u7684\u3001\u5e26\u6709\u63d0\u793a\u7684\u5185\u6838\u8ffd\u8e2a\u5de5\u5177\u548c\u5b66\u4e60 eBPF \u7a0b\u5e8f\u7684\u6559\u7a0b\uff0c\u5e2e\u52a9\u7528\u6237\u5728\u7f16\u5199 eBPF \u7a0b\u5e8f\u65f6\u66f4\u5feb\u5730\u4e86\u89e3\u8bed\u6cd5\u548c\u8c03\u8bd5\u9519\u8bef\uff0c\u5e76\u4e14\u53ef\u4ee5\u6839\u636e\u7528\u6237\u7684\u53cd\u9988\u8c03\u6574\u63d0\u793a\u548c\u5efa\u8bae\u7684\u8d28\u91cf\uff1b\u4ee5\u53ca\u63d0\u4f9b\u4e00\u4e2a\u7ed3\u6784\u5316\u7684\u5b66\u4e60 eBPF \u7a0b\u5e8f\u7684\u6559\u7a0b\uff0c\u4ece\u57fa\u7840\u7684\u8bed\u6cd5\u548c API \u5f00\u59cb\uff0c\u7ed3\u5408\u901a\u8fc7\u7528\u6237\u6700\u7ec8\u60f3\u7f16\u5199\u7684 eBPF \u7a0b\u5e8f\u7684\u9700\u6c42\uff0c\u9010\u6b65\u5411\u7528\u6237\u4ecb\u7ecd\u5e38\u7528\u7684 eBPF \u5e94\u7528\u573a\u666f\u548c\u7f16\u5199\u6280\u5de7\u3002</p> <p>\u67d0\u79cd\u610f\u4e49\u4e0a\u6765\u8bf4\uff0c\u5b83\u751a\u81f3\u53ef\u4ee5\u4e0d\u4ec5\u4ec5\u662f\u4e00\u79cd\u8bed\u8a00\u6a21\u578b\uff0c\u501f\u52a9\u7b80\u5355\u7684\u5bf9\u8bdd\u7684\u4ea4\u4e92\u6a21\u5f0f\uff0c\u4ee5\u53ca\u80fd\u64cd\u63a7\u5404\u7c7b\u5de5\u5177\u3001\u8bbf\u95ee\u7f51\u7edc\u7684\u624b\u6bb5\uff0c\u5b83\u4e5f\u8bb8\u53ef\u4ee5\u8d77\u5230\u4e00\u4e2a\u5de8\u5927\u7684\u3001\u524d\u65e0\u53e4\u4eba\u7684\u77e5\u8bc6\u5e93\u7684\u4f5c\u7528\uff1a\u8fde\u63a5\u5404\u884c\u5404\u4e1a\uff0c\u6839\u636e\u81ea\u7136\u8bed\u8a00\u8f93\u5165\u800c\u975e\u5173\u952e\u8bcd\uff0c\u7ed9\u51fa\u7efc\u5408\u6982\u62ec\u7684\u3001\u65e0\u6cd5\u88ab\u641c\u7d22\u5f15\u64ce\u7b80\u5355\u83b7\u53d6\u5230\u7684\u601d\u8003\u548c\u7b54\u6848\u3002</p> <p>\u5728\u5f53\u4eca\u4fe1\u606f\u7206\u70b8\u7684\u65f6\u4ee3\uff0c\u6211\u4eec\u53ef\u4ee5\u8f7b\u6613\u5730\u83b7\u5f97\u5404\u79cd\u6d77\u91cf\u7684\u4fe1\u606f\uff0c\u4f46\u8fd9\u4e5f\u5e26\u6765\u4e86\u53e6\u4e00\u4e2a\u95ee\u9898\uff0c\u5c31\u662f\u4fe1\u606f\u7684\u5206\u6563\u548c\u788e\u7247\u5316\uff0c\u5f88\u96be\u5c06\u8fd9\u4e9b\u4fe1\u606f\u6574\u5408\u8d77\u6765\uff0c\u5f62\u6210\u6709\u4ef7\u503c\u7684\u77e5\u8bc6\u3002\u800c ChatGPT \u53ef\u4ee5\u901a\u8fc7\u81ea\u7136\u8bed\u8a00\u4ea4\u4e92\u7684\u65b9\u5f0f\uff0c\u5c06\u5404\u79cd\u4fe1\u606f\u548c\u77e5\u8bc6\u6574\u5408\u8d77\u6765\uff0c\u4e43\u81f3\u4e3b\u52a8\u53bb\u83b7\u53d6\u77e5\u8bc6\u548c\u63a5\u6536\u53cd\u9988\uff08\u5c31\u50cf\u6211\u4eec\u5728 GPTtrace \u4e2d\u505a\u7684\u4e00\u6837\uff09\uff0c\u5f62\u6210\u4e00\u4e2a\u5de8\u5927\u7684\u77e5\u8bc6\u5e93\uff0c\u4e3a\u4eba\u4eec\u63d0\u4f9b\u7efc\u5408\u7684\u601d\u8003\u548c\u7b54\u6848\u3002</p> <p>\u8fd9\u79cd\u65b9\u5f0f\u53ef\u4ee5\u8fde\u63a5\u5404\u884c\u5404\u4e1a\uff0c\u4e0d\u53d7\u7279\u5b9a\u9886\u57df\u6216\u884c\u4e1a\u7684\u9650\u5236\uff0c\u6839\u636e\u81ea\u7136\u8bed\u8a00\u8f93\u5165\u800c\u975e\u5173\u952e\u8bcd\uff0c\u7ed9\u51fa\u66f4\u52a0\u51c6\u786e\u3001\u7efc\u5408\u7684\u6982\u62ec\u3002\u6b64\u5916\uff0c\u7531\u4e8e ChatGPT \u53ef\u4ee5\u64cd\u63a7\u5404\u7c7b\u5de5\u5177\u548c\u8bbf\u95ee\u7f51\u7edc\uff0c\u5b83\u53ef\u4ee5\u66f4\u52a0\u6df1\u5165\u5730\u4e86\u89e3\u5404\u79cd\u77e5\u8bc6\u548c\u4fe1\u606f\uff0c\u5e76\u4e3a\u7528\u6237\u63d0\u4f9b\u66f4\u52a0\u5168\u9762\u548c\u6df1\u5165\u7684\u89e3\u7b54\u3002</p> <p>\u8fd9\u79cd\u9769\u547d\u6027\u7684\u53d8\u5316\u53ef\u80fd\u5df2\u7ecf\u7ad9\u5728\u4eba\u7c7b\u6587\u660e\u53d8\u9769\u7684\u524d\u591c\uff0c\u6211\u4eec\u83b7\u53d6\u77e5\u8bc6\u548c\u601d\u8003\u7684\u65b9\u5f0f\u5c06\u88ab\u98a0\u8986\uff0c\u7c7b\u4f3c\u7684\u5927\u6a21\u578b\u7684\u51fa\u73b0\u5c06\u6210\u4e3a\u8fd9\u4e2a\u53d8\u9769\u7684\u91cd\u8981\u63a8\u624b\u3002</p>"},{"location":"blogs/GPTtrace.zh/#_4","title":"\u672a\u6765\u5728\u4f55\u65b9\uff1f","text":"<p>\u5176\u5b9e\u8fd9\u4e2a\u6a21\u578b\u672c\u8eab\u7684\u6548\u679c\uff0c\u5e76\u4e0d\u7b97\u60ca\u8273\uff0c\u751a\u81f3\u53ef\u4ee5\u8bf4\u8fd8\u6709\u975e\u5e38\u591a\u7684\u6210\u957f\u7a7a\u95f4\u3002\u5bf9\u4e8e\u6211\u8fd9\u6837\u7684\u975e AI \u4e13\u4e1a\u7814\u7a76\u4eba\u5458\uff08AI\u5de5\u5177\u548c\u6a21\u578b\u7684\u6d88\u8d39\u8005\uff09\u6765\u8bf4\uff0c\u548c\u4f20\u7edf\u7684\u8bad\u7ec3\u6df1\u5ea6\u5b66\u4e60\u6a21\u578b\u7684\u65b9\u5f0f\u6bd4\u8d77\u6765\uff1a</p> <ul> <li>\u8bad\u7ec3\u6a21\u578b\u4e0d\u9700\u8981\u6574\u7406\u6570\u636e\u96c6\u548c\u6e05\u6d17\u6570\u636e\u96c6\uff0c\u4ec5\u4ec5\u9700\u8981\u51e0\u7bc7\u9ad8\u8d28\u91cf\u7684\u6587\u6863\u548c\u6559\u7a0b\uff0c\u6570\u91cf\u975e\u5e38\u5c11\uff0c\u4f7f\u7528\u81ea\u7136\u8bed\u8a00\u63cf\u8ff0\u5373\u53ef\uff1b\u6781\u5927\u5730\u51cf\u5c11\u4e86\u975e\u4e13\u4e1a\u4eba\u58eb\u7684\u51c6\u5907\u5de5\u4f5c\uff1b</li> <li>\u53ea\u9700\u8981\u5bf9\u8bdd\u4e0a\u4e0b\u6587\u5373\u53ef\u76f4\u89c2\u548c\u65b9\u4fbf\u5730\u8fdb\u884c\u8bad\u7ec3\uff0c\u4efb\u4f55\u4eba\u90fd\u53ef\u4ee5\u8f7b\u677e\u7406\u89e3\uff08\u6216\u8005\u5c1d\u8bd5\u7c7b\u6bd4\uff09AI \u662f\u600e\u4e48\u8fdb\u884c\u5b66\u4e60\u7684\uff1b</li> <li>\u53ef\u4ee5\u9002\u5e94\u975e\u5e38\u591a\u79cd\u4e0d\u540c\u9886\u57df\u7684\u4efb\u52a1\uff0c\u53ea\u8981\u4efb\u4f55\u4efb\u52a1\u80fd\u88ab\u8f6c\u6362\u6210\u4e00\u6bb5\u6587\u672c\u6216\u6307\u4ee4\uff1b</li> </ul> <p>\u6b63\u5982\u54c8\u5c14\u6ee8\u5de5\u4e1a\u5927\u5b66\u8f66\u4e07\u7fd4\u5148\u751f\u5728\u9752\u6e90Workshop\u4e2d\u63d0\u53ca\u7684\uff0cChatGPT \u65f6\u4ee3\uff0cNLPer \u7684\u5371\u4e0e\u673a\u4e2d\u6240\u8bf4\u7684\u90a3\u6837\uff1a</p> <p>ChatGPT\u65f6\u4ee3\uff0c\u4e3a\u4e86\u5e94\u5bf9\u5f53\u524d\u7684\u6311\u6218\uff0c\u81ea\u7136\u8bed\u8a00\u9886\u57df\u7684\u7814\u7a76\u8005\u53ef\u4ee5\u501f\u9274\u4fe1\u606f\u68c0\u7d22\u7814\u7a76\u8005\u7684\u7ecf\u9a8c\u3002\u9996\u5148\uff0c\u5b66\u672f\u754c\u53ef\u80fd\u4e0d\u518d\u8fdb\u884c\u7cfb\u7edf\u7ea7\u522b\u7684\u7814\u7a76\uff0c\u4e3b\u8981\u96c6\u4e2d\u5728\u76f8\u5bf9\u8fb9\u7f18\u7684\u7814\u7a76\u65b9\u5411\u4e0a\uff1b\u5176\u6b21\uff0c\u4f7f\u7528\u5de5\u4e1a\u754c\u5de8\u5934\u63d0\u4f9b\u7684\u6570\u636e\u8fdb\u884c\u5b9e\u9a8c\uff0c\u5e76\u4e0d\u4e00\u5b9a\u80fd\u5f97\u51fa\u53ef\u9760\u7684\u7ed3\u8bba\uff0c\u7531\u4e8e\u5b58\u5728\u9690\u79c1\u95ee\u9898\uff0c\u6570\u636e\u7684\u771f\u5b9e\u6027\u5b58\u7591\uff1b\u901a\u8fc7\u8c03\u7528\u516c\u53f8\u63d0\u4f9b\u7684 API \u8fdb\u884c\u7814\u7a76\uff0c\u4e00\u65e6\u6a21\u578b\u88ab\u8c03\u6574\uff0c\u5176\u7ed3\u8bba\u6709\u53ef\u80fd\u4e5f\u4f1a\u6539\u53d8\u3002</p> <p>\u5f53\u4f7f\u7528 AI \u89e3\u51b3\u7279\u5b9a\u95ee\u9898\u7684\u95e8\u69db\u53d8\u5f97\u8db3\u591f\u7684\u4f4e\u5ec9\uff0c\u53cd\u800c\u662f AI \u66f4\u8fdb\u4e00\u6b65\u666e\u53ca\u3001\u66f4\u8fdb\u4e00\u6b65\u89e3\u51b3\u66f4\u591a\u7ec6\u5206\u573a\u666f\u4e0b\u7684\u95ee\u9898\u7684\u5de8\u5927\u673a\u4f1a\u3002\u53e6\u4e00\u65b9\u9762\u53ef\u80fd\u662f\u652f\u6491 AI \u7684\u57fa\u7840\u8bbe\u65bd\uff1a\u5f53\u751f\u6210\u7684\u5185\u5bb9\uff08\u4f8b\u5982\u4ee3\u7801\uff0c\u6587\u672c\uff0c\u7b97\u6cd5\uff0c\u97f3\u9891\u89c6\u9891\uff09\u7684\u6210\u672c\u53d8\u5f97\u66f4\u5ec9\u4ef7\uff0c\u4e5f\u8bb8\u53ef\u7f16\u7a0b\u3001\u4f4e\u4ee3\u7801\u7684\u5e73\u53f0\u4e5f\u4f1a\u53d8\u5f97\u76f8\u5bf9\u539f\u5148\u5de8\u5927\u7684\u5355\u4f53\u5e94\u7528\u6765\u8bf4\uff0c\u53d8\u5f97\u66f4\u52a0\u5177\u6709\u53ef\u6269\u5c55\u6027\u548c\u53ef\u590d\u7528\u6027\u3002\u4f8b\u5982\uff0c\u4ece\u4e00\u6bb5\u63cf\u8ff0\u6216\u4ea4\u4e92\u5f0f\u5730\u5bf9\u8bdd\u4e2d\u76f4\u63a5\u751f\u6210\u4e00\u4e2a FaaS \u7684\u63a5\u53e3\u53d1\u5e03\uff0c\u76f4\u63a5\u751f\u6210\u4e00\u4e2a\u7f51\u9875\u524d\u7aef\u5e76\u90e8\u7f72\uff0c\u6216\u4f7f\u7528 ChatGPT \u751f\u6210\u7684\u4ee3\u7801\u76f4\u63a5\u4f5c\u4e3a\u53ef\u89c2\u6d4b\u7684\u91c7\u96c6\u548c\u6570\u636e\u5904\u7406\u7a0b\u5e8f\uff0c\u90e8\u7f72\u5230\u5927\u578b\u7684\u53ef\u89c2\u6d4b\u6027\u5e73\u53f0\u4e2d\u3002</p> <p>\u6211\u4eec\u73b0\u5728\u4e5f\u5728\u63a2\u7d22\u4e00\u4e9b eBPF \u548c Wasm \u7ed3\u5408\u7684\u7f16\u8bd1\u5de5\u5177\u94fe\u548c\u8fd0\u884c\u65f6\uff0c\u5e0c\u671b\u5b9e\u73b0\u4ece\u5185\u6838\u6001\u5230\u7528\u6237\u6001\u7684\u53ef\u7f16\u7a0b\u6269\u5c55\u6548\u679c\uff1ahttps://github.com/eunomia-bpf/wasm-bpf</p>"},{"location":"blogs/GPTtrace.zh/#_5","title":"\u4e00\u4e9b\u53c2\u8003\u94fe\u63a5","text":"<ul> <li>ChatGPT\uff1ahttps://chat.openai.com/chat</li> <li>GPTtrace\uff1ahttps://github.com/eunomia-bpf/GPTtrace</li> <li>ChatGPT Python API: https://github.com/mmabrouk/chatgpt-wrapper</li> <li>\u57fa\u4e8e CO-RE (\u4e00\u6b21\u7f16\u5199\uff0c\u5230\u5904\u8fd0\u884c\uff09 libbpf \u7684 eBPF \u5f00\u53d1\u8005\u6559\u7a0b\uff1a\u901a\u8fc7 20 \u4e2a\u5c0f\u5de5\u5177\u4e00\u6b65\u6b65\u5b66\u4e60 eBPF\uff08\u5c1d\u8bd5\u6559\u4f1a ChatGPT \u7f16\u5199 eBPF \u7a0b\u5e8f\uff09\uff1ahttps://github.com/eunomia-bpf/bpf-developer-tutorial</li> <li>ChatGPT\u7c7b\u5de5\u5177\u5982\u4f55\u5b9e\u73b0\u300c\u964d\u7ef4\u6253\u51fb\u300d| \u804a\u5929\u673a\u5668\u4eba\u95ed\u95e8\u7814\u8ba8\u89c2\u70b9\u603b\u7ed3\uff1ahttps://mp.weixin.qq.com/s/fB9rguy26ej-alm7l_i8iQ</li> <li>eunomia-bpf \u5f00\u6e90\u793e\u533a\uff1ahttps://github.com/eunomia-bpf</li> </ul> <p>\u6ce8\uff1a\u672c\u6587\u4f7f\u7528 ChatGPT \u8fdb\u884c\u8f85\u52a9\u5199\u4f5c\u5b8c\u6210\u3002</p>"},{"location":"blogs/bpf-news.zh/","title":"eBPF \u8fdb\u9636: \u5185\u6838\u65b0\u7279\u6027\u8fdb\u5c55\u4e00\u89c8","text":"<p>Linux \u5185\u6838\u5728 2022 \u5e74\u4e3b\u8981\u53d1\u5e03\u4e86 5.16-5.19 \u4ee5\u53ca 6.0 \u548c 6.1 \u8fd9\u51e0\u4e2a\u7248\u672c\uff0c\u6bcf\u4e2a\u7248\u672c\u90fd\u4e3a eBPF \u5f15\u5165\u4e86\u5927\u91cf\u7684\u65b0\u7279\u6027\u3002\u672c\u6587\u5c06\u5bf9\u8fd9\u4e9b\u65b0\u7279\u6027\u8fdb\u884c\u4e00\u70b9\u7b80\u8981\u7684\u4ecb\u7ecd\uff0c\u66f4\u8be6\u7ec6\u7684\u8d44\u6599\u8bf7\u53c2\u8003\u5bf9\u5e94\u7684\u94fe\u63a5\u4fe1\u606f\u3002\u603b\u4f53\u800c\u8a00\uff0ceBPF \u5728\u5185\u6838\u4e2d\u4f9d\u7136\u662f\u6700\u6d3b\u8dc3\u7684\u6a21\u5757\u4e4b\u4e00\uff0c\u5b83\u7684\u529f\u80fd\u7279\u6027\u4e5f\u8fd8\u5728\u9ad8\u901f\u53d1\u5c55\u4e2d\u3002\u67d0\u79cd\u610f\u4e49\u4e0a\u8bf4\uff0ceBPF \u6b63\u671d\u7740\u4e00\u4e2a\u5b8c\u5907\u7684\u5185\u6838\u6001\u53ef\u7f16\u7a0b\u63a5\u53e3\u5feb\u901f\u8fdb\u5316\u3002</p> <ul> <li>eBPF \u8fdb\u9636: \u5185\u6838\u65b0\u7279\u6027\u8fdb\u5c55\u4e00\u89c8</li> <li>BPF kfuncs</li> <li>Bloom Filter Map\uff1a5.16</li> <li>Compile Once \u2013 Run Everywhere\uff1aLinux 5.17</li> <li>bpf_loop() \u8f85\u52a9\u51fd\u6570\uff1a5.17</li> <li>BPF_LINK_TYPE_KPROBE_MULTI\uff1a5.18</li> <li>\u52a8\u6001\u6307\u9488\u548c\u7c7b\u578b\u6307\u9488\uff1a5.19</li> <li>USDT\uff1a5.19</li> <li>bpf panic\uff1a6.1</li> <li>BPF \u5185\u5b58\u5206\u914d\u5668\u3001\u94fe\u8868\uff1a6.1</li> <li>user ring buffer 6.1</li> </ul>"},{"location":"blogs/bpf-news.zh/#bpf-kfuncs","title":"BPF kfuncs","text":"<p>BPF\u5b50\u7cfb\u7edf\u66b4\u9732\u4e86\u5185\u6838\u5185\u90e8\u7b97\u6cd5\u548c\u6570\u636e\u7ed3\u6784\u7684\u8bb8\u591a\u65b9\u9762\uff1b\u8fd9\u81ea\u7136\u5bfc\u81f4\u4e86\u5bf9\u5728\u5185\u6838\u53d8\u5316\u65f6\u4fdd\u6301\u63a5\u53e3\u7a33\u5b9a\u6027\u7684\u5173\u6ce8\u3002\u957f\u671f\u4ee5\u6765\uff0cBPF\u5bf9\u7528\u6237\u7a7a\u95f4\u4e0d\u63d0\u4f9b\u63a5\u53e3\u7a33\u5b9a\u6027\u4fdd\u8bc1\u7684\u7acb\u573a\u4f3c\u4e4e\u4e00\u76f4\u6709\u70b9\u95ee\u9898\uff1b\u8fc7\u53bb\uff0c\u5185\u6838\u5f00\u53d1\u8005\u53d1\u73b0\u4ed6\u4eec\u4e0d\u5f97\u4e0d\u7ef4\u62a4\u90a3\u4e9b\u4e0d\u6253\u7b97\u7a33\u5b9a\u7684\u63a5\u53e3\u3002\u73b0\u5728BPF\u793e\u533a\u5f00\u59cb\u8003\u8651\u81f3\u5c11\u4e3a\u5b83\u7684\u4e00\u4e9b\u63a5\u53e3\u63d0\u4f9b\u660e\u786e\u7684\u7a33\u5b9a\u6027\u627f\u8bfa\u53ef\u80fd\u610f\u5473\u7740\u4ec0\u4e48\u3002</p> <p>BPF\u5141\u8bb8\u7531\u7528\u6237\u7a7a\u95f4\u52a0\u8f7d\u7684\u7a0b\u5e8f\u88ab\u9644\u52a0\u5230\u5927\u91cf\u94a9\u5b50\u4e2d\u7684\u4efb\u4f55\u4e00\u4e2a\uff0c\u5e76\u5728\u5185\u6838\u4e2d\u8fd0\u884c--\u5728\u5b50\u7cfb\u7edf\u7684\u9a8c\u8bc1\u5668\u5f97\u51fa\u8fd9\u4e9b\u7a0b\u5e8f\u4e0d\u4f1a\u635f\u5bb3\u7cfb\u7edf\u7684\u7ed3\u8bba\u4e4b\u540e\u3002\u4e00\u4e2a\u7a0b\u5e8f\u5c06\u83b7\u5f97\u7531\u5b83\u6240\u8fde\u63a5\u7684\u94a9\u5b50\u63d0\u4f9b\u7ed9\u5b83\u7684\u5185\u6838\u6570\u636e\u7ed3\u6784\u7684\u8bbf\u95ee\u6743\u3002\u5728\u67d0\u4e9b\u60c5\u51b5\u4e0b\uff0c\u7a0b\u5e8f\u53ef\u4ee5\u76f4\u63a5\u4fee\u6539\u8fd9\u4e9b\u6570\u636e\uff0c\u4ece\u800c\u76f4\u63a5\u5f71\u54cd\u5185\u6838\u7684\u8fd0\u884c\uff1b\u5728\u5176\u4ed6\u60c5\u51b5\u4e0b\uff0c\u5185\u6838\u5c06\u5bf9BPF\u7a0b\u5e8f\u8fd4\u56de\u7684\u503c\u91c7\u53d6\u884c\u52a8\uff0c\u4f8b\u5982\uff0c\u5141\u8bb8\u6216\u4e0d\u5141\u8bb8\u67d0\u9879\u64cd\u4f5c\u3002</p> <p>\u8fd8\u6709\u4e24\u79cd\u673a\u5236\uff0c\u5185\u6838\u53ef\u4ee5\u901a\u8fc7\u5b83\u4eec\u4f7fBPF\u7a0b\u5e8f\u83b7\u5f97\u989d\u5916\u7684\u529f\u80fd\u3002\u5e2e\u52a9\u51fd\u6570\uff08\u6216 \"helpers\"\uff09\u662f\u4e3a\u63d0\u4f9b\u7ed9BPF\u7a0b\u5e8f\u800c\u7f16\u5199\u7684\u7279\u6b8a\u51fd\u6570\uff1b\u5b83\u4eec\u4ece\u6269\u5c55BPF\u65f6\u4ee3\u5f00\u59cb\u5c31\u5b58\u5728\u4e86\u3002\u88ab\u79f0\u4e3akfuncs\u7684\u673a\u5236\u6bd4\u8f83\u65b0\uff1b\u5b83\u5141\u8bb8\u4efb\u4f55\u5185\u6838\u51fd\u6570\u88ab\u63d0\u4f9b\u7ed9BPF\uff0c\u53ef\u80fd\u4f1a\u6709\u4e00\u4e9b\u9650\u5236\u3002Kfuncs\u66f4\u7b80\u5355\u3001\u66f4\u7075\u6d3b\uff1b\u5982\u679c\u5b83\u4eec\u9996\u5148\u88ab\u5b9e\u73b0\uff0c\u90a3\u4e48\u4f3c\u4e4e\u4e0d\u592a\u53ef\u80fd\u6709\u4eba\u4f1a\u5728\u540e\u6765\u6dfb\u52a0\u5e2e\u52a9\u5668\u3002\u4e5f\u5c31\u662f\u8bf4\uff0ckfuncs\u6709\u4e00\u4e2a\u91cd\u8981\u7684\u9650\u5236\uff0c\u5373\u5b83\u4eec\u53ea\u80fd\u88abJIT\u7f16\u8bd1\u7684BPF\u4ee3\u7801\u8bbf\u95ee\uff0c\u6240\u4ee5\u5b83\u4eec\u5728\u7f3a\u4e4fJIT\u652f\u6301\u7684\u67b6\u6784\u4e0a\u662f\u4e0d\u53ef\u7528\u7684\uff08\u8fd9\u4e2a\u5217\u8868\u76ee\u524d\u5305\u62ec32\u4f4dArm\u548cRISC-V\uff0c\u5c3d\u7ba1\u589e\u52a0\u8fd9\u4e24\u79cd\u652f\u6301\u7684\u8865\u4e01\u6b63\u5728\u5f00\u53d1\u4e2d\uff09. \u6bcf\u4e2akfunc\u90fd\u4e3aBPF\u7a0b\u5e8f\u63d0\u4f9b\u4e86\u4e00\u4e9b\u6709\u7528\u7684\u529f\u80fd\uff0c\u4f46\u51e0\u4e4e\u6bcf\u4e2akfunc\u90fd\u66b4\u9732\u4e86\u5185\u6838\u5185\u90e8\u5de5\u4f5c\u65b9\u5f0f\u7684\u67d0\u4e9b\u65b9\u9762\u3002</p> <ul> <li>Reconsidering BPF ABI stability: https://mp.weixin.qq.com/s/wYDSXuwVgmGw-wmFgBNJcA</li> <li>Documentation/bpf: Add a description of \"stable kfuncs\" https://www.spinics.net/lists/kernel/msg4676660.html</li> </ul>"},{"location":"blogs/bpf-news.zh/#bloom-filter-map516","title":"Bloom Filter Map\uff1a5.16","text":"<p>\u5e03\u9686\u8fc7\u6ee4\u5668\u662f\u4e00\u79cd\u8282\u7701\u7a7a\u95f4\u7684\u6982\u7387\u6570\u636e\u7ed3\u6784\uff0c\u7528\u4e8e\u5feb\u901f\u6d4b\u8bd5\u4e00\u4e2a\u5143\u7d20\u662f\u5426\u5b58\u5728\u4e8e\u4e00\u4e2a\u96c6\u5408\u4e2d\u3002\u5728\u5e03\u9686\u8fc7\u6ee4\u5668\u4e2d\uff0c\u5047\u9633\u6027\u662f\u53ef\u80fd\u7684\uff0c\u800c\u5047\u9634\u6027\u5219\u4e0d\u53ef\u80fd\u3002</p> <p>\u8fd9\u4e2a\u8865\u4e01\u96c6\u5305\u62ec\u5e03\u9686\u8fc7\u6ee4\u5668\u4e2d\u53ef\u914d\u7f6e\u6570\u91cf\u7684\u54c8\u5e0c\u503c\u548c\u6761\u76ee\u7684\u57fa\u51c6\u6d4b\u8bd5\u3002\u8fd9\u4e9b\u57fa\u51c6\u5927\u81f4\u8868\u660e\uff0c\u5e73\u5747\u800c\u8a00\uff0c\u4f7f\u75283\u4e2a\u54c8\u5e0c\u51fd\u6570\u662f\u6700\u7406\u60f3\u7684\u9009\u62e9\u4e4b\u4e00\u3002\u5f53\u6bd4\u8f83hashmap\u67e5\u627e\u4e2d\u4f7f\u75283\u4e2a\u54c8\u5e0c\u503c\u7684bloom filter\u548c\u4e0d\u4f7f\u7528bloom filter\u7684hashmap\u67e5\u627e\u65f6\uff0c\u4f7f\u7528bloom filter\u7684\u67e5\u627e\u5bf9\u4e8e5\u4e07\u4e2a\u6761\u76ee\u5927\u7ea6\u5feb15%\uff0c\u5bf9\u4e8e10\u4e07\u4e2a\u6761\u76ee\u5feb25%\uff0c\u5bf9\u4e8e5\u4e07\u4e2a\u6761\u76ee\u5feb180%\uff0c\u5bf9\u4e8e1\u767e\u4e07\u4e2a\u6761\u76ee\u5feb200%\u3002</p> <ul> <li>BPF: Implement bloom filter map https://lwn.net/Articles/868024/</li> </ul>"},{"location":"blogs/bpf-news.zh/#compile-once-run-everywherelinux-517","title":"Compile Once \u2013 Run Everywhere\uff1aLinux 5.17","text":"<p>Linux 5.17 \u4e3a eBPF \u6dfb\u52a0\u4e86\u4e00\u6b21\u7f16\u8bd1\u5230\u5904\u6267\u884c\uff08Compile Once \u2013 Run Everywhere\uff0c\u7b80\u79f0 CO-RE\uff09\uff0c\u5927\u5927\u7b80\u5316\u4e86 eBPF \u7a0b\u5e8f\u5904\u7406\u591a\u7248\u672c\u5185\u6838\u517c\u5bb9\u65f6\u7684\u590d\u6742\u6027\u4ee5\u53ca\u5faa\u73af\u903b\u8f91\u7684\u5904\u7406\u3002</p> <p>eBPF \u7684\u4e00\u6b21\u7f16\u8bd1\u5230\u5904\u6267\u884c\uff08\u7b80\u79f0 CO-RE\uff09\u9879\u76ee\u501f\u52a9\u4e86 BPF \u7c7b\u578b\u683c\u5f0f\uff08BPF Type Format, \u7b80\u79f0 BTF\uff09\u63d0\u4f9b\u7684\u8c03\u8bd5\u4fe1\u606f\uff0c\u518d\u901a\u8fc7\u4e0b\u9762\u7684\u56db\u4e2a\u6b65\u9aa4\uff0c\u4f7f\u5f97 eBPF \u7a0b\u5e8f\u53ef\u4ee5\u9002\u914d\u4e0d\u540c\u7248\u672c\u7684\u5185\u6838\uff1a</p> <ul> <li>\u7b2c\u4e00\uff0c\u5728 bpftool \u5de5\u5177\u4e2d\u63d0\u4f9b\u4e86\u4ece BTF \u751f\u6210\u5934\u6587\u4ef6\u7684\u5de5\u5177\uff0c\u4ece\u800c\u6446\u8131\u4e86\u5bf9\u5185\u6838\u5934\u6587\u4ef6\u7684\u4f9d\u8d56\u3002</li> <li>\u7b2c\u4e8c\uff0c\u901a\u8fc7\u5bf9 BPF \u4ee3\u7801\u4e2d\u7684\u8bbf\u95ee\u504f\u79fb\u91cf\u8fdb\u884c\u91cd\u5199\uff0c\u89e3\u51b3\u4e86\u4e0d\u540c\u5185\u6838\u7248\u672c\u4e2d\u6570\u636e\u7ed3\u6784\u504f\u79fb\u91cf\u4e0d\u540c\u7684\u95ee\u9898\u3002</li> <li>\u7b2c\u4e09\uff0c\u5728 libbpf \u4e2d\u9884\u5b9a\u4e49\u4e0d\u540c\u5185\u6838\u7248\u672c\u4e2d\u6570\u636e\u7ed3\u6784\u7684\u4fee\u6539\uff0c\u89e3\u51b3\u4e86\u4e0d\u540c\u5185\u6838\u4e2d\u6570\u636e\u7ed3\u6784\u4e0d\u517c\u5bb9\u7684\u95ee\u9898\u3002</li> <li>\u7b2c\u56db\uff0c\u5728 libbpf \u4e2d\u63d0\u4f9b\u4e00\u7cfb\u5217\u7684\u5185\u6838\u7279\u6027\u63a2\u6d4b\u5e93\u51fd\u6570\uff0c\u89e3\u51b3\u4e86 eBPF \u7a0b\u5e8f\u5728\u4e0d\u540c\u5185\u6838\u5185\u7248\u672c\u4e2d\u9700\u8981\u6267\u884c\u4e0d\u540c\u884c\u4e3a\u7684\u95ee\u9898\u3002\u6bd4\u5982\uff0c\u4f60\u53ef\u4ee5\u7528 bpf_core_type_exists() \u548cbpf_core_field_exists() \u5206\u522b\u68c0\u67e5\u5185\u6838\u6570\u636e\u7c7b\u578b\u548c\u6210\u5458\u53d8\u91cf\u662f\u5426\u5b58\u5728\uff0c\u4e5f\u53ef\u4ee5\u7528\u7c7b\u4f3c extern int LINUX_KERNEL_VERSION __kconfig \u7684\u65b9\u5f0f\u67e5\u8be2\u5185\u6838\u7684\u914d\u7f6e\u9009\u9879\u3002</li> </ul> <p>\u91c7\u7528\u8fd9\u4e9b\u65b9\u6cd5\u4e4b\u540e\uff0cCO-RE \u5c31\u4f7f\u5f97 eBPF \u7a0b\u5e8f\u53ef\u4ee5\u5728\u5f00\u53d1\u73af\u5883\u7f16\u8bd1\u5b8c\u6210\u4e4b\u540e\uff0c\u5206\u53d1\u5230\u4e0d\u540c\u7248\u672c\u5185\u6838\u7684\u673a\u5668\u4e2d\u8fd0\u884c\uff0c\u5e76\u4e14\u4e5f\u4e0d\u518d\u9700\u8981\u76ee\u6807\u673a\u5668\u5b89\u88c5\u5404\u79cd\u5f00\u53d1\u5de5\u5177\u548c\u5185\u6838\u5934\u6587\u4ef6\u3002\u6240\u4ee5\uff0cLinux \u5185\u6838\u793e\u533a\u66f4\u63a8\u8350\u6240\u6709\u5f00\u53d1\u8005\u4f7f\u7528 CO-RE \u548c libbpf \u6765\u6784\u5efa eBPF \u7a0b\u5e8f\u3002\u5b9e\u9645\u4e0a\uff0c\u5982\u679c\u4f60\u770b\u8fc7 BCC \u7684\u6e90\u4ee3\u7801\uff0c\u4f60\u4f1a\u53d1\u73b0 BCC \u5df2\u7ecf\u628a\u5f88\u591a\u5de5\u5177\u90fd\u8fc1\u79fb\u5230\u4e86 CO-RE\u3002</p> <ul> <li>eBPF\u591a\u5185\u6838\u7248\u672c\u517c\u5bb9\u8be6\u89e3\uff1a https://time.geekbang.org/column/article/534577</li> <li>BPF CO-RE reference guide\uff1ahttps://nakryiko.com/posts/bpf-core-reference-guide/</li> </ul>"},{"location":"blogs/bpf-news.zh/#bpf_loop-517","title":"bpf_loop() \u8f85\u52a9\u51fd\u6570\uff1a5.17","text":"<p>\u6269\u5c55\u7684BPF\u865a\u62df\u673a\u7684\u4e3b\u8981\u7279\u5f81\u4e4b\u4e00\u662f\u5185\u7f6e\u4e8e\u5185\u6838\u7684\u9a8c\u8bc1\u5668\uff0c\u5b83\u786e\u4fdd\u6240\u6709BPF\u7a0b\u5e8f\u90fd\u80fd\u5b89\u5168\u8fd0\u884c\u3002\u4e0d\u8fc7\uff0cBPF\u5f00\u53d1\u8005\u5e38\u5e38\u8ba4\u4e3a\u9a8c\u8bc1\u5668\u6709\u70b9\u559c\u5fe7\u53c2\u534a\uff1b\u867d\u7136\u5b83\u80fd\u5728\u5f88\u591a\u95ee\u9898\u53d1\u751f\u4e4b\u524d\u6293\u4f4f\u5b83\u4eec\uff0c\u4f46\u5b83\u4e5f\u5f88\u96be\u8ba9\u4eba\u6ee1\u610f\u3002\u5c06\u5176\u4e0e\u4e00\u4e2a\u5584\u610f\u4f46\u53d7\u89c4\u5219\u7ea6\u675f\u4e14\u6311\u5254\u7684\u5b98\u50da\u673a\u6784\u76f8\u63d0\u5e76\u8bba\u5e76\u4e0d\u662f\u5b8c\u5168\u9519\u7684\u3002Joanne Koong\u63d0\u51fa\u7684 bpf_loop() \u5efa\u8bae\u662f\u4e3a\u4e86\u8ba9\u4e00\u79cd\u7c7b\u578b\u7684\u5faa\u73af\u7ed3\u6784\u66f4\u5bb9\u6613\u53d6\u60a6BPF\u7684\u5b98\u50da\u4eec\u3002</p> <p>\u7b80\u800c\u8a00\u4e4b\uff0c\u8fd9\u5c31\u662fKoong\u7684\u8865\u4e01\u7684\u76ee\u7684\u3002\u5b83\u589e\u52a0\u4e86\u4e00\u4e2a\u65b0\u7684\u8f85\u52a9\u51fd\u6570\uff0c\u53ef\u4ee5\u4eceBPF\u4ee3\u7801\u4e2d\u8c03\u7528\u3002</p> <pre><code>    long bpf_loop(u32 iterations, long (*loop_fn)(u32 index, void *ctx),\nvoid *ctx, u64 flags);\n</code></pre> <p>\u5bf9 bpf_loop() \u7684\u8c03\u7528\u5c06\u5bfc\u81f4\u5bf9 loop_fn() \u7684\u8fed\u4ee3\u8c03\u7528\uff0c\u8fed\u4ee3\u6570\u548c\u4f20\u5165\u7684 ctx \u4f5c\u4e3a\u53c2\u6570\u3002flags \u503c\u76ee\u524d\u672a\u4f7f\u7528\uff0c\u5fc5\u987b\u4e3a\u96f6\u3002loop_fn() \u901a\u5e38\u5c06\u8fd4\u56de0\uff1b\u8fd4\u56de\u503c\u4e3a1\u5c06\u7acb\u5373\u7ed3\u675f\u8fed\u4ee3\u3002\u4e0d\u5141\u8bb8\u6709\u5176\u4ed6\u7684\u8fd4\u56de\u503c\u3002</p> <p>\u4e0d\u50cf bpf_for_each_map_elem() \u53d7\u9650\u4e8e bpf map \u5927\u5c0f\uff0cbpf_loop() \u7684\u5faa\u73af\u6b21\u6570\u9ad8\u8fbe 1&lt;&lt;23 = 8388608\uff08\u8d85\u8fc7 8 \u767e\u4e07\uff09\u6b21\uff1b\u5927\u5927\u5730\u6269\u5c55\u4e86 bpf_loop() \u7684\u5e94\u7528\u573a\u666f\u3002\u4e0d\u8fc7\uff0cbpf_loop() \u5e76\u6ca1\u6709\u53d7\u9650\u4e8e BPF \u6307\u4ee4\u6570\uff081 \u767e\u4e07\u6761\uff09\uff0c\u8fd9\u662f\u56e0\u4e3a\u5faa\u73af\u53d1\u751f\u5728 bpf_loop() \u5e2e\u52a9\u51fd\u6570\u5185\u90e8\u3002</p> <ul> <li>A different approach to BPF loops\uff1ahttps://lwn.net/Articles/877062/</li> <li>eBPF Talk: \u5b9e\u6218\u7ecf\u9a8c\u4e4b loop\uff1ahttps://mp.weixin.qq.com/s/neOVsMNVWFbwpTSek-_YsA</li> </ul>"},{"location":"blogs/bpf-news.zh/#bpf_link_type_kprobe_multi518","title":"BPF_LINK_TYPE_KPROBE_MULTI\uff1a5.18","text":"<p>\u8fd9\u4e2a\u8865\u4e01\u96c6\u589e\u52a0\u4e86\u65b0\u7684\u94fe\u63a5\u7c7b\u578bBPF_TRACE_KPROBE_MULTI\uff0c\u5b83\u901a\u8fc7Masami\u5236\u4f5c\u7684fprobe API [1]\u6765\u8fde\u63a5kprobe\u7a0b\u5e8f\u3002fprobe API\u5141\u8bb8\u4e00\u6b21\u5728\u591a\u4e2a\u51fd\u6570\u4e0a\u9644\u52a0\u63a2\u9488\uff0c\u901f\u5ea6\u975e\u5e38\u5feb\uff0c\u56e0\u4e3a\u5b83\u5de5\u4f5c\u5728ftrace\u4e4b\u4e0a\u3002\u53e6\u4e00\u65b9\u9762\uff0c\u5b83\u5c06\u63a2\u6d4b\u70b9\u9650\u5236\u5728\u51fd\u6570\u5165\u53e3\u6216\u8fd4\u56de\u3002</p> <ul> <li>bpf: Add kprobe multi link\uff1ahttps://lwn.net/Articles/885811/</li> </ul>"},{"location":"blogs/bpf-news.zh/#519","title":"\u52a8\u6001\u6307\u9488\u548c\u7c7b\u578b\u6307\u9488\uff1a5.19","text":"<p>BPF\u7a0b\u5e8f\u4e2d\u7684\u6240\u6709\u5185\u5b58\u8bbf\u95ee\u90fd\u4f7f\u7528\u9a8c\u8bc1\u5668\u8fdb\u884c\u5b89\u5168\u6027\u9759\u6001\u68c0\u67e5\uff0c\u9a8c\u8bc1\u5668\u5728\u5141\u8bb8\u7a0b\u5e8f\u8fd0\u884c\u4e4b\u524d\u5bf9\u5176\u8fdb\u884c\u5168\u9762\u5206\u6790\u3002\u867d\u7136\u8fd9\u5141\u8bb8 BPF \u7a0b\u5e8f\u5728\u5185\u6838\u7a7a\u95f4\u4e2d\u5b89\u5168\u8fd0\u884c\uff0c\u4f46\u5b83\u9650\u5236\u4e86\u8be5\u7a0b\u5e8f\u5982\u4f55\u4f7f\u7528\u6307\u9488\u3002\u76f4\u5230\u6700\u8fd1\uff0c\u4e00\u4e2a\u8fd9\u6837\u7684\u9650\u5236\u662f\u5728 BPF \u7a0b\u5e8f\u4e2d\u88ab\u6307\u9488\u5f15\u7528\u7684\u5185\u5b58\u533a\u57df\u7684\u5927\u5c0f\u5fc5\u987b\u5728\u52a0\u8f7d BPF \u7a0b\u5e8f\u65f6\u9759\u6001\u77e5\u9053\u3002Joanne Koong \u6700\u8fd1\u8bbe\u7f6e\u7684\u4e00\u4e2a\u8865\u4e01\u96c6\u589e\u5f3a\u4e86 BPF\uff0c\u4ee5\u652f\u6301\u4f7f\u7528\u6307\u5411\u52a8\u6001\u5927\u5c0f\u7684\u5185\u5b58\u533a\u57df\u7684\u6307\u9488\u52a0\u8f7d\u7a0b\u5e8f\u3002</p> <p>Koong \u7684\u8865\u4e01\u96c6\u589e\u52a0\u4e86\u5bf9\u8bbf\u95ee BPF \u7a0b\u5e8f\u4e2d\u52a8\u6001\u5927\u5c0f\u7684\u5185\u5b58\u533a\u57df\u7684\u652f\u6301\uff0c\u5176\u4e2d\u5305\u542b\u4e00\u4e2a\u540d\u4e3a dynptrs \u7684\u65b0\u7279\u6027\u3002dynptrs \u80cc\u540e\u7684\u4e3b\u8981\u601d\u60f3\u662f\u5c06\u6307\u5411\u52a8\u6001\u5927\u5c0f\u7684\u6570\u636e\u533a\u57df\u7684\u6307\u9488\u4e0e\u9a8c\u8bc1\u5668\u548c\u4e00\u4e9b BPF \u8f85\u52a9\u51fd\u6570\u4f7f\u7528\u7684\u5143\u6570\u636e\u76f8\u5173\u8054\uff0c\u4ee5\u786e\u4fdd\u5bf9\u8be5\u533a\u57df\u7684\u8bbf\u95ee\u662f\u6709\u6548\u7684\u3002Koong \u7684\u8865\u4e01\u96c6\u5728\u4e00\u4e2a\u65b0\u5b9a\u4e49\u7684\u7c7b\u578b\u4e2d\u521b\u5efa\u4e86\u8fd9\u79cd\u5173\u8054\uff0c\u79f0\u4e3astruct bpf_dynptr\u3002\u8fd9\u79cd\u7ed3\u6784\u5bf9 BPF \u7a0b\u5e8f\u662f\u4e0d\u900f\u660e\u7684\u3002</p> <ul> <li>https://mp.weixin.qq.com/s/rz4pd41Y-Cet5YVSAKmCRw</li> </ul>"},{"location":"blogs/bpf-news.zh/#usdt519","title":"USDT\uff1a5.19","text":"<p>\u9759\u6001\u8ddf\u8e2a\u70b9\uff08tracepoint\uff09\uff0c\u5728\u7528\u6237\u7a7a\u95f4\u4e5f\u88ab\u79f0\u4e3a USDT\uff08\u7528\u6237\u9759\u6001\u5b9a\u4e49\u7684\u8ddf\u8e2a\uff09\u63a2\u9488\uff08\u5e94\u7528\u7a0b\u5e8f\u4e2d\u611f\u5174\u8da3\u7684\u7279\u5b9a\u4f4d\u7f6e\uff09\uff0c\u8ddf\u8e2a\u5668\u53ef\u4ee5\u5728\u6b64\u5904\u6302\u8f7d\u68c0\u67e5\u4ee3\u7801\u6267\u884c\u548c\u6570\u636e\u3002\u5b83\u4eec\u7531\u5f00\u53d1\u4eba\u5458\u5728\u6e90\u4ee3\u7801\u4e2d\u660e\u786e\u5b9a\u4e49\uff0c\u901a\u5e38\u5728\u7f16\u8bd1\u65f6\u7528 \u201c\u2013enable-trace\u201d \u7b49\u6807\u5fd7\u542f\u7528\u3002\u9759\u6001\u8ddf\u8e2a\u70b9\u7684\u4f18\u52bf\u5728\u4e8e\u5b83\u4eec\u4e0d\u4f1a\u7ecf\u5e38\u53d8\u5316\uff1a\u5f00\u53d1\u4eba\u5458\u901a\u5e38\u4f1a\u4fdd\u6301\u7a33\u5b9a\u7684\u9759\u6001\u8ddf\u8e2a ABI\uff0c\u6240\u4ee5\u8ddf\u8e2a\u5de5\u5177\u5728\u4e0d\u540c\u7684\u5e94\u7528\u7a0b\u5e8f\u7248\u672c\u4e4b\u95f4\u5de5\u4f5c\uff0c\u8fd9\u5f88\u6709\u7528\uff0c\u4f8b\u5982\u5f53\u5347\u7ea7 PostgreSQL \u5b89\u88c5\u5e76\u9047\u5230\u6027\u80fd\u964d\u4f4e\u65f6\u3002</p> <ul> <li>eBPF \u6982\u8ff0\uff1a\u7b2c 5 \u90e8\u5206\uff1a\u8ddf\u8e2a\u7528\u6237\u8fdb\u7a0b\uff1ahttps://www.ebpf.top/post/ebpf-overview-part-5/</li> <li>Using user-space tracepoints with BPF\uff1ahttps://lwn.net/Articles/753601/</li> </ul>"},{"location":"blogs/bpf-news.zh/#bpf-panic61","title":"bpf panic\uff1a6.1","text":"<p>BPF\u5b50\u7cfb\u7edf\u7684\u5173\u952e\u5356\u70b9\u4e4b\u4e00\u662f\u52a0\u8f7dBPF\u7a0b\u5e8f\u662f\u5b89\u5168\u7684\uff1aBPF\u9a8c\u8bc1\u5668\u5728\u5141\u8bb8\u52a0\u8f7d\u4e4b\u524d\u786e\u4fdd\u8be5\u7a0b\u5e8f\u4e0d\u4f1a\u4f24\u5bb3\u5185\u6838\u3002\u968f\u7740\u66f4\u591a\u7684\u529f\u80fd\u88ab\u63d0\u4f9b\u7ed9BPF\u7a0b\u5e8f\uff0c\u8fd9\u79cd\u4fdd\u8bc1\u4e5f\u8bb8\u4f1a\u5931\u53bb\u4e00\u4e9b\u529b\u91cf\uff0c\u4f46\u5373\u4fbf\u5982\u6b64\uff0c\u770b\u5230 Artem Savkov \u7684\u8fd9\u4e2a\u63d0\u8bae\u52a0\u5165\u4e86\u4e00\u4e2a\u660e\u786e\u8bbe\u8ba1\u4e3a\u4f7f\u7cfb\u7edf\u5d29\u6e83\u7684BPF\u52a9\u624b\uff0c\u53ef\u80fd\u4f1a\u8ba9\u4eba\u6709\u70b9\u5403\u60ca\u3002\u5982\u679c\u8fd9\u4e2a\u8865\u4e01\u96c6\u4ee5\u7c7b\u4f3c\u4e8e\u76ee\u524d\u7684\u5f62\u5f0f\u88ab\u5408\u5e76\uff0c\u5b83\u5c06\u662f\u4e00\u4e2a\u65b0\u65f6\u4ee3\u7684\u9884\u5146\uff0c\u5373\u81f3\u5c11\u5728\u67d0\u4e9b\u60c5\u51b5\u4e0b\uff0cBPF\u7a0b\u5e8f\u88ab\u5141\u8bb8\u516c\u5f00\u5730\u8fdb\u884c\u7834\u574f\u3002</p> <p>\u6b63\u5982 Savkov \u6240\u6307\u51fa\u7684\uff0cBPF \u7684\u4e3b\u8981\u7528\u4f8b\u4e4b\u4e00\u662f\u5185\u6838\u8c03\u8bd5\uff0c\u8fd9\u9879\u4efb\u52a1\u4e5f\u7ecf\u5e38\u56e0\u4e3a\u5b58\u5728\u4e00\u4e2a\u9002\u65f6\u7684\u5d29\u6e83\u8f6c\u50a8\u800c\u5f97\u5230\u5e2e\u52a9\u3002\u901a\u8fc7\u4f7f\u5185\u6838\u7684panic() \u51fd\u6570\u5bf9BPF\u7a0b\u5e8f\u53ef\u7528\uff0cSavkov\u8bd5\u56fe\u5c06\u8fd9\u4e24\u8005\u7ed3\u5408\u8d77\u6765\uff0c\u5141\u8bb8BPF\u7a0b\u5e8f\u5728\u68c0\u6d4b\u5230\u8868\u660e\u5f00\u53d1\u4eba\u5458\u6b63\u5728\u5bfb\u627e\u7684\u95ee\u9898\u7684\u6761\u4ef6\u65f6\u5bfc\u81f4\u5d29\u6e83\uff0c\u5e76\u521b\u5efa\u5d29\u6e83\u8f6c\u50a8\u3002Savkov\u4f3c\u4e4e\u4e0d\u662f\u552f\u4e00\u60f3\u8981\u8fd9\u79cd\u80fd\u529b\u7684\u4eba\uff1bJiri Olsa\u6307\u51fa\uff0c\u4ed6\u4e5f\u6536\u5230\u4e86\u5173\u4e8e\u8fd9\u79cd\u529f\u80fd\u7684\u8bf7\u6c42\u3002</p> <ul> <li>The BPF panic function: https://lwn.net/Articles/901284/</li> </ul>"},{"location":"blogs/bpf-news.zh/#bpf-61","title":"BPF \u5185\u5b58\u5206\u914d\u5668\u3001\u94fe\u8868\uff1a6.1","text":"<p>\u672c\u7cfb\u5217\u4ecb\u7ecd\u4e86\u7528\u6237\u5b9a\u4e49\u7684BPF\u5bf9\u8c61\u5728\u7a0b\u5e8f\u4e2d\u7684 BTF \u7c7b\u578b\u3002\u8fd9\u5141\u8bb8BPF\u7a0b\u5e8f\u5206\u914d\u4ed6\u4eec\u81ea\u5df1\u7684\u5bf9\u8c61\uff0c\u5efa\u7acb\u4ed6\u4eec\u7684\u81ea\u5df1\u7684\u5bf9\u8c61\u5c42\u6b21\uff0c\u5e76\u4f7f\u7528\u7531BPF \u8fd0\u884c\u65f6\u63d0\u4f9b\u7684\u57fa\u672c\u6784\u4ef6\u6765\u7075\u6d3b\u5730\u5efa\u7acb\u81ea\u5df1\u7684\u6570\u636e\u7ed3\u6784\u3002</p> <p>\u7136\u540e\uff0c\u6211\u4eec\u4ecb\u7ecd\u4e86\u5bf9\u5355\u4e00\u6240\u6709\u6743BPF\u94fe\u8868\u7684\u652f\u6301\u3002\u5b83\u53ef\u4ee5\u653e\u5728BPF\u6620\u5c04\u6216\u5206\u914d\u7684\u5bf9\u8c61\u4e2d\uff0c\u5e76\u628a\u8fd9\u4e9b\u88ab\u5206\u914d\u7684\u5bf9\u8c61\u4f5c\u4e3a\u5143\u7d20\u3002\u5b83\u4f5c\u4e3a\u4e00\u4e2a\u4fb5\u5165\u6027\u7684\u96c6\u5408\u5de5\u4f5c\u3002\u8fd9\u6837\u505a\u7684\u76ee\u7684\u662f\u4e3a\u4e86\u5728\u5c06\u6765\u4f7f\u5206\u914d\u7684\u5bf9\u8c61\u6210\u4e3a\u591a\u4e2a\u6570\u636e\u7ed3\u6784\u7684\u4e00\u90e8\u5206\u3002</p> <p>\u8fd9\u4e2a\u8865\u4e01\u548c\u672a\u6765\u8865\u4e01\u7684\u6700\u7ec8\u76ee\u6807\u662f\u5141\u8bb8\u4eba\u4eec\u5728 BPF C \u4e2d\u505a\u4e00\u4e9b\u6709\u9650\u7684\u5185\u6838\u5f0f\u7f16\u7a0b\uff0c\u5e76\u5141\u8bb8\u7a0b\u5e8f\u5458\u7075\u6d3b\u5730\u4ece\u57fa\u672c\u7684\u6784\u5efa\u5757\u4e2d\u7075\u6d3b\u5730\u6784\u5efa\u81ea\u5df1\u7684\u590d\u6742\u6570\u636e\u7ed3\u6784\u3002</p> <p>\u5173\u952e\u7684\u533a\u522b\u5728\u4e8e\uff0c\u8fd9\u79cd\u7a0b\u5e8f\u662f\u7ecf\u8fc7\u9a8c\u8bc1\u7684\uff0c\u662f\u5b89\u5168\u7684\uff0c\u4fdd\u5b58\u7cfb\u7edf\u7684\u8fd0\u884c\u65f6\u5b8c\u6574\u6027\uff0c\u5e76\u88ab\u8bc1\u660e\u662f\u6ca1\u6709\u9519\u8bef\u7684</p> <p>\u5177\u4f53\u7684\u529f\u80fd\u5305\u542b</p> <ul> <li>\u5206\u914d\u5bf9\u8c61</li> <li>bpf_obj_new, bpf_obj_drop \u6765\u5206\u914d\u548c\u91ca\u653e\u5bf9\u8c61</li> <li>\u5355\u4e00\u6240\u6709\u6743\u7684BPF\u94fe\u8868</li> <li>\u5728 BPF maps \u4e2d\u652f\u6301\u5b83\u4eec</li> <li>\u5728\u5206\u914d\u7684\u5bf9\u8c61\u4e2d\u652f\u6301\u5b83\u4eec</li> <li>\u5168\u5c40\u81ea\u65cb\u9501\u3002</li> <li>\u5728\u88ab\u5206\u914d\u5bf9\u8c61\u4e2d\u7684\u81ea\u65cb\u9501\u3002</li> </ul> <p>\u53c2\u8003\uff1ahttps://lwn.net/Articles/914833/</p>"},{"location":"blogs/bpf-news.zh/#user-ring-buffer-61","title":"user ring buffer 6.1","text":"<p>\u8fd9\u4e2a\u8865\u4e01\u96c6\u5b9a\u4e49\u4e86\u4e00\u4e2a\u65b0\u7684\u6620\u5c04\u7c7b\u578b\uff0cBPF_MAP_TYPE_USER_RINGBUF\uff0c\u5b83\u5728\u4e00\u4e2a\u73af\u5f62\u7f13\u51b2\u5668\u4e0a\u63d0\u4f9b\u4e86\u5355\u7528\u6237\u7a7a\u95f4\u751f\u4ea7\u8005/\u5355\u5185\u6838\u6d88\u8d39\u8005\u7684\u8bed\u4e49\u3002  \u9664\u4e86\u65b0\u7684\u6620\u5c04\u7c7b\u578b\u5916\uff0c\u8fd8\u589e\u52a0\u4e86\u4e00\u4e2a\u540d\u4e3abpf_user_ringbuf_drain()\u7684\u8f85\u52a9\u51fd\u6570\uff0c\u5b83\u5141\u8bb8BPF\u7a0b\u5e8f\u6307\u5b9a\u4e00\u4e2a\u5177\u6709\u5982\u4e0b\u7b7e\u540d\u7684\u56de\u8c03\uff0c\u6837\u672c\u7531\u8f85\u52a9\u51fd\u6570\u53d1\u5e03\u5230\u8be5\u56de\u8c03\u3002</p> <pre><code>void\uff08struct bpf_dynptr *dynptr, void *context\uff09\u3002\n</code></pre> <p>\u7136\u540e\u7a0b\u5e8f\u53ef\u4ee5\u4f7f\u7528bpf_dynptr_read()\u6216bpf_dynptr_data()\u8f85\u52a9\u51fd\u6570\u6765\u5b89\u5168\u5730\u4ecedynptr\u4e2d\u8bfb\u53d6\u6837\u672c\u3002\u76ee\u524d\u6ca1\u6709\u53ef\u7528\u7684\u8f85\u52a9\u51fd\u6570\u6765\u786e\u5b9a\u6837\u672c\u7684\u5927\u5c0f\uff0c\u4f46\u662f\u5982\u679c\u9700\u8981\u7684\u8bdd\uff0c\u53ef\u4ee5\u5f88\u5bb9\u6613\u5730\u6dfb\u52a0\u4e00\u4e2a\u3002</p> <p>libbpf \u4e5f\u6dfb\u52a0\u4e86\u4e00\u4e9b\u5bf9\u5e94\u7684 API:</p> <pre><code>struct ring_buffer_user *\nring_buffer_user__new(int map_fd,\nconst struct ring_buffer_user_opts *opts);\nvoid ring_buffer_user__free(struct ring_buffer_user *rb);\nvoid *ring_buffer_user__reserve(struct ring_buffer_user *rb,\nuint32_t size);\nvoid *ring_buffer_user__poll(struct ring_buffer_user *rb, uint32_t size,\nint timeout_ms);\nvoid ring_buffer_user__discard(struct ring_buffer_user *rb, void *sample);\nvoid ring_buffer_user__submit(struct ring_buffer_user *rb, void *sample);\n</code></pre> <ul> <li>bpf: Add user-space-publisher ring buffer map type\uff1a https://lwn.net/Articles/907056/</li> </ul> <ul> <li>\u672c\u6587\u7531 eunomia-bpf \u56e2\u961f\u5b8c\u6210\uff0c\u6211\u4eec\u6b63\u5728\u63a2\u7d22 eBPF \u548c WebAssembly \u76f8\u4e92\u7ed3\u5408\u7684\u5de5\u5177\u94fe\u548c\u8fd0\u884c\u65f6: https://github.com/eunomia-bpf/wasm-bpf</li> <li>\u4ee5\u53ca\u5728 Wasm \u548c eBPF \u4e4b\u4e0a\uff0c\u5c1d\u8bd5\u6784\u5efa\u4e00\u4e9b\u6709\u8da3\u7684\u5e94\u7528\u573a\u666f\uff1a</li> </ul>"},{"location":"blogs/coolbpf-eunomia.zh/","title":"eunomia-bpf\uff1a\u5c55\u671b 2023\uff0c\u8ba9 eBPF \u63d2\u4e0a Wasm \u7684\u7fc5\u8180","text":""},{"location":"blogs/coolbpf-eunomia.zh/#httpszhuanlanzhihucomp600638396","title":"! https://zhuanlan.zhihu.com/p/600638396","text":"<p>\u56de\u671b\u8fc7\u53bb\u7684 2022 \u5e74\uff0c\u6709\u4e24\u9879\u6280\u672f\u5907\u53d7\u77a9\u76ee\uff1aeBPF \u548c WebAssembly\u3002</p>"},{"location":"blogs/coolbpf-eunomia.zh/#ebpf","title":"eBPF: \u5168\u65b0\u7684\u53ef\u80fd\u6027","text":"<p>eBPF \u662f\u4e00\u9879\u9769\u547d\u6027\u7684\u6280\u672f\uff0c\u8d77\u6e90\u4e8eLinux\u5185\u6838\uff0c\u53ef\u4ee5\u5728\u64cd\u4f5c\u7cfb\u7edf\u7684\u5185\u6838\u4e2d\u8fd0\u884c\u6c99\u76d2\u7a0b\u5e8f\u3002\u5b83\u88ab\u7528\u6765\u5b89\u5168\u548c\u6709\u6548\u5730\u6269\u5c55\u5185\u6838\u7684\u529f\u80fd\uff0c\u800c\u4e0d\u9700\u8981\u6539\u53d8\u5185\u6838\u7684\u6e90\u4ee3\u7801\u6216\u52a0\u8f7d\u5185\u6838\u6a21\u5757\u3002</p> <p>\u8fc7\u53bb\u4e00\u5e74\u4e2d\uff0c\u53ef\u89c2\u6d4b\u6280\u672f\u5f97\u5230\u4e86\u6781\u5927\u5173\u6ce8\uff0c\u4e5f\u88ab Gartner \u5217\u4e3a 2023 \u5e74\u5341\u5927\u6218\u7565\u6280\u672f\u8d8b\u52bf\u4e4b\u4e00\u3002eBPF \u672c\u8eab\u662f\u5bf9\u4f20\u7edf\u89c2\u6d4b\u80fd\u529b\u4e00\u4e2a\u975e\u5e38\u597d\u7684\u8865\u5145\uff0c\u5728\u5bf9\u5185\u6838\u65e0\u4fb5\u5165\u7684\u524d\u63d0\u4e0b\uff0c\u5b83\u901a\u8fc7\u52a8\u6001\u5730\u5411\u5185\u6838\u4e2d\u63d2\u5165\u4e00\u6bb5\u81ea\u5df1\u7684\u4ee3\u7801\uff0c\u5b9e\u73b0\u5b9a\u4e49\u76d1\u63a7\u53ca\u8ddf\u8e2a\u7b49\u591a\u79cd\u591a\u6837\u7684\u80fd\u529b\u3002\u540c\u65f6\uff0c eBPF \u4e5f\u4fc3\u8fdb\u4e86\u7f51\u7edc\uff0c\u5b89\u5168\u6027\uff0c\u5e94\u7528\u7a0b\u5e8f\u914d\u7f6e\u8ddf\u8e2a\u548c\u6027\u80fd\u6545\u969c\u6392\u9664\u7b49\u7b49\u9886\u57df\u7684\u65b0\u4e00\u4ee3\u5de5\u5177\u7684\u5f00\u53d1\uff0c\u8fd9\u4e9b\u5de5\u5177\u4e0d\u518d\u4f9d\u8d56\u73b0\u6709\u7684\u5185\u6838\u529f\u80fd\uff0c\u800c\u662f\u5728\u4e0d\u5f71\u54cd\u6267\u884c\u6548\u7387\u6216\u5b89\u5168\u6027\u7684\u60c5\u51b5\u4e0b\u4e3b\u52a8\u91cd\u65b0\u8fd0\u884c\u3002</p> <p>\u5982\u4eca\uff0c eBPF \u88ab\u5e7f\u6cdb\u5e94\u7528\u5728\u4e91\u539f\u751f\u3001\u53ef\u89c2\u6d4b\u3001\u6027\u80fd\u8c03\u4f18\u3001\u5b89\u5168\u3001\u786c\u4ef6\u52a0\u901f\u7b49\u9886\u57df\uff0c\u5e76\u4e14\u5176\u5e94\u7528\u573a\u666f\u8fd8\u5728\u5feb\u901f\u6269\u5c55\uff0c\u5404\u79cd\u573a\u666f\u57fa\u4e8e eBPF \u6280\u672f\u7684\u521b\u65b0\u9879\u76ee\u5448\u73b0\u4e95\u55b7\u73b0\u8c61\uff0c\u5bf9\u4e8e\u64cd\u4f5c\u7cfb\u7edf\u793e\u533a\u800c\u8a00\uff0ceBPF \u6280\u672f\u5e26\u6765\u4e86\u4e00\u4e2a\u5168\u65b0\u7684\u53ef\u80fd\u6027\u4ee5\u53ca\u5e7f\u9614\u7684\u5929\u5730\uff0c eBPF \u7684\u65f6\u4ee3\u5df2\u7136\u6765\u4e34\u3002</p> <p>\u8fc7\u53bb\u7684 eBPF summit 2022 \u4e2d\uff0c\u300aThe future of eBPF in the Linux Kernel\u300b\u5c55\u671b\u4e86 eBPF \u76f8\u5173\u6280\u672f\u7684\u53d1\u5c55\u65b9\u5411\uff0c\u5177\u4f53\u7684\u6f14\u8fdb\u65b9\u5411\u53ef\u80fd\u5305\u542b\u51e0\u4e2a\u65b9\u9762\uff1a</p> <ul> <li>\u66f4\u5b8c\u5907\u7684\u7f16\u7a0b\u8bed\u4e49\u652f\u6301\uff1a\u5f53\u524d eBPF \u7684\u7f16\u7a0b\u80fd\u529b\u5b58\u5728\u4e00\u4e9b\u5c40\u9650\u6027\uff08\u6bd4\u5982\u4e0d\u652f\u6301\u53d8\u91cf\u8fb9\u754c\u7684\u5faa\u73af\uff0c\u6307\u4ee4\u6570\u91cf\u53d7\u9650\u7b49\uff09\uff0c\u672a\u6765\u5e0c\u671b\u80fd\u8fdb\u4e00\u6b65\u63d0\u4f9b\u56fe\u7075\u5b8c\u5907\u7684\u7f16\u7a0b\u80fd\u529b\uff0c\u589e\u5f3a eBPF \u7684\u5faa\u73af\u3001\u5185\u5b58\u5206\u914d\u7b49\u591a\u79cd\u8bed\u8a00\u7279\u6027\u3002</li> <li>\u66f4\u5f3a\u7684\u5b89\u5168\u6027\uff1a\u652f\u6301\u7c7b\u578b\u5b89\u5168\uff0c\u589e\u5f3a\u8fd0\u884c\u65f6 Verifier\uff0c\u5e0c\u671b BPF \u4e5f\u80fd\u63d0\u4f9b\u5ab2\u7f8e Rust \u7684\u5b89\u5168\u7f16\u7a0b\u80fd\u529b\uff0c\u4ee5\u53ca\u5c1d\u8bd5\u6709\u6ca1\u6709\u53ef\u80fd\u7ed3\u5408 Rust \u548c BPF \u7684\u7279\u6027\uff0c\u63d0\u4f9b\u66f4\u8fdb\u4e00\u6b65\u7684\u3001\u540c\u65f6\u4fdd\u8bc1\u53ef\u79fb\u690d\u548c\u5b89\u5168\u6027\u7684\u5185\u6838\u529f\u80fd\u3002</li> <li>\u66f4\u5e7f\u6cdb\u7684\u79fb\u690d\u80fd\u529b\uff1a\u589e\u5f3a CO-RE\uff0c\u52a0\u5f3a Helper \u63a5\u53e3\u53ef\u79fb\u690d\u80fd\u529b\uff0c\u5b9e\u73b0\u8de8\u4f53\u7cfb\u3001\u5e73\u53f0\u7684\u79fb\u690d\u80fd\u529b\u3002</li> <li>\u66f4\u5f3a\u7684\u5185\u6838\u53ef\u7f16\u7a0b\u80fd\u529b\uff1a\u652f\u6301\u8bbf\u95ee/\u4fee\u6539\u5185\u6838\u4efb\u610f\u53c2\u6570\u3001\u8fd4\u56de\u503c\uff0c\u5b9e\u73b0\u66f4\u5f3a\u7684\u5185\u6838\u7f16\u7a0b\u80fd\u529b\uff0c\u751a\u81f3\u4f7f\u7528 BPF \u6765\u5e2e\u52a9\u6784\u5efa\u548c\u589e\u5f3a\u5185\u6838\u672c\u8eab\u7684\u5b89\u5168\u6027\u3002</li> </ul>"},{"location":"blogs/coolbpf-eunomia.zh/#wasm","title":"Wasm: \u5f15\u9886\u4e0b\u4e00\u4ee3\u8ba1\u7b97\u8303\u5f0f","text":"<p>\u76f8\u5bf9\u4e8e eBPF \u4e3b\u8981\u5173\u6ce8\u4e8e\u5185\u6838\u6001\u6216\u8005\u548c\u5185\u6838\u76f8\u5173\u7684\u5e94\u7528\uff0c\u7528\u6237\u6001\u7684 WebAssembly \u4e5f\u6210\u4e3a\u4e86 2022 \u5e74\u65b0\u7684\u7126\u70b9\u3002</p> <p>WebAssembly\uff08\u7b80\u79f0 Wasm\uff09\u662f\u4e00\u4e2a\u81ea\u8bde\u751f\u4e4b\u65e5\u8d77\u5c31\u5145\u6ee1\u6f5c\u529b\u7684\u6280\u672f\uff0c\u4e00\u5f00\u59cb\u4e3a\u4e86\u4e00\u4e2a\u53ef\u79fb\u690d\u7684\u76ee\u6807\u800c\u8bbe\u8ba1\u7684\u4e00\u79cd\u7c7b\u4f3c\u6c47\u7f16\u5b57\u8282\u7801\u7684\u6307\u4ee4\u683c\u5f0f\u6807\u51c6\uff0c\u53ef\u7528\u4e8e\u7f16\u8bd1C/C+/RUST\u7b49\u9ad8\u7ea7\u8bed\u8a00\uff0c\u4f7f\u5ba2\u6237\u7aef\u548c\u670d\u52a1\u5668\u5e94\u7528\u7a0b\u5e8f\u80fd\u591f\u5728\u6d4f\u89c8\u5668\u4e0a\u90e8\u7f72\uff1b\u65f6\u81f3\u4eca\u65e5\uff0cWebAssembly \u6b63\u5728\u6cbf\u7740\u5176\u540d\u5b57\u4e2d Web \u548c Assembly \u4e24\u4e2a\u9886\u57df\u4e4b\u5916\u7684\u65b9\u5411\u53d1\u5c55\uff0c\u4f7f\u7528\u4e0e Wasm \u517c\u5bb9\u7684\u8fd0\u884c\u65f6\uff0cWasm \u6587\u4ef6\u53ef\u4ee5\u5728\u5ba2\u6237\u7aef\u548c\u670d\u52a1\u5668\u7aef\u6267\u884c\uff0c\u4ece \"JavaScript \u6740\u624b\" \u5230 \"\u4e91\u8ba1\u7b97\u7684\u4e0b\u4e00\u4e2a\u524d\u6cbf\u65b9\u5411\" \u51e0\u4e4e\u8986\u76d6\u4e86\u5168\u90e8\u65b0\u5174\u9886\u57df\uff0c\u540c\u65f6\u5728\u4ece\u4e91\u8ba1\u7b97\u3001serverless \u5411\u8fb9\u7f18\u8ba1\u7b97\u6e17\u900f\uff0cWasm \u5df2\u7ecf\u8fdc\u8fdc\u8d85\u51fa\u4e86\u8d77\u4f5c\u4e3a\u7b2c\u56db\u79cd Web \u6807\u51c6\u8bed\u8a00\u7684\u89d2\u8272\u3002\u751a\u81f3\u91cd\u65b0\u5b9a\u4e49\u4e86\u5e94\u7528\u8f6f\u4ef6\u7684\u5f00\u53d1\u6a21\u5f0f\uff0c\u6b63\u9010\u6e10\u63a5\u8fd1\u5176 \u201c\u4e00\u6b21\u7f16\u5199\uff0c\u968f\u5904\u8fd0\u884c\u201d \u7684\u613f\u666f\u3002</p> <p>Wasm \u6709\u51e0\u4e2a\u5173\u952e\u7684\u8bbe\u8ba1\u76ee\u6807\u4f7f\u5176\u51fa\u751f\u5f00\u59cb\u5c31\u81ea\u5e26\u4ee4\u4eba\u4eae\u773c\u7684\u5173\u6ce8\uff1a</p> <ul> <li>\u53ef\u79fb\u690d\uff1aWasm \u88ab\u8bbe\u8ba1\u4e3a\u9488\u5bf9\u4f4e\u7ea7\u865a\u62df\u673a\u67b6\u6784\uff0c\u5176\u6307\u4ee4\u7531\u7269\u7406\u673a\u5355\u72ec\u7ffb\u8bd1\u6210\u673a\u5668\u4ee3\u7801\u3002\u8fd9\u610f\u5473\u7740 Wasm \u4e8c\u8fdb\u5236\u6587\u4ef6\u6700\u7ec8\u53ef\u4ee5\u5728\u5404\u79cd\u64cd\u4f5c\u7cfb\u7edf\u548c\u82af\u7247\u67b6\u6784\u4e0a\u8fd0\u884c \u2014\u2014 \u65e0\u8bba\u662f\u5728\u8fd0\u884c X86 \u7b14\u8bb0\u672c\u7535\u8111\u7684\u6d4f\u89c8\u5668\u4e2d\uff0c\u8fd8\u662f\u5728\u5185\u90e8\u6216\u4e91\u7aef\u7684\u670d\u52a1\u5668\u4e0a\uff0c\u5728\u79fb\u52a8\u8bbe\u5907\u3001\u7269\u8054\u7f51\u8bbe\u5907\u4e0a\u7b49\u7b49\u3002</li> <li>\u591a\u8bed\u8a00\uff1a\u56e0\u4e3a Wasm \u662f\u4e00\u4e2a\u7f16\u8bd1\u76ee\u6807\uff0c\u7528\u4e8e\u7f16\u7a0b\u6a21\u5757\u7684\u5177\u4f53\u8bed\u8a00\u5e76\u4e0d\u91cd\u8981\uff0c\u91cd\u8981\u7684\u662f\u662f\u5426\u6709\u652f\u6301\u5c06\u8be5\u8bed\u8a00\u7f16\u8bd1\u5230 Wasm\u3002\u5f00\u53d1\u4eba\u5458\u53ef\u4ee5\u7075\u6d3b\u5730\u4f7f\u7528\u591a\u79cd\u8bed\u8a00\uff08\u5982 C\u3001C++\u3001Rust\u3001\u51f9\u8bed\u8a00\u7b49\uff09\u6765\u6784\u5efa\u4e8c\u8fdb\u5236\u6587\u4ef6\uff0c\u5e76\u4eab\u53d7 Wasm \u5e26\u6765\u7684\u7ea2\u5229\u3002</li> <li>\u8f7b\u91cf\u548c\u9ad8\u6548\uff1a\u4f5c\u4e3a\u4e00\u4e2a\u4f4e\u7ea7\u522b\u7684\u4e8c\u8fdb\u5236\u6307\u4ee4\u683c\u5f0f\uff0c\u53ea\u9700\u8981\u8f83\u5c11\u7684\u64cd\u4f5c\u6765\u5c06 Wasm \u7ffb\u8bd1\u6210\u4f18\u5316\u7684\u673a\u5668\u4ee3\u7801\u3002</li> <li>\u5b89\u5168\uff1aWasm \u76ee\u6807\u4e4b\u4e00\u662f\u5b89\u5168\uff0c\u5b83\u5728\u4e00\u4e2a\u6c99\u76d2\u73af\u5883\u4e2d\u6267\u884c\uff0c\u5bf9\u4e3b\u673a\u8fd0\u884c\u65f6\u6ca1\u6709\u521d\u59cb\u53ef\u89c1\u6027\u3002\u8fd9\u610f\u5473\u7740\u5bf9\u7cfb\u7edf\u8d44\u6e90\uff08\u5982\u6587\u4ef6\u7cfb\u7edf\uff0c\u786c\u4ef6\u7b49\uff09\u7684\u8bbf\u95ee\u662f\u53d7\u9650\u5236\u7684\uff0c\u9664\u975e\u660e\u786e\u5bfc\u5165\u4e86\u5bf9\u5e94\u7684\u51fd\u6570\u4ee5\u652f\u6301\u3002\u56e0\u6b64 Wasm \u6781\u5927\u9650\u5236\u4e86\u653b\u51fb\u9762\uff0c\u5b9e\u73b0\u4e86\u591a\u79df\u6237\u73af\u5883\u4e2d\u4e0d\u53d7\u4fe1\u4efb\u7684\u4ee3\u7801\u5b89\u5168\u53d7\u9650\u5730\u6267\u884c\u3002</li> </ul> <p>\u8fc7\u53bb\u7684 2022 \u5e74 Wasm \u53d6\u5f97\u4e86\u4e0d\u5c11\u6fc0\u52a8\u4eba\u5fc3\u7684\u6210\u5c31\uff0c\u8bb8\u591a\u65b0\u7684 Wasm \u521d\u521b\u516c\u53f8\u6d8c\u73b0\uff0c\u8001\u724c\u4e91\u670d\u52a1\u5546\u548c\u516c\u53f8\u5ba3\u5e03\u652f\u6301 Wasm\uff0c\u5b57\u8282\u7801\u8054\u76df\u63a8\u51fa\u4e86\u8bb8\u591a\u65b0\u7684 Wasm \u6807\u51c6\uff0cCNCF\u4e3b\u529e\u4e86\u4e24\u6b21 WasmDay \u6d3b\u52a8\uff0c\u800c Wasm \u6700\u5927\u7684\u7528\u6237\u4e4b\u4e00 Figma \u88ab Adobe \u4ee5\u60ca\u4eba\u7684 200 \u4ebf\u7f8e\u5143\u6536\u8d2d\u3002\u5bf9\u4e8e WebAssembly \u800c\u8a00\uff0c2023 \u5e74\u5f88\u6709\u53ef\u80fd\u4e5f\u4f1a\u662f\u7206\u53d1\u7684\u4e00\u5e74\uff1a</p> <ul> <li>\u7ec4\u4ef6\u6a21\u578b\u63cf\u8ff0\u4e86Wasm\u4e8c\u8fdb\u5236\u6587\u4ef6\u76f8\u4e92\u4ea4\u4e92\u7684\u65b9\u5f0f\uff0c\u6b63\u5728\u8fc5\u901f\u6210\u719f\uff0c\u5df2\u7ecf\u51fa\u73b0\u4e86\u53c2\u8003\u5b9e\u73b0\u3002\u5f00\u53d1\u4eba\u5458\u53ef\u4ee5\u58f0\u660e\u4ed6\u4eec\u7684\u5e94\u7528\u7a0b\u5e8f\u9700\u8981\u54ea\u4e9b\u7ec4\u4ef6\uff0c\u6216\u8005\u66f4\u62bd\u8c61\u5730\u8bf4\uff0c\u4ed6\u4eec\u7684\u5e94\u7528\u9700\u8981\u54ea\u4e9b\u529f\u80fd\uff08\u800c\u4e0d\u662f\u7528\u4ed6\u4eec\u9996\u9009\u7684\u6e90\u8bed\u8a00\u67e5\u627e\u5e93\uff09\uff0c\u7136\u540eWasm\u8fd0\u884c\u65f6\u53ef\u4ee5\u4ee3\u8868\u7528\u6237\u7ec4\u88c5\u6b63\u786e\u7684\u7ec4\u4ef6\u96c6\u30022023 \u5e74\u5c06\u662f\u7ec4\u4ef6\u6a21\u578b\u5f00\u59cb\u91cd\u65b0\u5b9a\u4e49\u6211\u4eec\u5982\u4f55\u7f16\u5199\u8f6f\u4ef6\u7684\u4e00\u5e74\u3002</li> <li>Wasm\u6539\u53d8\u4e86\u65e0\u670d\u52a1\u5668\u73af\u5883\u7684\u6f5c\u529b\u3002\u7531\u4e8e\u51e0\u4e4e\u5373\u65f6\u7684\u542f\u52a8\u65f6\u95f4\u3001\u8f83\u5c0f\u7684\u4e8c\u8fdb\u5236\u6587\u4ef6\u5927\u5c0f\u4ee5\u53ca\u5e73\u53f0\u548c\u67b6\u6784\u4e2d\u7acb\u6027\uff0cWasm\u4e8c\u8fdb\u5236\u6587\u4ef6\u53ef\u4ee5\u7528\u8fd0\u884c\u5f53\u4eca\u65e0\u670d\u52a1\u5668\u57fa\u7840\u8bbe\u65bd\u6240\u9700\u7684\u4e00\u5c0f\u90e8\u5206\u8d44\u6e90\u6765\u6267\u884c\u3002</li> <li>2022\u5e74\u5e95\uff0cOCI Registry\u5de5\u4f5c\u7ec4\u5ba3\u5e03\u4e86\u4e00\u79cd\u5b58\u50a8\u5bb9\u5668\u955c\u50cf\u4ee5\u5916\u7684\u5176\u4ed6\u5185\u5bb9\u7684\u5b98\u65b9\u65b9\u5f0f\u3002\u8fd9\u53ef\u80fd\u5305\u62ecHelm\u56fe\u8868\u3001\u7167\u7247\u6216Wasm\u5e94\u7528\u7a0b\u5e8f\u3002\u8fd9\u4e2a\u65b0\u529f\u80fd\u88ab\u79f0\u4e3a\u201c\u5de5\u4ef6\u5b58\u50a8\u201d\u3002</li> <li>\u6240\u6709\u5927\u578b\u7f16\u7a0b\u8bed\u8a00\u90fd\u5c06\u5f97\u5230Wasm\u652f\u6301\uff1aWasm GC\u63d0\u6848\u5f88\u53ef\u80fd\u5728 2023 \u5e74\u521d\u5c31\u80fd\u53ef\u7528\u5e76\u5f97\u5230\u652f\u6301\uff0c\u56e0\u6b64 Kotlin \u548c Dart \u5c06\u5f88\u5feb\u53d1\u5e03Wasm\u7f16\u8bd1\u5668\uff0cJava \u4e5f\u5f88\u53ef\u80fd\u5c06\u6210\u4e3a\u6700\u6d41\u884c\u7684 Wasm \u5f00\u53d1\u8bed\u8a00\u3002</li> </ul>"},{"location":"blogs/coolbpf-eunomia.zh/#coolbpf-eunomia-bpf-eunomia-lcc","title":"Coolbpf + eunomia-bpf = eunomia-lcc","text":"<p>\u5728\u8fc7\u53bb\u7684\u4e00\u5e74\u4e2d\uff0c\u963f\u91cc\u4e91\u9f99\u8725\u793e\u533a\u7cfb\u7edf\u8fd0\u7ef4SIG\uff08Special Interest Group\uff09 \u6b63\u5f0f\u5f00\u6e90\u4e86 Coolbpf \u9879\u76ee\u3002Coolbpf \u4ee5 CO-RE\uff08Compile Once-Run Everywhere\uff09\u4e3a\u57fa\u7840\u5b9e\u73b0\uff0c\u4fdd\u7559\u4e86\u8d44\u6e90\u5360\u7528\u4f4e\u3001\u53ef\u79fb\u690d\u6027\u5f3a\u7b49\u4f18\u70b9\uff0c\u878d\u5408\u4e86BCC\u52a8\u6001\u7f16\u8bd1\u7279\u6027\uff0c\u901a\u8fc7\u8fdc\u7a0b\u670d\u52a1\u80fd\u529b\uff0c\u6781\u5927\u7b80\u5316\u5f00\u53d1\u7f16\u8bd1\u548c\u8fd0\u884c\u6548\u7387\uff0c\u9002\u5408\u5728\u751f\u4ea7\u73af\u5883\u6279\u91cf\u90e8\u7f72\u5e94\u7528\u3002Coolbpf \u8fd8\u652f\u6301\u5728\u6ca1\u6709 eBPF \u7279\u6027\u7684\u4f4e\u5185\u6838\u7248\u672c\u4e0a\uff0c\u901a\u8fc7\u63d0\u4f9b\u7684 eBPF \u9a71\u52a8\uff0c\u5e2e\u52a9\u5b83\u5b89\u5168\u7684\u5728\u4f4e\u7248\u672c\u4e0a\u8fd0\u884c\uff0c\u4ece\u5185\u6838\u6001\u548c\u6279\u91cf\u90e8\u7f72\u4e24\u4e2a\u89d2\u5ea6\u5145\u5206\u589e\u5f3a\u4e86 eBPF \u7a0b\u5e8f\"\u4e00\u6b21\u7f16\u8bd1\uff0c\u5230\u5904\u8fd0\u884c\u201d \u7684\u80fd\u529b\u3002</p> <p>eunomia-bpf \u4e5f\u662f\u4e00\u4e2a\u7ed3\u5408 Wasm \u7684\u901a\u7528\u3001\u8f7b\u91cf\u7ea7\u3001\u591a\u8bed\u8a00\u7684\u4e0b\u4e00\u4ee3 eBPF \u5f00\u53d1\u6846\u67b6/\u7ec4\u4ef6\u5e93\uff0c2022 \u5e74\u4e0b\u534a\u5e74\u5728\u9f99\u8725\u793e\u533a <code>eBPF \u6280\u672f\u63a2\u7d22 SIG</code> [3] [5] \u53d1\u8d77\u5e76\u5b75\u5316\u3002eunomia-bpf \u5305\u542b\u4e00\u4e2a\u8fd0\u884c\u65f6\u548c\u7f16\u8bd1\u5de5\u5177\u94fe\uff0c\u4e3b\u8981\u5173\u6ce8\u4e8e\u6539\u8fdb eBPF \u7a0b\u5e8f\u7528\u6237\u6001\u7684\u5f00\u53d1\u548c\u4f7f\u7528\u4f53\u9a8c\uff0c\u4e3b\u8981\u6709\u4e09\u4e2a\u7279\u6027\uff1a</p> <ol> <li>\u53ea\u9700\u7f16\u5199\u5185\u6838\u6001\u4ee3\u7801\u5373\u53ef\u8fd0\u884c eBPF \u7a0b\u5e8f\uff0c\u5185\u6838\u6001\u524d\u7aef\u5b8c\u5168\u517c\u5bb9 bcc\u3001\u539f\u751f libbpf \u7b49\u591a\u79cd\u8bed\u6cd5\uff0c\u53ef\u4ee5\u964d\u4f4e eBPF \u5f00\u53d1\u7684\u5b66\u4e60\u6210\u672c\uff0c\u63d0\u9ad8\u5f00\u53d1\u6548\u7387\uff1b</li> <li>\u7f16\u8bd1\u5de5\u5177\u94fe\u548c\u8fd0\u884c\u65f6\u5b8c\u5168\u5206\u79bb\uff0c\u4fdd\u8bc1\u4e0d\u540c\u7248\u672c\u7f16\u8bd1\u5de5\u5177\u94fe\u548c\u8fd0\u884c\u65f6\u4e4b\u95f4\u7684\u517c\u5bb9\u6027\uff0c\u4ee5 CO-RE\uff08\u4e00\u6b21\u7f16\u8bd1\u3001\u5230\u5904\u8fd0\u884c\uff09\u7684\u65b9\u5f0f\u52a0\u8f7d\uff0c\u964d\u4f4e\u90e8\u7f72\u548c\u4f7f\u7528\u7684\u8d44\u6e90\u6d88\u8017\uff1b\u8fd8\u53ef\u4ee5\u8ba9 BCC/bpftrace \u7c7b\u578b\u7684\u4ee3\u7801\u4e5f\u652f\u6301 AOT \u7f16\u8bd1\uff0c\u5728\u52a0\u8f7d\u7684\u7684\u65f6\u5019\u4e0d\u4f9d\u8d56 llvm \u7b49\u5e93\uff0c\u540c\u65f6\u4fdd\u7559 bpftrace \u7c7b\u4f3c\u811a\u672c\u4e00\u6837\u7684\u7b80\u5355\u4f7f\u7528\u65b9\u5f0f\uff1b</li> <li>\u7528\u6237\u6001\u4e5f\u652f\u6301\u591a\u79cd\u8bed\u8a00\uff0c\u4f8b\u5982 C++/C/Rust \u7b49\uff0c\u53ef\u4ee5\u4f7f\u7528\u591a\u79cd\u8bed\u8a00\u5728 Wasm \u4e2d\u5f00\u53d1 eBPF \u7684\u7528\u6237\u6001\u7a0b\u5e8f\uff0c\u5e76\u4e14\u4ee5 Wasm \u6a21\u5757\uff0c\u6216\u8005 JSON/YAML \u914d\u7f6e\u6587\u4ef6\u7684\u65b9\u5f0f\u5206\u53d1\u548c\u52a8\u6001\u52a0\u8f7d eBPF \u7a0b\u5e8f\uff0c\u540c\u65f6\u4ee5 Wasm OCI \u955c\u50cf\u7684\u5f62\u5f0f\u5b58\u50a8\u548c\u7ba1\u7406\u4efb\u610f\u5305\u542b\u7528\u6237\u6001\u548c\u5185\u6838\u6001\u7684 eBPF \u5e94\u7528\u3002</li> </ol> <p>eunomia-bpf \u5e0c\u671b\u6210\u4e3a\u4e00\u4e2a\u4ee5\u7c7b\u5e93\u6216\u8005\u677e\u6563\u7ec4\u5408\u7684\u6846\u67b6\u7684\u65b9\u5f0f\u63d0\u4f9b\uff0c\u5728\u7f16\u8bd1\u6784\u5efa\u548c\u5206\u53d1\u8fd0\u884c eBPF \u7a0b\u5e8f\u65b9\u9762\u505a\u66f4\u591a\u7684\u63a2\u7d22\u5de5\u4f5c\uff0c\u8ba9\u5176\u4ed6\u516c\u53f8\u548c\u4e2a\u4eba\uff0c\u60f3\u8981\u57fa\u4e8e\u81ea\u5df1\u7684\u5185\u6838\u6001 ebpf \u57fa\u7840\u8bbe\u65bd\uff0c\u642d\u5efa\u4e00\u4e2a\u7c7b\u4f3c\u7684\u7528\u6237\u6001\u5f00\u53d1\u8fd0\u884c\u73af\u5883\uff0c\u6216\u8005\u5b8c\u6574\u7684\u5f00\u53d1\u5e73\u53f0\u3001\u63d2\u4ef6\u8fd0\u884c\u65f6\uff0c\u53d8\u5f97\u66f4\u5bb9\u6613\u5f88\u591a\u3002</p> <p>\u5728 2022 \u5e74\u5e95\uff0c\u6211\u4eec\u5c1d\u8bd5\u5c06 Coolbpf \u548c eunomia-bpf \u7ed3\u5408\u8d77\u6765\uff0c\u501f\u52a9 Coolbpf \u63d0\u4f9b\u7684\u4f4e\u5185\u6838\u7248\u672c\u652f\u6301\u7684\u5185\u6838\u6001\u57fa\u7840\u8bbe\u65bd\uff0c\u4ee5\u53ca\u6279\u91cf\u90e8\u7f72\u5e94\u7528\u7684\u80fd\u529b\uff0c\u4ee5\u53ca eunomia-bpf \u63d0\u4f9b\u7684\u7ed3\u5408 Wasm \u7684\u7528\u6237\u6001\u5f00\u53d1\u3001\u5206\u53d1\u7279\u6027\uff0c\u5728 Coolbpf \u7684\u5927\u6846\u67b6\u4e0b\u521b\u5efa\u4e86\u4e00\u4e2a\u65b0\u7684 eBPF \u7528\u6237\u6001\u5f00\u53d1\u5e93\uff1aeunomia-lcc\uff0c\u5e0c\u671b\u8ba9 Coolbpf \u4e5f\u80fd\uff1a</p> <ul> <li>\u5728\u7f16\u5199 eBPF \u7a0b\u5e8f\u6216\u5de5\u5177\u65f6\u53ea\u7f16\u5199\u5185\u6838\u6001\u4ee3\u7801\uff0c\u5c31\u80fd\u81ea\u52a8\u83b7\u53d6\u5185\u6838\u6001\u5bfc\u51fa\u4fe1\u606f\uff0c\u81ea\u52a8\u751f\u6210\u547d\u4ee4\u884c\u53c2\u6570\u3001\u76f4\u65b9\u56fe\u8f93\u51fa\u7b49\uff1b</li> <li>\u4f7f\u7528 Wasm \u8fdb\u884c\u7528\u6237\u6001\u4ea4\u4e92\u7a0b\u5e8f\u7684\u5f00\u53d1\uff0c\u5728 Wasm \u865a\u62df\u673a\u5185\u90e8\u63a7\u5236\u6574\u4e2a eBPF \u7a0b\u5e8f\u7684\u52a0\u8f7d\u548c\u6267\u884c\uff0c\u4ee5\u53ca\u5904\u7406 eBPF \u4e0a\u62a5\u7684\u6570\u636e\uff1b</li> <li>\u53ef\u4ee5\u5c06\u9884\u7f16\u8bd1\u7684 eBPF \u7a0b\u5e8f\u6253\u5305\u4e3a\u901a\u7528\u7684 JSON \u6216 Wasm \u6a21\u5757\uff0c\u8de8\u67b6\u6784\u548c\u5185\u6838\u7248\u672c\u8fdb\u884c\u5206\u53d1\uff0c\u65e0\u9700\u91cd\u65b0\u7f16\u8bd1\u5373\u53ef\u52a8\u6001\u52a0\u8f7d\u8fd0\u884c\u3002</li> </ul> <p>\u540c\u65f6\u8fd8\u80fd\u4fdd\u7559 Coolbpf \u7684\u4f4e\u7248\u672c\u517c\u5bb9\u3001BTF \u81ea\u52a8\u83b7\u53d6\u3001\u8fdc\u7a0b\u7f16\u8bd1\u7b49\u7279\u6027\uff0c\u8ba9 eBPF \u7a0b\u5e8f\u7684\u5f00\u53d1\u66f4\u52a0\u7b80\u4fbf\u6613\u884c\u3002</p> <p>\u5c55\u671b\u672a\u6765\uff0ceunomia-bpf \u7684\u56e2\u961f\u5728 2023 \u5e74\u4e5f\u5e0c\u671b\u5c1d\u8bd5\u63a2\u7d22\u3001\u6539\u8fdb\u3001\u5b8c\u5584 eBPF \u7a0b\u5e8f\u5f00\u53d1\u3001\u7f16\u8bd1\u3001\u6253\u5305\u3001\u53d1\u5e03\u3001\u5b89\u88c5\u3001\u5347\u7ea7\u7b49\u7684\u6d41\u7a0b\u548c\u5de5\u5177\u3001SDK\uff0c\u5e76\u79ef\u6781\u5411\u4e0a\u6e38\u793e\u533a\u53cd\u9988\uff0c\u8fdb\u4e00\u6b65\u589e\u5f3a eBPF \u7684\u7f16\u7a0b\u4f53\u9a8c\u548c\u8bed\u8a00\u80fd\u529b\uff1b\u4ee5\u53ca\u66f4\u8fdb\u4e00\u6b65\u5730\u548c WebAssembly \u76f8\u7ed3\u5408\uff0c\u5728\u53ef\u89c2\u6d4b\u6027\u3001serverless\u3001\u53ef\u7f16\u7a0b\u5185\u6838\u7b49\u8bf8\u591a\u65b9\u9762\u505a\u66f4\u591a\u7684\u63a2\u7d22\u548c\u5b9e\u8df5\uff0c\u671d\u7740\u56fe\u7075\u5b8c\u5907\u548c\u66f4\u5b8c\u5584\u7684\u8bed\u8a00\u652f\u6301\u8fc8\u8fdb\u3002</p>"},{"location":"blogs/coolbpf-eunomia.zh/#_1","title":"\u53c2\u8003\u8d44\u6599","text":"<ol> <li>Wasm \u5c06\u5f15\u9886\u4e0b\u4e00\u4ee3\u8ba1\u7b97\u8303\u5f0f [\u8bd1]\uff1ahttps://www.oschina.net/news/214580</li> <li>WebAssembly\uff1a2023\u5e74\u76845\u4e2a\u9884\u6d4b: https://www.sohu.com/a/626985661_121119003</li> <li>eBPF \u6280\u672f\u63a2\u7d22 SIG \u4e3b\u9875\uff1a https://openanolis.cn/sig/ebpfresearch</li> <li>Coolbpf \u9879\u76ee\u5f00\u6e90\u4ed3\u5e93: https://gitee.com/anolis/coolbpf</li> <li>eunomia-bpf \u9f99\u8725\u793e\u533a\u955c\u50cf\u4ed3\u5e93\uff1ahttps://gitee.com/anolis/eunomia</li> <li>eunomia-bpf Github \u4ed3\u5e93\uff1ahttps://github.com/eunomia-bpf/eunomia-bpf</li> <li>\u5f53 Wasm \u9047\u89c1 eBPF\uff1a\u4f7f\u7528 WebAssembly \u7f16\u5199\u3001\u5206\u53d1\u3001\u52a0\u8f7d\u8fd0\u884c eBPF \u7a0b\u5e8f | \u9f99\u8725\u6280\u672f: https://developer.aliyun.com/article/1050439</li> <li>2023\uff0c\u53ef\u89c2\u6d4b\u6027\u9700\u6c42\u5c06\u8fce\u6765\u201c\u7206\u53d1\u4e4b\u5e74\u201d\uff1fhttps://36kr.com/p/dp2063589382737542</li> </ol>"},{"location":"blogs/ebpf-wasm.zh/","title":"\u5f53 Wasm \u9047\u89c1 eBPF \uff1a\u4f7f\u7528 WebAssembly \u7f16\u5199\u3001\u5206\u53d1\u3001\u52a0\u8f7d\u8fd0\u884c eBPF \u7a0b\u5e8f","text":""},{"location":"blogs/ebpf-wasm.zh/#httpszhuanlanzhihucomp573941739","title":"!https://zhuanlan.zhihu.com/p/573941739","text":"<p>\u5f53\u4eca\u4e91\u539f\u751f\u4e16\u754c\u4e2d\u4e24\u4e2a\u6700\u70ed\u95e8\u7684\u8f7b\u91cf\u7ea7\u4ee3\u7801\u6267\u884c\u6c99\u7bb1/\u865a\u62df\u673a\u662f eBPF \u548c WebAssembly\u3002\u5b83\u4eec\u90fd\u8fd0\u884c\u4ece C\u3001C++ \u548c Rust \u7b49\u8bed\u8a00\u7f16\u8bd1\u7684\u9ad8\u6027\u80fd\u5b57\u8282\u7801\u7a0b\u5e8f\uff0c\u5e76\u4e14\u90fd\u662f\u8de8\u5e73\u53f0\u3001\u53ef\u79fb\u690d\u7684\u3002\u4e8c\u8005\u6700\u5927\u7684\u533a\u522b\u5728\u4e8e\uff1a eBPF \u5728 Linux \u5185\u6838\u4e2d\u8fd0\u884c\uff0c\u800c WebAssembly \u5728\u7528\u6237\u7a7a\u95f4\u4e2d\u8fd0\u884c\u3002\u6211\u4eec\u5e0c\u671b\u80fd\u505a\u4e00\u4e9b\u5c06\u4e8c\u8005\u76f8\u4e92\u878d\u5408\u7684\u5c1d\u8bd5\uff1a\u4f7f\u7528 Wasm \u6765\u7f16\u5199\u901a\u7528\u7684 eBPF \u7a0b\u5e8f\uff0c\u7136\u540e\u53ef\u4ee5\u5c06\u5176\u5206\u53d1\u5230\u4efb\u610f\u4e0d\u540c\u7248\u672c\u3001\u4e0d\u540c\u67b6\u6784\u7684 Linux \u5185\u6838\u4e2d\uff0c\u65e0\u9700\u91cd\u65b0\u7f16\u8bd1\u5373\u53ef\u8fd0\u884c\u3002</p>"},{"location":"blogs/ebpf-wasm.zh/#webassembly-vs-ebpf","title":"WebAssembly vs. eBPF","text":"<p>WebAssembly(\u7f29\u5199 Wasm)\u662f\u57fa\u4e8e\u5806\u6808\u865a\u62df\u673a\u7684\u4e8c\u8fdb\u5236\u6307\u4ee4\u683c\u5f0f\u3002Wasm \u662f\u4e3a\u4e86\u4e00\u4e2a\u53ef\u79fb\u690d\u7684\u76ee\u6807\u800c\u8bbe\u8ba1\u7684\uff0c\u53ef\u4f5c\u4e3a C/C+/RUST \u7b49\u9ad8\u7ea7\u8bed\u8a00\u7684\u7f16\u8bd1\u76ee\u6807\uff0c\u4f7f\u5ba2\u6237\u7aef\u548c\u670d\u52a1\u5668\u5e94\u7528\u7a0b\u5e8f\u80fd\u591f\u5728 Web \u4e0a\u90e8\u7f72\u3002Wasm \u7684\u8fd0\u884c\u65f6\u6709\u591a\u79cd\u5b9e\u73b0\uff0c\u5305\u62ec\u6d4f\u89c8\u5668\u548c\u72ec\u7acb\u7684\u7cfb\u7edf\uff0c\u5b83\u53ef\u4ee5\u7528\u4e8e\u89c6\u9891\u548c\u97f3\u9891\u7f16\u89e3\u7801\u5668\u3001\u56fe\u5f62\u548c 3D\u3001\u591a\u5a92\u4f53\u548c\u6e38\u620f\u3001\u5bc6\u7801\u8ba1\u7b97\u6216\u4fbf\u643a\u5f0f\u8bed\u8a00\u5b9e\u73b0\u7b49\u5e94\u7528\u3002</p> <p>\u5c3d\u7ba1 Wasm \u662f\u4e3a\u4e86\u63d0\u9ad8\u7f51\u9875\u4e2d\u6027\u80fd\u654f\u611f\u6a21\u5757\u8868\u73b0\u800c\u63d0\u51fa\u7684\u5b57\u8282\u7801\u6807\u51c6, \u4f46\u662f Wasm \u5374\u4e0d\u4ec5\u80fd\u7528\u5728\u6d4f\u89c8\u5668(browser)\u4e2d, \u4e5f\u53ef\u4ee5\u7528\u5728\u5176\u4ed6\u73af\u5883\u4e2d\u3002Wasm \u5df2\u7ecf\u53d1\u5c55\u6210\u4e3a\u4e00\u4e2a\u8f7b\u91cf\u7ea7\u3001\u9ad8\u6027\u80fd\u3001\u8de8\u5e73\u53f0\u548c\u591a\u8bed\u79cd\u7684\u8f6f\u4ef6\u6c99\u76d2\u73af\u5883\uff0c\u88ab\u8fd0\u7528\u4e8e\u4e91\u539f\u751f\u8f6f\u4ef6\u7ec4\u4ef6\u3002\u4e0e Linux \u5bb9\u5668\u76f8\u6bd4\uff0cWebAssembly \u7684\u542f\u52a8\u901f\u5ea6\u53ef\u4ee5\u63d0\u9ad8 100 \u500d\uff0c\u5185\u5b58\u548c\u78c1\u76d8\u5360\u7528\u7a7a\u95f4\u8981\u5c0f\u5f97\u591a\uff0c\u5e76\u4e14\u5177\u6709\u66f4\u597d\u5b9a\u4e49\u7684\u5b89\u5168\u6c99\u7bb1\u3002\u7136\u800c\uff0c\u6743\u8861\u662f WebAssembly \u9700\u8981\u81ea\u5df1\u7684\u8bed\u8a00 SDK \u548c\u7f16\u8bd1\u5668\u5de5\u5177\u94fe\uff0c\u4f7f\u5176\u6210\u4e3a\u6bd4 Linux \u5bb9\u5668\u66f4\u53d7\u9650\u5236\u7684\u5f00\u53d1\u73af\u5883\u3002WebAssembly \u8d8a\u6765\u8d8a\u591a\u5730\u7528\u4e8e\u96be\u4ee5\u90e8\u7f72 Linux \u5bb9\u5668\u6216\u5e94\u7528\u7a0b\u5e8f\u6027\u80fd\u81f3\u5173\u91cd\u8981\u7684\u8fb9\u7f18\u8ba1\u7b97\u573a\u666f\u3002</p> <p>Wasm \u7684\u7f16\u8bd1\u548c\u90e8\u7f72\u6d41\u7a0b\u5982\u4e0b\uff1a</p> <p></p> <p>\u901a\u5e38\u53ef\u4ee5\u5c06 C/C+/RUST \u7b49\u9ad8\u7ea7\u8bed\u8a00\u7f16\u8bd1\u4e3a Wasm \u5b57\u8282\u7801\uff0c\u5728 Wasm \u865a\u62df\u673a\u4e2d\u8fdb\u884c\u52a0\u8f7d\u8fd0\u884c\u3002Wasm \u865a\u62df\u673a\u4f1a\u901a\u8fc7\u89e3\u91ca\u6267\u884c\u6216 JIT \u7684\u65b9\u5f0f\uff0c\u5c06 Wasm \u5b57\u8282\u7801\u7ffb\u8bd1\u4e3a\u5bf9\u5e94\u5e73\u53f0\uff08 x86/arm \u7b49\uff09\u7684\u673a\u5668\u7801\u8fd0\u884c\u3002</p> <p>eBPF \u6e90\u4e8e BPF\uff0c\u672c\u8d28\u4e0a\u662f\u5904\u4e8e\u5185\u6838\u4e2d\u7684\u4e00\u4e2a\u9ad8\u6548\u4e0e\u7075\u6d3b\u7684\u865a\u62df\u673a\u7ec4\u4ef6\uff0c\u4ee5\u4e00\u79cd\u5b89\u5168\u7684\u65b9\u5f0f\u5728\u8bb8\u591a\u5185\u6838 hook \u70b9\u6267\u884c\u5b57\u8282\u7801\u3002BPF \u6700\u521d\u7684\u76ee\u7684\u662f\u7528\u4e8e\u9ad8\u6548\u7f51\u7edc\u62a5\u6587\u8fc7\u6ee4\uff0c\u7ecf\u8fc7\u91cd\u65b0\u8bbe\u8ba1\uff0ceBPF \u4e0d\u518d\u5c40\u9650\u4e8e\u7f51\u7edc\u534f\u8bae\u6808\uff0c\u5df2\u7ecf\u6210\u4e3a\u5185\u6838\u9876\u7ea7\u7684\u5b50\u7cfb\u7edf\uff0c\u6f14\u8fdb\u4e3a\u4e00\u4e2a\u901a\u7528\u6267\u884c\u5f15\u64ce\u3002\u5f00\u53d1\u8005\u53ef\u57fa\u4e8e eBPF \u5f00\u53d1\u6027\u80fd\u5206\u6790\u5de5\u5177\u3001\u8f6f\u4ef6\u5b9a\u4e49\u7f51\u7edc\u3001\u5b89\u5168\u7b49\u8bf8\u591a\u573a\u666f\u3002eBPF \u6709\u4e00\u4e9b\u7f16\u7a0b\u9650\u5236\uff0c\u9700\u8981\u7ecf\u8fc7\u9a8c\u8bc1\u5668\u786e\u4fdd\u5176\u5728\u5185\u6838\u5e94\u7528\u573a\u666f\u4e2d\u662f\u5b89\u5168\u7684\uff08\u4f8b\u5982\uff0c\u6ca1\u6709\u65e0\u9650\u5faa\u73af\u3001\u5185\u5b58\u8d8a\u754c\u7b49\uff09\uff0c\u4f46\u8fd9\u4e5f\u610f\u5473\u7740 eBPF \u7684\u7f16\u7a0b\u6a21\u578b\u4e0d\u662f\u56fe\u7075\u5b8c\u5907\u7684\u3002\u76f8\u6bd4\u4e4b\u4e0b\uff0cWebAssembly \u662f\u4e00\u79cd\u56fe\u7075\u5b8c\u5907\u7684\u8bed\u8a00\uff0c\u5177\u6709\u80fd\u591f\u6253\u7834\u6c99\u76d2\u548c\u8bbf\u95ee\u539f\u751f OS \u5e93\u7684\u6269\u5c55 WASI (WebAssembly System Interface, Wasm \u7cfb\u7edf\u63a5\u53e3) \uff0c\u540c\u65f6 Wasm \u8fd0\u884c\u65f6\u53ef\u4ee5\u5b89\u5168\u5730\u9694\u79bb\u5e76\u4ee5\u63a5\u8fd1\u539f\u751f\u7684\u6027\u80fd\u6267\u884c\u7528\u6237\u7a7a\u95f4\u4ee3\u7801\u3002\u4e8c\u8005\u7684\u9886\u57df\u4e3b\u4f53\u4e0a\u6709\u4e0d\u5c11\u5dee\u5f02\uff0c\u4f46\u4e5f\u6709\u4e0d\u5c11\u76f8\u4e92\u91cd\u53e0\u7684\u5730\u65b9\u3002</p> <p>\u6709\u4e00\u4e9b\u5728 Linux \u5185\u6838\u4e2d\u8fd0\u884c WebAssembly \u7684\u5c1d\u8bd5\uff0c\u7136\u800c\u57fa\u672c\u4e0a\u4e0d\u592a\u6210\u529f\u3002 eBPF \u662f\u8fd9\u4e2a\u5e94\u7528\u573a\u666f\u4e0b\u66f4\u597d\u7684\u9009\u62e9\u3002\u4f46\u662f WebAssembly \u7a0b\u5e8f\u53ef\u4ee5\u5904\u7406\u8bb8\u591a\u7c7b\u5185\u6838\u7684\u4efb\u52a1\uff0c\u53ef\u4ee5\u88ab AOT \u7f16\u8bd1\u6210\u539f\u751f\u5e94\u7528\u7a0b\u5e8f\u3002\u6765\u81ea CNCF \u7684 WasmEdge Runtime \u662f\u4e00\u4e2a\u5f88\u597d\u7684\u57fa\u4e8e LLVM \u7684\u4e91\u539f\u751f WebAssembly \u7f16\u8bd1\u5668\u3002\u539f\u751f\u5e94\u7528\u7a0b\u5e8f\u5c06\u6240\u6709\u6c99\u7bb1\u68c0\u67e5\u5408\u5e76\u5230\u539f\u751f\u5e93\u4e2d\uff0c\u8fd9\u5141\u8bb8 WebAssembly \u7a0b\u5e8f\u8868\u73b0\u5f97\u50cf\u4e00\u4e2a\u72ec\u7acb\u7684 unikernel \u201c\u5e93\u64cd\u4f5c\u7cfb\u7edf\u201d\u3002\u6b64\u5916\uff0c\u8fd9\u79cd AOT \u7f16\u8bd1\u7684\u6c99\u76d2 WebAssembly \u5e94\u7528\u7a0b\u5e8f\u53ef\u4ee5\u5728\u5fae\u5185\u6838\u64cd\u4f5c\u7cfb\u7edf\uff08\u5982 seL4\uff09\u4e0a\u8fd0\u884c\uff0c\u5e76\u4e14\u53ef\u4ee5\u63a5\u7ba1\u8bb8\u591a\u201c\u5185\u6838\u7ea7\u201d\u4efb\u52a1[1]\u3002</p> <p>\u867d\u7136 WebAssembly \u53ef\u4ee5\u4e0b\u964d\u5230\u5185\u6838\u7ea7\u522b\uff0c\u4f46 eBPF \u4e5f\u53ef\u4ee5\u4e0a\u5347\u5230\u5e94\u7528\u7a0b\u5e8f\u7ea7\u522b\u3002\u5728 sidecar \u4ee3\u7406\u4e2d\uff0cEnvoy Proxy \u5f00\u521b\u4e86\u4f7f\u7528 Wasm \u4f5c\u4e3a\u6269\u5c55\u673a\u5236\u5bf9\u6570\u636e\u5e73\u9762\u8fdb\u884c\u7f16\u7a0b\u7684\u65b9\u6cd5\u3002\u5f00\u53d1\u4eba\u5458\u53ef\u4ee5\u7528 C\u3001C++\u3001Rust\u3001AssemblyScript\u3001Swift \u548c TinyGo \u7b49\u8bed\u8a00\u7f16\u5199\u7279\u5b9a\u5e94\u7528\u7684\u4ee3\u7406\u903b\u8f91\uff0c\u5e76\u5c06\u8be5\u6a21\u5757\u7f16\u8bd1\u5230 Wasm \u4e2d\u3002\u901a\u8fc7 proxy-Wasm \u6807\u51c6\uff0c\u4ee3\u7406\u53ef\u4ee5\u5728 Wasmtime \u548c WasmEdge \u7b49\u9ad8\u6027\u80fd\u8fd0\u884c\u673a\u5236\u4e2d\u6267\u884c\u90a3\u4e9b Wasm \u63d2\u4ef6[2]\u3002</p> <p>\u5c3d\u7ba1\u76ee\u524d\u6709\u4e0d\u5c11\u5e94\u7528\u7a0b\u5e8f\u540c\u65f6\u4f7f\u7528\u4e86\u4e8c\u8005\uff0c\u4f46\u5927\u591a\u6570\u65f6\u5019\u8fd9\u4e24\u4e2a\u865a\u62df\u673a\u662f\u76f8\u4e92\u72ec\u7acb\u5e76\u4e14\u6ca1\u6709\u4ea4\u96c6\u7684\uff1a\u4f8b\u5982\u5728\u53ef\u89c2\u6d4b\u6027\u5e94\u7528\u4e2d\uff0c\u901a\u8fc7 eBPF \u63a2\u9488\u83b7\u53d6\u6570\u636e\uff0c\u83b7\u53d6\u6570\u636e\u4e4b\u540e\u5728\u7528\u6237\u6001\u5f15\u5165 Wasm \u63d2\u4ef6\u6a21\u5757\uff0c\u8fdb\u884c\u53ef\u914d\u7f6e\u7684\u6570\u636e\u5904\u7406\u3002Wasm \u6a21\u5757\u548c eBPF \u7a0b\u5e8f\u7684\u5206\u53d1\u3001\u8fd0\u884c\u3001\u52a0\u8f7d\u3001\u63a7\u5236\u76f8\u4e92\u72ec\u7acb\uff0c\u4ec5\u4ec5\u5b58\u5728\u6570\u636e\u6d41\u7684\u5173\u8054\u3002</p>"},{"location":"blogs/ebpf-wasm.zh/#_1","title":"\u6211\u4eec\u7684\u4e00\u6b21\u5c1d\u8bd5","text":"<p>\u4e00\u822c\u6765\u8bf4\uff0c\u4e00\u4e2a\u5b8c\u6574\u7684 eBPF \u5e94\u7528\u7a0b\u5e8f\u5206\u4e3a\u7528\u6237\u7a7a\u95f4\u7a0b\u5e8f\u548c\u5185\u6838\u7a0b\u5e8f\u4e24\u90e8\u5206\uff1a</p> <ul> <li>\u7528\u6237\u7a7a\u95f4\u7a0b\u5e8f\u8d1f\u8d23\u52a0\u8f7d BPF \u5b57\u8282\u7801\u81f3\u5185\u6838\uff0c\u6216\u8d1f\u8d23\u8bfb\u53d6\u5185\u6838\u56de\u4f20\u7684\u7edf\u8ba1\u4fe1\u606f\u6216\u8005\u4e8b\u4ef6\u8be6\u60c5\uff0c\u8fdb\u884c\u76f8\u5173\u7684\u6570\u636e\u5904\u7406\u548c\u63a7\u5236\uff1b</li> <li>\u5185\u6838\u4e2d\u7684 BPF \u5b57\u8282\u7801\u8d1f\u8d23\u5728\u5185\u6838\u4e2d\u6267\u884c\u7279\u5b9a\u4e8b\u4ef6\uff0c\u5982\u9700\u8981\u4e5f\u4f1a\u5c06\u6267\u884c\u7684\u7ed3\u679c\u901a\u8fc7 maps \u6216\u8005 perf-event \u4e8b\u4ef6\u53d1\u9001\u81f3\u7528\u6237\u7a7a\u95f4</li> </ul> <p>\u7528\u6237\u6001\u7a0b\u5e8f\u53ef\u4ee5\u5728\u52a0\u8f7d eBPF \u7a0b\u5e8f\u524d\u63a7\u5236\u4e00\u4e9b eBPF \u7a0b\u5e8f\u7684\u53c2\u6570\u548c\u53d8\u91cf\uff0c\u4ee5\u53ca\u6302\u8f7d\u70b9\uff1b\u4e5f\u53ef\u4ee5\u901a\u8fc7 map \u7b49\u7b49\u65b9\u5f0f\u8fdb\u884c\u7528\u6237\u6001\u548c\u5185\u6838\u6001\u4e4b\u95f4\u7684\u53cc\u5411\u901a\u4fe1\u3002\u901a\u5e38\u6765\u8bf4\u7528\u6237\u6001\u7684 eBPF \u7a0b\u5e8f\u53ef\u4ee5\u57fa\u4e8e <code>libbpf</code> \u5e93\u8fdb\u884c\u5f00\u53d1\uff0c\u6765\u63a7\u5236\u5185\u6838\u6001 eBPF \u7a0b\u5e8f\u7684\u88c5\u8f7d\u548c\u8fd0\u884c\u3002\u90a3\u4e48\uff0c\u5982\u679c\u5c06\u7528\u6237\u6001\u7684\u6240\u6709\u63a7\u5236\u548c\u6570\u636e\u5904\u7406\u903b\u8f91\u5168\u90e8\u79fb\u5230 Wasm \u865a\u62df\u673a\u4e2d\uff0c\u901a\u8fc7 Wasm module \u6253\u5305\u548c\u5206\u53d1 eBPF \u5b57\u8282\u7801\uff0c\u540c\u65f6\u5728 Wasm \u865a\u62df\u673a\u5185\u90e8\u63a7\u5236\u6574\u4e2a eBPF \u7a0b\u5e8f\u7684\u52a0\u8f7d\u548c\u6267\u884c\uff0c\u4e5f\u8bb8\u6211\u4eec\u5c31\u53ef\u4ee5\u5c06\u4e8c\u8005\u7684\u4f18\u52bf\u7ed3\u5408\u8d77\u6765\uff0c\u8ba9\u4efb\u610f eBPF \u7a0b\u5e8f\u80fd\u6709\u5982\u4e0b\u7279\u6027\uff1a</p> <ul> <li><code>\u53ef\u79fb\u690d</code>\uff1a\u8ba9 eBPF \u5de5\u5177\u548c\u5e94\u7528\u5b8c\u5168\u5e73\u53f0\u65e0\u5173\u3001\u53ef\u79fb\u690d\uff0c\u4e0d\u9700\u8981\u8fdb\u884c\u91cd\u65b0\u7f16\u8bd1\u5373\u53ef\u4ee5\u8de8\u5e73\u53f0\u5206\u53d1\uff1b</li> <li><code>\u9694\u79bb\u6027</code>\uff1a\u501f\u52a9 Wasm \u7684\u53ef\u9760\u6027\u548c\u9694\u79bb\u6027\uff0c\u8ba9 eBPF \u7a0b\u5e8f\u7684\u52a0\u8f7d\u548c\u6267\u884c\u3001\u4ee5\u53ca\u7528\u6237\u6001\u7684\u6570\u636e\u5904\u7406\u6d41\u7a0b\u66f4\u52a0\u5b89\u5168\u53ef\u9760\uff1b\u4e8b\u5b9e\u4e0a\u4e00\u4e2a eBPF \u5e94\u7528\u7684\u7528\u6237\u6001\u63a7\u5236\u4ee3\u7801\u901a\u5e38\u8fdc\u8fdc\u591a\u4e8e\u5185\u6838\u6001\uff1b</li> <li><code>\u5305\u7ba1\u7406</code>\uff1a\u501f\u52a9 Wasm \u7684\u751f\u6001\u548c\u5de5\u5177\u94fe\uff0c\u5b8c\u6210 eBPF \u7a0b\u5e8f\u6216\u5de5\u5177\u7684\u5206\u53d1\u3001\u7ba1\u7406\u3001\u52a0\u8f7d\u7b49\u5de5\u4f5c\uff0c\u76ee\u524d eBPF \u7a0b\u5e8f\u6216\u5de5\u5177\u751f\u6001\u53ef\u80fd\u7f3a\u4e4f\u4e00\u4e2a\u901a\u7528\u7684\u5305\u7ba1\u7406\u6216\u63d2\u4ef6\u7ba1\u7406\u7cfb\u7edf\uff1b</li> <li><code>\u8de8\u8bed\u8a00</code>\uff1a\u76ee\u524d eBPF \u7a0b\u5e8f\u7531\u591a\u79cd\u7528\u6237\u6001\u8bed\u8a00\u5f00\u53d1\uff08\u5982 Go\\Rust\\C\\C++\\Python \u7b49\uff09\uff0c\u8d85\u8fc7 30 \u79cd\u7f16\u7a0b\u8bed\u8a00\u53ef\u4ee5\u88ab\u7f16\u8bd1\u6210 WebAssembly \u6a21\u5757\uff0c\u5141\u8bb8\u5404\u79cd\u80cc\u666f\u7684\u5f00\u53d1\u4eba\u5458\uff08C\u3001Go\u3001Rust\u3001Java\u3001TypeScript \u7b49\uff09\u7528\u4ed6\u4eec\u9009\u62e9\u7684\u8bed\u8a00\u7f16\u5199 eBPF \u7684\u7528\u6237\u6001\u7a0b\u5e8f\uff0c\u800c\u4e0d\u9700\u8981\u5b66\u4e60\u65b0\u7684\u8bed\u8a00\uff1b</li> <li><code>\u654f\u6377\u6027</code>\uff1a\u5bf9\u4e8e\u5927\u578b\u7684 eBPF \u5e94\u7528\u7a0b\u5e8f\uff0c\u53ef\u4ee5\u4f7f\u7528 Wasm \u4f5c\u4e3a\u63d2\u4ef6\u6269\u5c55\u5e73\u53f0\uff1a\u6269\u5c55\u7a0b\u5e8f\u53ef\u4ee5\u5728\u8fd0\u884c\u65f6\u76f4\u63a5\u4ece\u63a7\u5236\u5e73\u9762\u4ea4\u4ed8\u548c\u91cd\u65b0\u52a0\u8f7d\u3002\u8fd9\u4e0d\u4ec5\u610f\u5473\u7740\u6bcf\u4e2a\u4eba\u90fd\u53ef\u4ee5\u4f7f\u7528\u5b98\u65b9\u548c\u672a\u7ecf\u4fee\u6539\u7684\u5e94\u7528\u7a0b\u5e8f\u6765\u52a0\u8f7d\u81ea\u5b9a\u4e49\u6269\u5c55\uff0c\u800c\u4e14\u4efb\u4f55 eBPF \u7a0b\u5e8f\u7684\u9519\u8bef\u4fee\u590d\u548c/\u6216\u66f4\u65b0\u90fd\u53ef\u4ee5\u5728\u8fd0\u884c\u65f6\u63a8\u9001\u548c/\u6216\u6d4b\u8bd5\uff0c\u800c\u4e0d\u9700\u8981\u66f4\u65b0\u548c/\u6216\u91cd\u65b0\u90e8\u7f72\u4e00\u4e2a\u65b0\u7684\u4e8c\u8fdb\u5236\uff1b</li> <li><code>\u8f7b\u91cf\u7ea7</code>\uff1aWebAssembly \u5fae\u670d\u52a1\u6d88\u8017 1% \u7684\u8d44\u6e90\uff0c\u4e0e Linux \u5bb9\u5668\u5e94\u7528\u76f8\u6bd4\uff0c\u51b7\u542f\u52a8\u7684\u65f6\u95f4\u662f 1%\uff1a\u6211\u4eec\u4e5f\u8bb8\u53ef\u4ee5\u501f\u6b64\u5b9e\u73b0 eBPF as a service\uff0c\u8ba9 eBPF \u7a0b\u5e8f\u7684\u52a0\u8f7d\u548c\u6267\u884c\u53d8\u5f97\u66f4\u52a0\u8f7b\u91cf\u7ea7\u3001\u5feb\u901f\u3001\u7b80\u4fbf\u6613\u884c\uff1b</li> </ul> <p>eunomia-bpf \u662f <code>eBPF \u6280\u672f\u63a2\u7d22 SIG</code> [3] [5] \u4e2d\u53d1\u8d77\u5e76\u5b75\u5316\u7684\u9879\u76ee\uff0c\u76ee\u524d\u4e5f\u5df2\u7ecf\u5728 github [4] \u4e0a\u5f00\u6e90\u3002eunomia-bpf \u662f\u4e00\u4e2a eBPF \u7a0b\u5e8f\u7684\u8f7b\u91cf\u7ea7\u5f00\u53d1\u52a0\u8f7d\u6846\u67b6\uff0c\u5305\u542b\u4e86\u4e00\u4e2a\u7528\u6237\u6001\u52a8\u6001\u52a0\u8f7d\u6846\u67b6/\u8fd0\u884c\u65f6\u5e93\uff0c\u4ee5\u53ca\u4e00\u4e2a\u7b80\u5355\u7684\u7f16\u8bd1 Wasm \u548c eBPF \u5b57\u8282\u7801\u7684\u5de5\u5177\u94fe\u5bb9\u5668\u3002\u4e8b\u5b9e\u4e0a\uff0c\u5728 Wasm \u6a21\u5757\u4e2d\u7f16\u5199 eBPF \u4ee3\u7801\u548c\u901a\u5e38\u719f\u6089\u7684\u4f7f\u7528 libbpf \u6846\u67b6\u6216 Coolbpf \u5f00\u53d1 eBPF \u7a0b\u5e8f\u7684\u65b9\u5f0f\u662f\u57fa\u672c\u4e00\u6837\u7684\uff0cWasm \u7684\u590d\u6742\u6027\u4f1a\u88ab\u9690\u85cf\u5728 eunomia-bpf \u7684\u7f16\u8bd1\u5de5\u5177\u94fe\u548c\u8fd0\u884c\u65f6\u5e93\u4e2d\uff0c\u5f00\u53d1\u8005\u53ef\u4ee5\u4e13\u6ce8\u4e8e eBPF \u7a0b\u5e8f\u7684\u5f00\u53d1\u548c\u8c03\u8bd5\uff0c\u4e0d\u9700\u8981\u4e86\u89e3 Wasm \u7684\u80cc\u666f\u77e5\u8bc6\uff0c\u4e5f\u4e0d\u9700\u8981\u62c5\u5fc3 Wasm \u7684\u7f16\u8bd1\u73af\u5883\u914d\u7f6e\u3002</p>"},{"location":"blogs/ebpf-wasm.zh/#wasm-ebpf","title":"\u4f7f\u7528 Wasm \u6a21\u5757\u5206\u53d1\u3001\u52a8\u6001\u52a0\u8f7d eBPF \u7a0b\u5e8f","text":"<p>eunomia-bpf \u5e93\u5305\u542b\u4e00\u4e2a\u7b80\u5355\u7684\u547d\u4ee4\u884c\u5de5\u5177\uff08ecli\uff09\uff0c\u5305\u542b\u4e86\u4e00\u4e2a\u5c0f\u578b\u7684 Wasm \u8fd0\u884c\u65f6\u6a21\u5757\u548c eBPF \u52a8\u6001\u88c5\u8f7d\u7684\u529f\u80fd\uff0c\u53ef\u4ee5\u76f4\u63a5\u4e0b\u8f7d\u4e0b\u6765\u540e\u8fdb\u884c\u4f7f\u7528\uff1a</p> <pre><code># download the release from https://github.com/eunomia-bpf/eunomia-bpf/releases/latest/download/ecli\n$ wget https://aka.pw/bpf-ecli -O ecli &amp;&amp; chmod +x ./ecli\n$ sudo ./ecli run https://eunomia-bpf.github.io/eunomia-bpf/sigsnoop/app.wasm\n2022-10-11 14:05:50 URL:https://eunomia-bpf.github.io/eunomia-bpf/sigsnoop/app.wasm [70076/70076] -&gt; \"/tmp/ebpm/app.wasm\" [1]\nrunning and waiting for the ebpf events from perf event...\n{\"pid\":1709490,\"tpid\":1709077,\"sig\":0,\"ret\":0,\"comm\":\"node\",\"sig_name\":\"N/A\"}\n{\"pid\":1712603,\"tpid\":1717412,\"sig\":2,\"ret\":0,\"comm\":\"kworker/u4:3\",\"sig_name\":\"SIGINT\"}\n{\"pid\":1712603,\"tpid\":1717411,\"sig\":2,\"ret\":0,\"comm\":\"kworker/u4:3\",\"sig_name\":\"SIGINT\"}\n{\"pid\":0,\"tpid\":847,\"sig\":14,\"ret\":0,\"comm\":\"swapper/1\",\"sig_name\":\"SIGALRM\"}\n{\"pid\":1709490,\"tpid\":1709077,\"sig\":0,\"ret\":0,\"comm\":\"node\",\"sig_name\":\"N/A\"}\n{\"pid\":1709139,\"tpid\":1709077,\"sig\":0,\"ret\":0,\"comm\":\"node\",\"sig_name\":\"N/A\"}\n{\"pid\":1717420,\"tpid\":1717419,\"sig\":17,\"ret\":0,\"comm\":\"cat\",\"sig_name\":\"SIGCHLD\"}\n</code></pre> <p>ecli \u4f1a\u81ea\u52a8\u4ece\u7f51\u9875\u4e0a\u4e0b\u8f7d\u5e76\u52a0\u8f7d sigsnoop/app.wasm \u8fd9\u4e2a wasm \u6a21\u5757\uff0c\u5b83\u5305\u542b\u4e86\u4e00\u4e2a eBPF \u7a0b\u5e8f\uff0c\u7528\u4e8e\u8ddf\u8e2a\u5185\u6838\u4e2d\u8fdb\u7a0b\u7684\u4fe1\u53f7\u53d1\u9001\u548c\u63a5\u6536\u3002\u8fd9\u91cc\u6211\u4eec\u53ef\u4ee5\u770b\u5230\u4e00\u4e2a\u7b80\u5355\u7684 JSON \u683c\u5f0f\u7684\u8f93\u51fa\uff0c\u5305\u542b\u4e86\u8fdb\u7a0b\u7684 PID\u3001\u4fe1\u53f7\u7684\u7c7b\u578b\u3001\u53d1\u9001\u8005\u548c\u63a5\u6536\u8005\uff0c\u4ee5\u53ca\u4fe1\u53f7\u540d\u79f0\u7b49\u4fe1\u606f\u3002\u5b83\u4e5f\u53ef\u4ee5\u9644\u5e26\u4e00\u4e9b\u547d\u4ee4\u884c\u53c2\u6570\uff0c\u4f8b\u5982\uff1a</p> <pre><code>$ wget https://eunomia-bpf.github.io/eunomia-bpf/sigsnoop/app.wasm\n2022-10-11 14:08:07 (40.5 MB/s) - \u2018app.wasm.1\u2019 saved [70076/70076]\n$ sudo ./ecli run app.wasm -h\nUsage: sigsnoop [-h] [-x] [-k] [-n] [-p PID] [-s SIGNAL]\nTrace standard and real-time signals.\n    -h, --help  show this help message and exit\n    -x, --failed  failed signals only\n    -k, --killed  kill only\n    -p, --pid=&lt;int&gt;  target pid\n    -s, --signal=&lt;int&gt;  target signal\n$ sudo ./ecli run app.wasm -p 1641\nrunning and waiting for the ebpf events from perf event...\n{\"pid\":1641,\"tpid\":14900,\"sig\":23,\"ret\":0,\"comm\":\"YDLive\",\"sig_name\":\"SIGURG\"}\n{\"pid\":1641,\"tpid\":14900,\"sig\":23,\"ret\":0,\"comm\":\"YDLive\",\"sig_name\":\"SIGURG\"}\n</code></pre> <p>\u6211\u4eec\u53ef\u4ee5\u901a\u8fc7 -p \u63a7\u5236\u5b83\u8ffd\u8e2a\u54ea\u4e2a\u8fdb\u7a0b\uff0c\u5728\u5185\u6838\u6001 eBPF \u7a0b\u5e8f\u4e2d\u8fdb\u884c\u4e00\u4e9b\u8fc7\u6ee4\u548c\u5904\u7406\u3002\u540c\u6837\u4e5f\u53ef\u4ee5\u4f7f\u7528 ecli \u6765\u52a8\u6001\u52a0\u8f7d\u4f7f\u7528\u5176\u4ed6\u7684\u5de5\u5177\uff0c\u4f8b\u5982 opensnoop\uff1a</p> <pre><code>$ sudo ./ecli run https://eunomia-bpf.github.io/eunomia-bpf/opensnoop/app.wasm\n2022-10-11 14:11:56 URL:https://eunomia-bpf.github.io/eunomia-bpf/opensnoop/app.wasm [61274/61274] -&gt; \"/tmp/ebpm/app.wasm\" [1]\nrunning and waiting for the ebpf events from perf event...\n{\"ts\":0,\"pid\":2344,\"uid\":0,\"ret\":26,\"flags\":0,\"comm\":\"YDService\",\"fname\":\"/proc/1718823/cmdline\"}\n{\"ts\":0,\"pid\":2344,\"uid\":0,\"ret\":26,\"flags\":0,\"comm\":\"YDService\",\"fname\":\"/proc/1718824/cmdline\"}\n{\"ts\":0,\"pid\":2344,\"uid\":0,\"ret\":26,\"flags\":0,\"comm\":\"YDService\",\"fname\":\"/proc/self/stat\"}\n</code></pre> <p>opensnoop \u4f1a\u8ffd\u8e2a\u8fdb\u7a0b\u7684 open() \u8c03\u7528\uff0c\u5373\u5185\u6838\u4e2d\u6240\u6709\u7684\u6253\u5f00\u6587\u4ef6\u64cd\u4f5c\uff0c\u8fd9\u91cc\u6211\u4eec\u53ef\u4ee5\u770b\u5230\u8fdb\u7a0b\u7684 PID\u3001UID\u3001\u8fd4\u56de\u503c\u3001\u8c03\u7528\u6807\u5fd7\u3001\u8fdb\u7a0b\u540d\u548c\u6587\u4ef6\u540d\u7b49\u4fe1\u606f\u3002\u5185\u6838\u6001\u7684 eBPF \u7a0b\u5e8f\u4f1a\u88ab\u5305\u542b\u5728 Wasm \u6a21\u5757\u4e2d\u8fdb\u884c\u5206\u53d1\uff0c\u5728\u52a0\u8f7d\u7684\u65f6\u5019\u901a\u8fc7 BTF \u4fe1\u606f\u548c libbpf \u8fdb\u884c\u91cd\u5b9a\u4f4d\u64cd\u4f5c\uff0c\u4ee5\u9002\u5e94\u4e0d\u540c\u7684\u5185\u6838\u7248\u672c\u3002\u540c\u65f6\uff0c\u7531\u4e8e\u7528\u6237\u6001\u7684\u76f8\u5173\u5904\u7406\u4ee3\u7801\u5b8c\u5168\u7531 Wasm \u7f16\u5199\uff0c\u5185\u6838\u6001\u7531 eBPF \u6307\u4ee4\u7f16\u5199\uff0c\u56e0\u6b64\u4e0d\u53d7\u5177\u4f53\u6307\u4ee4\u96c6\uff08x86\u3001ARM \u7b49\uff09\u7684\u9650\u5236\uff0c\u53ef\u4ee5\u5728\u4e0d\u540c\u7684\u5e73\u53f0\u4e0a\u8fd0\u884c\u3002</p>"},{"location":"blogs/ebpf-wasm.zh/#wasm-ebpf_1","title":"\u4f7f\u7528 Wasm \u5f00\u53d1\u548c\u6253\u5305 eBPF \u7a0b\u5e8f","text":"<p>\u540c\u6837\uff0c\u4ee5\u4e0a\u6587\u6240\u8ff0\u7684 sigsnoop \u4e3a\u4f8b\uff0c\u8981\u8ddf\u8e2a\u8fdb\u7a0b\u7684\u4fe1\u53f7\u53d1\u9001\u548c\u63a5\u6536\uff0c\u6211\u4eec\u9996\u5148\u9700\u8981\u5728 sigsnoop.bpf.c \u4e2d\u7f16\u5199\u5185\u6838\u6001\u7684 eBPF \u4ee3\u7801\uff1a</p> <pre><code>#include &lt;vmlinux.h&gt;\n#include &lt;bpf/bpf_helpers.h&gt;\n#include \"sigsnoop.h\"\nconst volatile pid_t filtered_pid = 0;\n.....\nstruct {\n__uint(type, BPF_MAP_TYPE_PERF_EVENT_ARRAY);\n__uint(key_size, sizeof(__u32));\n__uint(value_size, sizeof(__u32));\n} events SEC(\".maps\");\nSEC(\"tracepoint/signal/signal_generate\")\nint sig_trace(struct trace_event_raw_signal_generate *ctx)\n{\nstruct event event = {};\npid_t tpid = ctx-&gt;pid;\nint ret = ctx-&gt;errno;\nint sig = ctx-&gt;sig;\n__u64 pid_tgid;\n__u32 pid;\n...\npid_tgid = bpf_get_current_pid_tgid();\npid = pid_tgid &gt;&gt; 32;\nif (filtered_pid &amp;&amp; pid != filtered_pid)\nreturn 0;\nevent.pid = pid;\nevent.tpid = tpid;\nevent.sig = sig;\nevent.ret = ret;\nbpf_get_current_comm(event.comm, sizeof(event.comm));\nbpf_perf_event_output(ctx, &amp;events, BPF_F_CURRENT_CPU, &amp;event, sizeof(event));\nreturn 0;\n}\nchar LICENSE[] SEC(\"license\") = \"Dual BSD/GPL\";\n</code></pre> <p>\u8fd9\u91cc\u6211\u4eec\u4f7f\u7528 <code>tracepoint/signal/signal_generate</code> \u8fd9\u4e2a tracepoint \u6765\u5728\u5185\u6838\u4e2d\u8ffd\u8e2a\u4fe1\u53f7\u7684\u4ea7\u751f\u4e8b\u4ef6\u3002\u5185\u6838\u6001\u4ee3\u7801\u901a\u8fc7 BPF_MAP_TYPE_PERF_EVENT_ARRAY \u5f80\u7528\u6237\u6001\u5bfc\u51fa\u4fe1\u606f\uff0c\u4e3a\u6b64\u6211\u4eec\u9700\u8981\u5728 sigsnoop.h \u5934\u6587\u4ef6\uff0c\u4e2d\u5b9a\u4e49\u4e00\u4e2a\u5bfc\u51fa\u4fe1\u606f\u7684\u7ed3\u6784\u4f53\uff1a</p> <pre><code>#ifndef __SIGSNOOP_H\n#define __SIGSNOOP_H\n#define TASK_COMM_LEN 16\nstruct event {\nunsigned int pid;\nunsigned int tpid;\nint sig;\nint ret;\nchar comm[TASK_COMM_LEN];\n};\n#endif /* __SIGSNOOP_H */\n</code></pre> <p>\u53ef\u4ee5\u76f4\u63a5\u4f7f\u7528 eunomia-bpf \u7684\u7f16\u8bd1\u5de5\u5177\u94fe\u5c06\u5176\u7f16\u8bd1\u4e3a JSON \u683c\u5f0f\uff0c\u751f\u6210\u4e00\u4e2a package.json \u6587\u4ef6\uff0c\u5e76\u4e14\u53ef\u4ee5\u76f4\u63a5\u4f7f\u7528 ecli \u52a0\u8f7d\u8fd0\u884c\uff1a</p> <pre><code>$ docker run -it -v `pwd`/:/src/ ghcr.io/eunomia-bpf/ecc-`uname -m`:latest\nmake\n  BPF      .output/client.bpf.o\n  GEN-SKEL .output/client.skel.h\n  CC       .output/client.o\n  CC       .output/cJSON.o\n  CC       .output/create_skel_json.o\n  BINARY   client\n  DUMP_LLVM_MEMORY_LAYOUT\n  DUMP_EBPF_PROGRAM\n  FIX_TYPE_INFO_IN_EBPF\n  GENERATE_PACKAGE_JSON\n$ sudo ./ecli run package.json\nrunning and waiting for the ebpf events from perf event...\ntime pid tpid sig ret comm\n14:39:39 1723835 1723834 17 0 dirname\n14:39:39 1723836 1723834 17 0 chmod\n14:39:39 1723838 1723837 17 0 ps\n14:39:39 1723839 1723837 17 0 grep\n14:39:39 1723840 1723837 17 0 grep\n14:39:39 1723841 1723837 17 0 wc\n</code></pre> <p>\u6211\u4eec\u6240\u6709\u7684\u7f16\u8bd1\u5de5\u5177\u94fe\u90fd\u5df2\u7ecf\u6253\u5305\u6210\u4e86 docker \u955c\u50cf\u7684\u5f62\u5f0f\u5e76\u53d1\u5e03\u5230\u4e86 docker hub \u4e0a\uff0c\u53ef\u4ee5\u76f4\u63a5\u5f00\u7bb1\u5373\u7528\u3002\u6b64\u65f6\u52a8\u6001\u52a0\u8f7d\u8fd0\u884c\u7684\u53ea\u6709\u5185\u6838\u6001\u7684 eBPF \u4ee3\u7801\u548c\u4e00\u4e9b\u8f85\u52a9\u4fe1\u606f\uff0c\u5e2e\u52a9 eunomia-bpf \u5e93\u81ea\u52a8\u83b7\u53d6\u5185\u6838\u6001\u5f80\u7528\u6237\u6001\u4e0a\u62a5\u7684\u4e8b\u4ef6\u3002\u5982\u679c\u6211\u4eec\u60f3\u8981\u5728\u7528\u6237\u6001\u8fdb\u884c\u4e00\u4e9b\u53c2\u6570\u914d\u7f6e\u548c\u8c03\u6574\uff0c\u4ee5\u53ca\u6570\u636e\u5904\u7406\u6d41\u7a0b\uff0c\u6211\u4eec\u9700\u8981\u5728\u7528\u6237\u6001\u7f16\u5199\u4ee3\u7801\uff0c\u5c06\u5185\u6838\u6001\u7684 eBPF \u4ee3\u7801\u548c\u7528\u6237\u6001\u7684\u4ee3\u7801\u6253\u5305\u6210\u4e00\u4e2a\u5b8c\u6574\u7684 eBPF \u7a0b\u5e8f\u3002</p> <p>\u53ef\u4ee5\u76f4\u63a5\u4e00\u884c\u547d\u4ee4\uff0c\u751f\u6210 eBPF \u7a0b\u5e8f\u7684\u7528\u6237\u6001 WebAssembly \u5f00\u53d1\u6846\u67b6\uff1a</p> <pre><code>$ docker run -it -v `pwd`/:/src/ ghcr.io/eunomia-bpf/ecc-`uname -m`:latest gen-wasm-skel\nmake\n  GENERATE_PACKAGE_JSON\n  GEN-Wasm-SKEL\n$ ls\napp.c eunomia-include ewasm-skel.h package.json README.md  sigsnoop.bpf.c  sigsnoop.h\n</code></pre> <p>\u6211\u4eec\u63d0\u4f9b\u7684\u662f C \u8bed\u8a00\u7248\u672c\u7684 Wasm \u5f00\u53d1\u6846\u67b6\uff0c\u5b83\u5305\u542b\u5982\u4e0b\u8fd9\u4e9b\u6587\u4ef6\uff1a</p> <ul> <li>ewasm-skel.h\uff1a\u7528\u6237\u6001 WebAssembly \u5f00\u53d1\u6846\u67b6\u7684\u5934\u6587\u4ef6\uff0c\u5305\u542b\u4e86\u9884\u7f16\u8bd1\u7684 eBPF \u7a0b\u5e8f\u5b57\u8282\u7801\uff0c\u548c eBPF \u7a0b\u5e8f\u6846\u67b6\u8f85\u52a9\u4fe1\u606f\uff0c\u7528\u6765\u52a8\u6001\u52a0\u8f7d\uff1b</li> <li>eunomia-include\uff1a\u4e00\u4e9b header-only \u7684\u5e93\u51fd\u6570\u548c\u8f85\u52a9\u6587\u4ef6\uff0c\u7528\u6765\u8f85\u52a9\u5f00\u53d1\uff1b</li> <li>app.c\uff1a\u7528\u6237\u6001 WebAssembly \u7a0b\u5e8f\u7684\u4e3b\u8981\u4ee3\u7801\uff0c\u5305\u542b\u4e86 eBPF \u7a0b\u5e8f\u7684\u4e3b\u8981\u903b\u8f91\uff0c\u4ee5\u53ca eBPF \u7a0b\u5e8f\u7684\u6570\u636e\u5904\u7406\u6d41\u7a0b\u3002</li> </ul> <p>\u4ee5 sigsnoop \u4e3a\u4f8b\uff0c\u7528\u6237\u6001\u5305\u542b\u4e00\u4e9b\u547d\u4ee4\u884c\u89e3\u6790\u3001\u914d\u7f6e eBPF \u7a0b\u5e8f\u548c\u6570\u636e\u5904\u7406\u7684\u4ee3\u7801\uff0c\u4f1a\u5c06\u6839\u636e signal number \u5c06\u4fe1\u53f7\u4e8b\u4ef6\u7684\u82f1\u6587\u540d\u79f0\u6dfb\u52a0\u5230\u4e8b\u4ef6\u4e2d\uff1a</p> <pre><code>....\nint main(int argc, const char** argv)\n{\nstruct argparse_option options[] = {\nOPT_HELP(),\nOPT_BOOLEAN('x', \"failed\", &amp;failed_only, \"failed signals only\", NULL, 0, 0),\nOPT_BOOLEAN('k', \"killed\", &amp;kill_only, \"kill only\", NULL, 0, 0),\nOPT_INTEGER('p', \"pid\", &amp;target_pid, \"target pid\", NULL, 0, 0),\nOPT_INTEGER('s', \"signal\", &amp;target_signal, \"target signal\", NULL, 0, 0),\nOPT_END(),\n};\nstruct argparse argparse;\nargparse_init(&amp;argparse, options, usages, 0);\nargparse_describe(&amp;argparse, \"Trace standard and real-time signals.\\n\", \"\");\nargc = argparse_parse(&amp;argparse, argc, argv);\ncJSON *program = cJSON_Parse(program_data);\nprogram = set_bpf_program_global_var(program, \"filtered_pid\", cJSON_CreateNumber(target_pid));\nprogram = set_bpf_program_global_var(program, \"target_signal\", cJSON_CreateNumber(target_signal));\nprogram = set_bpf_program_global_var(program, \"failed_only\", cJSON_CreateBool(failed_only));\nreturn start_bpf_program(cJSON_PrintUnformatted(program));\n}\nint process_event(int ctx, char *e, int str_len)\n{\ncJSON *json = cJSON_Parse(e);\nint sig = cJSON_GetObjectItem(json, \"sig\")-&gt;valueint;\nconst char *name = sig_name[sig];\ncJSON_AddItemToObject(json, \"sig_name\", cJSON_CreateString(name));\nchar *out = cJSON_PrintUnformatted(json);\nprintf(\"%s\\n\", out);\nreturn 0;\n}\n</code></pre> <p>\u6700\u540e\u4f7f\u7528\u5bb9\u5668\u955c\u50cf\u5373\u53ef\u4e00\u884c\u547d\u4ee4\u5b8c\u6210 WebAssembly/eBPF \u7a0b\u5e8f\u7684\u7f16\u8bd1\u548c\u6253\u5305\uff0c\u4f7f\u7528 ecli \u5373\u53ef\u4e00\u952e\u8fd0\u884c\uff1a</p> <pre><code>$ docker run -it -v `pwd`/:/src/ ghcr.io/eunomia-bpf/ecc-`uname -m`:latest build-wasm\nmake\n  GENERATE_PACKAGE_JSON\n  BUILD-Wasm\nbuild app.wasm success\n$ sudo ./ecli run app.wasm -h\nUsage: sigsnoop [-h] [-x] [-k] [-n] [-p PID] [-s SIGNAL]\n</code></pre> <p>\u7531\u4e8e\u6211\u4eec\u57fa\u4e8e\u4e00\u6b21\u7f16\u8bd1\u3001\u5230\u5904\u8fd0\u884c\u7684 libbpf \u6846\u67b6\u5b8c\u6210\u52a0\u8f7d\u548c\u542f\u52a8 eBPF \u7a0b\u5e8f\u7684\u64cd\u4f5c\uff0c\u56e0\u6b64\u7f16\u8bd1\u548c\u8fd0\u884c\u4e24\u4e2a\u6b65\u9aa4\u662f\u5b8c\u5168\u5206\u79bb\u7684\uff0c\u53ef\u4ee5\u901a\u8fc7\u7f51\u7edc\u6216\u4efb\u610f\u65b9\u5f0f\u76f4\u63a5\u8fdb\u884c eBPF \u7a0b\u5e8f\u7684\u5206\u53d1\u548c\u90e8\u7f72\uff0c\u4e0d\u4f9d\u8d56\u4e8e\u7279\u5b9a\u5185\u6838\u7248\u672c\u3002\u501f\u52a9 WebAssembly \u7684\u8f7b\u91cf\u7ea7\u7279\u6027\uff0ceBPF \u7a0b\u5e8f\u7684\u542f\u52a8\u901f\u5ea6\u4e5f\u6bd4\u901a\u5e38\u7684\u4f7f\u7528\u955c\u50cf\u5f62\u5f0f\u5206\u53d1\u7684 libbpf \u7a0b\u5e8f\u5feb\u4e0a\u4e0d\u5c11\uff0c\u901a\u5e38\u53ea\u9700\u4e0d\u5230 100 ms \u7684\u65f6\u95f4\u5373\u53ef\u5b8c\u6210\uff0c\u6bd4\u8d77\u4f7f\u7528 BCC \u90e8\u7f72\u542f\u52a8\u65f6\uff0c\u4f7f\u7528 LLVM\u3001Clang \u7f16\u8bd1\u8fd0\u884c\u6d88\u8017\u7684\u65f6\u95f4\u548c\u5927\u91cf\u8d44\u6e90\uff0c\u66f4\u662f\u6709\u4e86\u8d28\u7684\u98de\u8dc3\u3002</p> <p>\u4e0a\u9762\u63d0\u53ca\u7684\u793a\u4f8b\u7a0b\u5e8f\u7684\u5b8c\u6574\u4ee3\u7801\uff0c\u53ef\u4ee5\u53c2\u8003\u8fd9\u91cc[6]\u3002</p>"},{"location":"blogs/ebpf-wasm.zh/#_2","title":"\u6f14\u793a\u89c6\u9891","text":"<p>\u6211\u4eec\u4e5f\u6709\u4e00\u4e2a\u5728 B \u7ad9\u4e0a\u7684\u6f14\u793a\u89c6\u9891\uff0c\u6f14\u793a\u4e86\u5982\u4f55\u4ece bcc/libbpf-tools \u4e2d\u79fb\u690d\u4e00\u4e2a eBPF \u5de5\u5177\u7a0b\u5e8f\u5230 eunomia-bpf \u4e2d\uff0c\u5e76\u4e14\u4f7f\u7528 Wasm \u6216 JSON \u6587\u4ef6\u6765\u5206\u53d1\u3001\u52a0\u8f7d eBPF \u7a0b\u5e8f\uff1ahttps://www.bilibili.com/video/BV1JN4y1A76k</p>"},{"location":"blogs/ebpf-wasm.zh/#_3","title":"\u6211\u4eec\u662f\u5982\u4f55\u505a\u5230\u7684","text":"<p><code>ecli</code> \u662f\u57fa\u4e8e\u6211\u4eec\u5e95\u5c42\u7684 eunomia-bpf \u5e93\u548c\u8fd0\u884c\u65f6\u5b9e\u73b0\u7684\u4e00\u4e2a\u7b80\u5355\u7684\u547d\u4ee4\u884c\u5de5\u5177\u3002\u6211\u4eec\u7684\u9879\u76ee\u67b6\u6784\u5982\u4e0b\u56fe\u6240\u793a\uff1a</p> <p></p> <p><code>ecli</code> \u5de5\u5177\u57fa\u4e8e <code>ewasm</code> \u5e93\u5b9e\u73b0\uff0c<code>ewasm</code> \u5e93\u5305\u542b\u4e00\u4e2a WAMR(wasm-micro-runtime) \u8fd0\u884c\u65f6\uff0c\u4ee5\u53ca\u57fa\u4e8e libbpf \u5e93\u6784\u5efa\u7684 eBPF \u52a8\u6001\u88c5\u8f7d\u6a21\u5757\u3002\u5927\u81f4\u6765\u8bf4\uff0c\u6211\u4eec\u5728 <code>Wasm</code> \u8fd0\u884c\u65f6\u548c\u7528\u6237\u6001\u7684 <code>libbpf</code> \u4e2d\u95f4\u591a\u52a0\u4e86\u4e00\u5c42\u62bd\u8c61\u5c42\uff08<code>eunomia-bpf</code> \u5e93\uff09\uff0c\u4f7f\u5f97\u4e00\u6b21\u7f16\u8bd1\u3001\u5230\u5904\u8fd0\u884c\u7684 eBPF \u4ee3\u7801\u53ef\u4ee5\u4ece JSON \u5bf9\u8c61\u4e2d\u52a8\u6001\u52a0\u8f7d\u3002JSON \u5bf9\u8c61\u4f1a\u5728\u7f16\u8bd1\u65f6\u88ab\u5305\u542b\u5728 Wasm \u6a21\u5757\u4e2d\uff0c\u56e0\u6b64\u5728\u8fd0\u884c\u65f6\uff0c\u6211\u4eec\u53ef\u4ee5\u901a\u8fc7\u89e3\u6790 JSON \u5bf9\u8c61\u6765\u83b7\u53d6 eBPF \u7a0b\u5e8f\u7684\u4fe1\u606f\uff0c\u7136\u540e\u52a8\u6001\u52a0\u8f7d eBPF \u7a0b\u5e8f\u3002</p> <p>\u4f7f\u7528 Wasm \u6216 JSON \u7f16\u8bd1\u5206\u53d1 eBPF \u7a0b\u5e8f\u7684\u6d41\u7a0b\u56fe\u5927\u81f4\u5982\u4e0b\uff1a</p> <p></p> <p>\u5927\u81f4\u6765\u8bf4\uff0c\u6574\u4e2a eBPF \u7a0b\u5e8f\u7684\u7f16\u5199\u548c\u52a0\u8f7d\u5206\u4e3a\u4e09\u4e2a\u90e8\u5206\uff1a</p> <ol> <li>\u7528 eunomia-cc \u5de5\u5177\u94fe\u5c06\u5185\u6838\u7684 eBPF \u4ee3\u7801\u9aa8\u67b6\u548c\u5b57\u8282\u7801\u7f16\u8bd1\u4e3a JSON \u683c\u5f0f</li> <li>\u5728\u7528\u6237\u6001\u5f00\u53d1\u7684\u9ad8\u7ea7\u8bed\u8a00\uff08\u4f8b\u5982 C \u8bed\u8a00\uff09\u4e2d\u5d4c\u5165 JSON \u6570\u636e\uff0c\u5e76\u63d0\u4f9b\u4e00\u4e9b API \u7528\u4e8e\u64cd\u4f5c JSON \u5f62\u6001\u7684 eBPF \u7a0b\u5e8f\u9aa8\u67b6</li> <li>\u5c06\u7528\u6237\u6001\u7a0b\u5e8f\u548c JSON \u6570\u636e\u4e00\u8d77\u7f16\u8bd1\u4e3a Wasm \u5b57\u8282\u7801\u5e76\u6253\u5305\u4e3a Wasm \u6a21\u5757\uff0c\u7136\u540e\u5728\u76ee\u6807\u673a\u5668\u4e0a\u52a0\u8f7d\u5e76\u8fd0\u884c Wasm \u7a0b\u5e8f</li> <li>\u4ece Wasm \u6a21\u5757\u4e2d\u52a0\u8f7d\u5185\u5d4c\u7684 JSON \u6570\u636e\uff0c\u7528 eunomia-bpf \u5e93\u52a8\u6001\u88c5\u8f7d\u548c\u914d\u7f6e eBPF \u7a0b\u5e8f\u9aa8\u67b6\u3002</li> </ol> <p>\u6211\u4eec\u9700\u8981\u5b8c\u6210\u7684\u4ec5\u4ec5\u662f\u5c11\u91cf\u7684 native API \u548c Wasm \u8fd0\u884c\u65f6\u7684\u7ed1\u5b9a\uff0c\u5e76\u4e14\u5728 Wasm \u4ee3\u7801\u4e2d\u5904\u7406 JSON \u6570\u636e\u3002\u4f60\u53ef\u4ee5\u5728\u4e00\u4e2a\u5355\u4e00\u7684 <code>Wasm</code> \u6a21\u5757\u4e2d\u62e5\u6709\u591a\u4e2a <code>eBPF</code> \u7a0b\u5e8f\u3002\u5982\u679c\u4e0d\u4f7f\u7528\u6211\u4eec\u63d0\u4f9b\u7684 Wasm \u8fd0\u884c\u65f6\uff0c\u6216\u8005\u60f3\u8981\u4f7f\u7528\u5176\u4ed6\u8bed\u8a00\u8fdb\u884c\u7528\u6237\u6001\u7684 eBPF \u8f85\u52a9\u4ee3\u7801\u7684\u5f00\u53d1\uff0c\u5728\u6211\u4eec\u63d0\u4f9b\u7684 <code>eunomia-bpf</code> \u5e93\u57fa\u7840\u4e0a\u5b8c\u6210\u4e00\u4e9b WebaAssembly \u7684\u7ed1\u5b9a\u5373\u53ef\u3002</p> <p>\u53e6\u5916\uff0c\u5bf9\u4e8e eunomia-bpf \u5e93\u800c\u8a00\uff0c\u4e0d\u9700\u8981 Wasm \u6a21\u5757\u548c\u8fd0\u884c\u65f6\u540c\u6837\u53ef\u4ee5\u542f\u52a8\u548c\u52a8\u6001\u52a0\u8f7d eBPF \u7a0b\u5e8f\uff0c\u4e0d\u8fc7\u6b64\u65f6\u52a8\u6001\u52a0\u8f7d\u8fd0\u884c\u7684\u5c31\u53ea\u662f\u5185\u6838\u6001\u7684 eBPF \u7a0b\u5e8f\u5b57\u8282\u7801\u3002\u4f60\u53ef\u4ee5\u624b\u52a8\u6216\u4f7f\u7528\u4efb\u610f\u8bed\u8a00\u4fee\u6539 JSON \u5bf9\u8c61\u6765\u63a7\u5236 eBPF \u7a0b\u5e8f\u7684\u52a0\u8f7d\u548c\u53c2\u6570\uff0c\u5e76\u4e14\u901a\u8fc7 eunomia-bpf \u81ea\u52a8\u83b7\u53d6\u5185\u6838\u6001\u4e0a\u62a5\u7684\u8fd4\u56de\u6570\u636e\u3002\u5bf9\u4e8e\u521d\u5b66\u8005\u800c\u8a00\uff0c\u8fd9\u53ef\u80fd\u6bd4\u4f7f\u7528 WebAssembly \u66f4\u52a0\u7b80\u5355\u65b9\u4fbf\uff1a\u53ea\u9700\u8981\u7f16\u5199\u5185\u6838\u6001\u7684 eBPF \u7a0b\u5e8f\uff0c\u7136\u540e\u4f7f\u7528 eunomia-cc \u5de5\u5177\u94fe\u5c06\u5176\u7f16\u8bd1\u4e3a JSON \u683c\u5f0f\uff0c\u6700\u540e\u4f7f\u7528 eunomia-bpf \u5e93\u52a0\u8f7d\u548c\u8fd0\u884c\u5373\u53ef\u3002\u5b8c\u5168\u4e0d\u7528\u8003\u8651\u4efb\u4f55\u7528\u6237\u6001\u7684\u8f85\u52a9\u7a0b\u5e8f\uff0c\u5305\u62ec Wasm \u5728\u5185\u3002\u5177\u4f53\u53ef\u4ee5\u53c2\u8003\u6211\u4eec\u7684\u4f7f\u7528\u624b\u518c[7]\u6216\u793a\u4f8b\u4ee3\u7801[8]\u3002</p>"},{"location":"blogs/ebpf-wasm.zh/#_4","title":"\u672a\u6765\u7684\u65b9\u5411","text":"<p>\u76ee\u524d eunomia-bpf \u7684\u5de5\u5177\u94fe\u7684\u5b9e\u73b0\u8fd8\u8fdc\u8fdc\u8c08\u4e0d\u4e0a\u5b8c\u5584\uff0c\u53ea\u662f\u6709\u4e00\u4e2a\u53ef\u884c\u6027\u9a8c\u8bc1\u7684\u7248\u672c\u3002\u5bf9\u4e8e\u4e00\u4e2a\u5f00\u53d1\u5de5\u5177\u94fe\u6765\u8bf4\uff0c\u5177\u4f53\u7684 API \u6807\u51c6\u548c\u76f8\u5173\u7684\u751f\u6001\u662f\u975e\u5e38\u91cd\u8981\u7684\uff0c\u6211\u4eec\u5e0c\u671b\u5982\u679c\u6709\u673a\u4f1a\u7684\u8bdd\uff0c\u4e5f\u8bb8\u53ef\u4ee5\u548c SIG \u793e\u533a\u7684\u5176\u4ed6\u6210\u5458\u4e00\u8d77\u8ba8\u8bba\u5e76\u5f62\u6210\u4e00\u4e2a\u5177\u4f53\u7684 API \u6807\u51c6\uff0c\u80fd\u591f\u57fa\u4e8e eBPF \u548c Wasm \u7b49\u6280\u672f\uff0c\u5171\u540c\u63d0\u4f9b\u4e00\u4e2a\u901a\u7528\u7684\u3001\u8de8\u5e73\u53f0\u548c\u5185\u6838\u7248\u672c\u7684\u63d2\u4ef6\u751f\u6001\uff0c\u4e3a\u5404\u81ea\u7684\u5e94\u7528\u589e\u52a0 eBPF \u548c Wasm \u7684\u8d85\u80fd\u529b\u3002</p> <p>\u76ee\u524d eunomia-bpf \u8de8\u5185\u6838\u7248\u672c\u7684\u52a8\u6001\u52a0\u8f7d\u7279\u6027\u8fd8\u4f9d\u8d56\u4e8e\u5185\u6838\u7684 BTF \u4fe1\u606f\uff0cSIG \u793e\u533a\u7684 Coolbpf \u9879\u76ee[9]\u672c\u8eab\u80fd\u63d0\u4f9b BTF \u7684\u81ea\u52a8\u751f\u6210\u3001\u4f4e\u7248\u672c\u5185\u6838\u7684\u9002\u914d\u529f\u80fd\uff0c\u672a\u6765\u4f4e\u7248\u672c\u5185\u6838\u7684\u652f\u6301\u4f1a\u57fa\u4e8e Coolbpf \u7684\u73b0\u6709\u7684\u90e8\u5206\u5b8c\u6210\u3002\u540c\u65f6\uff0c\u6211\u4eec\u4e5f\u4f1a\u7ed9 Coolbpf \u7684 API \u5b9e\u73b0\u3001\u8fdc\u7a0b\u7f16\u8bd1\u540e\u7aef\u63d0\u4f9b\u7c7b\u4f3c\u4e8e eunomia-bpf \u7684\u5185\u6838\u6001\u7f16\u8bd1\u548c\u8fd0\u884c\u5b8c\u5168\u5206\u79bb\u7684\u529f\u80fd\uff0c\u8ba9\u4f7f\u7528 Coolbpf API \u5f00\u53d1 eBPF \u7684\u7a0b\u5e8f\uff0c\u5728\u8fdc\u7a0b\u7f16\u8bd1\u4e00\u6b21\u8fc7\u540e\u53ef\u4ee5\u5728\u4efb\u610f\u5185\u6838\u7248\u672c\u548c\u67b6\u6784\u4e0a\u76f4\u63a5\u4f7f\u7528\uff0c\u5728\u90e8\u7f72\u65f6\u65e0\u9700\u518d\u6b21\u8fde\u63a5\u8fdc\u7a0b\u670d\u52a1\u5668\uff1b\u4e5f\u53ef\u4ee5\u5c06\u7f16\u8bd1\u5b8c\u6210\u7684 eBPF \u7a0b\u5e8f\u4f5c\u4e3a Go\u3001Python\u3001Rust \u7b49\u8bed\u8a00\u7684\u5f00\u53d1\u5305\u76f4\u63a5\u4f7f\u7528\uff0c\u8ba9\u5f00\u53d1\u8005\u80fd\u8f7b\u677e\u83b7\u5f97 eBPF \u7a0b\u5e8f\u4e0a\u62a5\u7684\u4fe1\u606f\uff0c\u800c\u5b8c\u5168\u4e0d\u9700\u8981\u518d\u6b21\u8fdb\u884c\u4efb\u4f55 eBPF \u7a0b\u5e8f\u7684\u7f16\u8bd1\u8fc7\u7a0b\u3002</p> <p>SIG \u793e\u533a\u5b75\u5316\u4e8e\u9ad8\u6821\u7684 Linux Microscope (LMP) \u9879\u76ee[10]\u4e2d\uff0c\u4e5f\u5df2\u7ecf\u6709\u4e00\u4e9b\u57fa\u4e8e eunomia-bpf \u63d0\u4f9b\u901a\u7528\u7684\u3001\u89c4\u8303\u5316\u3001\u53ef\u4ee5\u968f\u65f6\u4e0b\u8f7d\u8fd0\u884c\u7684 eBPF \u7a0b\u5e8f\u6216\u5de5\u5177\u5e93\u7684\u8ba1\u5212\uff0c\u76ee\u524d\u8fd8\u5728\u7ee7\u7eed\u5b8c\u5584\u7684\u9636\u6bb5\u3002</p>"},{"location":"blogs/ebpf-wasm.zh/#_5","title":"\u53c2\u8003\u8d44\u6599","text":"<ol> <li>eBPF \u548c WebAssembly\uff1a\u54ea\u79cd VM \u4f1a\u5236\u9738\u4e91\u539f\u751f\u65f6\u4ee3? https://juejin.cn/post/7043721713602789407</li> <li>eBPF \u548c Wasm\uff1a\u63a2\u7d22\u670d\u52a1\u7f51\u683c\u6570\u636e\u5e73\u9762\u7684\u672a\u6765: https://cloudnative.to/blog/ebpf-wasm-service-mesh/</li> <li>eBPF \u6280\u672f\u63a2\u7d22 SIG \u4e3b\u9875\uff1a https://openanolis.cn/sig/ebpfresearch</li> <li>eunomia-bpf Github \u4ed3\u5e93\uff1ahttps://github.com/eunomia-bpf/eunomia-bpf</li> <li>eunomia-bpf \u9f99\u8725\u793e\u533a\u955c\u50cf\u4ed3\u5e93\uff1ahttps://gitee.com/anolis/eunomia</li> <li>sigsnoop \u793a\u4f8b\u4ee3\u7801\uff1ahttps://gitee.com/anolis/eunomia/tree/master/examples/bpftools/sigsnoop</li> <li>eunomia-bpf \u7528\u6237\u624b\u518c\uff1ahttps://openanolis.cn/sig/ebpfresearch/doc/646023027267993641</li> <li>\u66f4\u591a\u793a\u4f8b\u4ee3\u7801\uff1ahttps://gitee.com/anolis/eunomia/tree/master/examples/bpftools/sigsnoop</li> <li>Coolbpf \u9879\u76ee\u4ecb\u7ecd\uff1ahttps://openanolis.cn/sig/ebpfresearch/doc/633529753894377555</li> <li>LMP \u9879\u76ee\u4ecb\u7ecd\uff1ahttps://openanolis.cn/sig/ebpfresearch/doc/633661297090877527</li> </ol>"},{"location":"blogs/eunomia-bpf%E7%9A%84%E4%B8%89%E6%9C%88%E8%BF%9B%E5%B1%95.zh/","title":"eunomia-bpf \u7684 3 \u6708\u8fdb\u5c55","text":"<p>eunomia-bpf \u9879\u76ee\u662f\u4e00\u4e2a\u5f00\u6e90\u9879\u76ee\uff0c\u65e8\u5728\u63d0\u4f9b\u4e00\u7ec4\u5de5\u5177\uff0c\u7528\u4e8e\u5728 Linux \u5185\u6838\u4e2d\u66f4\u65b9\u4fbf\u5730\u7f16\u5199\u548c\u8fd0\u884c eBPF \u7a0b\u5e8f\u3002\u5728\u8fc7\u53bb\u4e00\u4e2a\u6708\u4e2d\uff0c\u8be5\u9879\u76ee\u53d6\u5f97\u4e86\u4e00\u4e9b\u65b0\u7684\u8fdb\u5c55\uff0c\u4ee5\u4e0b\u662f\u8fd9\u4e9b\u8fdb\u5c55\u7684\u6982\u8ff0\u3002</p> <p>\u9996\u5148\uff0ceunomia-bpf \u52a8\u6001\u52a0\u8f7d\u5e93\u8fdb\u884c\u4e86\u4e00\u4e9b\u91cd\u8981\u7684\u66f4\u65b0\u3002\u8be5\u5e93\u73b0\u5728\u652f\u6301 btf hub\uff0c\u8fd9\u4f7f\u5f97\u5728\u4f4e\u5185\u6838\u7248\u672c\u4e0a\u79fb\u690d eBPF \u7a0b\u5e8f\u66f4\u52a0\u5bb9\u6613\u3002ecli \u7a0b\u5e8f\u4e5f\u8fdb\u884c\u4e86\u5b8c\u5168\u7684\u91cd\u5199\uff0c\u73b0\u5728\u662f\u4f7f\u7528 Rust \u7f16\u5199\u7684\uff0c\u5df2\u7ecf\u53d6\u4ee3\u4e86\u539f\u672c\u4f7f\u7528 C++ \u7f16\u5199\u7684\u7248\u672c\u3002\u6b64\u5916\uff0c\u8be5\u5e93\u8fd8\u4fee\u590d\u4e86\u4f7f\u7528 JSON \u52a8\u6001\u52a0\u8f7d eBPF \u7a0b\u5e8f\u7684\u8f93\u51fa\u95ee\u9898\uff0c\u5e76\u5728 CI \u4e2d\u81ea\u52a8\u53d1\u5e03 Docker \u955c\u50cf\u3002</p> <p>\u5176\u6b21\uff0cWasm-bpf \u9879\u76ee\u4e5f\u8fdb\u884c\u4e86\u4e00\u4e9b\u66f4\u65b0\u3002\u8be5\u9879\u76ee\u6dfb\u52a0\u4e86\u4e00\u7cfb\u5217\u7684 examples\uff0c\u8fd9\u4e9b examples \u5173\u6ce8\u4e8e\u5b89\u5168\u3001\u7f51\u7edc\u3001\u8ffd\u8e2a\u7b49\u591a\u4e2a\u65b9\u5411\u3002Wasm-bpf \u9879\u76ee\u8fd8\u6dfb\u52a0\u4e86 Rust \u8bed\u8a00\u7684 Guest SDK \u652f\u6301\uff0c\u5e76\u5c1d\u8bd5\u6dfb\u52a0\u4e86 Go \u8bed\u8a00\u7684 Guest SDK \u652f\u6301\u3002Rust \u548c wasmtime \u7684\u8fd0\u884c\u65f6\u5b9e\u73b0\u4e5f\u5df2\u7ecf\u52a0\u5165\u4e86\u8be5\u9879\u76ee\uff0c\u5e76\u4e3a WasmEdge \u6dfb\u52a0\u4e86\u8fd0\u884c\u65f6\u63d2\u4ef6\u3002\u6b64\u5916\uff0c\u8be5\u9879\u76ee\u8fdb\u884c\u4e86\u4e00\u7cfb\u5217\u7684\u4fee\u590d\u548c\u6587\u6863\u91cd\u6784\uff0c\u5e76\u5b8c\u5584\u4e86 CI \u548c\u6d4b\u8bd5\u7b49\u5185\u5bb9\u3002\u8be5\u9879\u76ee\u8fd8\u5c1d\u8bd5\u4f7f\u7528 Wasm \u7ec4\u4ef6\u6a21\u578b\uff0c\u5e76\u6dfb\u52a0\u4e86\u4e00\u4e2a\u5de5\u5177\uff0c\u7528\u4e8e\u6dfb\u52a0\u5728 wasm \u6a21\u5757\u4e2d\u5b9a\u4e49\u7684\u8868\u5bfc\u51fa\u3002\u6700\u540e\uff0c\u8be5\u9879\u76ee\u8fd8\u4ea7\u751f\u4e86\u4e09\u7bc7\u535a\u5ba2\u548c\u6f14\u793a\u89c6\u9891\u7b49\u76f8\u5173\u5185\u5bb9\u3002</p> <p>\u6700\u540e\uff0ceunomia-bpf \u8fd8\u65b0\u589e\u4e86\u4e00\u4e2a\u540d\u4e3a GPTtrace \u7684 demo \u9879\u76ee\u3002\u8be5\u9879\u76ee\u4f7f\u7528 ChatGPT \u81ea\u52a8\u5316\u751f\u6210 eBPF \u7a0b\u5e8f\u548c\u8ffd\u8e2a\uff0c\u6709\u52a9\u4e8e\u7528\u6237\u66f4\u8f7b\u677e\u5730\u521b\u5efa\u548c\u8ffd\u8e2a\u81ea\u5b9a\u4e49\u7684\u7cfb\u7edf\u4e8b\u4ef6\u3002\u8be5\u9879\u76ee\u8fd8\u66f4\u65b0\u4e86\u6559\u7a0b\u6587\u6863\uff0c\u4f7f\u5176\u66f4\u6613\u4e8e\u4f7f\u7528\u3002</p> <p>\u603b\u4f53\u6765\u770b\uff0ceunomia-bpf \u9879\u76ee\u5728 3 \u6708\u4efd\u53d6\u5f97\u4e86\u4e00\u4e9b\u91cd\u8981\u7684\u8fdb\u5c55\u3002\u8fd9\u4e9b\u66f4\u65b0\u548c\u6539\u8fdb\u6709\u52a9\u4e8e\u4f7f\u8be5\u9879\u76ee\u66f4\u52a0\u6613\u4e8e\u4f7f\u7528\u548c\u7075\u6d3b\uff0c\u6269\u5c55\u4e86\u5176\u529f\u80fd\u548c\u9002\u7528\u8303\u56f4\u3002\u5982\u679c\u4f60\u5bf9\u8be5\u9879\u76ee\u611f\u5174\u8da3\uff0c\u53ef\u4ee5\u5173\u6ce8\u5b83\u7684\u6700\u65b0\u52a8\u6001\u548c\u66f4\u65b0\u3002</p> <p>\u4ee5\u4e0b\u662f\u66f4\u8be6\u7ec6\u7684\u66f4\u65b0\u5217\u8868\uff1a</p> <ul> <li>eunomia-bpf \u52a8\u6001\u52a0\u8f7d\u5e93<ul> <li>\u6dfb\u52a0\u5bf9 btf hub \u7684\u652f\u6301\uff0c\u5141\u8bb8\u66f4\u597d\u5730\u5728\u4f4e\u5185\u6838\u7248\u672c\u4e0a\u79fb\u690d eBPF \u7a0b\u5e8f\u00a0link</li> <li>\u4f7f\u7528 Rust \u7f16\u5199\u7684 ecli \u5b8c\u5168\u66ff\u6362\u4e86\u539f\u5148\u4f7f\u7528 C++ \u7f16\u5199\u7684\u7248\u672c\u00a0link</li> <li>\u4fee\u590d\u4e86\u4f7f\u7528 JSON \u52a8\u6001\u52a0\u8f7d eBPF \u7a0b\u5e8f\u7684\u8f93\u51fa\u95ee\u9898\u00a0link link</li> <li>\u5728 CI \u4e2d\u81ea\u52a8\u53d1\u5e03 Docker \u955c\u50cf\u00a0link link</li> <li>\u5c1d\u8bd5\u5728\u5176\u4ed6\u5e73\u53f0\u4e0a\u6dfb\u52a0\u652f\u6301\uff0c\u4ee5\u53ca\u5728 RISC-V \u4e0a\u8fdb\u884c\u66f4\u591a\u7684\u6d4b\u8bd5\u00a0link</li> </ul> </li> <li>Wasm-bpf<ul> <li>\u6dfb\u52a0\u4e86\u4e00\u7cfb\u5217 examples\uff0c\u5173\u6ce8\u4e8e\u5b89\u5168\u3001\u7f51\u7edc\u3001\u8ffd\u8e2a\u7b49\u591a\u4e2a\u65b9\u5411\u00a0link link link</li> <li>\u6dfb\u52a0\u4e86 Rust \u8bed\u8a00\u7684 Guest SDK \u652f\u6301\u00a0link</li> <li>\u5c1d\u8bd5\u6dfb\u52a0\u4e86 Go \u8bed\u8a00\u7684 Guest SDK \u652f\u6301\u00a0link</li> <li>\u6dfb\u52a0\u4e86 Rust \u548c wasmtime \u7684\u8fd0\u884c\u65f6\u5b9e\u73b0\u00a0link</li> <li>\u4e3a WasmEdge \u6dfb\u52a0\u4e86\u8fd0\u884c\u65f6\u63d2\u4ef6\u00a0link</li> <li>\u4e00\u7cfb\u5217\u5c0f\u4fee\u590d\u548c\u6587\u6863\u91cd\u6784\u00a0link link link link link</li> <li>CI \u548c\u6d4b\u8bd5\u7b49\u7684\u5b8c\u5584\u00a0link link</li> <li>Wasm component model \u7684\u5c1d\u8bd5\u00a0link</li> <li>A tool to add an export of the table defined in the wasm module\u00a0link</li> <li>\u4e09\u7bc7 blog \u548c\u6f14\u793a\u89c6\u9891\u7b49\u4ea7\u51fa</li> </ul> </li> <li>\u65b0 demo \u9879\u76ee: GPTtrace: Generate eBPF programs and tracing with ChatGPT and natural language\u00a0link<ul> <li>\u6559\u7a0b\u6587\u6863\u7684\u5b8c\u5584\uff1alink</li> </ul> </li> </ul>"},{"location":"blogs/how-to-write-c-in-wasm.zh/","title":"\u5728 WebAssembly \u4e2d\u4f7f\u7528 C/C++ \u548c libbpf \u7f16\u5199 eBPF \u7a0b\u5e8f","text":"<p>\u4f5c\u8005\uff1a\u4e8e\u6850\uff0c\u90d1\u6631\u7b19</p> <p>eBPF\uff08extended Berkeley Packet Filter\uff09\u662f\u4e00\u79cd\u9ad8\u6027\u80fd\u7684\u5185\u6838\u865a\u62df\u673a\uff0c\u53ef\u4ee5\u8fd0\u884c\u5728\u5185\u6838\u7a7a\u95f4\u4e2d\uff0c\u7528\u6765\u6536\u96c6\u7cfb\u7edf\u548c\u7f51\u7edc\u4fe1\u606f\u3002\u968f\u7740\u8ba1\u7b97\u673a\u6280\u672f\u7684\u4e0d\u65ad\u53d1\u5c55\uff0ceBPF \u7684\u529f\u80fd\u65e5\u76ca\u5f3a\u5927\uff0c\u8fdb\u800c\u88ab\u7528\u6765\u6784\u5efa\u5404\u79cd\u6548\u7387\u9ad8\u6548\u7684\u5728\u7ebf\u8bca\u65ad\u548c\u8ddf\u8e2a\u7cfb\u7edf\uff0c\u4ee5\u53ca\u5b89\u5168\u7684\u7f51\u7edc\u548c\u670d\u52a1\u7f51\u683c\u3002</p> <p>WebAssembly\uff08Wasm\uff09\u6700\u521d\u662f\u4ee5\u6d4f\u89c8\u5668\u5b89\u5168\u6c99\u76d2\u4e3a\u76ee\u7684\u5f00\u53d1\u7684\uff0c\u53d1\u5c55\u5230\u76ee\u524d\u4e3a\u6b62\uff0cWebAssembly \u5df2\u7ecf\u6210\u4e3a\u4e00\u4e2a\u7528\u4e8e\u4e91\u539f\u751f\u8f6f\u4ef6\u7ec4\u4ef6\u7684\u9ad8\u6027\u80fd\u3001\u8de8\u5e73\u53f0\u548c\u591a\u8bed\u8a00\u8f6f\u4ef6\u6c99\u7bb1\u73af\u5883\uff0cWasm \u8f7b\u91cf\u7ea7\u5bb9\u5668\u4e5f\u975e\u5e38\u9002\u5408\u4f5c\u4e3a\u4e0b\u4e00\u4ee3\u65e0\u670d\u52a1\u5668\u5e73\u53f0\u8fd0\u884c\u65f6\uff0c\u6216\u5728\u8fb9\u7f18\u8ba1\u7b97\u7b49\u8d44\u6e90\u53d7\u9650\u7684\u573a\u666f\u9ad8\u6548\u6267\u884c\u3002</p> <p>\u73b0\u5728\uff0c\u501f\u52a9 Wasm-bpf \u7f16\u8bd1\u5de5\u5177\u94fe\u548c\u8fd0\u884c\u65f6\uff0c\u6211\u4eec\u53ef\u4ee5\u4f7f\u7528 Wasm \u5c06 eBPF \u7a0b\u5e8f\u7f16\u5199\u4e3a\u8de8\u5e73\u53f0\u7684\u6a21\u5757\uff0c\u540c\u65f6\u4f7f\u7528 C/C++ \u6216 Rust \u6765\u7f16\u5199 Wasm \u7a0b\u5e8f\u3002\u901a\u8fc7\u5728 WebAssembly \u4e2d\u4f7f\u7528 eBPF \u7a0b\u5e8f\uff0c\u6211\u4eec\u4e0d\u4ec5\u80fd\u8ba9 Wasm \u5e94\u7528\u4eab\u53d7\u5230 eBPF \u7684\u9ad8\u6027\u80fd\u548c\u5bf9\u7cfb\u7edf\u63a5\u53e3\u7684\u8bbf\u95ee\u80fd\u529b\uff0c\u8fd8\u53ef\u4ee5\u8ba9 eBPF \u7a0b\u5e8f\u4f7f\u7528\u5230 Wasm \u7684\u6c99\u7bb1\u3001\u7075\u6d3b\u6027\u3001\u8de8\u5e73\u53f0\u6027\u3001\u548c\u52a8\u6001\u52a0\u8f7d\uff0c\u5e76\u4e14\u4f7f\u7528 Wasm \u7684 OCI \u955c\u50cf\u6765\u65b9\u4fbf\u3001\u5feb\u6377\u5730\u5206\u53d1\u548c\u7ba1\u7406 eBPF \u7a0b\u5e8f\u3002\u7ed3\u5408\u8fd9\u4e24\u79cd\u6280\u672f\uff0c\u6211\u4eec\u5c06\u4f1a\u7ed9 eBPF \u548c Wasm \u751f\u6001\u6765\u4e00\u4e2a\u5168\u65b0\u7684\u5f00\u53d1\u4f53\u9a8c\uff01</p>"},{"location":"blogs/how-to-write-c-in-wasm.zh/#wasm-bpf-wasm-ebpf","title":"\u4f7f\u7528 Wasm-bpf \u5de5\u5177\u94fe\u5728 Wasm \u4e2d\u7f16\u5199\u3001\u52a8\u6001\u52a0\u8f7d\u3001\u5206\u53d1\u8fd0\u884c eBPF \u7a0b\u5e8f","text":"<p>Wasm-bpf \u662f\u4e00\u4e2a\u5168\u65b0\u7684\u5f00\u6e90\u9879\u76ee\uff1ahttps://github.com/eunomia-bpf/wasm-bpf\u3002\u5b83\u5b9a\u4e49\u4e86\u4e00\u5957 eBPF \u76f8\u5173\u7cfb\u7edf\u63a5\u53e3\u7684\u62bd\u8c61\uff0c\u5e76\u63d0\u4f9b\u4e86\u4e00\u5957\u5bf9\u5e94\u7684\u5f00\u53d1\u5de5\u5177\u94fe\u3001\u5e93\u4ee5\u53ca\u901a\u7528\u7684 Wasm + eBPF \u8fd0\u884c\u65f6\u5b9e\u4f8b\u3002\u5b83\u53ef\u4ee5\u63d0\u4f9b\u548c libbpf-bootstrap \u76f8\u4f3c\u7684\u5f00\u53d1\u4f53\u9a8c\uff0c\u81ea\u52a8\u751f\u6210\u5bf9\u5e94\u7684 skeleton \u5934\u6587\u4ef6\uff0c\u4ee5\u53ca\u7528\u4e8e\u5728 Wasm \u548c eBPF \u4e4b\u95f4\u65e0\u5e8f\u5217\u5316\u901a\u4fe1\u7684\u6570\u636e\u7ed3\u6784\u5b9a\u4e49\u3002\u4f60\u53ef\u4ee5\u975e\u5e38\u5bb9\u6613\u5730\u4f7f\u7528\u4efb\u4f55\u8bed\u8a00\uff0c\u5728\u4efb\u4f55\u5e73\u53f0\u4e0a\u5efa\u7acb\u4f60\u81ea\u5df1\u7684 Wasm-eBPF \u8fd0\u884c\u65f6\uff0c\u4f7f\u7528\u76f8\u540c\u7684\u5de5\u5177\u94fe\u6765\u6784\u5efa\u5e94\u7528\u3002\u66f4\u8be6\u7ec6\u7684\u4ecb\u7ecd\uff0c\u8bf7\u53c2\u8003\u6211\u4eec\u7684\u4e0a\u4e00\u7bc7\u535a\u5ba2\uff1aWasm-bpf: \u67b6\u8d77 Webassembly \u548c eBPF \u5185\u6838\u53ef\u7f16\u7a0b\u7684\u6865\u6881\u3002</p> <p>\u57fa\u4e8e Wasm\uff0c\u6211\u4eec\u53ef\u4ee5\u4f7f\u7528\u591a\u79cd\u8bed\u8a00\u6784\u5efa eBPF \u5e94\u7528\uff0c\u5e76\u4ee5\u7edf\u4e00\u3001\u8f7b\u91cf\u7ea7\u7684\u65b9\u5f0f\u7ba1\u7406\u548c\u53d1\u5e03\u3002\u4ee5\u6211\u4eec\u6784\u5efa\u7684\u793a\u4f8b\u5e94\u7528 bootstrap.wasm \u4e3a\u4f8b\uff0c\u5927\u5c0f\u4ec5\u4e3a ~90K\uff0c\u5f88\u5bb9\u6613\u901a\u8fc7\u7f51\u7edc\u5206\u53d1\uff0c\u5e76\u53ef\u4ee5\u5728\u4e0d\u5230 100ms \u7684\u65f6\u95f4\u5185\u5728\u53e6\u4e00\u53f0\u673a\u5668\u4e0a\u52a8\u6001\u90e8\u7f72\u3001\u52a0\u8f7d\u548c\u8fd0\u884c\uff0c\u5e76\u4e14\u4fdd\u7559\u8f7b\u91cf\u7ea7\u5bb9\u5668\u7684\u9694\u79bb\u7279\u6027\u3002\u8fd0\u884c\u65f6\u4e0d\u9700\u8981\u5185\u6838\u5934\u6587\u4ef6\u3001LLVM\u3001clang \u7b49\u4f9d\u8d56\uff0c\u4e5f\u4e0d\u9700\u8981\u505a\u4efb\u4f55\u6d88\u8017\u8d44\u6e90\u7684\u91cd\u91cf\u7ea7\u7684\u7f16\u8bd1\u5de5\u4f5c\u3002</p> <p>\u672c\u6587\u5c06\u4ee5 C/C++ \u8bed\u8a00\u4e3a\u4f8b\uff0c\u8ba8\u8bba C/C++ \u7f16\u5199 eBPF \u7a0b\u5e8f\u5e76\u7f16\u8bd1\u4e3a Wasm \u6a21\u5757\u3002\u4f7f\u7528 Rust \u8bed\u8a00\u7f16\u5199 eBPF \u7a0b\u5e8f\u5e76\u7f16\u8bd1\u4e3a Wasm \u6a21\u5757\u7684\u5177\u4f53\u793a\u4f8b\uff0c\u5c06\u5728\u4e0b\u4e00\u7bc7\u6587\u7ae0\u4e2d\u63cf\u8ff0\u3002</p> <p>\u6211\u4eec\u5728\u4ed3\u5e93\u4e2d\u63d0\u4f9b\u4e86\u51e0\u4e2a\u793a\u4f8b\u7a0b\u5e8f\uff0c\u5206\u522b\u5bf9\u5e94\u4e8e\u53ef\u89c2\u6d4b\u3001\u7f51\u7edc\u3001\u5b89\u5168\u7b49\u591a\u79cd\u573a\u666f\u3002</p>"},{"location":"blogs/how-to-write-c-in-wasm.zh/#cc-ebpf-wasm","title":"\u4f7f\u7528 C/C++ \u7f16\u5199 eBPF \u7a0b\u5e8f\u5e76\u7f16\u8bd1\u4e3a Wasm","text":"<p>libbpf \u662f\u4e00\u4e2a C/C++ \u7684 eBPF \u7528\u6237\u6001\u52a0\u8f7d\u548c\u63a7\u5236\u5e93\uff0c\u968f\u7740\u5185\u6838\u4e00\u8d77\u5206\u53d1\uff0c\u51e0\u4e4e\u5df2\u7ecf\u6210\u4e3a eBPF \u7528\u6237\u6001\u4e8b\u5b9e\u4e0a\u7684 API \u6807\u51c6\uff0clibbpf \u4e5f\u652f\u6301 CO-RE(Compile Once \u2013 Run Everywhere) \u7684\u89e3\u51b3\u65b9\u6848\uff0c\u5373\u9884\u7f16\u8bd1\u7684 bpf \u4ee3\u7801\u53ef\u4ee5\u5728\u4e0d\u540c\u5185\u6838\u7248\u672c\u4e0a\u6b63\u5e38\u5de5\u4f5c\uff0c\u800c\u65e0\u9700\u4e3a\u6bcf\u4e2a\u7279\u5b9a\u5185\u6838\u91cd\u65b0\u7f16\u8bd1\u3002\u6211\u4eec\u5e0c\u671b\u5c3d\u53ef\u80fd\u7684\u4fdd\u6301\u4e0e libbpf \u7684\u7528\u6237\u6001 API \u4ee5\u53ca\u884c\u4e3a\u4e00\u81f4\uff0c\u5c3d\u53ef\u80fd\u51cf\u5c11\u5e94\u7528\u8fc1\u79fb\u5230 Wasm \uff08\u5982\u679c\u9700\u8981\u7684\u8bdd\uff09\u7684\u6210\u672c\u3002</p> <p>libbpf-bootstrap \u4e3a\u751f\u6210\u57fa\u4e8e libbpf \u7684 bpf \u7a0b\u5e8f\u63d0\u4f9b\u4e86\u6a21\u677f,\u5f00\u53d1\u8005\u53ef\u4ee5\u5f88\u65b9\u4fbf\u7684\u4f7f\u7528\u8be5\u6a21\u677f\u751f\u6210\u81ea\u5b9a\u4e49\u7684 bpf \u7a0b\u5e8f\u3002\u4e00\u822c\u8bf4\u6765\uff0c\u5728\u975e Wasm \u6c99\u7bb1\u7684\u7528\u6237\u6001\u7a7a\u95f4\uff0c\u4f7f\u7528 libbpf-bootstrap \u811a\u624b\u67b6\uff0c\u53ef\u4ee5\u5feb\u901f\u3001\u8f7b\u677e\u5730\u4f7f\u7528 C/C++\u6784\u5efa BPF \u5e94\u7528\u7a0b\u5e8f\u3002</p> <p>\u7f16\u8bd1\u3001\u6784\u5efa\u548c\u8fd0\u884c eBPF \u7a0b\u5e8f\uff08\u65e0\u8bba\u662f\u91c7\u7528\u4ec0\u4e48\u8bed\u8a00\uff09\uff0c\u901a\u5e38\u5305\u542b\u4ee5\u4e0b\u51e0\u4e2a\u6b65\u9aa4\uff1a</p> <ul> <li>\u7f16\u5199\u5185\u6838\u6001 eBPF \u7a0b\u5e8f\u7684\u4ee3\u7801\uff0c\u4e00\u822c\u4f7f\u7528 C/C++ \u6216 Rust \u8bed\u8a00</li> <li>\u4f7f\u7528 clang \u7f16\u8bd1\u5668\u6216\u8005\u76f8\u5173\u5de5\u5177\u94fe\u7f16\u8bd1 eBPF \u7a0b\u5e8f\uff08\u8981\u5b9e\u73b0\u8de8\u5185\u6838\u7248\u672c\u79fb\u690d\u7684\u8bdd\uff0c\u9700\u8981\u5305\u542b BTF \u4fe1\u606f\uff09\u3002</li> <li>\u5728\u7528\u6237\u6001\u7684\u5f00\u53d1\u7a0b\u5e8f\u4e2d\uff0c\u7f16\u5199\u5bf9\u5e94\u7684\u52a0\u8f7d\u3001\u63a7\u5236\u3001\u6302\u8f7d\u3001\u6570\u636e\u5904\u7406\u903b\u8f91\uff1b</li> <li>\u5728\u5b9e\u9645\u8fd0\u884c\u7684\u9636\u6bb5\uff0c\u4ece\u7528\u6237\u6001\u5c06 eBPF \u7a0b\u5e8f\u52a0\u8f7d\u8fdb\u5165\u5185\u6838\uff0c\u5e76\u5b9e\u9645\u6267\u884c\u3002</li> </ul>"},{"location":"blogs/how-to-write-c-in-wasm.zh/#bootstrap","title":"bootstrap","text":"<p><code>bootstrap</code>\u662f\u4e00\u4e2a\u7b80\u5355\uff08\u4f46\u5b9e\u7528\uff09\u7684BPF\u5e94\u7528\u7a0b\u5e8f\u7684\u4f8b\u5b50\u3002\u5b83\u8ddf\u8e2a\u8fdb\u7a0b\u7684\u542f\u52a8\uff08\u51c6\u786e\u5730\u8bf4\uff0c\u662f <code>exec()</code> \u7cfb\u5217\u7684\u7cfb\u7edf\u8c03\u7528\uff09\u548c\u9000\u51fa\uff0c\u5e76\u53d1\u9001\u5173\u4e8e\u6587\u4ef6\u540d\u3001PID \u548c \u7236 PID \u7684\u6570\u636e\uff0c\u4ee5\u53ca\u9000\u51fa\u72b6\u6001\u548c\u8fdb\u7a0b\u7684\u6301\u7eed\u65f6\u95f4\u3002\u7528<code>-d &lt;min-duration-ms&gt;</code> \u4f60\u53ef\u4ee5\u6307\u5b9a\u8981\u8bb0\u5f55\u7684\u8fdb\u7a0b\u7684\u6700\u5c0f\u6301\u7eed\u65f6\u95f4\u3002</p> <p><code>bootstrap</code> \u662f\u5728 libbpf-bootstrap \u4e2d\uff0c\u6839\u636e BCC \u8f6f\u4ef6\u5305\u4e2d\u7684libbpf-tools\u7684\u7c7b\u4f3c\u601d\u60f3\u521b\u5efa\u7684\uff0c\u4f46\u5b83\u88ab\u8bbe\u8ba1\u6210\u66f4\u72ec\u7acb\u7684\uff0c\u5e76\u4e14\u6709\u66f4\u7b80\u5355\u7684 Makefile \u4ee5\u7b80\u5316\u7528\u6237\u7684\u7279\u6b8a\u9700\u6c42\u3002\u5b83\u6f14\u793a\u4e86\u5178\u578b\u7684BPF\u7279\u6027\uff0c\u5305\u542b\u4f7f\u7528\u591a\u4e2a BPF \u7a0b\u5e8f\u6bb5\u8fdb\u884c\u5408\u4f5c\uff0c\u4f7f\u7528 BPF map \u6765\u7ef4\u62a4\u72b6\u6001\uff0c\u4f7f\u7528 BPF ring buffer \u6765\u53d1\u9001\u6570\u636e\u5230\u7528\u6237\u7a7a\u95f4\uff0c\u4ee5\u53ca\u4f7f\u7528\u5168\u5c40\u53d8\u91cf\u6765\u53c2\u6570\u5316\u5e94\u7528\u7a0b\u5e8f\u884c\u4e3a\u3002</p> <p>\u4ee5\u4e0b\u662f\u6211\u4eec\u4f7f\u7528 Wasm \u7f16\u8bd1\u8fd0\u884c <code>bootstrap</code> \u7684\u4e00\u4e2a\u8f93\u51fa\u793a\u4f8b\uff1a</p> <pre><code>$ sudo sudo ./wasm-bpf bootstrap.wasm -h\nBPF bootstrap demo application.\nIt traces process start and exits and shows associated\ninformation (filename, process duration, PID and PPID, etc).\nUSAGE: ./bootstrap [-d &lt;min-duration-ms&gt;] -v\n$ sudo ./wasm-bpf bootstrap.wasm\nTIME     EVENT COMM             PID     PPID    FILENAME/EXIT CODE\n18:57:58 EXEC  sed              74911   74910   /usr/bin/sed\n18:57:58 EXIT  sed              74911   74910   [0] (2ms)\n18:57:58 EXIT  cat              74912   74910   [0] (0ms)\n18:57:58 EXEC  cat              74913   74910   /usr/bin/cat\n18:57:59 EXIT  cat              74913   74910   [0] (0ms)\n18:57:59 EXEC  cat              74914   74910   /usr/bin/cat\n18:57:59 EXIT  cat              74914   74910   [0] (0ms)\n18:57:59 EXEC  cat              74915   74910   /usr/bin/cat\n18:57:59 EXIT  cat              74915   74910   [0] (1ms)\n18:57:59 EXEC  sleep            74916   74910   /usr/bin/sleep\n</code></pre> <p>\u6211\u4eec\u53ef\u4ee5\u63d0\u4f9b\u4e0e libbpf-bootstrap \u5f00\u53d1\u76f8\u4f3c\u7684\u5f00\u53d1\u4f53\u9a8c\u3002\u53ea\u9700\u8fd0\u884c make \u5373\u53ef\u6784\u5efa wasm \u4e8c\u8fdb\u5236\u6587\u4ef6\uff1a</p> <pre><code>git clone https://github.com/eunomia-bpf/wasm-bpf --recursive\ncd examples/bootstrap\nmake\n</code></pre>"},{"location":"blogs/how-to-write-c-in-wasm.zh/#ebpf","title":"\u7f16\u5199\u5185\u6838\u6001\u7684 eBPF \u7a0b\u5e8f","text":"<p>\u8981\u6784\u5efa\u4e00\u4e2a\u5b8c\u6574\u7684 eBPF \u7a0b\u5e8f\uff0c\u9996\u5148\u8981\u7f16\u5199\u5185\u6838\u6001\u7684 bpf \u4ee3\u7801\u3002\u901a\u5e38\u4f7f\u7528 C \u8bed\u8a00\u7f16\u5199\uff0c\u5e76\u4f7f\u7528 clang \u5b8c\u6210\u7f16\u8bd1\uff1a</p> <pre><code>char LICENSE[] SEC(\"license\") = \"Dual BSD/GPL\";\nstruct {\n__uint(type, BPF_MAP_TYPE_HASH);\n__uint(max_entries, 8192);\n__type(key, pid_t);\n__type(value, u64);\n} exec_start SEC(\".maps\");\nstruct {\n__uint(type, BPF_MAP_TYPE_RINGBUF);\n__uint(max_entries, 256 * 1024);\n} rb SEC(\".maps\");\nconst volatile unsigned long long min_duration_ns = 0;\nconst volatile int *name_ptr;\nSEC(\"tp/sched/sched_process_exec\")\nint handle_exec(struct trace_event_raw_sched_process_exec *ctx)\n{\nstruct task_struct *task;\nunsigned fname_off;\nstruct event *e;\npid_t pid;\nu64 ts;\n....\n</code></pre> <p>\u53d7\u7bc7\u5e45\u6240\u9650\uff0c\u8fd9\u91cc\u6ca1\u6709\u8d34\u51fa\u5b8c\u6574\u7684\u4ee3\u7801\u3002\u5185\u6838\u6001\u4ee3\u7801\u7684\u7f16\u5199\u65b9\u5f0f\u548c\u5176\u4ed6\u57fa\u4e8e libbpf \u7684\u7a0b\u5e8f\u5b8c\u5168\u76f8\u540c\uff0c\u4e00\u822c\u6765\u8bf4\u4f1a\u5305\u542b\u4e00\u4e9b\u5168\u5c40\u53d8\u91cf\uff0c\u901a\u8fc7 <code>SEC</code> \u58f0\u660e\u6302\u8f7d\u70b9\u7684 eBPF \u51fd\u6570\uff0c\u4ee5\u53ca\u7528\u4e8e\u4fdd\u5b58\u72b6\u6001\uff0c\u6216\u8005\u5728\u7528\u6237\u6001\u548c\u5185\u6838\u6001\u4e4b\u95f4\u76f8\u4e92\u901a\u4fe1\u7684 map \u5bf9\u8c61\uff08\u6211\u4eec\u8fd8\u5728\u8fdb\u884c\u53e6\u5916\u4e00\u9879\u5de5\u4f5c\uff1abcc to libbpf converter\uff0c\u7b49\u5b83\u5b8c\u6210\u540e\u5c31\u53ef\u4ee5\u4ee5\u8fd9\u79cd\u65b9\u5f0f\u7f16\u8bd1 BCC \u98ce\u683c\u7684 eBPF \u5185\u6838\u6001\u7a0b\u5e8f\uff09\u3002\u5728\u7f16\u5199\u5b8c eBPF \u7a0b\u5e8f\u4e4b\u540e\uff0c\u8fd0\u884c <code>make</code> \u4f1a\u5728 <code>Makefile</code> \u8c03\u7528 clang \u548c llvm-strip \u6784\u5efaBPF\u7a0b\u5e8f\uff0c\u4ee5\u5265\u79bb\u8c03\u8bd5\u4fe1\u606f\uff1a</p> <pre><code>clang -g -O2 -target bpf -D__TARGET_ARCH_x86 -I../../third_party/vmlinux/x86/ -idirafter /usr/local/include -idirafter /usr/include -c bootstrap.bpf.c -o bootstrap.bpf.o\nllvm-strip -g bootstrap.bpf.o # strip useless DWARF info\n</code></pre> <p>\u4e4b\u540e\uff0c\u6211\u4eec\u4f1a\u63d0\u4f9b\u4e00\u4e2a\u4e3a\u4e86 Wasm \u4e13\u95e8\u5b9e\u73b0\u7684 bpftool\uff0c\u7528\u4e8e\u4ece BPF \u7a0b\u5e8f\u751f\u6210C\u5934\u6587\u4ef6\uff1a</p> <pre><code>../../third_party/bpftool/src/bpftool gen skeleton -j bootstrap.bpf.o &gt; bootstrap.skel.h\n</code></pre> <p>\u7531\u4e8e eBPF \u672c\u8eab\u7684\u6240\u6709 C \u5185\u5b58\u5e03\u5c40\u662f\u548c\u5f53\u524d\u6240\u5728\u673a\u5668\u7684\u6307\u4ee4\u96c6\u4e00\u6837\u7684\uff0c\u4f46\u662f wasm \u662f\u6709\u4e00\u5957\u786e\u5b9a\u7684\u5185\u5b58\u5e03\u5c40\uff08\u6bd4\u5982\u5f53\u524d\u6240\u5728\u673a\u5668\u662f 64 \u4f4d\u7684\uff0cWasm \u865a\u62df\u673a\u91cc\u9762\u662f 32 \u4f4d\u7684\uff0cC struct layout \u3001\u6307\u9488\u5bbd\u5ea6\u3001\u5927\u5c0f\u7aef\u7b49\u7b49\u90fd\u53ef\u80fd\u4e0d\u4e00\u6837\uff09\uff0c\u4e3a\u4e86\u786e\u4fdd eBPF \u7a0b\u5e8f\u80fd\u6b63\u786e\u548c Wasm \u4e4b\u95f4\u8fdb\u884c\u76f8\u4e92\u901a\u4fe1\uff0c\u6211\u4eec\u9700\u8981\u5b9a\u5236\u4e00\u4e2a\u4e13\u95e8\u7684 bpftool \u7b49\u5de5\u5177\uff0c\u5b9e\u73b0\u6b63\u786e\u751f\u6210\u53ef\u4ee5\u5728 Wasm \u4e2d\u5de5\u4f5c\u7684\u7528\u6237\u6001\u5f00\u53d1\u6846\u67b6\u3002</p> <p>skel \u5305\u542b\u4e00\u4e2a BPF \u7a0b\u5e8f\u7684skeleton\uff0c\u7528\u4e8e\u64cd\u4f5c BPF \u5bf9\u8c61\uff0c\u5e76\u63a7\u5236 BPF \u7a0b\u5e8f\u7684\u751f\u547d\u5468\u671f\uff0c\u4f8b\u5982\uff1a</p> <pre><code>    struct bootstrap_bpf {\nstruct bpf_object_skeleton *skeleton;\nstruct bpf_object *obj;\nstruct {\nstruct bpf_map *exec_start;\nstruct bpf_map *rb;\nstruct bpf_map *rodata;\n} maps;\nstruct {\nstruct bpf_program *handle_exec;\nstruct bpf_program *handle_exit;\n} progs;\nstruct bootstrap_bpf__rodata {\nunsigned long long min_duration_ns;\n} *rodata;\nstruct bootstrap_bpf__bss {\nuint64_t /* pointer */ name_ptr;\n} *bss;\n};\n</code></pre> <p>\u6211\u4eec\u4f1a\u5c06\u6240\u6709\u6307\u9488\u90fd\u5c06\u6839\u636e eBPF \u7a0b\u5e8f\u76ee\u6807\u6240\u5728\u7684\u6307\u4ee4\u96c6\u7684\u6307\u9488\u5927\u5c0f\u8f6c\u6362\u4e3a\u6574\u6570\uff0c\u4f8b\u5982\uff0c<code>name_ptr</code>\u3002\u6b64\u5916\uff0c\u586b\u5145\u5b57\u8282\u5c06\u660e\u786e\u6dfb\u52a0\u5230\u7ed3\u6784\u4f53\u4e2d\u4ee5\u786e\u4fdd\u7ed3\u6784\u4f53\u5e03\u5c40\u4e0e\u76ee\u6807\u7aef\u76f8\u540c\uff0c\u4f8b\u5982\u4f7f\u7528 <code>char __pad0[4];</code>\u3002\u6211\u4eec\u8fd8\u4f1a\u4f7f\u7528 <code>static_assert</code> \u6765\u786e\u4fdd\u7ed3\u6784\u4f53\u7684\u5185\u5b58\u957f\u5ea6\u548c\u539f\u5148 BTF \u4fe1\u606f\u4e2d\u7684\u7c7b\u578b\u957f\u5ea6\u76f8\u540c\u3002</p>"},{"location":"blogs/how-to-write-c-in-wasm.zh/#wasm","title":"\u6784\u5efa\u7528\u6237\u6001\u7684 Wasm \u4ee3\u7801\uff0c\u5e76\u83b7\u53d6\u5185\u6838\u6001\u6570\u636e","text":"<p>\u6211\u4eec\u9ed8\u8ba4\u4f7f\u7528 wasi-sdk \u4ece C/C++ \u4ee3\u7801\u6784\u5efa wasm \u4e8c\u8fdb\u5236\u6587\u4ef6\u3002\u60a8\u4e5f\u53ef\u4ee5\u4f7f\u7528 emcc \u5de5\u5177\u94fe\u6765\u6784\u5efa wasm \u4e8c\u8fdb\u5236\u6587\u4ef6\uff0c\u547d\u4ee4\u5e94\u8be5\u662f\u76f8\u4f3c\u7684\u3002\u60a8\u53ef\u4ee5\u8fd0\u884c\u4ee5\u4e0b\u547d\u4ee4\u6765\u5b89\u88c5 wasi-sdk\uff1a</p> <pre><code>wget https://github.com/WebAssembly/wasi-sdk/releases/download/wasi-sdk-17/wasi-sdk-17.0-linux.tar.gz\ntar -zxf wasi-sdk-17.0-linux.tar.gz\nsudo mkdir -p /opt/wasi-sdk/ &amp;&amp; sudo mv wasi-sdk-17.0/* /opt/wasi-sdk/\n</code></pre> <p>\u7136\u540e\u8fd0\u884c <code>make</code> \u4f1a\u5728 <code>Makefile</code> \u4e2d\u4f7f\u7528 wasi-clang \u7f16\u8bd1 C \u4ee3\u7801\uff0c\u751f\u6210 Wasm \u5b57\u8282\u7801\uff1a</p> <pre><code>/opt/wasi-sdk/bin/clang -O2 --sysroot=/opt/wasi-sdk/share/wasi-sysroot -Wl,--allow-undefined -o bootstrap.wasm bootstrap.c\n</code></pre> <p>\u7531\u4e8e\u5bbf\u4e3b\u673a\uff08\u6216 eBPF \u7aef\uff09\u7684 C \u7ed3\u6784\u5e03\u5c40\u53ef\u80fd\u4e0e\u76ee\u6807\uff08Wasm \u7aef\uff09\u7684\u7ed3\u6784\u5e03\u5c40\u4e0d\u540c\uff0c\u56e0\u6b64\u60a8\u53ef\u4ee5\u4f7f\u7528 ecc \u548c\u6211\u4eec\u7684 wasm-bpftool \u751f\u6210\u7528\u6237\u7a7a\u95f4\u4ee3\u7801\u7684 C \u5934\u6587\u4ef6\uff1a</p> <pre><code>ecc bootstrap.h --header-only\n../../third_party/bpftool/src/bpftool btf dump file bootstrap.bpf.o format c -j &gt; bootstrap.wasm.h\n</code></pre> <p>\u4f8b\u5982\uff0c\u539f\u5148\u5185\u6838\u6001\u7684\u5934\u6587\u4ef6\u4e2d\u7ed3\u6784\u4f53\u5b9a\u4e49\u5982\u4e0b\uff1a</p> <pre><code>struct event {\nint pid;\nint ppid;\nunsigned exit_code;\nunsigned long long duration_ns;\nchar comm[TASK_COMM_LEN];\nchar filename[MAX_FILENAME_LEN];\nchar exit_event;\n};\n</code></pre> <p>\u6211\u4eec\u7684\u5de5\u5177\u4f1a\u5c06\u5176\u8f6c\u6362\u4e3a\uff1a</p> <pre><code>struct event {\nint pid;\nint ppid;\nunsigned int exit_code;\nchar __pad0[4];\nunsigned long long duration_ns;\nchar comm[16];\nchar filename[127];\nchar exit_event;\n} __attribute__((packed));\nstatic_assert(sizeof(struct event) == 168, \"Size of event is not 168\");\n</code></pre> <p>\u6ce8\u610f\uff1a\u6b64\u8fc7\u7a0b\u548c\u5de5\u5177\u5e76\u4e0d\u603b\u662f\u5fc5\u9700\u7684\uff0c\u5bf9\u4e8e\u7b80\u5355\u7684\u5e94\u7528\uff0c\u4f60\u53ef\u4ee5\u624b\u52a8\u5b8c\u6210\u3002\u5bf9\u4e8e\u5185\u6838\u6001\u548c Wasm \u5e94\u7528\u90fd\u4f7f\u7528 C/C++ \u8bed\u8a00\u7684\u60c5\u51b5\u4e0b\uff0c\u4f60\u53ef\u4ee5\u624b\u52a8\u7f16\u5199\u6240\u6709\u4e8b\u4ef6\u7ed3\u6784\u4f53\u5b9a\u4e49\uff0c\u4f7f\u7528 <code>__attribute__((packed))</code> \u907f\u514d\u586b\u5145\u5b57\u8282\uff0c\u5e76\u5728\u4e3b\u673a\u548c wasm \u7aef\u4e4b\u95f4\u8f6c\u6362\u6240\u6709\u6307\u9488\u4e3a\u6b63\u786e\u7684\u6574\u6570\u3002\u6240\u6709\u7c7b\u578b\u5fc5\u987b\u5728 wasm \u4e2d\u5b9a\u4e49\u4e0e\u4e3b\u673a\u7aef\u76f8\u540c\u7684\u5927\u5c0f\u548c\u5e03\u5c40\u3002</p> <p>\u5bf9\u4e8e\u590d\u6742\u7684\u7a0b\u5e8f\uff0c\u624b\u52a8\u786e\u8ba4\u5185\u5b58\u5e03\u5c40\u7684\u6b63\u786e\u662f\u5206\u56f0\u96be\uff0c\u56e0\u6b64\u6211\u4eec\u521b\u5efa\u4e86 wasm \u7279\u5b9a\u7684 <code>bpftool</code>\uff0c\u7528\u4e8e\u4ece <code>BTF</code> \u4fe1\u606f\u4e2d\u751f\u6210\u5305\u542b\u6240\u6709\u7c7b\u578b\u5b9a\u4e49\u548c\u6b63\u786e\u7ed3\u6784\u4f53\u5e03\u5c40\u7684 C \u5934\u6587\u4ef6\uff0c\u4ee5\u4fbf\u7528\u6237\u7a7a\u95f4\u4ee3\u7801\u4f7f\u7528\u3002\u53ef\u4ee5\u901a\u8fc7\u7c7b\u4f3c\u7684\u65b9\u6848\uff0c\u4e00\u6b21\u6027\u5c06 eBPF \u7a0b\u5e8f\u4e2d\u6240\u6709\u7684\u7ed3\u6784\u4f53\u5b9a\u4e49\u8f6c\u6362\u4e3a Wasm \u7aef\u7684\u5185\u5b58\u5e03\u5c40\uff0c\u5e76\u786e\u4fdd\u5927\u5c0f\u7aef\u4e00\u81f4\uff0c\u5373\u53ef\u6b63\u786e\u8bbf\u95ee\u3002</p> <p>\u5bf9\u4e8e Wasm \u4e2d\u4e0d\u662f\u7531 C \u8bed\u8a00\u8fdb\u884c\u5f00\u53d1\u7684\u60c5\u51b5\u4e0b\uff0c\u501f\u52a9 Wasm \u7684\u7ec4\u4ef6\u6a21\u578b\uff0c\u6211\u4eec\u8fd8\u53ef\u4ee5\u5c06\u8fd9\u4e9b BTF \u4fe1\u606f\u7ed3\u6784\u4f53\u5b9a\u4e49\u4f5c\u4e3a wit \u7c7b\u578b\u58f0\u660e\u8f93\u51fa\uff0c\u7136\u540e\u5728\u7528\u6237\u7a7a\u95f4\u4ee3\u7801\u4e2d\u4f7f\u7528 wit-bindgen \u5de5\u5177\u4e00\u6b21\u6027\u751f\u6210\u591a\u79cd\u8bed\u8a00\uff08\u5982 C/C++/Rust/Go\uff09\u7684\u7c7b\u578b\u5b9a\u4e49\u3002\u8fd9\u90e8\u5206\u4f1a\u5728\u5173\u4e8e\u5982\u4f55\u4f7f\u7528 Rust \u5728 Wasm \u4e2d\u7f16\u5199 eBPF \u7a0b\u5e8f\u7684\u90e8\u5206\u8be6\u7ec6\u63cf\u8ff0\uff0c\u6211\u4eec\u4e5f\u4f1a\u5c06\u8fd9\u4e9b\u6b65\u9aa4\u548c\u5de5\u5177\u94fe\u7ee7\u7eed\u5b8c\u5584\uff0c\u4ee5\u6539\u8fdb Wasm-bpf \u7a0b\u5e8f\u7684\u7f16\u7a0b\u4f53\u9a8c\u3002</p> <p>\u6211\u4eec\u4e3a wasm \u7a0b\u5e8f\u63d0\u4f9b\u4e86\u4e00\u4e2a\u4ec5\u5305\u542b\u5934\u6587\u4ef6\u7684 libbpf API \u5e93\uff0c\u60a8\u53ef\u4ee5\u5728 libbpf-wasm.h\uff08wasm-include/libbpf-wasm.h\uff09\u4e2d\u627e\u5230\u5b83\uff0c\u5b83\u5305\u542b\u4e86\u4e00\u90e8\u5206 libbpf \u5e38\u7528\u7684\u7528\u6237\u6001 API \u548c\u7c7b\u578b\u5b9a\u4e49\u3002Wasm \u7a0b\u5e8f\u53ef\u4ee5\u4f7f\u7528 libbpf API \u64cd\u4f5c BPF \u5bf9\u8c61\uff0c\u4f8b\u5982\uff1a</p> <pre><code>/* Load and verify BPF application */\nskel = bootstrap_bpf__open();\n/* Parameterize BPF code with minimum duration parameter */\nskel-&gt;rodata-&gt;min_duration_ns = env.min_duration_ms * 1000000ULL;\n/* Load &amp; verify BPF programs */\nerr = bootstrap_bpf__load(skel);\n/* Attach tracepoints */\nerr = bootstrap_bpf__attach(skel);\n</code></pre> <p>rodata \u90e8\u5206\u7528\u4e8e\u5b58\u50a8 BPF \u7a0b\u5e8f\u4e2d\u7684\u5e38\u91cf\uff0c\u8fd9\u4e9b\u503c\u5c06\u5728 bpftool gen skeleton \u7684\u65f6\u5019\u7531\u4ee3\u7801\u751f\u6210\u6620\u5c04\u5230 object \u4e2d\u6b63\u786e\u7684\u504f\u79fb\u91cf,\u7136\u540e\u5728 open \u4e4b\u540e\u901a\u8fc7\u5185\u5b58\u6620\u5c04\u4fee\u6539\u5bf9\u5e94\u7684\u503c\uff0c\u56e0\u6b64\u4e0d\u9700\u8981\u5728 Wasm \u4e2d\u7f16\u8bd1 libelf \u5e93\uff0c\u8fd0\u884c\u65f6\u4ecd\u53ef\u52a8\u6001\u52a0\u8f7d\u548c\u64cd\u4f5c BPF \u5bf9\u8c61\u3002</p> <p>Wasm \u7aef\u7684 C \u4ee3\u7801\u4e0e\u672c\u5730 libbpf \u4ee3\u7801\u7565\u6709\u4e0d\u540c\uff0c\u4f46\u5b83\u53ef\u4ee5\u4ece eBPF \u7aef\u63d0\u4f9b\u5927\u90e8\u5206\u529f\u80fd\uff0c\u4f8b\u5982\uff0c\u4ece\u73af\u5f62\u7f13\u51b2\u533a\u6216 perf \u7f13\u51b2\u533a\u8f6e\u8be2\uff0c\u4ece Wasm \u7aef\u548c eBPF \u7aef\u8bbf\u95ee\u6620\u5c04\uff0c\u52a0\u8f7d\u3001\u9644\u52a0\u548c\u5206\u79bb BPF \u7a0b\u5e8f\u7b49\u3002\u5b83\u53ef\u4ee5\u652f\u6301\u5927\u91cf\u7684 eBPF \u7a0b\u5e8f\u7c7b\u578b\u548c\u6620\u5c04\uff0c\u6db5\u76d6\u4ece\u8ddf\u8e2a\u3001\u7f51\u7edc\u3001\u5b89\u5168\u7b49\u65b9\u9762\u7684\u5927\u591a\u6570 eBPF \u7a0b\u5e8f\u7684\u4f7f\u7528\u573a\u666f\u3002</p> <p>\u7531\u4e8e Wasm \u7aef\u7f3a\u5c11\u4e00\u4e9b\u529f\u80fd\uff0c\u4f8b\u5982 signal handler \u8fd8\u4e0d\u652f\u6301\uff082023\u5e742\u6708\uff09\uff0c\u539f\u59cb\u7684C\u4ee3\u7801\u6709\u53ef\u80fd\u65e0\u6cd5\u76f4\u63a5\u7f16\u8bd1\u4e3a wasm\uff0c\u60a8\u9700\u8981\u7a0d\u5fae\u4fee\u6539\u4ee3\u7801\u4ee5\u4f7f\u5176\u5de5\u4f5c\u3002\u6211\u4eec\u5c06\u5c3d\u6700\u5927\u52aa\u529b\u4f7f wasm \u7aef\u7684 libbpf API \u4e0e\u901a\u5e38\u5728\u7528\u6237\u7a7a\u95f4\u8fd0\u884c\u7684 libbpf API\u5c3d\u53ef\u80fd\u76f8\u4f3c\uff0c\u4ee5\u4fbf\u7528\u6237\u7a7a\u95f4\u4ee3\u7801\u53ef\u4ee5\u5728\u672a\u6765\u76f4\u63a5\u7f16\u8bd1\u4e3a wasm\u3002\u6211\u4eec\u8fd8\u5c06\u5c3d\u5feb\u63d0\u4f9b\u66f4\u591a\u8bed\u8a00\u7ed1\u5b9a\uff08Go\u7b49\uff09\u7684 wasm \u4fa7 eBPF \u7a0b\u5e8f\u5f00\u53d1\u5e93\u3002</p> <p>\u53ef\u4ee5\u5728\u7528\u6237\u6001\u7a0b\u5e8f\u4e2d\u4f7f\u7528 polling API \u83b7\u53d6\u5185\u6838\u6001\u4e0a\u4f20\u7684\u6570\u636e\u3002\u5b83\u5c06\u662f ring buffer \u548c perf buffer \u7684\u4e00\u4e2a\u5c01\u88c5\uff0c\u7528\u6237\u7a7a\u95f4\u4ee3\u7801\u53ef\u4ee5\u4f7f\u7528\u76f8\u540c\u7684 API \u4ece\u73af\u5f62\u7f13\u51b2\u533a\u6216\u6027\u80fd\u7f13\u51b2\u533a\u4e2d\u8f6e\u8be2\u4e8b\u4ef6\uff0c\u5177\u4f53\u53d6\u51b3\u4e8eBPF\u7a0b\u5e8f\u4e2d\u6307\u5b9a\u7684\u7c7b\u578b\u3002\u4f8b\u5982\uff0c\u73af\u5f62\u7f13\u51b2\u533a\u8f6e\u8be2\u5b9a\u4e49\u4e3a<code>BPF_MAP_TYPE_RINGBUF</code>\uff1a</p> <pre><code>struct {\n__uint(type, BPF_MAP_TYPE_RINGBUF);\n__uint(max_entries, 256 * 1024);\n} rb SEC(\".maps\");\n</code></pre> <p>\u4f60\u53ef\u4ee5\u5728\u7528\u6237\u6001\u4f7f\u7528\u4ee5\u4e0b\u4ee3\u7801\u4ece ring buffer \u4e2d\u8f6e\u8be2\u4e8b\u4ef6\uff1a</p> <pre><code>rb = bpf_buffer__open(skel-&gt;maps.rb, handle_event, NULL);\n/* Process events */\nprintf(\"%-8s %-5s %-16s %-7s %-7s %s\\n\", \"TIME\", \"EVENT\", \"COMM\", \"PID\",\n\"PPID\", \"FILENAME/EXIT CODE\");\nwhile (!exiting) {\n// poll buffer\nerr = bpf_buffer__poll(rb, 100 /* timeout, ms */);\n</code></pre> <p>ring buffer polling \u4e0d\u9700\u8981\u5e8f\u5217\u5316\u5f00\u9500\u3002bpf_buffer__poll API \u5c06\u8c03\u7528 handle_event \u56de\u8c03\u51fd\u6570\u6765\u5904\u7406\u73af\u5f62\u7f13\u51b2\u533a\u4e2d\u7684\u4e8b\u4ef6\u6570\u636e\uff1a</p> <pre><code>static int\nhandle_event(void *ctx, void *data, size_t data_sz)\n{\nconst struct event *e = data;\n...\nif (e-&gt;exit_event) {\nprintf(\"%-8s %-5s %-16s %-7d %-7d [%u]\", ts, \"EXIT\", e-&gt;comm, e-&gt;pid,\ne-&gt;ppid, e-&gt;exit_code);\nif (e-&gt;duration_ns)\nprintf(\" (%llums)\", e-&gt;duration_ns / 1000000);\nprintf(\"\\n\");\n}\n...\nreturn 0;\n}\n</code></pre> <p>\u8fd0\u884c\u65f6\u57fa\u4e8e libbpf CO-RE\uff08Compile Once, Run Everywhere\uff09API\uff0c\u7528\u4e8e\u5c06 bpf \u5bf9\u8c61\u52a0\u8f7d\u5230\u5185\u6838\u4e2d\uff0c\u56e0\u6b64 wasm-bpf \u7a0b\u5e8f\u4e0d\u53d7\u5b83\u7f16\u8bd1\u7684\u5185\u6838\u7248\u672c\u7684\u5f71\u54cd\uff0c\u53ef\u4ee5\u5728\u4efb\u4f55\u652f\u6301 BPF CO-RE \u7684\u5185\u6838\u7248\u672c\u4e0a\u8fd0\u884c\u3002</p>"},{"location":"blogs/how-to-write-c-in-wasm.zh/#ebpf-map","title":"\u4ece\u7528\u6237\u6001\u7a0b\u5e8f\u4e2d\u8bbf\u95ee\u548c\u66f4\u65b0 eBPF \u7a0b\u5e8f\u7684 map \u6570\u636e","text":"<p>runqlat \u662f\u4e00\u4e2a\u66f4\u590d\u6742\u7684\u793a\u4f8b\uff0c\u8fd9\u4e2a\u7a0b\u5e8f\u901a\u8fc7\u76f4\u65b9\u56fe\u5c55\u793a\u8c03\u5ea6\u5668\u8fd0\u884c\u961f\u5217\u5ef6\u8fdf\uff0c\u7ed9\u6211\u4eec\u5c55\u73b0\u4e86\u4efb\u52a1\u7b49\u4e86\u591a\u4e45\u624d\u80fd\u8fd0\u884c\u3002</p> <pre><code>$ sudo ./wasm-bpf runqlat.wasm -h\nSummarize run queue (scheduler) latency as a histogram.\nUSAGE: runqlat [--help] [interval] [count]\nEXAMPLES:\n    runqlat         # summarize run queue latency as a histogram\n    runqlat 1 10    # print 1 second summaries, 10 times\n$ sudo ./wasm-bpf runqlat.wasm 1\nTracing run queue latency... Hit Ctrl-C to end.\n     usecs               : count    distribution\n         0 -&gt; 1          : 72       |*****************************           |\n         2 -&gt; 3          : 93       |*************************************   |\n         4 -&gt; 7          : 98       |****************************************|\n         8 -&gt; 15         : 96       |*************************************** |\n        16 -&gt; 31         : 38       |***************                         |\n        32 -&gt; 63         : 4        |*                                       |\n        64 -&gt; 127        : 5        |**                                      |\n       128 -&gt; 255        : 6        |**                                      |\n       256 -&gt; 511        : 0        |                                        |\n       512 -&gt; 1023       : 0        |                                        |\n      1024 -&gt; 2047       : 0        |                                        |\n      2048 -&gt; 4095       : 1        |                                        |\n</code></pre> <p>runqlat \u4e2d\u4f7f\u7528 <code>map</code> API \u6765\u4ece\u7528\u6237\u6001\u8bbf\u95ee\u5185\u6838\u91cc\u7684 <code>map</code> \u5e76\u76f4\u63a5\u8bfb\u53d6\u6570\u636e\uff0c\u4f8b\u5982\uff1a</p> <pre><code>    while (!bpf_map_get_next_key(fd, &amp;lookup_key, &amp;next_key)) {\nerr = bpf_map_lookup_elem(fd, &amp;next_key, &amp;hist);\n...\nlookup_key = next_key;\n}\nlookup_key = -2;\nwhile (!bpf_map_get_next_key(fd, &amp;lookup_key, &amp;next_key)) {\nerr = bpf_map_delete_elem(fd, &amp;next_key);\n...\nlookup_key = next_key;\n}\n</code></pre> <p>\u8fd0\u884c\u65f6 wasm \u4ee3\u7801\u5c06\u4f1a\u4f7f\u7528\u5171\u4eab\u5185\u5b58\u6765\u8bbf\u95ee\u5185\u6838 map\uff0c\u5185\u6838\u6001\u53ef\u4ee5\u76f4\u63a5\u628a\u6570\u636e\u62f7\u8d1d\u5230\u7528\u6237\u6001 Wasm \u865a\u62df\u673a\u7684\u5806\u6808\u4e2d\uff0c\u800c\u4e0d\u9700\u8981\u9762\u5bf9\u7528\u6237\u6001\u4e3b\u673a\u4fa7\u7a0b\u5e8f\u548c Wasm \u8fd0\u884c\u65f6\u4e4b\u95f4\u7684\u989d\u5916\u62f7\u8d1d\u5f00\u9500\u3002\u540c\u6837\uff0c\u5bf9\u4e8e Wasm \u865a\u62df\u673a\u548c\u5185\u6838\u6001\u4e4b\u95f4\u5171\u4eab\u7684\u7c7b\u578b\u5b9a\u4e49\uff0c\u9700\u8981\u7ecf\u8fc7\u4ed4\u7ec6\u68c0\u67e5\u4ee5\u786e\u4fdd\u5b83\u4eec\u5728 Wasm \u548c\u5185\u6838\u6001\u4e2d\u7684\u7c7b\u578b\u662f\u4e00\u81f4\u7684\u3002</p> <p>\u53ef\u4ee5\u4f7f\u7528 <code>bpf_map_update_elem</code> \u5728\u7528\u6237\u6001\u7a0b\u5e8f\u5185\u66f4\u65b0\u5185\u6838\u7684 eBPF map\uff0c\u6bd4\u5982:</p> <pre><code>        cg_map_fd = bpf_map__fd(obj-&gt;maps.cgroup_map);\ncgfd = open(env.cgroupspath, O_RDONLY);\nif (cgfd &lt; 0) {\n...\n}\nif (bpf_map_update_elem(cg_map_fd, &amp;idx, &amp;cgfd, BPF_ANY)) {\n...\n}\n</code></pre> <p>\u56e0\u6b64\u5185\u6838\u7684 eBPF \u7a0b\u5e8f\u53ef\u4ee5\u4ece Wasm \u4fa7\u7684\u7a0b\u5e8f\u83b7\u53d6\u914d\u7f6e\uff0c\u6216\u8005\u5728\u8fd0\u884c\u7684\u65f6\u5019\u63a5\u6536\u6d88\u606f\u3002</p>"},{"location":"blogs/how-to-write-c-in-wasm.zh/#socket-filter-lsm","title":"\u66f4\u591a\u7684\u4f8b\u5b50\uff1asocket filter \u548c lsm","text":"<p>\u5728\u4ed3\u5e93\u4e2d\uff0c\u6211\u4eec\u8fd8\u63d0\u4f9b\u4e86\u66f4\u591a\u7684\u793a\u4f8b\uff0c\u4f8b\u5982\u4f7f\u7528 socket filter \u76d1\u63a7\u548c\u8fc7\u6ee4\u6570\u636e\u5305\uff1a</p> <pre><code>SEC(\"socket\")\nint socket_handler(struct __sk_buff *skb)\n{\nstruct so_event *e;\n__u8 verlen;\n__u16 proto;\n__u32 nhoff = ETH_HLEN;\nbpf_skb_load_bytes(skb, 12, &amp;proto, 2);\n...\nbpf_skb_load_bytes(skb, nhoff + 0, &amp;verlen, 1);\nbpf_skb_load_bytes(skb, nhoff + ((verlen &amp; 0xF) &lt;&lt; 2), &amp;(e-&gt;ports), 4);\ne-&gt;pkt_type = skb-&gt;pkt_type;\ne-&gt;ifindex = skb-&gt;ifindex;\nbpf_ringbuf_submit(e, 0);\nreturn skb-&gt;len;\n}\n</code></pre> <p>Linux Security Modules\uff08LSM\uff09\u662f\u4e00\u4e2a\u57fa\u4e8e\u94a9\u5b50\u7684\u6846\u67b6\uff0c\u7528\u4e8e\u5728Linux\u5185\u6838\u4e2d\u5b9e\u73b0\u5b89\u5168\u7b56\u7565\u548c\u5f3a\u5236\u8bbf\u95ee\u63a7\u5236\u3002\u76f4\u5230\u73b0\u5728\uff0c\u80fd\u591f\u5b9e\u73b0\u5b9e\u65bd\u5b89\u5168\u7b56\u7565\u76ee\u6807\u7684\u65b9\u5f0f\u53ea\u6709\u4e24\u79cd\u9009\u62e9\uff0c\u914d\u7f6e\u73b0\u6709\u7684LSM\u6a21\u5757\uff08\u5982AppArmor\u3001SELinux\uff09\uff0c\u6216\u7f16\u5199\u81ea\u5b9a\u4e49\u5185\u6838\u6a21\u5757\u3002</p> <p>Linux Kernel 5.7 \u5f15\u5165\u4e86\u7b2c\u4e09\u79cd\u65b9\u5f0f\uff1aLSM eBPF\u3002LSM BPF \u5141\u8bb8\u5f00\u53d1\u4eba\u5458\u7f16\u5199\u81ea\u5b9a\u4e49\u7b56\u7565\uff0c\u800c\u65e0\u9700\u914d\u7f6e\u6216\u52a0\u8f7d\u5185\u6838\u6a21\u5757\u3002LSM BPF \u7a0b\u5e8f\u5728\u52a0\u8f7d\u65f6\u88ab\u9a8c\u8bc1\uff0c\u7136\u540e\u5728\u8c03\u7528\u8def\u5f84\u4e2d\uff0c\u5230\u8fbeLSM\u94a9\u5b50\u65f6\u88ab\u6267\u884c\u3002\u4f8b\u5982\uff0c\u6211\u4eec\u53ef\u4ee5\u5728 Wasm \u8f7b\u91cf\u7ea7\u5bb9\u5668\u4e2d\uff0c\u4f7f\u7528 lsm \u9650\u5236\u6587\u4ef6\u7cfb\u7edf\u64cd\u4f5c\uff1a</p> <pre><code>// all lsm the hook point refer https://www.kernel.org/doc/html/v5.2/security/LSM.html\nSEC(\"lsm/path_rmdir\")\nint path_rmdir(const struct path *dir, struct dentry *dentry) {\nchar comm[16];\nbpf_get_current_comm(comm, sizeof(comm));\nunsigned char dir_name[] = \"can_not_rm\";\nunsigned char d_iname[32];\nbpf_probe_read_kernel(&amp;d_iname[0], sizeof(d_iname),\n&amp;(dir-&gt;dentry-&gt;d_iname[0]));\nbpf_printk(\"comm %s try to rmdir %s\", comm, d_iname);\nfor (int i = 0;i&lt;sizeof(dir_name);i++){\nif (d_iname[i]!=dir_name[i]){\nreturn 0;\n}\n}\nreturn -1;\n}\n</code></pre>"},{"location":"blogs/how-to-write-c-in-wasm.zh/#_1","title":"\u603b\u7ed3","text":"<p>\u672c\u4ee5 C/C++ \u8bed\u8a00\u4e3a\u4f8b\uff0c\u8ba8\u8bba\u4e86\u5982\u4f55\u4f7f\u7528 C/C++ \u7f16\u5199 eBPF \u7a0b\u5e8f\u5e76\u7f16\u8bd1\u4e3a Wasm \u6a21\u5757\u3002\u66f4\u5b8c\u6574\u7684\u4ee3\u7801\uff0c\u8bf7\u53c2\u8003\u6211\u4eec\u7684 Github \u4ed3\u5e93\uff1ahttps://github.com/eunomia-bpf/wasm-bpf.</p> <p>\u5728\u4e0b\u4e00\u7bc7\u6587\u7ae0\u4e2d\uff0c\u6211\u4eec\u4f1a\u8ba8\u8bba\u4f7f\u7528 Rust \u7f16\u5199 eBPF \u7a0b\u5e8f\u5e76\u7f16\u8bd1\u4e3a Wasm \u6a21\u5757\uff0c\u5e76\u4f7f\u7528 OCI \u955c\u50cf\u53d1\u5e03\u3001\u90e8\u7f72\u3001\u7ba1\u7406 eBPF \u7a0b\u5e8f\uff0c\u83b7\u5f97\u7c7b\u4f3c Docker \u7684\u4f53\u9a8c\u3002</p> <p>\u63a5\u4e0b\u6765\uff0c\u6211\u4eec\u4e5f\u4f1a\u7ee7\u7eed\u5b8c\u5584\u5728 Wasm \u4e2d\u4f7f\u7528\u591a\u79cd\u8bed\u8a00\u5f00\u53d1\u548c\u8fd0\u884c eBPF \u7a0b\u5e8f\u7684\u4f53\u9a8c\uff0c\u63d0\u4f9b\u66f4\u5b8c\u5584\u7684\u793a\u4f8b\u548c\u7528\u6237\u6001\u5f00\u53d1\u5e93/\u5de5\u5177\u94fe\uff0c\u4ee5\u53ca\u66f4\u5177\u4f53\u7684\u5e94\u7528\u573a\u666f\u3002</p>"},{"location":"blogs/how-to-write-c-in-wasm.zh/#_2","title":"\u53c2\u8003\u8d44\u6599","text":"<ul> <li>wasm-bpf Github \u5f00\u6e90\u5730\u5740\uff1ahttps://github.com/eunomia-bpf/wasm-bpf</li> <li>\u4ec0\u4e48\u662f eBPF\uff1ahttps://ebpf.io/what-is-ebpf</li> <li>WASI-eBPF: https://github.com/WebAssembly/WASI/issues/513</li> <li>\u9f99\u8725\u793e\u533a eBPF \u6280\u672f\u63a2\u7d22 SIG https://openanolis.cn/sig/ebpfresearch</li> <li>eunomia-bpf \u9879\u76ee\uff1ahttps://github.com/eunomia-bpf/eunomia-bpf</li> <li>eunomia-bpf \u9879\u76ee\u9f99\u8725 Gitee \u955c\u50cf\uff1ahttps://gitee.com/anolis/eunomia</li> <li>Wasm-bpf: \u67b6\u8d77 Webassembly \u548c eBPF \u5185\u6838\u53ef\u7f16\u7a0b\u7684\u6865\u6881\uff1ahttps://mp.weixin.qq.com/s/2InV7z1wcWic5ifmAXSiew</li> <li>\u5f53 WASM \u9047\u89c1 eBPF \uff1a\u4f7f\u7528 WebAssembly \u7f16\u5199\u3001\u5206\u53d1\u3001\u52a0\u8f7d\u8fd0\u884c eBPF \u7a0b\u5e8f\uff1ahttps://zhuanlan.zhihu.com/p/573941739</li> <li>\u6559\u4f60\u4f7f\u7528eBPF LSM\u70ed\u4fee\u590dLinux\u5185\u6838\u6f0f\u6d1e\uff1ahttps://www.bilibili.com/read/cv19597563</li> </ul>"},{"location":"blogs/how-to-write-rust-in-wasm.zh/","title":"\u5728 WebAssembly \u4e2d\u4f7f\u7528 Rust \u7f16\u5199 eBPF \u7a0b\u5e8f\u5e76\u53d1\u5e03 OCI \u955c\u50cf","text":"<p>\u4f5c\u8005\uff1a\u4e8e\u6850\uff0c\u90d1\u6631\u7b19</p> <p>eBPF\uff08extended Berkeley Packet Filter\uff09\u662f\u4e00\u79cd\u9ad8\u6027\u80fd\u7684\u5185\u6838\u865a\u62df\u673a\uff0c\u53ef\u4ee5\u8fd0\u884c\u5728\u5185\u6838\u7a7a\u95f4\u4e2d\uff0c\u4ee5\u6536\u96c6\u7cfb\u7edf\u548c\u7f51\u7edc\u4fe1\u606f\u3002\u968f\u7740\u8ba1\u7b97\u673a\u6280\u672f\u7684\u4e0d\u65ad\u53d1\u5c55\uff0ceBPF \u7684\u529f\u80fd\u65e5\u76ca\u5f3a\u5927\uff0c\u5e76\u4e14\u5df2\u7ecf\u6210\u4e3a\u5404\u79cd\u6548\u7387\u9ad8\u6548\u7684\u5728\u7ebf\u8bca\u65ad\u548c\u8ddf\u8e2a\u7cfb\u7edf\uff0c\u4ee5\u53ca\u6784\u5efa\u5b89\u5168\u7684\u7f51\u7edc\u3001\u670d\u52a1\u7f51\u683c\u7684\u91cd\u8981\u7ec4\u6210\u90e8\u5206\u3002</p> <p>WebAssembly\uff08Wasm\uff09\u6700\u521d\u662f\u4ee5\u6d4f\u89c8\u5668\u5b89\u5168\u6c99\u76d2\u4e3a\u76ee\u7684\u5f00\u53d1\u7684\uff0c\u53d1\u5c55\u5230\u76ee\u524d\u4e3a\u6b62\uff0cWebAssembly \u5df2\u7ecf\u6210\u4e3a\u4e00\u4e2a\u7528\u4e8e\u4e91\u539f\u751f\u8f6f\u4ef6\u7ec4\u4ef6\u7684\u9ad8\u6027\u80fd\u3001\u8de8\u5e73\u53f0\u548c\u591a\u8bed\u8a00\u8f6f\u4ef6\u6c99\u7bb1\u73af\u5883\uff0cWasm \u8f7b\u91cf\u7ea7\u5bb9\u5668\u4e5f\u975e\u5e38\u9002\u5408\u4f5c\u4e3a\u4e0b\u4e00\u4ee3\u65e0\u670d\u52a1\u5668\u5e73\u53f0\u8fd0\u884c\u65f6\uff0c\u6216\u5728\u8fb9\u7f18\u8ba1\u7b97\u7b49\u8d44\u6e90\u53d7\u9650\u7684\u573a\u666f\u9ad8\u6548\u6267\u884c\u3002</p> <p>\u73b0\u5728\uff0c\u501f\u52a9 Wasm-bpf \u7f16\u8bd1\u5de5\u5177\u94fe\u548c\u8fd0\u884c\u65f6\uff0c\u6211\u4eec\u53ef\u4ee5\u4f7f\u7528 Wasm \u5c06 eBPF \u7a0b\u5e8f\u7f16\u5199\u4e3a\u8de8\u5e73\u53f0\u7684\u6a21\u5757\uff0c\u4f7f\u7528 C/C++ \u548c Rust \u7f16\u5199\u7a0b\u5e8f\u3002\u901a\u8fc7\u5728 WebAssembly \u4e2d\u4f7f\u7528 eBPF \u7a0b\u5e8f\uff0c\u6211\u4eec\u4e0d\u4ec5\u8ba9 Wasm \u5e94\u7528\u83b7\u5f97 eBPF \u7684\u9ad8\u6027\u80fd\u3001\u5bf9\u7cfb\u7edf\u63a5\u53e3\u7684\u8bbf\u95ee\u80fd\u529b\uff0c\u8fd8\u53ef\u4ee5\u8ba9 eBPF \u7a0b\u5e8f\u4eab\u53d7\u5230 Wasm \u7684\u6c99\u7bb1\u3001\u7075\u6d3b\u6027\u3001\u8de8\u5e73\u53f0\u6027\u3001\u548c\u52a8\u6001\u52a0\u8f7d\u7684\u80fd\u529b\uff0c\u5e76\u4e14\u4f7f\u7528 Wasm \u7684 OCI \u955c\u50cf\u6765\u65b9\u4fbf\u3001\u5feb\u6377\u5730\u5206\u53d1\u548c\u7ba1\u7406 eBPF \u7a0b\u5e8f\u3002\u4f8b\u5982\uff0c\u53ef\u4ee5\u7c7b\u4f3c docker \u4e00\u6837\uff0c\u4ece\u4e91\u7aef\u4e00\u884c\u547d\u4ee4\u83b7\u53d6 Wasm \u8f7b\u91cf\u7ea7\u5bb9\u5668\u955c\u50cf\uff0c\u5e76\u8fd0\u884c\u4efb\u610f eBPF \u7a0b\u5e8f\u3002\u901a\u8fc7\u7ed3\u5408\u8fd9\u4e24\u79cd\u6280\u672f\uff0c\u6211\u4eec\u5c06\u4f1a\u7ed9 eBPF \u548c Wasm \u751f\u6001\u6765\u4e00\u4e2a\u5168\u65b0\u7684\u5f00\u53d1\u4f53\u9a8c\uff01</p>"},{"location":"blogs/how-to-write-rust-in-wasm.zh/#wasm-bpf-wasm-ebpf","title":"\u4f7f\u7528 Wasm-bpf \u5de5\u5177\u94fe\u5728 Wasm \u4e2d\u7f16\u5199\u3001\u52a8\u6001\u52a0\u8f7d\u3001\u5206\u53d1\u8fd0\u884c eBPF \u7a0b\u5e8f","text":"<p>\u5728\u524d\u4e24\u7bc7\u77ed\u6587\u4e2d\uff0c\u6211\u4eec\u5df2\u7ecf\u4ecb\u7ecd\u4e86 Wasm-bpf \u7684\u8bbe\u8ba1\u601d\u8def\uff0c\u4ee5\u53ca\u5982\u4f55\u4f7f\u7528 C/C++ \u5728 Wasm \u4e2d\u7f16\u5199 eBPF \u7a0b\u5e8f:</p> <ul> <li>Wasm-bpf: \u67b6\u8d77 Webassembly \u548c eBPF \u5185\u6838\u53ef\u7f16\u7a0b\u7684\u6865\u6881: https://mp.weixin.qq.com/s/2InV7z1wcWic5ifmAXSiew</li> <li>\u5728 WebAssembly \u4e2d\u4f7f\u7528 C/C++ \u548c libbpf \u7f16\u5199 eBPF \u7a0b\u5e8f: https://zhuanlan.zhihu.com/p/605542090</li> </ul> <p>\u57fa\u4e8e Wasm\uff0c\u6211\u4eec\u53ef\u4ee5\u4f7f\u7528\u591a\u79cd\u8bed\u8a00\u6784\u5efa eBPF \u5e94\u7528\uff0c\u5e76\u4ee5\u7edf\u4e00\u3001\u8f7b\u91cf\u7ea7\u7684\u65b9\u5f0f\u7ba1\u7406\u548c\u53d1\u5e03\u3002\u4ee5\u6211\u4eec\u6784\u5efa\u7684\u793a\u4f8b\u5e94\u7528 bootstrap.wasm \u4e3a\u4f8b\uff0c\u4f7f\u7528 C/C++ \u6784\u5efa\u7684\u955c\u50cf\u5927\u5c0f\u6700\u5c0f\u4ec5\u4e3a ~90K\uff0c\u5f88\u5bb9\u6613\u901a\u8fc7\u7f51\u7edc\u5206\u53d1\uff0c\u5e76\u53ef\u4ee5\u5728\u4e0d\u5230 100ms \u7684\u65f6\u95f4\u5185\u5728\u53e6\u4e00\u53f0\u673a\u5668\u4e0a\u52a8\u6001\u90e8\u7f72\u3001\u52a0\u8f7d\u548c\u8fd0\u884c\uff0c\u5e76\u4e14\u4fdd\u7559\u8f7b\u91cf\u7ea7\u5bb9\u5668\u7684\u9694\u79bb\u7279\u6027\u3002\u8fd0\u884c\u65f6\u4e0d\u9700\u8981\u5185\u6838\u7279\u5b9a\u7248\u672c\u5934\u6587\u4ef6\u3001LLVM\u3001clang \u7b49\u4f9d\u8d56\uff0c\u4e5f\u4e0d\u9700\u8981\u505a\u4efb\u4f55\u6d88\u8017\u8d44\u6e90\u7684\u91cd\u91cf\u7ea7\u7684\u7f16\u8bd1\u5de5\u4f5c\u3002\u5bf9\u4e8e Rust \u800c\u8a00\uff0c\u7f16\u8bd1\u4ea7\u7269\u4f1a\u7a0d\u5927\u4e00\u70b9\uff0c\u5927\u7ea6\u5728 2M \u5de6\u53f3\u3002</p> <p>\u672c\u6587\u5c06\u4ee5 Rust \u8bed\u8a00\u4e3a\u4f8b\uff0c\u8ba8\u8bba\uff1a</p> <ul> <li>\u4f7f\u7528 Rust \u7f16\u5199 eBPF \u7a0b\u5e8f\u5e76\u7f16\u8bd1\u4e3a Wasm \u6a21\u5757</li> <li>\u4f7f\u7528 OCI \u955c\u50cf\u53d1\u5e03\u3001\u90e8\u7f72\u3001\u7ba1\u7406 eBPF \u7a0b\u5e8f\uff0c\u83b7\u5f97\u7c7b\u4f3c Docker \u7684\u4f53\u9a8c</li> </ul> <p>\u6211\u4eec\u5728\u4ed3\u5e93\u4e2d\u63d0\u4f9b\u4e86\u51e0\u4e2a\u793a\u4f8b\u7a0b\u5e8f\uff0c\u5206\u522b\u5bf9\u5e94\u4e8e\u53ef\u89c2\u6d4b\u3001\u7f51\u7edc\u3001\u5b89\u5168\u7b49\u591a\u79cd\u573a\u666f\u3002</p>"},{"location":"blogs/how-to-write-rust-in-wasm.zh/#ebpf-wasm","title":"\u7f16\u5199 eBPF \u7a0b\u5e8f\u5e76\u7f16\u8bd1\u4e3a Wasm \u7684\u5927\u81f4\u6d41\u7a0b","text":"<p>\u4e00\u822c\u8bf4\u6765\uff0c\u5728\u975e Wasm \u6c99\u7bb1\u7684\u7528\u6237\u6001\u7a7a\u95f4\uff0c\u4f7f\u7528 libbpf-bootstrap \u811a\u624b\u67b6\uff0c\u53ef\u4ee5\u5feb\u901f\u3001\u8f7b\u677e\u5730\u4f7f\u7528 C/C++\u6784\u5efa BPF \u5e94\u7528\u7a0b\u5e8f\u3002\u7f16\u8bd1\u3001\u6784\u5efa\u548c\u8fd0\u884c eBPF \u7a0b\u5e8f\uff08\u65e0\u8bba\u662f\u91c7\u7528\u4ec0\u4e48\u8bed\u8a00\uff09\uff0c\u901a\u5e38\u5305\u542b\u4ee5\u4e0b\u51e0\u4e2a\u6b65\u9aa4\uff1a</p> <ul> <li>\u7f16\u5199\u5185\u6838\u6001 eBPF \u7a0b\u5e8f\u7684\u4ee3\u7801\uff0c\u4e00\u822c\u4f7f\u7528 C/C++ \u6216 Rust \u8bed\u8a00</li> <li>\u4f7f\u7528 clang \u7f16\u8bd1\u5668\u6216\u8005\u76f8\u5173\u5de5\u5177\u94fe\u7f16\u8bd1 eBPF \u7a0b\u5e8f\uff08\u8981\u5b9e\u73b0\u8de8\u5185\u6838\u7248\u672c\u79fb\u690d\u7684\u8bdd\uff0c\u9700\u8981\u5305\u542b BTF \u4fe1\u606f\uff09\u3002</li> <li>\u5728\u7528\u6237\u6001\u7684\u5f00\u53d1\u7a0b\u5e8f\u4e2d\uff0c\u7f16\u5199\u5bf9\u5e94\u7684\u52a0\u8f7d\u3001\u63a7\u5236\u3001\u6302\u8f7d\u3001\u6570\u636e\u5904\u7406\u903b\u8f91\uff1b</li> <li>\u5728\u5b9e\u9645\u8fd0\u884c\u7684\u9636\u6bb5\uff0c\u4ece\u7528\u6237\u6001\u5c06 eBPF \u7a0b\u5e8f\u52a0\u8f7d\u8fdb\u5165\u5185\u6838\uff0c\u5e76\u5b9e\u9645\u6267\u884c\u3002</li> </ul>"},{"location":"blogs/how-to-write-rust-in-wasm.zh/#rust-ebpf-wasm","title":"\u4f7f\u7528 Rust \u7f16\u5199 eBPF \u7a0b\u5e8f\u5e76\u7f16\u8bd1\u4e3a Wasm","text":"<p>Rust \u53ef\u80fd\u662f WebAssembly \u751f\u6001\u7cfb\u7edf\u4e2d\u652f\u6301\u6700\u597d\u7684\u8bed\u8a00\u3002Rust \u4e0d\u4ec5\u652f\u6301\u51e0\u4e2a WebAssembly \u7f16\u8bd1\u76ee\u6807\uff0c\u800c\u4e14 wasmtime\u3001Spin\u3001Wagi \u548c\u5176\u4ed6\u8bb8\u591a WebAssembly \u5de5\u5177\u90fd\u662f\u7528 Rust \u7f16\u5199\u7684\u3002\u56e0\u6b64\uff0c\u6211\u4eec\u4e5f\u63d0\u4f9b\u4e86 Rust \u7684\u5f00\u53d1\u793a\u4f8b\uff1a</p> <ul> <li>Wasm \u548c WASI \u7684 Rust \u751f\u6001\u7cfb\u7edf\u975e\u5e38\u68d2</li> <li>\u8bb8\u591a Wasm \u5de5\u5177\u90fd\u662f\u7528 Rust \u7f16\u5199\u7684\uff0c\u8fd9\u610f\u5473\u7740\u6709\u5927\u91cf\u7684\u4ee3\u7801\u53ef\u4ee5\u590d\u7528\u3002</li> <li>Spin \u901a\u5e38\u5728\u5bf9\u5176\u4ed6\u8bed\u8a00\u7684\u652f\u6301\u4e4b\u524d\u5c31\u6709Rust\u7684\u529f\u80fd\u652f\u6301</li> <li>Wasmtime \u662f\u7528 Rust\u7f16\u5199\u7684\uff0c\u901a\u5e38\u5728\u5176\u4ed6\u8fd0\u884c\u65f6\u4e4b\u524d\u5c31\u6709\u6700\u5148\u8fdb\u7684\u529f\u80fd\u3002</li> <li>\u53ef\u4ee5\u5728 WebAssembly \u4e2d\u4f7f\u7528\u8bb8\u591a\u73b0\u6210\u7684 Rust \u5e93\u3002</li> <li>\u7531\u4e8e Cargo \u7684\u7075\u6d3b\u6784\u5efa\u7cfb\u7edf\uff0c\u4e00\u4e9b Crates \u751a\u81f3\u6709\u7279\u6b8a\u7684\u529f\u80fd\u6807\u5fd7\u6765\u542f\u7528Wasm\u7684\u529f\u80fd\uff08\u4f8b\u5982Chrono\uff09\u3002</li> <li>\u7531\u4e8e Rust \u7684\u5185\u5b58\u7ba1\u7406\u6280\u672f\uff0c\u4e0e\u540c\u7c7b\u8bed\u8a00\u76f8\u6bd4\uff0cRust \u7684\u4e8c\u8fdb\u5236\u5927\u5c0f\u5f88\u5c0f\u3002</li> </ul> <p>\u6211\u4eec\u540c\u6837\u63d0\u4f9b\u4e86\u4e00\u4e2a Rust \u7684 eBPF SDK\uff0c\u53ef\u4ee5\u4f7f\u7528 Rust \u7f16\u5199 eBPF \u7684\u7528\u6237\u6001\u7a0b\u5e8f\u5e76\u7f16\u8bd1\u4e3a Wasm\u3002\u501f\u52a9 aya-rs \u63d0\u4f9b\u7684\u76f8\u5173\u5de5\u5177\u94fe\u652f\u6301\uff0c\u5185\u6838\u6001\u7684 eBPF \u7a0b\u5e8f\u4e5f\u53ef\u4ee5\u7528 Rust \u8fdb\u884c\u7f16\u5199\uff0c\u4e0d\u8fc7\u5728\u8fd9\u91cc\uff0c\u6211\u4eec\u8fd8\u662f\u590d\u7528\u4e4b\u524d\u4f7f\u7528 C \u8bed\u8a00\u7f16\u5199\u7684\u5185\u6838\u6001\u7a0b\u5e8f\u3002</p> <p>\u9996\u5148\uff0c\u6211\u4eec\u9700\u8981\u4f7f\u7528 rust \u63d0\u4f9b\u7684 wasi \u5de5\u5177\u94fe\uff0c\u521b\u5efa\u4e00\u4e2a\u65b0\u7684\u9879\u76ee\uff1a</p> <pre><code>rustup target add wasm32-wasi\ncargo new rust-helloworld\n</code></pre> <p>\u4e4b\u540e\uff0c\u53ef\u4ee5\u4f7f\u7528 <code>Makefile</code> \u8fd0\u884c make \u5b8c\u6210\u6574\u4e2a\u7f16\u8bd1\u6d41\u7a0b\uff0c\u5e76\u751f\u6210 <code>bootstrap.bpf.o</code> eBPF \u5b57\u8282\u7801\u6587\u4ef6\u3002</p>"},{"location":"blogs/how-to-write-rust-in-wasm.zh/#wit-bindgen-wasm","title":"\u4f7f\u7528 wit-bindgen \u751f\u6210\u7c7b\u578b\u4fe1\u606f\uff0c\u7528\u4e8e\u5185\u6838\u6001\u548c Wasm \u6a21\u5757\u4e4b\u95f4\u901a\u4fe1","text":"<p>wit-bindgen \u9879\u76ee\u662f\u4e00\u5957\u7740\u773c\u4e8e WebAssembly\uff0c\u5e76\u4f7f\u7528\u7ec4\u4ef6\u6a21\u578b\u7684\u8bed\u8a00\u7684\u7ed1\u5b9a\u751f\u6210\u5668\u3002\u7ed1\u5b9a\u662f\u7528 *.wit \u6587\u4ef6\u63cf\u8ff0\u7684\uff0c\u6587\u4ef6\u4e2d\u63cf\u8ff0\u4e86 Wasm \u6a21\u5757\u5bfc\u5165\u3001\u5bfc\u51fa\u7684\u51fd\u6570\u548c\u63a5\u53e3\u3002\u6211\u4eec\u53ef\u4ee5 wit-bindgen \u5b83\u6765\u751f\u6210\u591a\u79cd\u8bed\u8a00\u7684\u7c7b\u578b\u5b9a\u4e49\uff0c\u4ee5\u4fbf\u5728\u5185\u6838\u6001\u7684 eBPF \u548c\u7528\u6237\u6001\u7684 Wasm \u6a21\u5757\u4e4b\u95f4\u4f20\u9012\u6570\u636e\u3002</p> <p>\u6211\u4eec\u9996\u5148\u9700\u8981\u5728 <code>Cargo.toml</code> \u914d\u7f6e\u6587\u4ef6\u4e2d\u52a0\u5165 <code>wasm-bpf-binding</code> \u548c <code>wit-bindgen-guest-rust</code> \u4f9d\u8d56\uff1a</p> <pre><code>wasm-bpf-binding = { path = \"wasm-bpf-binding\" }\n</code></pre> <p>\u8fd9\u4e2a\u5305\u63d0\u4f9b\u4e86 wasm-bpf \u7531\u8fd0\u884c\u65f6\u63d0\u4f9b\u7ed9 Wasm \u6a21\u5757\uff0c\u7528\u4e8e\u52a0\u8f7d\u548c\u63a7\u5236 eBPF \u7a0b\u5e8f\u7684\u51fd\u6570\u7684\u7ed1\u5b9a\u3002</p> <ul> <li><code>wasm-bpf-binding</code> \u5728 wasm-bpf \u4ed3\u5e93\u4e2d\u6709\u63d0\u4f9b\u3002</li> </ul> <pre><code>[dependencies]\nwit-bindgen-guest-rust = { git = \"https://github.com/bytecodealliance/wit-bindgen\", version = \"0.3.0\" }\n[patch.crates-io]\nwit-component = {git = \"https://github.com/bytecodealliance/wasm-tools\", version = \"0.5.0\", rev = \"9640d187a73a516c42b532cf2a10ba5403df5946\"}\nwit-parser = {git = \"https://github.com/bytecodealliance/wasm-tools\", version = \"0.5.0\", rev = \"9640d187a73a516c42b532cf2a10ba5403df5946\"}\n</code></pre> <p>\u8fd9\u4e2a\u5305\u652f\u6301\u7528 wit \u6587\u4ef6\u4e3a rust \u5ba2\u6237\u7a0b\u5e8f\u751f\u6210\u7ed1\u5b9a\u3002\u4f7f\u7528\u8fd9\u4e2a\u5305\u7684\u60c5\u51b5\u4e0b\uff0c\u6211\u4eec\u4e0d\u9700\u8981\u518d\u624b\u52a8\u8fd0\u884c wit-bindgen\u3002</p> <p>\u63a5\u4e0b\u6765\uff0c\u6211\u4eec\u4f7f\u7528 <code>btf2wit</code> \u5de5\u5177\uff0c\u4ece BTF \u4fe1\u606f\u751f\u6210 wit \u6587\u4ef6\u3002\u53ef\u4ee5\u4f7f\u7528 <code>cargo install btf2wit</code> \u5b89\u88c5\u6211\u4eec\u63d0\u4f9b\u7684 btf2wit \u5de5\u5177\uff0c\u5e76\u7f16\u8bd1\u751f\u6210 wit \u4fe1\u606f\uff1a</p> <pre><code>cd btf\nclang -target bpf -g event-def.c -c -o event.def.o\nbtf2wit event.def.o -o event-def.wit\ncp *.wit ../wit/\n</code></pre> <ul> <li>\u5176\u4e2d <code>event-def.c</code> \u662f\u5305\u542b\u4e86\u6211\u4eec\u9700\u8981\u7684\u7ed3\u6784\u4f53\u4fe1\u606f\u7684\u7684 C \u7a0b\u5e8f\u6587\u4ef6\u3002\u53ea\u6709\u5728\u5bfc\u51fa\u7b26\u53f7\u4e2d\u7528\u5230\u7684\u7ed3\u6784\u4f53\u624d\u4f1a\u88ab\u8bb0\u5f55\u5728 BTF \u4e2d\u3002</li> </ul> <p>\u5bf9\u4e8e C \u7ed3\u6784\u4f53\u751f\u6210\u7684 wit \u4fe1\u606f\uff0c\u5927\u81f4\u5982\u4e0b\uff1a</p> <pre><code>default world host {\n    record event {\n         pid: s32,\n        ppid: s32,\n        exit-code: u32,\n        --pad0: list&lt;s8&gt;,\n        duration-ns: u64,\n        comm: list&lt;s8&gt;,\n        filename: list&lt;s8&gt;,\n        exit-event: s8,\n    }\n}\n</code></pre> <p><code>wit-bindgen-guest-rust</code> \u4f1a\u4e3a wit \u6587\u4ef6\u5939\u4e2d\u7684\u6240\u6709\u7c7b\u578b\u4fe1\u606f\uff0c\u81ea\u52a8\u751f\u6210 rust \u7684\u7c7b\u578b\uff0c\u4f8b\u5982\uff1a</p> <pre><code>#[repr(C, packed)]\n#[derive(Debug, Copy, Clone)]\nstruct Event {\npid: i32,\nppid: i32,\nexit_code: u32,\n__pad0: [u8; 4],\nduration_ns: u64,\ncomm: [u8; 16],\nfilename: [u8; 127],\nexit_event: u8,\n}\n</code></pre>"},{"location":"blogs/how-to-write-rust-in-wasm.zh/#_1","title":"\u7f16\u5199\u7528\u6237\u6001\u52a0\u8f7d\u548c\u5904\u7406\u4ee3\u7801","text":"<p>\u4e3a\u4e86\u5728 WASI \u4e0a\u8fd0\u884c\uff0c\u9700\u8981\u4e3a main.rs \u6dfb\u52a0 <code>#![no_main]</code> \u5c5e\u6027\uff0c\u5e76\u4e14 main \u51fd\u6570\u9700\u8981\u91c7\u7528\u7c7b\u4f3c\u5982\u4e0b\u7684\u5f62\u6001\uff1a</p> <pre><code>#[export_name = \"__main_argc_argv\"]\nfn exam_main(_env_json: u32, _str_len: i32) -&gt; i32 {\nreturn 0;\n}\n</code></pre> <p>\u7528\u6237\u6001\u52a0\u8f7d\u548c\u6302\u8f7d\u4ee3\u7801\uff0c\u548c C/C++ \u4e2d\u7c7b\u4f3c\uff1a</p> <p>```rust,ignore     let obj_ptr =         binding::wasm_load_bpf_object(bpf_object.as_ptr() as u32, bpf_object.len() as i32);     if obj_ptr == 0 {         println!(\"Failed to load bpf object\");         return 1;     }     let attach_result = binding::wasm_attach_bpf_program(         obj_ptr,         \"handle_exec\\0\".as_ptr() as u32,         \"\\0\".as_ptr() as u32,     );     .. <pre><code>polling ring buffer\uff1a\n\n```rust,ignore\n    let map_fd = binding::wasm_bpf_map_fd_by_name(obj_ptr, \"rb\\0\".as_ptr() as u32);\n    if map_fd &lt; 0 {\n        println!(\"Failed to get map fd: {}\", map_fd);\n        return 1;\n    }\n    // binding::wasm\n    let buffer = [0u8; 256];\n    loop {\n        // polling the buffer\n        binding::wasm_bpf_buffer_poll(\n            obj_ptr,\n            map_fd,\n            handle_event as i32,\n            0,\n            buffer.as_ptr() as u32,\n            buffer.len() as i32,\n            100,\n        );\n    }\n</code></pre></p> <p>\u4f7f\u7528 handler \u63a5\u6536\u8fd4\u56de\u503c\uff1a</p> <p>```rust,ignore</p> <p>extern \"C\" fn handle_event(_ctx: u32, data: u32, _data_sz: u32) {     let event_slice = unsafe { slice::from_raw_parts(data as const Event, 1) };     let event = &amp;event_slice[0];     let pid = event.pid;     let ppid = event.ppid;     let exit_code = event.exit_code;     if event.exit_event == 1 {         print!(             \"{:&lt;8} {:&lt;5} {:&lt;16} {:&lt;7} {:&lt;7} [{}]\",             \"TIME\",             \"EXIT\",             unsafe { CStr::from_ptr(event.comm.as_ptr() as const i8) }                 .to_str()                 .unwrap(),             pid,             ppid,             exit_code         );         .. } <pre><code>\u63a5\u4e0b\u6765\u5373\u53ef\u4f7f\u7528 cargo \u7f16\u8bd1\u8fd0\u884c\uff1a\n\n```console\n$ cargo build --target wasi32-wasm\n$ sudo wasm-bpf ./target/wasm32-wasi/debug/rust-helloworld.wasm\nTIME     EXEC  sh               180245  33666   /bin/sh\nTIME     EXEC  which            180246  180245  /usr/bin/which\nTIME     EXIT  which            180246  180245  [0] (1ms)\nTIME     EXIT  sh               180245  33666   [0] (3ms)\nTIME     EXEC  sh               180247  33666   /bin/sh\nTIME     EXEC  ps               180248  180247  /usr/bin/ps\nTIME     EXIT  ps               180248  180247  [0] (23ms)\nTIME     EXIT  sh               180247  33666   [0] (25ms)\nTIME     EXEC  sh               180249  33666   /bin/sh\nTIME     EXEC  cpuUsage.sh      180250  180249  /root/.vscode-server-insiders/bin/a7d49b0f35f50e460835a55d20a00a735d1665a3/out/vs/base/node/cpuUsage.sh\n</code></pre></p>"},{"location":"blogs/how-to-write-rust-in-wasm.zh/#oci-ebpf","title":"\u4f7f\u7528 OCI \u955c\u50cf\u53d1\u5e03\u548c\u7ba1\u7406 eBPF \u7a0b\u5e8f","text":"<p>\u5f00\u653e\u5bb9\u5668\u534f\u8bae (OCI) \u662f\u4e00\u4e2a\u8f7b\u91cf\u7ea7\uff0c\u5f00\u653e\u7684\u6cbb\u7406\u7ed3\u6784\uff0c\u4e3a\u5bb9\u5668\u6280\u672f\u5b9a\u4e49\u4e86\u89c4\u8303\u548c\u6807\u51c6\u3002\u5728 Linux \u57fa\u91d1\u4f1a\u7684\u652f\u6301\u4e0b\u6210\u7acb\uff0c\u7531\u5404\u5927\u8f6f\u4ef6\u4f01\u4e1a\u6784\u6210\uff0c\u81f4\u529b\u4e8e\u56f4\u7ed5\u5bb9\u5668\u683c\u5f0f\u548c\u8fd0\u884c\u65f6\u521b\u5efa\u5f00\u653e\u7684\u884c\u4e1a\u6807\u51c6\u3002\u5176\u4e2d\u5305\u62ec\u4e86\u4f7f\u7528 Container Registries \u8fdb\u884c\u5de5\u4f5c\u7684 API\uff0c\u6b63\u5f0f\u540d\u79f0\u4e3a OCI \u5206\u53d1\u89c4\u8303 (\u53c8\u540d\u201cdistribution-spec\u201d)\u3002</p> <p>Docker \u4e5f\u5ba3\u5e03\u63a8\u51fa\u4e0e WebAssembly \u96c6\u6210 (Docker+Wasm) \u7684\u9996\u4e2a\u6280\u672f\u9884\u89c8\u7248\uff0c\u5e76\u8868\u793a\u516c\u53f8\u5df2\u52a0\u5165\u5b57\u8282\u7801\u8054\u76df (Bytecode Alliance)\uff0c\u6210\u4e3a\u6295\u7968\u6210\u5458\u3002Docker+Wasm \u8ba9\u5f00\u53d1\u8005\u80fd\u591f\u66f4\u5bb9\u6613\u5730\u5feb\u901f\u6784\u5efa\u9762\u5411 Wasm \u8fd0\u884c\u65f6\u7684\u5e94\u7528\u7a0b\u5e8f\u3002</p> <p>\u501f\u52a9\u4e8e Wasm \u7684\u76f8\u5173\u751f\u6001\uff0c\u53ef\u4ee5\u975e\u5e38\u65b9\u4fbf\u5730\u53d1\u5e03\u3001\u4e0b\u8f7d\u548c\u7ba1\u7406 eBPF \u7a0b\u5e8f\uff0c\u4f8b\u5982\uff0c\u4f7f\u7528 <code>wasm-to-oci</code> \u5de5\u5177\uff0c\u53ef\u4ee5\u5c06 Wasm \u7a0b\u5e8f\u6253\u5305\u4e3a OCI \u955c\u50cf\uff0c\u83b7\u53d6\u7c7b\u4f3c docker \u7684\u4f53\u9a8c\uff1a</p> <pre><code>wasm-to-oci push testdata/hello.wasm &lt;oci-registry&gt;.azurecr.io/wasm-to-oci:v1\nwasm-to-oci pull &lt;oci-registry&gt;.azurecr.io/wasm-to-oci:v1 --out test.wasm\n</code></pre> <p>\u6211\u4eec\u4e5f\u5c06\u5176\u96c6\u6210\u5230\u4e86 eunomia-bpf \u7684 ecli \u5de5\u5177\u4e2d\uff0c\u53ef\u4ee5\u4e00\u884c\u547d\u4ee4\u4ece\u4e91\u7aef\u7684 Github Packages \u4e2d\u4e0b\u8f7d\u5e76\u8fd0\u884c eBPF \u7a0b\u5e8f\uff0c\u6216\u901a\u8fc7 Github Packages \u53d1\u5e03\uff1a</p> <pre><code># push to Github Packages\necli push https://ghcr.io/eunomia-bpf/sigsnoop:latest\n# pull from Github Packages\necli pull https://ghcr.io/eunomia-bpf/sigsnoop:latest\n# run eBPF program\necli run https://ghcr.io/eunomia-bpf/sigsnoop:latest\n</code></pre> <p>\u6211\u4eec\u5df2\u7ecf\u5728 LMP \u9879\u76ee\u7684 eBPF Hub \u4e2d\uff0c\u6709\u4e00\u4e9b\u521b\u5efa\u7b26\u5408 OCI \u6807\u51c6\u7684 Wasm-eBPF \u5e94\u7528\u7a0b\u5e8f\uff0c\u5e76\u5229\u7528 ORAS \u7b80\u5316\u6269\u5c55 eBPF \u5e94\u7528\u5f00\u53d1\uff0c\u5206\u53d1\u3001\u52a0\u8f7d\u3001\u8fd0\u884c\u80fd\u529b\u7684\u5c1d\u8bd5[11]\uff0c\u4ee5\u53ca\u57fa\u4e8e Wasm \u540c\u65f6\u4f7f\u7528\u591a\u79cd\u4e0d\u540c\u8bed\u8a00\u5f00\u53d1 eBPF \u7684\u7528\u6237\u6001\u6570\u636e\u5904\u7406\u63d2\u4ef6\u7684\u5b9e\u8df5\u3002\u57fa\u4e8e\u6700\u65b0\u7684 Wasm-bpf \u6846\u67b6\uff0c\u6709\u66f4\u591a\u7684\u63a2\u7d22\u6027\u5de5\u4f5c\u53ef\u4ee5\u7ee7\u7eed\u5c55\u5f00\uff0c\u6211\u4eec\u5e0c\u671b\u5c1d\u8bd5\u6784\u5efa\u4e00\u4e2a\u5b8c\u6574\u7684\u9488\u5bf9 eBPF \u548c Wasm \u7a0b\u5e8f\u7684\u5305\u7ba1\u7406\u7cfb\u7edf\uff0c\u4ee5\u53ca\u66f4\u591a\u7684\u53ef\u4ee5\u63a2\u7d22\u7684\u5e94\u7528\u573a\u666f\u3002</p>"},{"location":"blogs/how-to-write-rust-in-wasm.zh/#_2","title":"\u603b\u7ed3","text":"<p>\u672c\u6587\u4ee5 Rust \u8bed\u8a00\u4e3a\u4f8b\uff0c\u8ba8\u8bba\u4e86\u4f7f\u7528 Rust \u7f16\u5199 eBPF \u7a0b\u5e8f\u5e76\u7f16\u8bd1\u4e3a Wasm \u6a21\u5757\u4ee5\u53ca\u4f7f\u7528 OCI \u955c\u50cf\u53d1\u5e03\u3001\u90e8\u7f72\u3001\u7ba1\u7406 eBPF \u7a0b\u5e8f\uff0c\u83b7\u5f97\u7c7b\u4f3c Docker \u7684\u4f53\u9a8c\u3002\u66f4\u5b8c\u6574\u7684\u4ee3\u7801\uff0c\u8bf7\u53c2\u8003\u6211\u4eec\u7684 Github \u4ed3\u5e93\uff1ahttps://github.com/eunomia-bpf/wasm-bpf.</p> <p>\u63a5\u4e0b\u6765\uff0c\u6211\u4eec\u4f1a\u7ee7\u7eed\u5b8c\u5584\u5728 Wasm \u4e2d\u4f7f\u7528\u591a\u79cd\u8bed\u8a00\u5f00\u53d1\u548c\u8fd0\u884c eBPF \u7a0b\u5e8f\u7684\u4f53\u9a8c\uff0c\u63d0\u4f9b\u66f4\u5b8c\u5584\u7684\u793a\u4f8b\u548c\u7528\u6237\u6001\u5f00\u53d1\u5e93/\u5de5\u5177\u94fe\uff0c\u4ee5\u53ca\u66f4\u5177\u4f53\u7684\u5e94\u7528\u573a\u666f\u3002</p>"},{"location":"blogs/how-to-write-rust-in-wasm.zh/#_3","title":"\u53c2\u8003\u8d44\u6599","text":"<ul> <li>wasm-bpf Github \u5f00\u6e90\u5730\u5740\uff1ahttps://github.com/eunomia-bpf/wasm-bpf</li> <li>\u4ec0\u4e48\u662f eBPF\uff1ahttps://ebpf.io/what-is-ebpf</li> <li>WASI-eBPF: https://github.com/WebAssembly/WASI/issues/513</li> <li>\u9f99\u8725\u793e\u533a eBPF \u6280\u672f\u63a2\u7d22 SIG https://openanolis.cn/sig/ebpfresearch</li> <li>eunomia-bpf \u9879\u76ee\uff1ahttps://github.com/eunomia-bpf/eunomia-bpf</li> <li>eunomia-bpf \u9879\u76ee\u9f99\u8725 Gitee \u955c\u50cf\uff1ahttps://gitee.com/anolis/eunomia</li> <li>Wasm-bpf: \u67b6\u8d77 Webassembly \u548c eBPF \u5185\u6838\u53ef\u7f16\u7a0b\u7684\u6865\u6881\uff1ahttps://mp.weixin.qq.com/s/2InV7z1wcWic5ifmAXSiew</li> <li>\u5f53 Wasm \u9047\u89c1 eBPF \uff1a\u4f7f\u7528 WebAssembly \u7f16\u5199\u3001\u5206\u53d1\u3001\u52a0\u8f7d\u8fd0\u884c eBPF \u7a0b\u5e8f\uff1ahttps://zhuanlan.zhihu.com/p/573941739</li> <li>Docker+Wasm\u6280\u672f\u9884\u89c8\uff1ahttps://zhuanlan.zhihu.com/p/583614628</li> <li>LMP eBPF-Hub: https://github.com/linuxkerneltravel/lmp</li> <li>wasm-to-oci: https://github.com/engineerd/wasm-to-oci</li> <li>btf2wit: https://github.com/eunomia-bpf/btf2wit</li> </ul>"},{"location":"blogs/introduce-to-wasm-bpf-bpf-community.zh/","title":"Wasm-bpf: \u67b6\u8d77 Webassembly \u548c eBPF \u5185\u6838\u53ef\u7f16\u7a0b\u7684\u6865\u6881","text":"<p>\u4f5c\u8005\uff1a\u90d1\u6631\u7b19\uff0c\u9648\u8302\u6797</p> <p>Wasm \u6700\u521d\u662f\u4ee5\u6d4f\u89c8\u5668\u5b89\u5168\u6c99\u76d2\u4e3a\u76ee\u7684\u5f00\u53d1\u7684\uff0c\u53d1\u5c55\u5230\u76ee\u524d\u4e3a\u6b62\uff0cWebAssembly \u5df2\u7ecf\u6210\u4e3a\u4e00\u4e2a\u7528\u4e8e\u4e91\u539f\u751f\u8f6f\u4ef6\u7ec4\u4ef6\u7684\u9ad8\u6027\u80fd\u3001\u8de8\u5e73\u53f0\u548c\u591a\u8bed\u8a00\u8f6f\u4ef6\u6c99\u7bb1\u73af\u5883\uff0cWasm \u8f7b\u91cf\u7ea7\u5bb9\u5668\u4e5f\u975e\u5e38\u9002\u5408\u4f5c\u4e3a\u4e0b\u4e00\u4ee3\u65e0\u670d\u52a1\u5668\u5e73\u53f0\u8fd0\u884c\u65f6\u3002\u53e6\u4e00\u4e2a\u4ee4\u4eba\u5174\u594b\u7684\u8d8b\u52bf\u662f eBPF \u7684\u5174\u8d77\uff0c\u5b83\u4f7f\u4e91\u539f\u751f\u5f00\u53d1\u4eba\u5458\u80fd\u591f\u6784\u5efa\u5b89\u5168\u7684\u7f51\u7edc\u3001\u670d\u52a1\u7f51\u683c\u548c\u591a\u79cd\u53ef\u89c2\u6d4b\u6027\u7ec4\u4ef6\uff0c\u5e76\u4e14\u5b83\u4e5f\u5728\u9010\u6b65\u6e17\u900f\u548c\u6df1\u5165\u5230\u5185\u6838\u7684\u5404\u4e2a\u7ec4\u4ef6\uff0c\u63d0\u4f9b\u66f4\u5f3a\u5927\u7684\u5185\u6838\u6001\u53ef\u7f16\u7a0b\u4ea4\u4e92\u80fd\u529b\u3002</p> <p>Wasm-bpf \u662f\u4e00\u4e2a\u5168\u65b0\u7684\u5f00\u6e90\u9879\u76ee[1]\uff0c\u5b83\u5b9a\u4e49\u4e86\u4e00\u5957 eBPF \u76f8\u5173\u7cfb\u7edf\u63a5\u53e3\u7684\u62bd\u8c61\uff0c\u5e76\u63d0\u4f9b\u4e86\u4e00\u5957\u5bf9\u5e94\u7684\u5f00\u53d1\u5de5\u5177\u94fe\u3001\u5e93\u4ee5\u53ca\u901a\u7528\u7684 Wasm + eBPF \u8fd0\u884c\u65f6\u5e73\u53f0\u5b9e\u4f8b\uff0c\u8ba9\u4efb\u610f Wasm \u865a\u62df\u673a\u6216\u8005 Wasm \u8f7b\u91cf\u7ea7\u5bb9\u5668\u4e2d\u7684\u5e94\u7528\uff0c\u6709\u80fd\u529b\u5c06\u4f7f\u7528\u573a\u666f\u4e0b\u6c89\u548c\u62d3\u5c55\u5230\u5185\u6838\u6001\uff0c\u83b7\u53d6\u5185\u6838\u6001\u548c\u7528\u6237\u6001\u7684\u51e0\u4e4e\u6240\u6709\u6570\u636e\uff0c\u5728\u7f51\u7edc\u3001\u5b89\u5168\u7b49\u591a\u4e2a\u65b9\u9762\u5b9e\u73b0\u5bf9\u6574\u4e2a\u64cd\u4f5c\u7cfb\u7edf\u5c42\u9762\u7684\u53ef\u7f16\u7a0b\u63a7\u5236\uff0c\u4ece\u800c\u6781\u5927\u7684\u62d3\u5c55 WebAssembly \u751f\u6001\u5728\u975e\u6d4f\u89c8\u5668\u7aef\u7684\u5e94\u7528\u573a\u666f\u3002</p>"},{"location":"blogs/introduce-to-wasm-bpf-bpf-community.zh/#ebpf-webassembly","title":"\u57fa\u4e8e eBPF \u7684\u7cfb\u7edf\u63a5\u53e3\uff0c\u4e3a\u4e91\u539f\u751f WebAssembly \u5e26\u6765\u66f4\u591a\u53ef\u80fd","text":""},{"location":"blogs/introduce-to-wasm-bpf-bpf-community.zh/#wasm-wasi","title":"Wasm &amp; WASI","text":"<p>\u4e5f\u8bb8\u4f60\u4e5f\u5df2\u7ecf\u770b\u8fc7 Solomon Hykes (Docker\u7684\u521b\u59cb\u4eba\u4e4b\u4e00)\u8fd9\u53e5\u8bdd\uff1a</p> <p>\u5982\u679c\u57282008\u5e74\u5df2\u7ecf\u6709\u4e86 Wasm + WASI\uff0c\u6211\u4eec\u6839\u672c\u4e0d\u9700\u8981\u521b\u5efa Docker\u3002 Wasm \u5c31\u6709\u8fd9\u4e48\u91cd\u8981\u3002 \u670d\u52a1\u7aef\u7684 WebAssembly \u662f\u8ba1\u7b97\u7684\u672a\u6765\u3002</p> <p>2022 \u5e74\uff0cWebAssembly\uff08\u901a\u5e38\u7f29\u5199\u4e3a Wasm\uff09\u6210\u4e3a\u4e86\u7126\u70b9\uff1a\u65b0\u7684 Wasm \u521d\u521b\u4f01\u4e1a\u51fa\u73b0\uff0c\u8001\u724c\u516c\u53f8\u5ba3\u5e03\u652f\u6301 Wasm\uff0cBytecode Alliance \u53d1\u5e03\u4e86\u8bb8\u591a Wasm \u6807\u51c6\uff0cCloud Native Computing Foundation \u4e3e\u529e\u4e86\u4e24\u6b21 WasmDay \u6d3b\u52a8\uff0c\u800c\u5176\u4e2d\u6700\u5927\u7684 Wasm \u7528\u6237\u4e4b\u4e00 Figma \u88ab Adobe \u4ee5\u60ca\u4eba\u7684 200 \u4ebf\u7f8e\u5143\u7684\u4ef7\u683c\u6536\u8d2d[2]\u3002</p> <p>Wasm \u662f\u4e00\u79cd\u4e8c\u8fdb\u5236\u683c\u5f0f\u3002\u8bb8\u591a\u4e0d\u540c\u7684\u8bed\u8a00\u90fd\u53ef\u4ee5\u7f16\u8bd1\u4e3a\u76f8\u540c\u7684\u683c\u5f0f\uff0c\u5e76\u4e14\u8be5\u4e8c\u8fdb\u5236\u683c\u5f0f\u53ef\u4ee5\u5728\u5927\u91cf\u64cd\u4f5c\u7cfb\u7edf\u548c\u4f53\u7cfb\u7ed3\u6784\u4e0a\u8fd0\u884c\u3002Java \u548c .NET \u5728\u8fd9\u65b9\u9762\u4e5f\u5f88\u76f8\u4f3c\uff0c\u4f46\u662f Wasm \u6709\u4e00\u4e2a\u91cd\u8981\u7684\u533a\u522b\uff1aWasm \u8fd0\u884c\u65f6\u4e0d\u4fe1\u4efb\u6267\u884c\u7684\u4e8c\u8fdb\u5236\u6587\u4ef6\u3002Wasm \u5e94\u7528\u7a0b\u5e8f\u88ab\u9694\u79bb\u5728\u6c99\u76d2\u4e2d\uff0c\u53ea\u80fd\u8bbf\u95ee\u7528\u6237\u660e\u786e\u5141\u8bb8\u7684\u8d44\u6e90\uff08\u5982\u6587\u4ef6\u6216\u73af\u5883\u53d8\u91cf\uff09\u3002Wasm \u8fd8\u6709\u8bb8\u591a\u5176\u4ed6\u7406\u60f3\u7684\u7279\u6027\uff08\u4f8b\u5982\u975e\u5e38\u51fa\u8272\u7684\u6027\u80fd\uff09\uff0c\u4f46\u6b63\u662f\u5b83\u7684\u5b89\u5168\u6a21\u578b\u4f7f Wasm \u5728\u5e7f\u6cdb\u7684\u73af\u5883\u4e2d\u4f7f\u7528\uff0c\u4ece\u6d4f\u89c8\u5668\u5230\u8fb9\u7f18\u548c IoT\uff0c\u751a\u81f3\u5230\u4e91\u7aef[3]\u3002</p> <p>\u56e0\u4e3a\u65e0\u6cd5\u4f9d\u8d56\u6d4f\u89c8\u5668\u4e2d\u73b0\u6709\u53ef\u7528\u7684 JavaScript \u5f15\u64ce\u63a5\u53e3\uff0c\u6240\u4ee5\u76ee\u524d\u5927\u591a\u6570\u5728\u6d4f\u89c8\u5668\u5916\u8fd0\u884c\u7684 Wasm \u8f7b\u91cf\u7ea7\u5bb9\u5668\u9700\u8981\u4f7f\u7528 WASI\uff08WebAssembly \u7cfb\u7edf\u63a5\u53e3\uff09\u3002\u8fd9\u4e9b\u8fd0\u884c\u65f6\u5141\u8bb8 Wasm \u5e94\u7528\u7a0b\u5e8f\u4ee5\u4e0e POSIX \u7c7b\u4f3c\uff08\u4f46\u4e0d\u5b8c\u5168\u76f8\u540c\uff09\u7684\u65b9\u5f0f\u4e0e\u5176 host \u64cd\u4f5c\u7cfb\u7edf\u4ea4\u4e92\u3002</p> <p>\u4f46\u662f\uff0c\u76f8\u5bf9\u4e8e\u4f20\u7edf\u7684\u5bb9\u5668\u4e2d\u53ef\u4ee5\u4f7f\u7528\u51e0\u4e4e\u6240\u6709\u7684\u7cfb\u7edf\u8c03\u7528\uff0c\u76ee\u524d WASI \u6240\u80fd\u63d0\u4f9b\u7684\u7cfb\u7edf\u8d44\u6e90\u975e\u5e38\u6709\u9650\uff0c\u76ee\u524d\u4ec5\u4ec5\u5728\u6587\u4ef6\u7cfb\u7edf\u3001socket \u7f51\u7edc\u8fde\u63a5\u7b49\u65b9\u9762\u63d0\u4f9b\u4e86\u4e00\u4e9b\u57fa\u672c\u7684\u652f\u6301\uff0c\u5bf9\u4e8e\u64cd\u4f5c\u7cfb\u7edf\u5e95\u5c42\u8d44\u6e90\u7684\u8bbf\u95ee\u3001\u63a7\u5236\u548c\u7ba1\u7406\u80fd\u529b\u4ecd\u7136\u5b58\u5728\u5927\u91cf\u7a7a\u767d\uff0c\u4f8b\u5982\u5bf9 Wasm \u6a21\u5757\u6216\u8005\u5916\u90e8\u5176\u4ed6\u8fdb\u7a0b\u7684\u6267\u884c\u8d44\u6e90\u9650\u5236\u4e0e\u884c\u4e3a\u89c2\u6d4b\uff0c\u5bf9\u7f51\u7edc\u5305\u7684\u5feb\u901f\u8f6c\u53d1\u548c\u5904\u7406\uff0c\u751a\u81f3\u548c wasm \u6c99\u7bb1\u5916\u7684\u5176\u4ed6\u8fdb\u7a0b\u8fdb\u884c\u901a\u4fe1\uff0c\u8bbf\u95ee\u5916\u8bbe\u7b49\uff0c\u90fd\u6ca1\u6709\u4e00\u4e2a\u6bd4\u8f83\u6210\u719f\u7684\u89e3\u51b3\u65b9\u6848\u3002\u8fd9\u4e5f\u4f7f\u5f97\u5927\u591a\u6570\u7684 Wasm \u8f7b\u91cf\u7ea7\u5bb9\u5668\u5728\u5b9e\u9645\u5e94\u7528\u4e2d\u8fd8\u662f\u4e3b\u8981\u96c6\u4e2d\u4e8e\u7eaf\u7cb9\u7684\u8ba1\u7b97\u5bc6\u96c6\u578b\u5e94\u7528\uff0c\u800c\u5728\u7f51\u7edc\u3001\u5b89\u5168\u7b49\u65b9\u9762\uff0c\u8fd8\u662f\u9700\u8981\u4f9d\u8d56\u4e8e\u4f20\u7edf\u7684\u5bb9\u5668\u6280\u672f\u3002</p> <p>\u8fd9\u4e5f\u662f\u6211\u4eec\u5e0c\u671b\u5efa\u7acb Wasm-bpf \u9879\u76ee\u7684\u521d\u8877\uff1a\u501f\u52a9\u5f53\u524d\u5185\u6838\u6001 eBPF \u63d0\u4f9b\u7684\u7cfb\u7edf\u63a5\u53e3\u4ee5\u53ca\u548c\u7528\u6237\u6001\u4ea4\u4e92\u7684\u80fd\u529b\uff0c\u62d3\u5c55\u6574\u4e2a WASI \u7684\u751f\u6001\u84dd\u56fe\uff0c\u4e3a Wasm \u5e94\u7528\u5e26\u6765\u66f4\u591a\u53ef\u80fd\u7684\u4f7f\u7528\u573a\u666f\uff0c\u540c\u65f6\u4e5f\u80fd\u5728\u7528\u6237\u6001\u589e\u5f3a eBPF \u7a0b\u5e8f\u7684\u80fd\u529b\u3002</p> <p>\u6216\u8005\u6362\u53e5\u8bdd\u8bf4\uff0c\u7c7b\u4f3c\u4e8e\u6d4f\u89c8\u5668\u4e2d\u8fd0\u884c\u7684 Wasm \u7a0b\u5e8f\uff0c\u53ef\u4ee5\u901a\u8fc7 JavaScript \u5f15\u64ce\u63a5\u53e3\u8bbf\u95ee\u6d4f\u89c8\u5668\u63d0\u4f9b\u7684\u5404\u79cd\u7cfb\u7edf\u8d44\u6e90\uff0cWasm-bpf \u7684\u65b9\u6848\u5c31\u662f\u501f\u52a9 eBPF \u865a\u62df\u673a\u63a5\u53e3\u8bbf\u95ee\u64cd\u4f5c\u7cfb\u7edf\u7684\u5404\u7c7b\u8d44\u6e90\uff1b\u5f97\u76ca\u4e8e eBPF \u76ee\u524d\u5728 Linux \u5185\u6838\u751a\u81f3 Windows \u7b49\u5176\u4ed6\u64cd\u4f5c\u7cfb\u7edf\u4e2d\u7684\u5e7f\u6cdb\u652f\u6301\uff0c\u4ee5\u53ca\u4e0d\u540c\u5185\u6838\u7248\u672c\u548c\u67b6\u6784\u4e4b\u95f4\u7684\u53ef\u79fb\u690d\u6027\uff0c\u548c\u5185\u6838 BPF \u9a8c\u8bc1\u5f15\u64ce\u7684\u53ef\u9760\u6027\uff0c\u6211\u4eec\u4ecd\u7136\u53ef\u4ee5\u5728\u4e00\u5b9a\u7a0b\u5ea6\u4e0a\u4fdd\u8bc1\u5e94\u7528\u7684\u53ef\u79fb\u690d\u6027\u548c\u5b89\u5168\u8fb9\u754c\u3002</p>"},{"location":"blogs/introduce-to-wasm-bpf-bpf-community.zh/#wasm-bpf-wasm-ebpf","title":"Wasm-bpf\uff1a\u8d85\u8f7b\u91cf\u7ea7 Wasm + eBPF \u901a\u7528\u8fd0\u884c\u65f6\u5e73\u53f0","text":"<p>Wasm-bpf \u9879\u76ee\u5df2\u7ecf\u5b9e\u73b0\u4e86\u5185\u6838\u6001 eBPF \u865a\u62df\u673a\u548c\u7528\u6237\u6001\u4e4b\u95f4\u7cfb\u7edf\u63a5\u53e3\u5b8c\u6574\u7684\u62bd\u8c61\u673a\u5236\uff0c\u5e76\u63d0\u4f9b\u4e86\u5bf9\u5e94\u7684\u5de5\u5177\u94fe\u4ee5\u5c06 eBPF \u5e94\u7528\u7f16\u8bd1\u4e3a Wasm \u6a21\u5757\uff0c\u5e2e\u52a9\u8fdb\u884c\u5185\u6838\u6001 eBPF \u548c\u7528\u6237\u6001 Wasm \u4e4b\u95f4\u65e0\u5e8f\u5217\u5316\uff0c\u5171\u4eab\u5185\u5b58\u7684\u9ad8\u6548\u53cc\u5411\u901a\u4fe1\uff0c\u5e76\u901a\u8fc7\u4ee3\u7801\u751f\u6210\u6280\u672f\uff0c\u63d0\u4f9b\u548c\u5176\u4ed6\u7528\u6237\u6001 eBPF \u5f00\u53d1\u6846\u67b6\u51e0\u4e4e\u4e00\u81f4\u7684\u3001\u7b80\u5355\u4fbf\u6377\u7684\u5f00\u53d1\u4f53\u9a8c\u3002\u501f\u52a9 Wasm \u7ec4\u4ef6\u6a21\u578b\u4e0d\u65ad\u5b8c\u5584\u7684\u751f\u6001\u652f\u6301\uff0c\u6211\u4eec\u4e5f\u53ef\u4ee5\u4e3a eBPF \u793e\u533a\u5e26\u6765\u66f4\u591a\u7528\u6237\u6001\u5f00\u53d1\u8bed\u8a00\uff0c\u4e0d\u540c\u8bed\u8a00\u5b9e\u73b0\u7684\u53ef\u89c2\u6d4b\u6027\u3001\u7f51\u7edc\u7b49 eBPF \u5e94\u7528\u548c\u6570\u636e\u5904\u7406\u63d2\u4ef6\u4e5f\u53ef\u4ee5\u88ab\u8f7b\u677e\u96c6\u6210\u3001\u590d\u7528\u3001\u7edf\u4e00\u7ba1\u7406\u3002</p> <p>\u5728\u51e0\u4e4e\u5df2\u7ecf\u6210\u4e3a eBPF \u7528\u6237\u6001\u4e8b\u5b9e\u4e0a\u7684 API \u6807\u51c6\u7684 libbpf \u5e93\uff0c\u548c WAMR(wasm-micro-runtime) \u4e4b\u4e0a\uff0c\u53ea\u9700\u8981 300+ \u884c\u4ee3\u7801\u5373\u53ef\u6784\u5efa\u5b8c\u6574\u7684\u901a\u7528 Wasm-eBPF \u8fd0\u884c\u7ec4\u4ef6\uff0c\u5e76\u652f\u6301\u5927\u591a\u6570\u7684 eBPF \u4f7f\u7528\u573a\u666f -- \u4efb\u4f55\u4eba\u7528\u4efb\u4f55\u4e3b\u6d41 Wasm \u8fd0\u884c\u65f6\uff0c\u6216\u8005\u4efb\u4f55 eBPF \u7528\u6237\u6001\u5e93\uff0c\u4ee5\u53ca\u4efb\u4f55\u7f16\u7a0b\u8bed\u8a00\uff0c\u90fd\u53ef\u4ee5\u8f7b\u677e\u6dfb\u52a0\u5bf9\u5e94\u7684\u865a\u62df\u673a\u652f\u6301\uff0c\u5e76\u590d\u7528\u6211\u4eec\u7684\u5de5\u5177\u94fe\u8f7b\u677e\u5b9e\u73b0 Wasm-eBPF \u7a0b\u5e8f\u7684\u7f16\u5199\u548c\u5f00\u53d1\u3002</p> <p>\u4e4b\u524d\u5728 eunomia-bpf \u9879\u76ee\u4e2d\uff0c\u5df2\u7ecf\u6709\u4e00\u4e9b\u5c06 eBPF \u548c Wasm \u7ed3\u5408\u7684\u63a2\u7d22[4]\uff0c\u4f46\u5b83\u5e76\u4e0d\u662f\u4e3a\u4e86 Wasm \u539f\u751f\u5e94\u7528\u548c\u8f7b\u91cf\u7ea7\u5bb9\u5668\u7684\u573a\u666f\u8bbe\u8ba1\u7684\uff0c\u4e0d\u7b26\u5408 Wasm-eBPF \u7684\u901a\u7528\u7f16\u7a0b\u6a21\u578b\uff0c\u53ea\u662f\u5c06 Wasm \u4f5c\u4e3a\u6570\u636e\u5904\u7406\u63d2\u4ef6\uff0c\u6027\u80fd\u4e5f\u8f83\u4e3a\u4f4e\u4e0b\u3002\u56e0\u6b64\u6211\u4eec\u521b\u5efa\u4e86\u4e00\u4e2a\u65b0\u7684\u5f00\u6e90\u4ed3\u5e93\uff0c\u8ba9 Wasm-bpf \u9879\u76ee\u4e13\u6ce8\u4e8e\u5229\u7528 eBPF \u589e\u5f3a\u548c\u6269\u5c55 WebAssembly \u4f7f\u7528\u573a\u666f\uff0c\u5e76\u8fdb\u4e00\u6b65\u5b8c\u5584\u5bf9\u5e94\u7684\u5de5\u5177\u94fe\u548c\u5f00\u53d1\u5e93\u652f\u6301\uff1ahttps://github.com/eunomia-bpf/wasm-bpf \u3002\u53cd\u8fc7\u6765\uff0c\u4e00\u4e2a\u901a\u7528\u7684 Wasm-eBPF \u5f00\u53d1\u6846\u67b6\uff0c\u501f\u52a9 Wasm \u76f8\u5173\u7684\u751f\u6001\u4e5f\u53ef\u4ee5\u4e3a eBPF \u76f8\u5173\u793e\u533a\u5728\u7528\u6237\u6001\u7684\u8fdb\u4e00\u6b65\u6df1\u5165\u62d3\u5c55\uff0c\u63d0\u4f9b\u66f4\u591a\u7684\u53ef\u80fd\u6027\u3002</p>"},{"location":"blogs/introduce-to-wasm-bpf-bpf-community.zh/#ebpf","title":"eBPF\uff1a\u5b89\u5168\u548c\u6709\u6548\u5730\u6269\u5c55\u5185\u6838","text":"<p>eBPF \u662f\u4e00\u9879\u9769\u547d\u6027\u7684\u6280\u672f\uff0c\u8d77\u6e90\u4e8e Linux \u5185\u6838\uff0c\u53ef\u4ee5\u5728\u64cd\u4f5c\u7cfb\u7edf\u7684\u5185\u6838\u4e2d\u8fd0\u884c\u6c99\u76d2\u7a0b\u5e8f\u3002\u5b83\u88ab\u7528\u6765\u5b89\u5168\u548c\u6709\u6548\u5730\u6269\u5c55\u5185\u6838\u7684\u529f\u80fd\uff0c\u800c\u4e0d\u9700\u8981\u6539\u53d8\u5185\u6838\u7684\u6e90\u4ee3\u7801\u6216\u52a0\u8f7d\u5185\u6838\u6a21\u5757\u3002eBPF \u901a\u8fc7\u5141\u8bb8\u5728\u64cd\u4f5c\u7cfb\u7edf\u5185\u8fd0\u884c\u6c99\u76d2\u7a0b\u5e8f\uff0c\u5e94\u7528\u7a0b\u5e8f\u5f00\u53d1\u4eba\u5458\u53ef\u4ee5\u5728\u8fd0\u884c\u65f6\uff0c\u53ef\u7f16\u7a0b\u5730\u5411\u64cd\u4f5c\u7cfb\u7edf\u52a8\u6001\u6dfb\u52a0\u989d\u5916\u7684\u529f\u80fd\u3002\u7136\u540e\uff0c\u64cd\u4f5c\u7cfb\u7edf\u4fdd\u8bc1\u5b89\u5168\u548c\u6267\u884c\u6548\u7387\uff0c\u5c31\u50cf\u5728\u5373\u65f6\u7f16\u8bd1\uff08JIT\uff09\u7f16\u8bd1\u5668\u548c\u9a8c\u8bc1\u5f15\u64ce\u7684\u5e2e\u52a9\u4e0b\u8fdb\u884c\u672c\u5730\u7f16\u8bd1\u4e00\u6837\u3002eBPF \u7a0b\u5e8f\u5728\u5185\u6838\u7248\u672c\u4e4b\u95f4\u662f\u53ef\u79fb\u690d\u7684\uff0c\u5e76\u4e14\u53ef\u4ee5\u81ea\u52a8\u66f4\u65b0\uff0c\u4ece\u800c\u907f\u514d\u4e86\u5de5\u4f5c\u8d1f\u8f7d\u4e2d\u65ad\u548c\u8282\u70b9\u91cd\u542f\u3002</p> <p>\u4eca\u5929\uff0ceBPF\u88ab\u5e7f\u6cdb\u7528\u4e8e\u5404\u7c7b\u573a\u666f\uff1a\u5728\u73b0\u4ee3\u6570\u636e\u4e2d\u5fc3\u548c\u4e91\u539f\u751f\u73af\u5883\u4e2d\uff0c\u53ef\u4ee5\u63d0\u4f9b\u9ad8\u6027\u80fd\u7684\u7f51\u7edc\u5305\u5904\u7406\u548c\u8d1f\u8f7d\u5747\u8861\uff1b\u4ee5\u975e\u5e38\u4f4e\u7684\u8d44\u6e90\u5f00\u9500\uff0c\u505a\u5230\u5bf9\u591a\u79cd\u7ec6\u7c92\u5ea6\u6307\u6807\u7684\u53ef\u89c2\u6d4b\u6027\uff0c\u5e2e\u52a9\u5e94\u7528\u7a0b\u5e8f\u5f00\u53d1\u4eba\u5458\u8ddf\u8e2a\u5e94\u7528\u7a0b\u5e8f\uff0c\u4e3a\u6027\u80fd\u6545\u969c\u6392\u9664\u63d0\u4f9b\u6d1e\u5bdf\u529b\uff1b\u4fdd\u969c\u5e94\u7528\u7a0b\u5e8f\u548c\u5bb9\u5668\u8fd0\u884c\u65f6\u7684\u5b89\u5168\u6267\u884c\uff0c\u7b49\u7b49\u3002\u53ef\u80fd\u6027\u662f\u65e0\u7a77\u7684\uff0c\u800c eBPF \u5728\u64cd\u4f5c\u7cfb\u7edf\u5185\u6838\u4e2d\u6240\u91ca\u653e\u7684\u521b\u65b0\u624d\u521a\u521a\u5f00\u59cb[3]\u3002</p>"},{"location":"blogs/introduce-to-wasm-bpf-bpf-community.zh/#ebpf-javascript","title":"eBPF \u7684\u672a\u6765\uff1a\u5185\u6838\u7684 JavaScript \u53ef\u7f16\u7a0b\u63a5\u53e3","text":"<p>\u5bf9\u4e8e\u6d4f\u89c8\u5668\u800c\u8a00\uff0cJavaScript \u7684\u5f15\u5165\u5e26\u6765\u7684\u53ef\u7f16\u7a0b\u6027\u5f00\u542f\u4e86\u4e00\u573a\u5de8\u5927\u7684\u9769\u547d\uff0c\u4f7f\u6d4f\u89c8\u5668\u53d1\u5c55\u6210\u4e3a\u51e0\u4e4e\u72ec\u7acb\u7684\u64cd\u4f5c\u7cfb\u7edf\u3002\u73b0\u5728\u8ba9\u6211\u4eec\u56de\u5230 eBPF\uff1a\u4e3a\u4e86\u7406\u89e3 eBPF \u5bf9 Linux \u5185\u6838\u7684\u53ef\u7f16\u7a0b\u6027\u5f71\u54cd\uff0c\u5bf9 Linux \u5185\u6838\u7684\u7ed3\u6784\u4ee5\u53ca\u5b83\u5982\u4f55\u4e0e\u5e94\u7528\u7a0b\u5e8f\u548c\u786c\u4ef6\u8fdb\u884c\u4ea4\u4e92\u6709\u4e00\u4e2a\u9ad8\u5c42\u6b21\u7684\u7406\u89e3\u662f\u6709\u5e2e\u52a9\u7684[4]\u3002</p> <p>Linux \u5185\u6838\u7684\u4e3b\u8981\u76ee\u7684\u662f\u62bd\u8c61\u51fa\u786c\u4ef6\u6216\u865a\u62df\u786c\u4ef6\uff0c\u5e76\u63d0\u4f9b\u4e00\u4e2a\u4e00\u81f4\u7684API\uff08\u7cfb\u7edf\u8c03\u7528\uff09\uff0c\u5141\u8bb8\u5e94\u7528\u7a0b\u5e8f\u8fd0\u884c\u548c\u5171\u4eab\u8d44\u6e90\u3002\u4e3a\u4e86\u5b9e\u73b0\u8fd9\u4e2a\u76ee\u7684\uff0c\u6211\u4eec\u7ef4\u62a4\u4e86\u4e00\u7cfb\u5217\u5b50\u7cfb\u7edf\u548c\u5c42\uff0c\u4ee5\u5206\u914d\u8fd9\u4e9b\u8d23\u4efb[5]\u3002\u6bcf\u4e2a\u5b50\u7cfb\u7edf\u901a\u5e38\u5141\u8bb8\u67d0\u79cd\u7a0b\u5ea6\u7684\u914d\u7f6e\uff0c\u4ee5\u8003\u8651\u5230\u7528\u6237\u7684\u4e0d\u540c\u9700\u6c42\u3002\u5982\u679c\u4e0d\u80fd\u914d\u7f6e\u6240\u9700\u7684\u884c\u4e3a\uff0c\u5c31\u9700\u8981\u6539\u53d8\u5185\u6838\uff0c\u4ece\u5386\u53f2\u4e0a\u770b\uff0c\u6539\u53d8\u5185\u6838\u7684\u884c\u4e3a\uff0c\u6216\u8005\u8ba9\u7528\u6237\u7f16\u5199\u7684\u7a0b\u5e8f\u80fd\u591f\u5728\u5185\u6838\u4e2d\u8fd0\u884c\uff0c\u5c31\u6709\u4e24\u79cd\u9009\u62e9:</p> \u672c\u5730\u652f\u6301\u5185\u6838\u6a21\u5757 \u5199\u4e00\u4e2a\u5185\u6838\u6a21\u5757 \u6539\u53d8\u5185\u6838\u6e90\u4ee3\u7801\uff0c\u5e76\u8bf4\u670dLinux\u5185\u6838\u793e\u533a\u76f8\u4fe1\u8fd9\u79cd\u6539\u53d8\u662f\u5fc5\u8981\u7684\u3002\u7b49\u5f85\u51e0\u5e74\uff0c\u8ba9\u65b0\u7684\u5185\u6838\u7248\u672c\u6210\u4e3a\u4e00\u79cd\u5546\u54c1\u3002 \u5b9a\u671f\u4fee\u590d\u5b83\uff0c\u56e0\u4e3a\u6bcf\u4e2a\u5185\u6838\u7248\u672c\u90fd\u53ef\u80fd\u7834\u574f\u5b83\u3002\u7531\u4e8e\u7f3a\u4e4f\u5b89\u5168\u8fb9\u754c\uff0c\u5192\u7740\u7834\u574f\u4f60\u7684Linux\u5185\u6838\u7684\u98ce\u9669 <p>\u5b9e\u9645\u4e0a\uff0c\u4e24\u79cd\u65b9\u6848\u90fd\u4e0d\u5e38\u7528\uff0c\u524d\u8005\u6210\u672c\u592a\u9ad8\uff0c\u540e\u8005\u5219\u51e0\u4e4e\u6ca1\u6709\u53ef\u79fb\u690d\u6027\u3002</p> <p>\u6709\u4e86 eBPF\uff0c\u5c31\u6709\u4e86\u4e00\u4e2a\u65b0\u7684\u9009\u62e9\uff0c\u53ef\u4ee5\u91cd\u65b0\u7f16\u7a0b Linux \u5185\u6838\u7684\u884c\u4e3a\uff0c\u800c\u4e0d\u9700\u8981\u6539\u53d8\u5185\u6838\u7684\u6e90\u4ee3\u7801\u6216\u52a0\u8f7d\u5185\u6838\u6a21\u5757\uff0c\u540c\u65f6\u4fdd\u8bc1\u5728\u4e0d\u540c\u5185\u6838\u7248\u672c\u4e4b\u95f4\u4e00\u5b9a\u7a0b\u5ea6\u4e0a\u7684\u884c\u4e3a\u4e00\u81f4\u6027\u548c\u517c\u5bb9\u6027\u3001\u4ee5\u53ca\u5b89\u5168\u6027[6]\u3002\u4e3a\u4e86\u5b9e\u73b0\u8fd9\u4e2a\u76ee\u7684\uff0ceBPF \u7a0b\u5e8f\u4e5f\u9700\u8981\u6709\u4e00\u5957\u5bf9\u5e94\u7684 API\uff0c\u5141\u8bb8\u7528\u6237\u5b9a\u4e49\u7684\u5e94\u7528\u7a0b\u5e8f\u8fd0\u884c\u548c\u5171\u4eab\u8d44\u6e90 --- \u6362\u53e5\u8bdd\u8bf4\uff0c\u67d0\u79cd\u610f\u4e49\u4e0a\u8bb2 eBPF \u865a\u62df\u673a\u4e5f\u63d0\u4f9b\u4e86\u4e00\u5957\u7c7b\u4f3c\u4e8e\u7cfb\u7edf\u8c03\u7528\u7684\u673a\u5236\uff0c\u501f\u52a9 eBPF \u548c\u7528\u6237\u6001\u901a\u4fe1\u7684\u673a\u5236\uff0cWasm \u865a\u62df\u673a\u548c\u7528\u6237\u6001\u5e94\u7528\u4e5f\u53ef\u4ee5\u83b7\u5f97\u8fd9\u5957\u201c\u7cfb\u7edf\u8c03\u7528\u201d\u7684\u5b8c\u6574\u4f7f\u7528\u6743\uff0c\u4e00\u65b9\u9762\u80fd\u53ef\u7f16\u7a0b\u5730\u6269\u5c55\u4f20\u7edf\u7684\u7cfb\u7edf\u8c03\u7528\u7684\u80fd\u529b\uff0c\u53e6\u4e00\u65b9\u9762\u80fd\u5728\u7f51\u7edc\u3001\u6587\u4ef6\u7cfb\u7edf\u7b49\u8bb8\u591a\u5c42\u6b21\u5b9e\u73b0\u66f4\u9ad8\u6548\u7684\u53ef\u7f16\u7a0b IO \u5904\u7406\u3002</p> <p></p> <p>\u6b63\u5982\u4e0a\u56fe\u6240\u793a\uff0c\u5f53\u4eca\u7684 Linux \u5185\u6838\u6b63\u5728\u5411\u4e00\u4e2a\u65b0\u7684\u5185\u6838\u6a21\u578b\u6f14\u5316\uff1a\u7528\u6237\u5b9a\u4e49\u7684\u5e94\u7528\u7a0b\u5e8f\u53ef\u4ee5\u5728\u5185\u6838\u6001\u548c\u7528\u6237\u6001\u540c\u65f6\u6267\u884c\uff0c\u7528\u6237\u6001\u901a\u8fc7\u4f20\u7edf\u7684\u7cfb\u7edf\u8c03\u7528\u8bbf\u95ee\u7cfb\u7edf\u8d44\u6e90\uff0c\u5185\u6838\u6001\u5219\u901a\u8fc7 BPF Helper Calls \u548c\u7cfb\u7edf\u7684\u5404\u4e2a\u90e8\u5206\u5b8c\u6210\u4ea4\u4e92\u3002\u622a\u6b62 2023 \u5e74\u521d\uff0c\u5185\u6838\u4e2d\u7684 eBPF \u865a\u62df\u673a\u4e2d\u5df2\u7ecf\u6709 220 \u591a\u4e2aHelper \u7cfb\u7edf\u63a5\u53e3\uff0c\u6db5\u76d6\u4e86\u975e\u5e38\u591a\u7684\u5e94\u7528\u573a\u666f\u3002</p> <p>\u503c\u5f97\u6ce8\u610f\u7684\u662f\uff0cBPF Helper Call \u548c\u7cfb\u7edf\u8c03\u7528\u4e8c\u8005\u5e76\u4e0d\u662f\u7ade\u4e89\u5173\u7cfb\uff0c\u5b83\u4eec\u7684\u7f16\u7a0b\u6a21\u578b\u548c\u6709\u6027\u80fd\u4f18\u52bf\u7684\u573a\u666f\u5b8c\u5168\u4e0d\u540c\uff0c\u4e5f\u4e0d\u4f1a\u5b8c\u5168\u66ff\u4ee3\u5bf9\u65b9\u3002\u5bf9 Wasm \u548c Wasi \u76f8\u5173\u751f\u6001\u6765\u8bf4\uff0c\u60c5\u51b5\u4e5f\u7c7b\u4f3c\uff0c\u4e13\u95e8\u8bbe\u8ba1\u7684 wasi \u63a5\u53e3\u9700\u8981\u7ecf\u5386\u4e00\u4e2a\u6f2b\u957f\u7684\u6807\u51c6\u5316\u8fc7\u7a0b\uff0c\u4f46\u53ef\u80fd\u5728\u7279\u5b9a\u573a\u666f\u80fd\u4e3a\u7528\u6237\u6001\u5e94\u7528\u83b7\u53d6\u66f4\u4f73\u7684\u6027\u80fd\u548c\u53ef\u79fb\u690d\u6027\u4fdd\u8bc1\uff0c\u800c eBPF \u5728\u4fdd\u8bc1\u6c99\u7bb1\u672c\u8d28\u548c\u53ef\u79fb\u690d\u6027\u7684\u524d\u63d0\u4e0b\uff0c\u53ef\u4ee5\u63d0\u4f9b\u4e00\u4e2a\u5feb\u901f\u7075\u6d3b\u7684\u6269\u5c55\u7cfb\u7edf\u63a5\u53e3\u7684\u65b9\u6848\u3002</p> <p>\u76ee\u524d\u7684 eBPF \u4ecd\u7136\u5904\u4e8e\u65e9\u671f\u9636\u6bb5\uff0c\u4f46\u662f\u501f\u52a9\u5f53\u524d eBPF \u63d0\u4f9b\u7684\u5185\u6838\u63a5\u53e3\u548c\u7528\u6237\u6001\u4ea4\u4e92\u7684\u80fd\u529b\uff0c\u7ecf\u7531 Wasm-bpf \u7684\u7cfb\u7edf\u63a5\u53e3\u8f6c\u6362\uff0cWasm \u865a\u62df\u673a\u4e2d\u7684\u5e94\u7528\u5df2\u7ecf\u51e0\u4e4e\u6709\u80fd\u529b\u83b7\u53d6\u5185\u6838\u4ee5\u53ca\u7528\u6237\u6001\u4efb\u610f\u4e00\u4e2a\u51fd\u6570\u8c03\u7528\u7684\u6570\u636e\u548c\u8fd4\u56de\u503c\uff08kprobe\uff0cuprobe...\uff09\uff1b\u4ee5\u5f88\u4f4e\u7684\u4ee3\u4ef7\u6536\u96c6\u548c\u7406\u89e3\u6240\u6709\u7cfb\u7edf\u8c03\u7528\uff0c\u5e76\u83b7\u53d6\u6240\u6709\u7f51\u7edc\u64cd\u4f5c\u7684\u6570\u636e\u5305\u548c\u5957\u63a5\u5b57\u7ea7\u522b\u7684\u6570\u636e\uff08tracepoint\uff0csocket...\uff09\uff1b\u5728\u7f51\u7edc\u5305\u5904\u7406\u89e3\u51b3\u65b9\u6848\u4e2d\u6dfb\u52a0\u989d\u5916\u7684\u534f\u8bae\u5206\u6790\u5668\uff0c\u5e76\u8f7b\u677e\u5730\u7f16\u7a0b\u4efb\u4f55\u8f6c\u53d1\u903b\u8f91\uff08XDP\uff0cTC...\uff09\uff0c\u4ee5\u6ee1\u8db3\u4e0d\u65ad\u53d8\u5316\u7684\u9700\u6c42\uff0c\u800c\u65e0\u9700\u79bb\u5f00Linux\u5185\u6838\u7684\u6570\u636e\u5305\u5904\u7406\u73af\u5883\u3002</p> <p>\u4e0d\u4ec5\u5982\u6b64\uff0ceBPF \u8fd8\u6709\u80fd\u529b\u5f80\u7528\u6237\u7a7a\u95f4\u4efb\u610f\u8fdb\u7a0b\u7684\u4efb\u610f\u5730\u5740\u5199\u5165\u6570\u636e\uff08bpf_probe_write_user[7]\uff09\uff0c\u6709\u9650\u5ea6\u5730\u4fee\u6539\u5185\u6838\u51fd\u6570\u7684\u8fd4\u56de\u503c\uff08bpf_override_return[8]\uff09\uff0c\u751a\u81f3\u5728\u5185\u6838\u6001\u76f4\u63a5\u6267\u884c\u67d0\u4e9b\u7cfb\u7edf\u8c03\u7528[9]\uff1b\u6240\u5e78\u7684\u662f\uff0ceBPF \u5728\u52a0\u8f7d\u8fdb\u5185\u6838\u4e4b\u524d\u5bf9\u5b57\u8282\u7801\u4f1a\u8fdb\u884c\u4e25\u683c\u7684\u5b89\u5168\u68c0\u67e5\uff0c\u786e\u4fdd\u6ca1\u6709\u5185\u5b58\u8d8a\u754c\u7b49\u64cd\u4f5c\uff0c\u540c\u65f6\uff0c\u8bb8\u591a\u53ef\u80fd\u4f1a\u6269\u5927\u653b\u51fb\u9762\u3001\u5e26\u6765\u5b89\u5168\u98ce\u9669\u7684\u529f\u80fd\u90fd\u662f\u9700\u8981\u5728\u7f16\u8bd1\u5185\u6838\u65f6\u660e\u786e\u9009\u62e9\u542f\u7528\u624d\u80fd\u4f7f\u7528\u7684\uff1b\u5728 Wasm \u865a\u62df\u673a\u5c06\u5b57\u8282\u7801\u52a0\u8f7d\u8fdb\u5185\u6838\u4e4b\u524d\uff0c\u4e5f\u53ef\u4ee5\u660e\u786e\u9009\u62e9\u542f\u7528\u6216\u8005\u7981\u7528\u67d0\u4e9b eBPF \u529f\u80fd\uff0c\u4ee5\u786e\u4fdd\u6c99\u7bb1\u7684\u5b89\u5168\u6027\u3002</p> <p>\u6240\u6709\u7684\u8fd9\u4e9b\u573a\u666f\u90fd\u4e0d\u9700\u8981\u79bb\u5f00 Wasm \u8f7b\u91cf\u7ea7\u5bb9\u5668\uff1a\u4e0d\u50cf\u4f20\u7edf\u7684\u4f7f\u7528 Wasm \u4f5c\u4e3a\u6570\u636e\u5904\u7406\u6216\u8005\u63a7\u5236\u63d2\u4ef6\u7684\u5e94\u7528\u4e2d\uff0c\u8fd9\u4e9b\u6b65\u9aa4\u7531 Wasm \u865a\u62df\u673a\u5916\u7684\u903b\u8f91\u5b9e\u73b0\uff0c\u73b0\u5728\u53ef\u4ee5\u5728 Wasm \u8f7b\u91cf\u7ea7\u5bb9\u5668\u4e2d\u5b9e\u73b0\u5bf9 eBPF \u4ee5\u53ca eBPF \u80fd\u8bbf\u95ee\u7684\u51e0\u4e4e\u6240\u6709\u7cfb\u7edf\u8d44\u6e90\uff0c\u5b8c\u6574\u7684\u63a7\u5236\u548c\u4ea4\u4e92\uff0c\u751a\u81f3\u5b9e\u65f6\u751f\u6210 eBPF \u4ee3\u7801\u6539\u53d8\u5185\u6838\u7684\u884c\u4e3a\u903b\u8f91\uff0c\u5b9e\u73b0\u6574\u4e2a\u7cfb\u7edf\u4ece\u7528\u6237\u6001\u6269\u5c55\u5230\u5185\u6838\u6001\u7684\u53ef\u7f16\u7a0b\u6027\u3002</p>"},{"location":"blogs/introduce-to-wasm-bpf-bpf-community.zh/#wasm-ebpf","title":"Wasm \u5bf9 eBPF \u7684\u7528\u6237\u6001\u589e\u5f3a\uff1a\u7ec4\u4ef6\u6a21\u578b","text":"<p>\u6807\u51c6\u5f88\u5c11\u662f\u4e00\u4e2a\u751f\u6001\u7cfb\u7edf\u4e2d\u6700\u4ee4\u4eba\u5174\u594b\u7684\u90e8\u5206\u3002\u800c\u4e14\uff0c\u968f\u7740 \u201c\u7ec4\u4ef6\u6a21\u578b\u201d \u8fd9\u6837\u7684\u540d\u5b57\uff0c\u6fc0\u8d77\u5174\u594b\u611f\u786e\u5b9e\u662f\u4e00\u9879\u8270\u5de8\u7684\u4efb\u52a1\u3002\u4f46\u662f\uff0c\u5728\u8fd9\u4e2a\u4e4f\u5473\u7684\u540d\u5b57\u80cc\u540e\u662f Wasm \u4e3a\u8f6f\u4ef6\u4e16\u754c\u5e26\u6765\u7684\u6700\u91cd\u8981\u7684\u521b\u65b0\u3002</p> <p>\u7ec4\u4ef6\u6a21\u578b\u63cf\u8ff0\u4e86 Wasm \u4e8c\u8fdb\u5236\u6587\u4ef6\u4e4b\u95f4\u5982\u4f55\u4ea4\u4e92\u7684\u65b9\u5f0f\u3002\u66f4\u5177\u4f53\u5730\u8bf4\uff0c\u4e24\u4e2a\u7ec4\u4ef6\u53ef\u4ee5\u544a\u8bc9\u5bf9\u65b9\u5b83\u4eec\u63d0\u4f9b\u7684\u670d\u52a1\u4ee5\u53ca\u9700\u8981\u5c65\u884c\u7684\u671f\u671b\u3002\u7136\u540e\uff0cWasm \u6a21\u5757\u53ef\u4ee5\u5229\u7528\u5f7c\u6b64\u7684\u80fd\u529b\u3002\u8fd9\u4e3a\u8f6f\u4ef6\u5f00\u53d1\u4eba\u5458\u63d0\u4f9b\u4e86\u4e00\u79cd\u65b0\u7684\u5efa\u7acb\u5e94\u7528\u7a0b\u5e8f\u7684\u65b9\u5f0f\u3002\u5f00\u53d1\u4eba\u5458\u53ef\u4ee5\u58f0\u660e\u5e94\u7528\u7a0b\u5e8f\u6240\u9700\u7684\u7ec4\u4ef6\uff08\u6216\u8005\u66f4\u62bd\u8c61\u5730\u8bf4\uff0c\u5e94\u7528\u7a0b\u5e8f\u6240\u9700\u7684\u529f\u80fd\uff09\uff0c\u7136\u540e Wasm \u8fd0\u884c\u65f6\u53ef\u4ee5\u4ee3\u8868\u7528\u6237\u7ec4\u88c5\u6b63\u786e\u7684\u7ec4\u4ef6\u96c6\u5408\u3002\u7ec4\u4ef6\u6a21\u578b\u6b63\u5728\u8fc5\u901f\u6210\u719f\uff0c\u5df2\u7ecf\u51fa\u73b0\u4e86\u53c2\u8003\u5b9e\u73b0\u30022023 \u5e74\u5c06\u662f\u7ec4\u4ef6\u6a21\u578b\u5f00\u59cb\u91cd\u65b0\u5b9a\u4e49\u6211\u4eec\u5982\u4f55\u7f16\u5199\u8f6f\u4ef6\u7684\u4e00\u5e74[10]\u3002</p> <p>\u501f\u52a9 Wasm \u7684\u76f8\u5173\u751f\u6001\uff0c\u5c24\u5176\u662f\u57fa\u4e8e Wasm \u7684\u8f7b\u91cf\u7ea7\u5bb9\u5668\u6280\u672f\u3001\u7ec4\u4ef6\u6a21\u578b\uff0c\u6211\u4eec\u540c\u6837\u4e5f\u53ef\u4ee5\u7ed9 eBPF \u7684\u5e94\u7528\u8d4b\u4e88\u5982\u4e0b\u7279\u6027\uff1a</p> <ul> <li><code>\u53ef\u79fb\u690d</code>\uff1a\u8ba9 eBPF \u5de5\u5177\u548c\u5e94\u7528\u5b8c\u5168\u5e73\u53f0\u65e0\u5173\u3001\u53ef\u79fb\u690d\uff0c\u4e0d\u9700\u8981\u8fdb\u884c\u91cd\u65b0\u7f16\u8bd1\u5373\u53ef\u4ee5\u8de8\u5e73\u53f0\u5206\u53d1\uff1b</li> <li><code>\u9694\u79bb\u6027</code>\uff1a\u501f\u52a9 Wasm \u7684\u53ef\u9760\u6027\u548c\u9694\u79bb\u6027\uff0c\u8ba9 eBPF \u7a0b\u5e8f\u7684\u52a0\u8f7d\u548c\u6267\u884c\u3001\u4ee5\u53ca\u7528\u6237\u6001\u7684\u6570\u636e\u5904\u7406\u6d41\u7a0b\u66f4\u52a0\u5b89\u5168\u53ef\u9760\uff1b\u4e8b\u5b9e\u4e0a\u4e00\u4e2a eBPF \u5e94\u7528\u7684\u7528\u6237\u6001\u63a7\u5236\u4ee3\u7801\u3001\u6570\u636e\u5904\u7406\u4ee3\u7801\u7684\u90e8\u5206\u901a\u5e38\u8fdc\u8fdc\u591a\u4e8e\u5185\u6838\u6001\uff1b</li> <li><code>\u5305\u7ba1\u7406</code>\uff1a\u501f\u52a9 Wasm \u7684\u751f\u6001\u548c\u5de5\u5177\u94fe\uff0c\u5b8c\u6210 eBPF \u7a0b\u5e8f\u6216\u5de5\u5177\u7684\u5206\u53d1\u3001\u7ba1\u7406\u3001\u52a0\u8f7d\u7b49\u5de5\u4f5c\uff0c\u76ee\u524d eBPF \u7a0b\u5e8f\u6216\u5de5\u5177\u751f\u6001\u4e5f\u7f3a\u4e4f\u4e00\u4e2a\u901a\u7528\u7684\u5305\u7ba1\u7406\u6216\u63d2\u4ef6\u7ba1\u7406\u7cfb\u7edf\uff1b</li> <li><code>\u8de8\u8bed\u8a00</code>\uff1a\u76ee\u524d eBPF \u7a0b\u5e8f\u7531\u591a\u79cd\u7528\u6237\u6001\u8bed\u8a00\u5f00\u53d1\uff08\u5982 Go\\Rust\\C\\C++\\Python \u7b49\uff09\uff0c\u8d85\u8fc7 30 \u79cd\u7f16\u7a0b\u8bed\u8a00\u53ef\u4ee5\u88ab\u7f16\u8bd1\u6210 WebAssembly \u6a21\u5757\uff0c\u53ef\u4ee5\u5141\u8bb8\u5404\u79cd\u80cc\u666f\u7684\u5f00\u53d1\u4eba\u5458\uff08C\u3001Go\u3001Rust\u3001Java\u3001TypeScript \u7b49\uff09\u7528\u4ed6\u4eec\u9009\u62e9\u7684\u8bed\u8a00\u7f16\u5199 eBPF \u7684\u7528\u6237\u6001\u7a0b\u5e8f\uff0c\u800c\u4e0d\u9700\u8981\u5b66\u4e60\u65b0\u7684\u8bed\u8a00\uff0c\u751a\u81f3\u6211\u4eec\u53ef\u4ee5\u5c06 Wasm \u52a8\u6001\u7ffb\u8bd1\u4e3a eBPF \u7a0b\u5e8f\uff0c\u52a0\u8f7d\u8fdb\u5165\u5185\u6838\uff0c\u6216\u8005\u5728 Wasm \u8f7b\u91cf\u7ea7\u5bb9\u5668\u4e2d\u76f4\u63a5\u751f\u6210 eBPF \u5b57\u8282\u7801\uff1b</li> <li><code>\u654f\u6377\u6027</code>\uff1a\u5bf9\u4e8e\u5927\u578b\u7684 eBPF \u5e94\u7528\u7a0b\u5e8f\uff0c\u53ef\u4ee5\u4f7f\u7528 Wasm \u4f5c\u4e3a\u63d2\u4ef6\u6269\u5c55\u5e73\u53f0\uff1a\u6269\u5c55\u7a0b\u5e8f\u53ef\u4ee5\u5728\u8fd0\u884c\u65f6\u76f4\u63a5\u4ece\u63a7\u5236\u5e73\u9762\u4ea4\u4ed8\u548c\u91cd\u65b0\u52a0\u8f7d\u3002\u8fd9\u4e0d\u4ec5\u610f\u5473\u7740\u6bcf\u4e2a\u4eba\u90fd\u53ef\u4ee5\u4f7f\u7528\u5b98\u65b9\u548c\u672a\u7ecf\u4fee\u6539\u7684\u5e94\u7528\u7a0b\u5e8f\u6765\u52a0\u8f7d\u81ea\u5b9a\u4e49\u6269\u5c55\uff0c\u800c\u4e14\u4efb\u4f55 eBPF \u7a0b\u5e8f\u7684\u9519\u8bef\u4fee\u590d\u548c/\u6216\u66f4\u65b0\u90fd\u53ef\u4ee5\u5728\u8fd0\u884c\u65f6\u63a8\u9001\u548c/\u6216\u6d4b\u8bd5\uff0c\u800c\u4e0d\u9700\u8981\u66f4\u65b0\u548c/\u6216\u91cd\u65b0\u90e8\u7f72\u4e00\u4e2a\u65b0\u7684\u4e8c\u8fdb\u5236\uff1b\u5bf9\u4e8e\u53ef\u89c2\u6d4b\u6027\u5e94\u7528\u6765\u8bf4\uff0c\u9700\u8981\u66f4\u65b0\u6570\u636e\u5904\u7406\u63d2\u4ef6\uff0c\u4e5f\u65e0\u9700\u7ecf\u5386\u91cd\u65b0\u7f16\u8bd1\u90e8\u7f72\u6574\u4e2a\u5e94\u7528\u7a0b\u5e8f\u7684\u8fc7\u7a0b\uff1b</li> <li><code>\u8f7b\u91cf\u7ea7</code>\uff1aWebAssembly \u5fae\u670d\u52a1\u6d88\u8017 1% \u7684\u8d44\u6e90\uff0c\u4e0e Linux \u5bb9\u5668\u5e94\u7528\u76f8\u6bd4\uff0c\u51b7\u542f\u52a8\u7684\u65f6\u95f4\u662f 1%\uff1b\u5bf9\u4e8e\u5927\u91cf\u7684\u5c0f\u578b eBPF \u7a0b\u5e8f\u9700\u8981\u5feb\u901f\u90e8\u7f72\u548c\u505c\u6b62\u7684\u573a\u666f\uff0cWasm \u7684\u8f7b\u91cf\u7ea7\u7279\u6027\u53ef\u4ee5\u5927\u5927\u964d\u4f4e\u7cfb\u7edf\u7684\u8d44\u6e90\u5f00\u9500\u3002</li> </ul> <p>\u6211\u4eec\u5df2\u7ecf\u5728 LMP \u9879\u76ee\u7684 eBPF Hub \u4e2d\uff0c\u6709\u4e00\u4e9b\u521b\u5efa\u7b26\u5408 OCI \u6807\u51c6\u7684 Wasm-eBPF \u5e94\u7528\u7a0b\u5e8f\uff0c\u5e76\u5229\u7528 ORAS \u7b80\u5316\u6269\u5c55 eBPF \u5e94\u7528\u5f00\u53d1\uff0c\u5206\u53d1\u3001\u52a0\u8f7d\u3001\u8fd0\u884c\u80fd\u529b\u7684\u5c1d\u8bd5[11]\uff0c\u4ee5\u53ca\u57fa\u4e8e Wasm \u540c\u65f6\u4f7f\u7528\u591a\u79cd\u4e0d\u540c\u8bed\u8a00\u5f00\u53d1 eBPF \u7684\u7528\u6237\u6001\u6570\u636e\u5904\u7406\u63d2\u4ef6\u7684\u5b9e\u8df5\uff0c\u57fa\u4e8e\u6700\u65b0\u7684 Wasm-bpf \u6846\u67b6\uff0c\u6709\u66f4\u591a\u7684\u63a2\u7d22\u6027\u5de5\u4f5c\u53ef\u4ee5\u7ee7\u7eed\u5c55\u5f00\u3002</p>"},{"location":"blogs/introduce-to-wasm-bpf-bpf-community.zh/#ebpf_1","title":"\u7528\u6237\u7a7a\u95f4\u548c eBPF \u7a0b\u5e8f\u7684\u4ea4\u4e92\u6d41\u7a0b","text":"<p>eBPF \u7a0b\u5e8f\u662f\u4ee5\u51fd\u6570\u4e3a\u5355\u4f4d\u7684\u3001\u4e8b\u4ef6\u9a71\u52a8\u7684\uff0c\u5f53\u5185\u6838\u6216\u7528\u6237\u7a7a\u95f4\u5e94\u7528\u7a0b\u5e8f\u901a\u8fc7\u67d0\u4e2a hook \u70b9\u65f6\u5c31\u4f1a\u8fd0\u884c\u7279\u5b9a\u7684 eBPF \u7a0b\u5e8f\u3002\u8981\u4f7f\u7528\u4e00\u4e2a eBPF \u7a0b\u5e8f\uff0c\u9996\u5148\u6211\u4eec\u9700\u8981\u4f7f\u7528 clang/LLVM \u5de5\u5177\u94fe\u5c06\u5bf9\u5e94\u7684\u6e90\u4ee3\u7801\u7f16\u8bd1\u4e3a bpf \u5b57\u8282\u7801\uff0c\u5176\u4e2d\u5305\u542b\u5bf9\u5e94\u7684\u6570\u636e\u7ed3\u6784\u5b9a\u4e49\u3001maps \u548c progs \u5b9a\u4e49\uff0cprogs \u5373\u7a0b\u5e8f\u6bb5\uff0cmaps \u53ef\u4ee5\u7528\u6765\u5b58\u50a8\u6570\u636e\u6216\u8005\u548c\u7528\u6237\u7a7a\u95f4\u5b9e\u73b0\u53cc\u5411\u901a\u4fe1\u3002\u4e4b\u540e\uff0c\u6211\u4eec\u53ef\u4ee5\u501f\u52a9\u7528\u6237\u6001\u7684\u5f00\u53d1\u6846\u67b6\u548c\u52a0\u8f7d\u6846\u67b6\uff0c\u5b9e\u73b0\u5b8c\u6574\u7684 eBPF \u5e94\u7528\u3002</p>"},{"location":"blogs/introduce-to-wasm-bpf-bpf-community.zh/#ebpf_2","title":"\u901a\u5e38\u7684\u7528\u6237\u6001 eBPF \u5f00\u53d1\u6846\u67b6","text":"<p>\u5bf9\u4e8e\u4e00\u4e2a\u5b8c\u6574\u7684 eBPF \u5e94\u7528\uff0c\u901a\u5e38\u9700\u8981\u5305\u542b\u7528\u6237\u6001\u548c\u5185\u6838\u6001\u4e24\u90e8\u5206\uff1a</p> <ul> <li>\u7528\u6237\u6001\u7a0b\u5e8f\u9700\u8981\u901a\u8fc7\u4e00\u7cfb\u5217\u7cfb\u7edf\u8c03\u7528\u8ddf\u5185\u6838\u8fdb\u884c\u4ea4\u4e92\uff08\u4e3b\u8981\u662f bpf \u7cfb\u7edf\u8c03\u7528\uff09\uff0c\u521b\u5efa\u5bf9\u5e94\u7684 map \u4ee5\u5728\u5185\u6838\u6001\u4fdd\u5b58\u6570\u636e\u6216\u548c\u7528\u6237\u6001\u901a\u4fe1\uff0c\u6839\u636e\u914d\u7f6e\u52a8\u6001\u9009\u62e9\u52a0\u8f7d\u4e0d\u540c\u7684\u7a0b\u5e8f\u6bb5\uff0c\u52a8\u6001\u4fee\u6539\u5b57\u8282\u7801\u6216\u914d\u7f6e eBPF \u7a0b\u5e8f\u7684\u53c2\u6570\uff0c\u5c06\u5bf9\u5e94\u7684\u5b57\u8282\u7801\u4fe1\u606f\u52a0\u8f7d\u8fdb\u5185\u6838\uff0c\u901a\u8fc7\u9a8c\u8bc1\u5668\u786e\u4fdd\u5b89\u5168\u6027\uff0c\u5e76\u901a\u8fc7 maps \u548c\u5185\u6838\u4e4b\u95f4\u5b9e\u73b0\u53cc\u5411\u901a\u4fe1\uff0c\u901a\u8fc7 ring buffer / perf buffer \u4e4b\u7c7b\u7684\u673a\u5236\u4ece\u5185\u6838\u6001\u5411\u7528\u6237\u6001\u4f20\u9012\u6570\u636e\uff08\u6216\u8005\u53cd\u4e4b\uff09\u3002</li> <li>\u5185\u6838\u6001\u4e3b\u8981\u8d1f\u8d23\u5177\u4f53\u7684\u8ba1\u7b97\u903b\u8f91\u4e0e\u6570\u636e\u6536\u96c6\u3002</li> </ul>"},{"location":"blogs/introduce-to-wasm-bpf-bpf-community.zh/#wasm-ebpf-ebpf","title":"\u5728\u7528\u6237\u6001 Wasm-eBPF \u7cfb\u7edf\u63a5\u53e3\u4e4b\u4e0a\u5b9a\u4e49\u7684\u5168\u65b0 eBPF \u5f00\u53d1\u6846\u67b6","text":"<p>\u8fd9\u4e2a\u9879\u76ee\u672c\u8d28\u4e0a\u53ef\u4ee5\u8bf4\u662f\u5e0c\u671b\u628a Wasm \u6c99\u7bb1\u5f53\u505a\u5728\u64cd\u4f5c\u7cfb\u7edf\u4e4b\u4e0a\u5efa\u7acb\u7684\u53e6\u4e00\u4e2a\u7528\u6237\u6001\u8fd0\u884c\u7a7a\u95f4\uff0c\u8ba9 Wasm \u5e94\u7528\u5728\u6c99\u7bb1\u4e2d\u5b9e\u73b0\u548c\u901a\u5e38\u7528\u6237\u6001\u4e2d\u8fd0\u884c\u7684 eBPF \u5e94\u7528\u4e00\u6837\u7684\u7f16\u7a0b\u6a21\u578b\u548c\u6267\u884c\u903b\u8f91\u3002Wasm-bpf \u4f1a\u9700\u8981\u4e00\u4e2a\u5728 host\uff08\u6c99\u7bb1\u5916\u90e8\uff09\u6784\u5efa\u7684\u8fd0\u884c\u65f6\u6269\u5c55\uff0c\u4ee5\u53ca\u4e00\u4e9b\u5728\u6c99\u7bb1\u5185\u90e8\u88ab\u7f16\u8bd1\u4e3a Wasm \u5b57\u8282\u7801\u7684\u8fd0\u884c\u65f6\u5e93\u6765\u63d0\u4f9b\u5b8c\u6574\u7684\u652f\u6301\u3002</p> <p></p> <p>\u8981\u5b9e\u73b0\u5b8c\u5907\u7684\u5f00\u53d1\u6a21\u578b\uff0c\u6211\u4eec\u9700\u8981\uff1a</p> <ul> <li>\u4e00\u4e2a Wasm \u6a21\u5757\u53ef\u4ee5\u5bf9\u5e94\u591a\u4e2a eBPF \u7a0b\u5e8f\uff1b</li> <li>\u4e00\u4e2a eBPF \u7a0b\u5e8f\u5b9e\u4f8b\u4e5f\u53ef\u4ee5\u88ab\u591a\u4e2a Wasm \u6a21\u5757\u6240\u5171\u7528\uff1b</li> <li>\u53ef\u4ee5\u5c06 eBPF \u7a0b\u5e8f\u4ece Wasm \u6c99\u7bb1\u4e2d\u52a8\u6001\u52a0\u8f7d\u8fdb\u5185\u6838\u3001\u9009\u62e9\u6240\u9700\u7684\u6302\u8f7d\u70b9\u6302\u8f7d\u3001\u5378\u8f7d\uff0c\u63a7\u5236\u591a\u4e2a eBPF \u5b57\u8282\u7801\u5bf9\u8c61\u7684\u5b8c\u6574\u751f\u547d\u5468\u671f\uff0c\u5e76\u652f\u6301\u5927\u591a\u6570\u7684 eBPF \u7a0b\u5e8f\u7c7b\u578b\uff1b</li> <li>\u53ef\u4ee5\u901a\u8fc7\u591a\u79cd\u7c7b\u578b\u7684 Maps \u548c\u5185\u6838\u53cc\u5411\u901a\u4fe1\uff0c\u652f\u6301\u5927\u591a\u6570\u7684 Maps \u7c7b\u578b\uff1b</li> <li>\u901a\u8fc7 ring buffer \u548c perf event polling \u4ece\u5185\u6838\u6001\u5411\u7528\u6237\u6001\u9ad8\u6548\u53d1\u9001\u4fe1\u606f\uff08\u5bf9\u4e8e ring buffer \u6765\u8bf4\uff0c\u4e5f\u53ef\u4ee5\u53cd\u4e4b\uff09\uff1b</li> <li>\u51e0\u4e4e\u53ef\u4ee5\u9002\u914d\u4e8e\u6240\u6709\u7684\u4f7f\u7528 eBPF \u7a0b\u5e8f\u7684\u5e94\u7528\u573a\u666f\uff0c\u5e76\u53ef\u4ee5\u968f\u7740\u5185\u6838\u529f\u80fd\u7684\u6dfb\u52a0\u4e0d\u65ad\u6f14\u5316\u548c\u6269\u5c55\uff0c\u540c\u65f6\u4e0d\u9700\u8981\u53d8\u52a8 Wasm \u865a\u62df\u673a\u7684\u7cfb\u7edf\u63a5\u53e3\u3002</li> </ul> <p>\u8fd9\u5c31\u662f\u76ee\u524d Wasm-bpf \u9879\u76ee\u6240\u505a\u7684\u5de5\u4f5c\u3002\u6211\u4eec\u4e5f\u63d0\u51fa\u4e86\u4e00\u4e2a\u65b0\u7684 WASI \u7684 Proposal: WASI-eBPF[12].</p> <p>\u5728 Wasm-bpf \u9879\u76ee\u4e2d\uff0c\u6240\u6709 Wasm \u548c eBPF \u865a\u62df\u673a\u4e4b\u95f4\u7684\u901a\u4fe1\u90fd\u65e0\u9700\u7ecf\u8fc7\u5e8f\u5217\u5316\u3001\u53cd\u5e8f\u5217\u5316\u673a\u5236\uff0c\u901a\u8fc7\u5de5\u5177\u94fe\u4e2d\u4ee3\u7801\u751f\u6210\u6280\u672f\u548c BTF\uff08BPF \u7c7b\u578b\u683c\u5f0f[13]\uff09\u4fe1\u606f\u7684\u652f\u6301\uff0c\u6211\u4eec\u53ef\u4ee5\u5b9e\u73b0\u5728 eBPF \u548c Wasm \u4e4b\u95f4\u53ef\u80fd\u4e0d\u540c\u7684\u7ed3\u6784\u4f53\u5185\u5b58\u5e03\u5c40\u3001\u4e0d\u540c\u7684\u5927\u5c0f\u7aef\u673a\u5236\u3001\u4e0d\u540c\u7684\u6307\u9488\u5bbd\u5ea6\u4e4b\u95f4\u7684\u6b63\u786e\u901a\u4fe1\uff0c\u5728\u8fd0\u884c\u65f6\u51e0\u4e4e\u4e0d\u4f1a\u5f15\u5165\u4efb\u4f55\u989d\u5916\u7684\u5f00\u9500\uff1b\u901a\u8fc7 eBPF Maps \u901a\u4fe1\u7684\u65f6\u5019\u6570\u636e\u53ef\u4ee5\u76f4\u63a5\u7531\u5185\u6838\u6001\u590d\u5236\u5230 Wasm \u865a\u62df\u673a\u7684\u5185\u5b58\u4e2d\uff0c\u907f\u514d\u591a\u6b21\u62f7\u8d1d\u5e26\u6765\u7684\u989d\u5916\u635f\u8017\u3002\u540c\u65f6\uff0c\u901a\u8fc7\u81ea\u52a8\u751f\u6210 skeleton \uff08bpf \u4ee3\u7801\u6846\u67b6\uff09\u548c\u7c7b\u578b\u5b9a\u4e49\u7684\u65b9\u5f0f\uff0c\u7528\u6237\u6001\u7a0b\u5e8f\u7684 eBPF-Wasm \u5f00\u53d1\u4f53\u9a8c\u4e5f\u5f97\u5230\u4e86\u975e\u5e38\u5927\u7684\u6539\u5584\u3002</p> <p>\u5f97\u76ca\u4e8e libbpf \u63d0\u4f9b\u7684 CO-RE\uff08Compile-Once, Run Everywhere\uff09\u6280\u672f\uff0c\u5728\u4e0d\u540c\u5185\u6838\u7248\u672c\u4e4b\u95f4\u79fb\u690d eBPF \u5b57\u8282\u7801\u5bf9\u8c61\uff0c\u4e5f\u4e0d\u9700\u8981\u5f15\u5165\u989d\u5916\u7684\u91cd\u65b0\u7f16\u8bd1\u6d41\u7a0b\uff0c\u8fd0\u884c\u65f6\u4e5f\u6ca1\u6709\u4efb\u4f55\u7684 LLVM/Clang \u4f9d\u8d56[14]\u3002</p> <p>\u901a\u5e38\uff0c\u4e00\u4e2a\u7f16\u8bd1\u597d\u7684 eBPF-Wasm \u6a21\u5757\u53ea\u6709\u5927\u7ea6 90Kb\uff0c\u5728\u4e0d\u5230 100ms \u5185\u5373\u53ef\u4ee5\u5b8c\u6210\u52a8\u6001\u52a0\u8f7d\u8fdb\u5185\u6838\u5e76\u6267\u884c\u7684\u8fc7\u7a0b\u3002\u6211\u4eec\u4e5f\u5728\u4ed3\u5e93\u4e2d\u63d0\u4f9b\u4e86\u51e0\u4e2a\u4f8b\u5b50\uff0c\u5206\u522b\u5bf9\u5e94\u4e8e\u53ef\u89c2\u6d4b\u3001\u7f51\u7edc\u3001\u5b89\u5168\u7b49\u591a\u79cd\u573a\u666f\uff0c\u4f7f\u7528 C/C++ \u8bed\u8a00\u6216 Rust \u8bed\u8a00\u7f16\u5199\u3002</p> <p>\u611f\u8c22\u534e\u5357\u7406\u5de5\u5927\u5b66\u8d56\u6653\u94ee\u526f\u6559\u6388\u3001\u897f\u5b89\u90ae\u7535\u5927\u5b66\u9648\u8389\u541b\u6559\u6388\u56e2\u961f\u548c\u8fbe\u5766\u79d1\u6280\u738b\u749e\u3001\u65bd\u7ee7\u6210\u8001\u5e08\u5bf9 Wasm \u548c eBPF \u76f8\u7ed3\u5408\u7684\u6307\u5bfc\u4e0e\u5e2e\u52a9\uff0c\u5728\u63a5\u4e0b\u6765\u7684\u5de5\u4f5c\u4e2d\uff0c\u6211\u4eec\u4f1a\u548c\u53c2\u52a0 2023 \u5f00\u6e90\u6bd5\u8bbe\u4e4b\u65c5\u7684\u540c\u5b66\u4eec\u4e00\u540c\u9488\u5bf9\u4e00\u4e9b Wasm-bpf \u5177\u4f53\u7684\u5e94\u7528\u573a\u666f\uff0c\u8fdb\u884c\u66f4\u6df1\u5165\u7684\u7814\u7a76\u4e0e\u63a2\u8ba8\uff0c\u5e76\u5728\u4e0b\u4e00\u7bc7 blog \u4e2d\u7ed9\u51fa\u66f4\u8be6\u7ec6\u7684\u539f\u7406\u89e3\u6790\u4e0e\u6027\u80fd\u5206\u6790\uff0c\u4ee5\u53ca\u5bf9\u5e94\u7684\u4e00\u4e9b\u4ee3\u7801\u793a\u4f8b\u3002</p> <p>Wasm-bpf \u7f16\u8bd1\u5de5\u5177\u94fe\u4e0e\u8fd0\u884c\u65f6\u6a21\u5757\u7b49\u76ee\u524d\u7531\u9f99\u8725\u793e\u533a eBPF \u6280\u672f\u63a2\u7d22 SIG[15] \u4e2d\u5b75\u5316\u7684 eunomia-bpf \u5f00\u6e90\u793e\u533a[16]\u5f00\u53d1\u4e0e\u7ef4\u62a4\uff0c\u611f\u8c22\u4e2d\u79d1\u9662\u8f6f\u4ef6\u6240 PLCT \u5b9e\u9a8c\u5ba4\u5bf9\u793e\u533a\u7684\u5927\u529b\u652f\u6301\u548c\u8d44\u52a9\uff0c\u611f\u8c22\u793e\u533a\u540c\u4f34\u4eec\u7684\u8d21\u732e\u3002\u63a5\u4e0b\u6765\uff0c\u6211\u4eec\u4e5f\u4f1a\u5728\u5bf9\u5e94\u7684 eBPF \u548c Wasm \u76f8\u5173\u7684\u5de5\u5177\u94fe\u548c\u8fd0\u884c\u65f6\u65b9\u9762\uff0c\u8fdb\u884c\u66f4\u591a\u7684\u5b8c\u5584\u548c\u63a2\u7d22\uff0c\u5e76\u79ef\u6781\u5411\u4e0a\u6e38\u793e\u533a\u53cd\u9988\u548c\u8d21\u732e\u3002</p>"},{"location":"blogs/introduce-to-wasm-bpf-bpf-community.zh/#_1","title":"\u53c2\u8003\u8d44\u6599","text":"<ul> <li>[1] wasm-bpf Github \u5f00\u6e90\u5730\u5740\uff1ahttps://github.com/eunomia-bpf/wasm-bpf</li> <li>[2] WebAssembly\uff1a\u65e0\u9700\u5bb9\u5668\u7684 Docker\uff1ahttps://zhuanlan.zhihu.com/p/595257541</li> <li>[3] \u4e91\u539f\u751f\u9879\u76ee\u53ef\u6269\u5c55\u6027\u7684\u5229\u5668 WebAssembly \u7b80\u4ecb https://mp.weixin.qq.com/s/fap0bl6GFGi8zN5BFLpkCw</li> <li>[4] \u5f53 Wasm \u9047\u89c1 eBPF \uff1a\u4f7f\u7528 WebAssembly \u7f16\u5199\u3001\u5206\u53d1\u3001\u52a0\u8f7d\u8fd0\u884c eBPF \u7a0b\u5e8f\uff1ahttps://zhuanlan.zhihu.com/p/573941739</li> <li>[5] https://ebpf.io/</li> <li>[6] \u4ec0\u4e48\u662f eBPF\uff1ahttps://ebpf.io/what-is-ebpf</li> <li>[7] Offensive BPF: Understanding and using bpf_probe_write_user https://embracethered.com/blog/posts/2021/offensive-bpf-libbpf-bpf_probe_write_user/</li> <li>[8] \u4e91\u539f\u751f\u5b89\u5168\u653b\u9632\uff5c\u4f7f\u7528eBPF\u9003\u9038\u5bb9\u5668\u6280\u672f\u5206\u6790\u4e0e\u5b9e\u8df5\uff1ahttps://security.tencent.com/index.php/blog/msg/206</li> <li>[9] kernel-versions.md: https://github.com/iovisor/bcc/blob/master/docs/kernel-versions.md</li> <li>[10] 2023 \u5e74 WebAssembly \u6280\u672f\u4e94\u5927\u8d8b\u52bf\u9884\u6d4b\uff1ahttps://zhuanlan.zhihu.com/p/597705400</li> <li>[11] LMP eBPF-Hub: https://github.com/linuxkerneltravel/lmp</li> <li>[12] WASI-eBPF: https://github.com/WebAssembly/WASI/issues/513</li> <li>[13] BPF BTF \u8be6\u89e3\uff1ahttps://www.ebpf.top/post/kernel_btf/</li> <li>[14] BPF \u53ef\u79fb\u690d\u6027\u548c CO-RE\uff08\u4e00\u6b21\u7f16\u8bd1\uff0c\u5230\u5904\u8fd0\u884c\uff09\uff1ahttps://cloud.tencent.com/developer/article/1802154</li> <li>[15] \u9f99\u8725\u793e\u533a eBPF \u6280\u672f\u63a2\u7d22 SIG https://openanolis.cn/sig/ebpfresearch</li> <li>[16] eunomia-bpf \u9879\u76ee\uff1ahttps://github.com/eunomia-bpf/eunomia-bpf</li> <li>[17] eunomia-bpf \u9879\u76ee\u9f99\u8725 Gitee \u955c\u50cf\uff1ahttps://gitee.com/anolis/eunomia</li> </ul>"},{"location":"blogs/introduce-to-wasm-bpf-wasm.zh/","title":"Wasm-bpf: \u4e3a\u4e91\u539f\u751f Webassembly \u63d0\u4f9b\u901a\u7528\u7684 eBPF \u5185\u6838\u53ef\u7f16\u7a0b\u80fd\u529b","text":"<p>\u4f5c\u8005\uff1a\u90d1\u6631\u7b19\uff0c\u9648\u8302\u6797</p> <p>Wasm \u6700\u521d\u662f\u4ee5\u6d4f\u89c8\u5668\u5b89\u5168\u6c99\u76d2\u4e3a\u76ee\u7684\u5f00\u53d1\u7684\uff0c\u53d1\u5c55\u5230\u76ee\u524d\u4e3a\u6b62\uff0cWebAssembly \u5df2\u7ecf\u6210\u4e3a\u4e00\u4e2a\u7528\u4e8e\u4e91\u539f\u751f\u8f6f\u4ef6\u7ec4\u4ef6\u7684\u9ad8\u6027\u80fd\u3001\u8de8\u5e73\u53f0\u548c\u591a\u8bed\u8a00\u8f6f\u4ef6\u6c99\u7bb1\u73af\u5883\uff0cWasm \u8f7b\u91cf\u7ea7\u5bb9\u5668\u4e5f\u975e\u5e38\u9002\u5408\u4f5c\u4e3a\u4e0b\u4e00\u4ee3\u65e0\u670d\u52a1\u5668\u5e73\u53f0\u8fd0\u884c\u65f6\u3002\u53e6\u4e00\u4e2a\u4ee4\u4eba\u5174\u594b\u7684\u8d8b\u52bf\u662f eBPF \u7684\u5174\u8d77\uff0c\u5b83\u4f7f\u4e91\u539f\u751f\u5f00\u53d1\u4eba\u5458\u80fd\u591f\u6784\u5efa\u5b89\u5168\u7684\u7f51\u7edc\u3001\u670d\u52a1\u7f51\u683c\u548c\u591a\u79cd\u53ef\u89c2\u6d4b\u6027\u7ec4\u4ef6\uff0c\u5e76\u4e14\u5b83\u4e5f\u5728\u9010\u6b65\u6e17\u900f\u548c\u6df1\u5165\u5230\u5185\u6838\u7684\u5404\u4e2a\u7ec4\u4ef6\uff0c\u63d0\u4f9b\u66f4\u5f3a\u5927\u7684\u5185\u6838\u6001\u53ef\u7f16\u7a0b\u4ea4\u4e92\u80fd\u529b\u3002</p> <p>Wasm-bpf \u662f\u4e00\u4e2a\u5168\u65b0\u7684\u5f00\u6e90\u9879\u76ee[1]\uff0c\u5b83\u5b9a\u4e49\u4e86\u4e00\u5957 eBPF \u76f8\u5173\u7cfb\u7edf\u63a5\u53e3\u7684\u62bd\u8c61\uff0c\u5e76\u63d0\u4f9b\u4e86\u4e00\u5957\u5bf9\u5e94\u7684\u5f00\u53d1\u5de5\u5177\u94fe\u3001\u5e93\u4ee5\u53ca\u901a\u7528\u7684 Wasm + eBPF \u8fd0\u884c\u65f6\u5e73\u53f0\u5b9e\u4f8b\uff0c\u8ba9\u4efb\u610f Wasm \u865a\u62df\u673a\u6216\u8005 Wasm \u8f7b\u91cf\u7ea7\u5bb9\u5668\u4e2d\u7684\u5e94\u7528\uff0c\u6709\u80fd\u529b\u5c06\u4f7f\u7528\u573a\u666f\u4e0b\u6c89\u548c\u62d3\u5c55\u5230\u5185\u6838\u6001\uff0c\u83b7\u53d6\u5185\u6838\u6001\u548c\u7528\u6237\u6001\u7684\u51e0\u4e4e\u6240\u6709\u6570\u636e\uff0c\u5728\u7f51\u7edc\u3001\u5b89\u5168\u7b49\u591a\u4e2a\u65b9\u9762\u5b9e\u73b0\u5bf9\u6574\u4e2a\u64cd\u4f5c\u7cfb\u7edf\u5c42\u9762\u7684\u53ef\u7f16\u7a0b\u63a7\u5236\uff0c\u4ece\u800c\u6781\u5927\u7684\u62d3\u5c55 WebAssembly \u751f\u6001\u5728\u975e\u6d4f\u89c8\u5668\u7aef\u7684\u5e94\u7528\u573a\u666f\u3002</p>"},{"location":"blogs/introduce-to-wasm-bpf-wasm.zh/#ebpf-wasm","title":"\u57fa\u4e8e eBPF \u7684\u7cfb\u7edf\u63a5\u53e3\uff0c\u4e3a Wasm \u5e26\u6765\u66f4\u591a\u53ef\u80fd","text":"<p>\u4e5f\u8bb8\u4f60\u4e5f\u5df2\u7ecf\u770b\u8fc7 Solomon Hykes (Docker\u7684\u521b\u59cb\u4eba\u4e4b\u4e00)\u8fd9\u53e5\u8bdd\uff1a</p> <p>\u5982\u679c\u57282008\u5e74\u5df2\u7ecf\u6709\u4e86 Wasm + WASI\uff0c\u6211\u4eec\u6839\u672c\u4e0d\u9700\u8981\u521b\u5efa Docker\u3002 Wasm \u5c31\u6709\u8fd9\u4e48\u91cd\u8981\u3002 \u670d\u52a1\u7aef\u7684 WebAssembly \u662f\u8ba1\u7b97\u7684\u672a\u6765\u3002</p> <p>\u56e0\u4e3a\u65e0\u6cd5\u4f9d\u8d56\u6d4f\u89c8\u5668\u4e2d\u73b0\u6709\u53ef\u7528\u7684 JavaScript \u5f15\u64ce\u63a5\u53e3\uff0c\u6240\u4ee5\u76ee\u524d\u5927\u591a\u6570\u5728\u6d4f\u89c8\u5668\u5916\u8fd0\u884c\u7684 Wasm \u8f7b\u91cf\u7ea7\u5bb9\u5668\u9700\u8981\u4f7f\u7528 WASI\uff08WebAssembly \u7cfb\u7edf\u63a5\u53e3\uff09\u3002\u8fd9\u4e9b\u8fd0\u884c\u65f6\u5141\u8bb8 Wasm \u5e94\u7528\u7a0b\u5e8f\u4ee5\u4e0e POSIX \u7c7b\u4f3c\uff08\u4f46\u4e0d\u5b8c\u5168\u76f8\u540c\uff09\u7684\u65b9\u5f0f\u4e0e\u5176 host \u64cd\u4f5c\u7cfb\u7edf\u4ea4\u4e92\u3002</p> <p>\u4f46\u662f\uff0c\u76f8\u5bf9\u4e8e\u4f20\u7edf\u7684\u5bb9\u5668\u4e2d\u53ef\u4ee5\u4f7f\u7528\u51e0\u4e4e\u6240\u6709\u7684\u7cfb\u7edf\u8c03\u7528\uff0c\u76ee\u524d WASI \u6240\u80fd\u63d0\u4f9b\u7684\u7cfb\u7edf\u8d44\u6e90\u975e\u5e38\u6709\u9650\uff0c\u76ee\u524d\u4ec5\u4ec5\u5728\u6587\u4ef6\u7cfb\u7edf\u3001socket \u7f51\u7edc\u8fde\u63a5\u7b49\u65b9\u9762\u63d0\u4f9b\u4e86\u4e00\u4e9b\u57fa\u672c\u7684\u652f\u6301\uff0c\u5bf9\u4e8e\u64cd\u4f5c\u7cfb\u7edf\u5e95\u5c42\u8d44\u6e90\u7684\u8bbf\u95ee\u3001\u63a7\u5236\u548c\u7ba1\u7406\u80fd\u529b\u4ecd\u7136\u5b58\u5728\u5927\u91cf\u7a7a\u767d\uff0c\u4f8b\u5982\u5bf9 Wasm \u6a21\u5757\u6216\u8005\u5916\u90e8\u5176\u4ed6\u8fdb\u7a0b\u7684\u6267\u884c\u8d44\u6e90\u9650\u5236\u4e0e\u884c\u4e3a\u89c2\u6d4b\uff0c\u5bf9\u7f51\u7edc\u5305\u7684\u5feb\u901f\u8f6c\u53d1\u548c\u5904\u7406\uff0c\u751a\u81f3\u548c wasm \u6c99\u7bb1\u5916\u7684\u5176\u4ed6\u8fdb\u7a0b\u8fdb\u884c\u901a\u4fe1\uff0c\u8bbf\u95ee\u5916\u8bbe\u7b49\uff0c\u90fd\u6ca1\u6709\u4e00\u4e2a\u6bd4\u8f83\u6210\u719f\u7684\u89e3\u51b3\u65b9\u6848\u3002\u8fd9\u4e5f\u4f7f\u5f97\u5927\u591a\u6570\u7684 Wasm \u8f7b\u91cf\u7ea7\u5bb9\u5668\u5728\u5b9e\u9645\u5e94\u7528\u4e2d\u8fd8\u662f\u4e3b\u8981\u96c6\u4e2d\u4e8e\u7eaf\u7cb9\u7684\u8ba1\u7b97\u5bc6\u96c6\u578b\u5e94\u7528\uff0c\u800c\u5728\u7f51\u7edc\u3001\u5b89\u5168\u7b49\u65b9\u9762\uff0c\u8fd8\u662f\u9700\u8981\u4f9d\u8d56\u4e8e\u4f20\u7edf\u7684\u5bb9\u5668\u6280\u672f\u3002</p> <p>\u8fd9\u4e5f\u662f\u6211\u4eec\u5e0c\u671b\u5efa\u7acb Wasm-bpf \u9879\u76ee\u7684\u521d\u8877\uff1a\u501f\u52a9\u5f53\u524d\u5185\u6838\u6001 eBPF \u63d0\u4f9b\u7684\u7cfb\u7edf\u63a5\u53e3\u4ee5\u53ca\u548c\u7528\u6237\u6001\u4ea4\u4e92\u7684\u80fd\u529b\uff0c\u62d3\u5c55\u6574\u4e2a WASI \u7684\u751f\u6001\u84dd\u56fe\uff0c\u4e3a Wasm \u5e94\u7528\u5e26\u6765\u66f4\u591a\u53ef\u80fd\u7684\u4f7f\u7528\u573a\u666f\uff0c\u540c\u65f6\u4e5f\u80fd\u5728\u7528\u6237\u6001\u589e\u5f3a eBPF \u7a0b\u5e8f\u7684\u80fd\u529b\u3002</p> <p>\u6216\u8005\u6362\u53e5\u8bdd\u8bf4\uff0c\u7c7b\u4f3c\u4e8e\u6d4f\u89c8\u5668\u4e2d\u8fd0\u884c\u7684 Wasm \u7a0b\u5e8f\uff0c\u901a\u8fc7 JavaScript \u5f15\u64ce\u63a5\u53e3\u8bbf\u95ee\u6d4f\u89c8\u5668\u63d0\u4f9b\u7684\u5404\u79cd\u7cfb\u7edf\u8d44\u6e90\uff0cWasm-bpf \u7684\u65b9\u6848\u5c31\u662f\u501f\u52a9 eBPF \u865a\u62df\u673a\u8bbf\u95ee\u64cd\u4f5c\u7cfb\u7edf\u7684\u5404\u7c7b\u8d44\u6e90\uff1b\u5f97\u76ca\u4e8e eBPF \u76ee\u524d\u5728 Linux \u5185\u6838\u751a\u81f3 Windows \u7b49\u5176\u4ed6\u64cd\u4f5c\u7cfb\u7edf\u4e2d\u7684\u5e7f\u6cdb\u652f\u6301\uff0c\u4ee5\u53ca\u4e0d\u540c\u5185\u6838\u7248\u672c\u548c\u67b6\u6784\u4e4b\u95f4\u7684\u53ef\u79fb\u690d\u6027\uff0c\u548c\u5185\u6838 BPF \u9a8c\u8bc1\u5f15\u64ce\u7684\u53ef\u9760\u6027\uff0c\u6211\u4eec\u4ecd\u7136\u53ef\u4ee5\u5728\u4e00\u5b9a\u7a0b\u5ea6\u4e0a\u4fdd\u8bc1\u5e94\u7528\u7684\u53ef\u79fb\u690d\u6027\u548c\u5b89\u5168\u8fb9\u754c\u3002</p> <p>Wasm-bpf \u9879\u76ee\u5df2\u7ecf\u5b9e\u73b0\u4e86\u5185\u6838\u6001 eBPF \u865a\u62df\u673a\u548c\u7528\u6237\u6001\u4e4b\u95f4\u7cfb\u7edf\u63a5\u53e3\u5b8c\u6574\u7684\u62bd\u8c61\u673a\u5236\uff0c\u5e76\u63d0\u4f9b\u4e86\u5bf9\u5e94\u7684\u5de5\u5177\u94fe\u4ee5\u5c06 eBPF \u5e94\u7528\u7f16\u8bd1\u4e3a Wasm \u6a21\u5757\uff0c\u5e2e\u52a9\u8fdb\u884c\u5185\u6838\u6001 eBPF \u548c\u7528\u6237\u6001 Wasm \u4e4b\u95f4\u65e0\u5e8f\u5217\u5316\uff0c\u5171\u4eab\u5185\u5b58\u7684\u9ad8\u6548\u53cc\u5411\u901a\u4fe1\uff0c\u5e76\u901a\u8fc7\u4ee3\u7801\u751f\u6210\u6280\u672f\uff0c\u63d0\u4f9b\u548c\u5176\u4ed6\u7528\u6237\u6001 eBPF \u5f00\u53d1\u6846\u67b6\u51e0\u4e4e\u4e00\u81f4\u7684\u3001\u7b80\u5355\u4fbf\u6377\u7684\u5f00\u53d1\u4f53\u9a8c\u3002\u501f\u52a9 Wasm \u7ec4\u4ef6\u6a21\u578b\u4e0d\u65ad\u5b8c\u5584\u7684\u751f\u6001\u652f\u6301\uff0c\u6211\u4eec\u4e5f\u53ef\u4ee5\u4e3a eBPF \u793e\u533a\u5e26\u6765\u66f4\u591a\u7528\u6237\u6001\u5f00\u53d1\u8bed\u8a00\uff0c\u4e0d\u540c\u8bed\u8a00\u5b9e\u73b0\u7684\u53ef\u89c2\u6d4b\u6027\u3001\u7f51\u7edc\u7b49 eBPF \u5e94\u7528\u548c\u6570\u636e\u5904\u7406\u63d2\u4ef6\u4e5f\u53ef\u4ee5\u88ab\u8f7b\u677e\u96c6\u6210\u3001\u590d\u7528\u3001\u7edf\u4e00\u7ba1\u7406\u3002</p> <p>\u5728\u51e0\u4e4e\u5df2\u7ecf\u6210\u4e3a eBPF \u7528\u6237\u6001\u4e8b\u5b9e\u4e0a\u7684 API \u6807\u51c6\u7684 libbpf \u5e93\uff0c\u548c WAMR(wasm-micro-runtime) \u4e4b\u4e0a\uff0c\u53ea\u9700\u8981 300+ \u884c\u4ee3\u7801\u5373\u53ef\u6784\u5efa\u5b8c\u6574\u7684\u901a\u7528 Wasm-eBPF \u8fd0\u884c\u7ec4\u4ef6\uff0c\u5e76\u652f\u6301\u5927\u591a\u6570\u7684 eBPF \u4f7f\u7528\u573a\u666f -- \u4efb\u4f55\u4eba\u7528\u4efb\u4f55\u4e3b\u6d41 Wasm \u8fd0\u884c\u65f6\uff0c\u6216\u8005\u4efb\u4f55 eBPF \u7528\u6237\u6001\u5e93\uff0c\u4ee5\u53ca\u4efb\u4f55\u7f16\u7a0b\u8bed\u8a00\uff0c\u90fd\u53ef\u4ee5\u8f7b\u677e\u6dfb\u52a0\u5bf9\u5e94\u7684\u865a\u62df\u673a\u652f\u6301\uff0c\u5e76\u590d\u7528\u6211\u4eec\u7684\u5de5\u5177\u94fe\u8f7b\u677e\u5b9e\u73b0 Wasm-eBPF \u7a0b\u5e8f\u7684\u7f16\u5199\u548c\u5f00\u53d1\u3002</p> <p>\u4e4b\u524d\u5728 eunomia-bpf \u9879\u76ee\u4e2d\uff0c\u5df2\u7ecf\u6709\u4e00\u4e9b\u5c06 eBPF \u548c Wasm \u7ed3\u5408\u7684\u63a2\u7d22\uff0c\u4f46\u5b83\u5e76\u4e0d\u662f\u4e3a\u4e86 Wasm \u539f\u751f\u5e94\u7528\u7684\u573a\u666f\u8bbe\u8ba1\u7684\uff0c\u4e0d\u7b26\u5408 Wasm-eBPF \u7684\u901a\u7528\u7f16\u7a0b\u6a21\u578b\uff0c\u6027\u80fd\u4e5f\u8f83\u4e3a\u4f4e\u4e0b\uff0c\u56e0\u6b64\u6211\u4eec\u521b\u5efa\u4e86\u4e00\u4e2a\u65b0\u7684\u5f00\u6e90\u4ed3\u5e93\uff0c\u8ba9 Wasm-bpf \u9879\u76ee\u4e13\u6ce8\u4e8e\u5229\u7528 eBPF \u589e\u5f3a\u548c\u6269\u5c55 WebAssembly \u4f7f\u7528\u573a\u666f\uff0c\u5e76\u8fdb\u4e00\u6b65\u5b8c\u5584\u5bf9\u5e94\u7684\u5de5\u5177\u94fe\u548c\u5f00\u53d1\u5e93\u652f\u6301\uff1ahttps://github.com/eunomia-bpf/wasm-bpf</p>"},{"location":"blogs/introduce-to-wasm-bpf-wasm.zh/#ebpf","title":"eBPF\uff1a\u5b89\u5168\u548c\u6709\u6548\u5730\u6269\u5c55\u5185\u6838","text":"<p>eBPF \u662f\u4e00\u9879\u9769\u547d\u6027\u7684\u6280\u672f\uff0c\u8d77\u6e90\u4e8e Linux \u5185\u6838\uff0c\u53ef\u4ee5\u5728\u64cd\u4f5c\u7cfb\u7edf\u7684\u5185\u6838\u4e2d\u8fd0\u884c\u6c99\u76d2\u7a0b\u5e8f\u3002\u5b83\u88ab\u7528\u6765\u5b89\u5168\u548c\u6709\u6548\u5730\u6269\u5c55\u5185\u6838\u7684\u529f\u80fd\uff0c\u800c\u4e0d\u9700\u8981\u6539\u53d8\u5185\u6838\u7684\u6e90\u4ee3\u7801\u6216\u52a0\u8f7d\u5185\u6838\u6a21\u5757\u3002</p> <p>\u4ece\u5386\u53f2\u4e0a\u770b\uff0c\u7531\u4e8e\u5185\u6838\u5177\u6709\u76d1\u7763\u548c\u63a7\u5236\u6574\u4e2a\u7cfb\u7edf\u7684\u7279\u6743\u80fd\u529b\uff0c\u6240\u4ee5\u64cd\u4f5c\u7cfb\u7edf\u4e00\u76f4\u662f\u5b9e\u73b0\u53ef\u89c2\u5bdf\u6027\u3001\u5b89\u5168\u6027\u548c\u7f51\u7edc\u529f\u80fd\u7b49\u591a\u79cd\u80fd\u529b\u7684\u7406\u60f3\u573a\u6240\u3002\u540c\u65f6\uff0c\u7531\u4e8e\u64cd\u4f5c\u7cfb\u7edf\u5185\u6838\u5bf9\u7a33\u5b9a\u6027\u548c\u5b89\u5168\u6027\u7684\u9ad8\u8981\u6c42\uff0c\u5185\u6838\u7684\u65b0\u529f\u80fd\u8fed\u4ee3\u901a\u5e38\u975e\u5e38\u8c28\u614e\uff0c\u4e5f\u5f88\u96be\u63a5\u53d7\u81ea\u5b9a\u4e49\u7684\u3001\u8f83\u5c11\u901a\u7528\u6027\u7684\u529f\u80fd\u6539\u8fdb\u3002\u56e0\u6b64\uff0c\u4e0e\u7528\u6237\u6001\u7684\u66f4\u591a\u529f\u80fd\u76f8\u6bd4\uff0c\u5185\u6838\u6001\u64cd\u4f5c\u7cfb\u7edf\u5c42\u9762\u7684\u521b\u65b0\u7387\u5386\u6765\u90fd\u6bd4\u8f83\u4f4e[2]\u3002</p> <p>eBPF \u4ece\u6839\u672c\u4e0a\u6539\u53d8\u4e86\u8fd9\u4e2a\u516c\u5f0f\u3002\u901a\u8fc7\u5141\u8bb8\u5728\u64cd\u4f5c\u7cfb\u7edf\u5185\u8fd0\u884c\u6c99\u76d2\u7a0b\u5e8f\uff0c\u5e94\u7528\u7a0b\u5e8f\u5f00\u53d1\u4eba\u5458\u53ef\u4ee5\u5728\u8fd0\u884c\u65f6\uff0c\u53ef\u7f16\u7a0b\u5730\u5411\u64cd\u4f5c\u7cfb\u7edf\u52a8\u6001\u6dfb\u52a0\u989d\u5916\u7684\u529f\u80fd\u3002\u7136\u540e\uff0c\u64cd\u4f5c\u7cfb\u7edf\u4fdd\u8bc1\u5b89\u5168\u548c\u6267\u884c\u6548\u7387\uff0c\u5c31\u50cf\u5728\u5373\u65f6\u7f16\u8bd1\uff08JIT\uff09\u7f16\u8bd1\u5668\u548c\u9a8c\u8bc1\u5f15\u64ce\u7684\u5e2e\u52a9\u4e0b\u8fdb\u884c\u672c\u5730\u7f16\u8bd1\u4e00\u6837\u3002eBPF \u7a0b\u5e8f\u5728\u5185\u6838\u7248\u672c\u4e4b\u95f4\u662f\u53ef\u79fb\u690d\u7684\uff0c\u5e76\u4e14\u53ef\u4ee5\u81ea\u52a8\u66f4\u65b0\uff0c\u4ece\u800c\u907f\u514d\u4e86\u5de5\u4f5c\u8d1f\u8f7d\u4e2d\u65ad\u548c\u8282\u70b9\u91cd\u542f\u3002</p> <p>\u4eca\u5929\uff0ceBPF\u88ab\u5e7f\u6cdb\u7528\u4e8e\u5404\u7c7b\u573a\u666f\uff1a\u5728\u73b0\u4ee3\u6570\u636e\u4e2d\u5fc3\u548c\u4e91\u539f\u751f\u73af\u5883\u4e2d\uff0c\u53ef\u4ee5\u63d0\u4f9b\u9ad8\u6027\u80fd\u7684\u7f51\u7edc\u5305\u5904\u7406\u548c\u8d1f\u8f7d\u5747\u8861\uff1b\u4ee5\u975e\u5e38\u4f4e\u7684\u8d44\u6e90\u5f00\u9500\uff0c\u505a\u5230\u5bf9\u591a\u79cd\u7ec6\u7c92\u5ea6\u6307\u6807\u7684\u53ef\u89c2\u6d4b\u6027\uff0c\u5e2e\u52a9\u5e94\u7528\u7a0b\u5e8f\u5f00\u53d1\u4eba\u5458\u8ddf\u8e2a\u5e94\u7528\u7a0b\u5e8f\uff0c\u4e3a\u6027\u80fd\u6545\u969c\u6392\u9664\u63d0\u4f9b\u6d1e\u5bdf\u529b\uff1b\u4fdd\u969c\u5e94\u7528\u7a0b\u5e8f\u548c\u5bb9\u5668\u8fd0\u884c\u65f6\u7684\u5b89\u5168\u6267\u884c\uff0c\u7b49\u7b49\u3002\u53ef\u80fd\u6027\u662f\u65e0\u7a77\u7684\uff0c\u800c eBPF \u5728\u64cd\u4f5c\u7cfb\u7edf\u5185\u6838\u4e2d\u6240\u91ca\u653e\u7684\u521b\u65b0\u624d\u521a\u521a\u5f00\u59cb[3]\u3002</p>"},{"location":"blogs/introduce-to-wasm-bpf-wasm.zh/#ebpf-javascript","title":"eBPF \u7684\u672a\u6765\uff1a\u5185\u6838\u7684 JavaScript \u53ef\u7f16\u7a0b\u63a5\u53e3","text":"<p>\u5bf9\u4e8e\u6d4f\u89c8\u5668\u800c\u8a00\uff0cJavaScript \u7684\u5f15\u5165\u5e26\u6765\u7684\u53ef\u7f16\u7a0b\u6027\u5f00\u542f\u4e86\u4e00\u573a\u5de8\u5927\u7684\u9769\u547d\uff0c\u4f7f\u6d4f\u89c8\u5668\u53d1\u5c55\u6210\u4e3a\u51e0\u4e4e\u72ec\u7acb\u7684\u64cd\u4f5c\u7cfb\u7edf\u3002\u73b0\u5728\u8ba9\u6211\u4eec\u56de\u5230 eBPF\uff1a\u4e3a\u4e86\u7406\u89e3 eBPF \u5bf9 Linux \u5185\u6838\u7684\u53ef\u7f16\u7a0b\u6027\u5f71\u54cd\uff0c\u5bf9 Linux \u5185\u6838\u7684\u7ed3\u6784\u4ee5\u53ca\u5b83\u5982\u4f55\u4e0e\u5e94\u7528\u7a0b\u5e8f\u548c\u786c\u4ef6\u8fdb\u884c\u4ea4\u4e92\u6709\u4e00\u4e2a\u9ad8\u5c42\u6b21\u7684\u7406\u89e3\u662f\u6709\u5e2e\u52a9\u7684[4]\u3002</p> <p>Linux \u5185\u6838\u7684\u4e3b\u8981\u76ee\u7684\u662f\u62bd\u8c61\u51fa\u786c\u4ef6\u6216\u865a\u62df\u786c\u4ef6\uff0c\u5e76\u63d0\u4f9b\u4e00\u4e2a\u4e00\u81f4\u7684API\uff08\u7cfb\u7edf\u8c03\u7528\uff09\uff0c\u5141\u8bb8\u5e94\u7528\u7a0b\u5e8f\u8fd0\u884c\u548c\u5171\u4eab\u8d44\u6e90\u3002\u4e3a\u4e86\u5b9e\u73b0\u8fd9\u4e2a\u76ee\u7684\uff0c\u6211\u4eec\u7ef4\u62a4\u4e86\u4e00\u7cfb\u5217\u5b50\u7cfb\u7edf\u548c\u5c42\uff0c\u4ee5\u5206\u914d\u8fd9\u4e9b\u8d23\u4efb\u3002\u6bcf\u4e2a\u5b50\u7cfb\u7edf\u901a\u5e38\u5141\u8bb8\u67d0\u79cd\u7a0b\u5ea6\u7684\u914d\u7f6e\uff0c\u4ee5\u8003\u8651\u5230\u7528\u6237\u7684\u4e0d\u540c\u9700\u6c42\u3002\u5982\u679c\u4e0d\u80fd\u914d\u7f6e\u6240\u9700\u7684\u884c\u4e3a\uff0c\u5c31\u9700\u8981\u6539\u53d8\u5185\u6838\uff0c\u4ece\u5386\u53f2\u4e0a\u770b\uff0c\u6539\u53d8\u5185\u6838\u7684\u884c\u4e3a\uff0c\u6216\u8005\u8ba9\u7528\u6237\u7f16\u5199\u7684\u7a0b\u5e8f\u80fd\u591f\u5728\u5185\u6838\u4e2d\u8fd0\u884c\uff0c\u5c31\u6709\u4e24\u79cd\u9009\u62e9:</p> \u672c\u5730\u652f\u6301\u5185\u6838\u6a21\u5757 \u5199\u4e00\u4e2a\u5185\u6838\u6a21\u5757 \u6539\u53d8\u5185\u6838\u6e90\u4ee3\u7801\uff0c\u5e76\u8bf4\u670dLinux\u5185\u6838\u793e\u533a\u76f8\u4fe1\u8fd9\u79cd\u6539\u53d8\u662f\u5fc5\u8981\u7684\u3002\u7b49\u5f85\u51e0\u5e74\uff0c\u8ba9\u65b0\u7684\u5185\u6838\u7248\u672c\u6210\u4e3a\u4e00\u79cd\u5546\u54c1\u3002 \u5b9a\u671f\u4fee\u590d\u5b83\uff0c\u56e0\u4e3a\u6bcf\u4e2a\u5185\u6838\u7248\u672c\u90fd\u53ef\u80fd\u7834\u574f\u5b83\u3002\u7531\u4e8e\u7f3a\u4e4f\u5b89\u5168\u8fb9\u754c\uff0c\u5192\u7740\u7834\u574f\u4f60\u7684Linux\u5185\u6838\u7684\u98ce\u9669 <p>\u5b9e\u9645\u4e0a\uff0c\u4e24\u79cd\u65b9\u6848\u90fd\u4e0d\u5e38\u7528\uff0c\u524d\u8005\u6210\u672c\u592a\u9ad8\uff0c\u540e\u8005\u5219\u51e0\u4e4e\u6ca1\u6709\u53ef\u79fb\u690d\u6027\u3002</p> <p>\u6709\u4e86 eBPF\uff0c\u5c31\u6709\u4e86\u4e00\u4e2a\u65b0\u7684\u9009\u62e9\uff0c\u53ef\u4ee5\u91cd\u65b0\u7f16\u7a0b Linux \u5185\u6838\u7684\u884c\u4e3a\uff0c\u800c\u4e0d\u9700\u8981\u6539\u53d8\u5185\u6838\u7684\u6e90\u4ee3\u7801\u6216\u52a0\u8f7d\u5185\u6838\u6a21\u5757\uff0c\u540c\u65f6\u4fdd\u8bc1\u5728\u4e0d\u540c\u5185\u6838\u7248\u672c\u4e4b\u95f4\u4e00\u5b9a\u7a0b\u5ea6\u4e0a\u7684\u884c\u4e3a\u4e00\u81f4\u6027\u548c\u517c\u5bb9\u6027\u3001\u4ee5\u53ca\u5b89\u5168\u6027\u3002\u4e3a\u4e86\u5b9e\u73b0\u8fd9\u4e2a\u76ee\u7684\uff0ceBPF \u7a0b\u5e8f\u4e5f\u9700\u8981\u6709\u4e00\u5957\u5bf9\u5e94\u7684 API\uff0c\u5141\u8bb8\u7528\u6237\u5b9a\u4e49\u7684\u5e94\u7528\u7a0b\u5e8f\u8fd0\u884c\u548c\u5171\u4eab\u8d44\u6e90 --- \u6362\u53e5\u8bdd\u8bf4\uff0c\u67d0\u79cd\u610f\u4e49\u4e0a\u8bb2 eBPF \u865a\u62df\u673a\u4e5f\u63d0\u4f9b\u4e86\u4e00\u5957\u7c7b\u4f3c\u4e8e\u7cfb\u7edf\u8c03\u7528\u7684\u673a\u5236\uff0c\u501f\u52a9 eBPF \u548c\u7528\u6237\u6001\u901a\u4fe1\u7684\u673a\u5236\uff0cWasm \u865a\u62df\u673a\u548c\u7528\u6237\u6001\u5e94\u7528\u4e5f\u53ef\u4ee5\u83b7\u5f97\u8fd9\u5957\u201c\u7cfb\u7edf\u8c03\u7528\u201d\u7684\u5b8c\u6574\u4f7f\u7528\u6743\uff0c\u4e00\u65b9\u9762\u80fd\u53ef\u7f16\u7a0b\u5730\u6269\u5c55\u4f20\u7edf\u7684\u7cfb\u7edf\u8c03\u7528\u7684\u80fd\u529b\uff0c\u53e6\u4e00\u65b9\u9762\u5b9e\u73b0\u66f4\u9ad8\u6548\u7684\u53ef\u7f16\u7a0b IO \u5904\u7406\u3002</p> <p></p> <p>\u6b63\u5982\u4e0a\u56fe\u6240\u793a\uff0c\u5f53\u4eca\u7684 Linux \u5185\u6838\u6b63\u5728\u5411\u4e00\u4e2a\u65b0\u7684\u5185\u6838\u6a21\u578b\u6f14\u5316\uff1a\u7528\u6237\u5b9a\u4e49\u7684\u5e94\u7528\u7a0b\u5e8f\u53ef\u4ee5\u5728\u5185\u6838\u6001\u548c\u7528\u6237\u6001\u540c\u65f6\u6267\u884c\uff0c\u7528\u6237\u6001\u901a\u8fc7\u4f20\u7edf\u7684\u7cfb\u7edf\u8c03\u7528\u8bbf\u95ee\u7cfb\u7edf\u8d44\u6e90\uff0c\u5185\u6838\u6001\u5219\u901a\u8fc7 BPF Helper Calls \u548c\u7cfb\u7edf\u7684\u5404\u4e2a\u90e8\u5206\u5b8c\u6210\u4ea4\u4e92\u3002\u622a\u6b62 2023 \u5e74\u521d\uff0c\u5185\u6838\u4e2d\u7684 eBPF \u865a\u62df\u673a\u4e2d\u5df2\u7ecf\u6709 220 \u591a\u4e2aHelper \u7cfb\u7edf\u63a5\u53e3\uff0c\u6db5\u76d6\u4e86\u975e\u5e38\u591a\u7684\u5e94\u7528\u573a\u666f\u3002</p> <p>\u503c\u5f97\u6ce8\u610f\u7684\u662f\uff0cBPF Helper Call \u548c\u7cfb\u7edf\u8c03\u7528\u4e8c\u8005\u5e76\u4e0d\u662f\u7ade\u4e89\u5173\u7cfb\uff0c\u5b83\u4eec\u7684\u7f16\u7a0b\u6a21\u578b\u548c\u6709\u6027\u80fd\u4f18\u52bf\u7684\u573a\u666f\u5b8c\u5168\u4e0d\u540c\uff0c\u4e5f\u4e0d\u4f1a\u5b8c\u5168\u66ff\u4ee3\u5bf9\u65b9\u3002\u5bf9 Wasm \u548c Wasi \u76f8\u5173\u751f\u6001\u6765\u8bf4\uff0c\u60c5\u51b5\u4e5f\u7c7b\u4f3c\uff0c\u4e13\u95e8\u8bbe\u8ba1\u7684 wasi \u63a5\u53e3\u9700\u8981\u7ecf\u5386\u4e00\u4e2a\u6f2b\u957f\u7684\u6807\u51c6\u5316\u8fc7\u7a0b\uff0c\u4f46\u53ef\u80fd\u5728\u7279\u5b9a\u573a\u666f\u80fd\u4e3a\u7528\u6237\u6001\u5e94\u7528\u83b7\u53d6\u66f4\u4f73\u7684\u6027\u80fd\u548c\u53ef\u79fb\u690d\u6027\u4fdd\u8bc1\uff0c\u800c eBPF \u5728\u4fdd\u8bc1\u6c99\u7bb1\u672c\u8d28\u548c\u53ef\u79fb\u690d\u6027\u7684\u524d\u63d0\u4e0b\uff0c\u53ef\u4ee5\u63d0\u4f9b\u4e00\u4e2a\u5feb\u901f\u7075\u6d3b\u7684\u6269\u5c55\u7cfb\u7edf\u63a5\u53e3\u7684\u65b9\u6848\u3002</p> <p>\u76ee\u524d\u7684 eBPF \u4ecd\u7136\u5904\u4e8e\u65e9\u671f\u9636\u6bb5\uff0c\u4f46\u662f\u501f\u52a9\u5f53\u524d eBPF \u63d0\u4f9b\u7684\u5185\u6838\u63a5\u53e3\u548c\u7528\u6237\u6001\u4ea4\u4e92\u7684\u80fd\u529b\uff0c\u7ecf\u7531 Wasm-bpf \u7684\u7cfb\u7edf\u63a5\u53e3\u8f6c\u6362\uff0cWasm \u865a\u62df\u673a\u4e2d\u7684\u5e94\u7528\u5df2\u7ecf\u51e0\u4e4e\u6709\u80fd\u529b\u83b7\u53d6\u5185\u6838\u4ee5\u53ca\u7528\u6237\u6001\u4efb\u610f\u4e00\u4e2a\u51fd\u6570\u8c03\u7528\u7684\u6570\u636e\u548c\u8fd4\u56de\u503c\uff08kprobe\uff0cuprobe...\uff09\uff1b\u4ee5\u5f88\u4f4e\u7684\u4ee3\u4ef7\u6536\u96c6\u548c\u7406\u89e3\u6240\u6709\u7cfb\u7edf\u8c03\u7528\uff0c\u5e76\u83b7\u53d6\u6240\u6709\u7f51\u7edc\u64cd\u4f5c\u7684\u6570\u636e\u5305\u548c\u5957\u63a5\u5b57\u7ea7\u522b\u7684\u6570\u636e\uff08tracepoint\uff0csocket...\uff09\uff1b\u5728\u7f51\u7edc\u5305\u5904\u7406\u89e3\u51b3\u65b9\u6848\u4e2d\u6dfb\u52a0\u989d\u5916\u7684\u534f\u8bae\u5206\u6790\u5668\uff0c\u5e76\u8f7b\u677e\u5730\u7f16\u7a0b\u4efb\u4f55\u8f6c\u53d1\u903b\u8f91\uff08XDP\uff0cTC...\uff09\uff0c\u4ee5\u6ee1\u8db3\u4e0d\u65ad\u53d8\u5316\u7684\u9700\u6c42\uff0c\u800c\u65e0\u9700\u79bb\u5f00Linux\u5185\u6838\u7684\u6570\u636e\u5305\u5904\u7406\u73af\u5883\u3002</p> <p>\u4e0d\u4ec5\u5982\u6b64\uff0ceBPF \u8fd8\u6709\u80fd\u529b\u5f80\u7528\u6237\u7a7a\u95f4\u4efb\u610f\u8fdb\u7a0b\u7684\u4efb\u610f\u5730\u5740\u5199\u5165\u6570\u636e\uff08bpf_probe_write_user[5]\uff09\uff0c\u6709\u9650\u5ea6\u5730\u4fee\u6539\u5185\u6838\u51fd\u6570\u7684\u8fd4\u56de\u503c\uff08bpf_override_return[6]\uff09\uff0c\u751a\u81f3\u5728\u5185\u6838\u6001\u76f4\u63a5\u6267\u884c\u67d0\u4e9b\u7cfb\u7edf\u8c03\u7528[7]\uff1b\u6240\u5e78\u7684\u662f\uff0ceBPF \u5728\u52a0\u8f7d\u8fdb\u5185\u6838\u4e4b\u524d\u5bf9\u5b57\u8282\u7801\u4f1a\u8fdb\u884c\u4e25\u683c\u7684\u5b89\u5168\u68c0\u67e5\uff0c\u786e\u4fdd\u6ca1\u6709\u5185\u5b58\u8d8a\u754c\u7b49\u64cd\u4f5c\uff0c\u540c\u65f6\uff0c\u8bb8\u591a\u53ef\u80fd\u4f1a\u6269\u5927\u653b\u51fb\u9762\u3001\u5e26\u6765\u5b89\u5168\u98ce\u9669\u7684\u529f\u80fd\u90fd\u662f\u9700\u8981\u5728\u7f16\u8bd1\u5185\u6838\u65f6\u660e\u786e\u9009\u62e9\u542f\u7528\u624d\u80fd\u4f7f\u7528\u7684\uff1b\u5728 Wasm \u865a\u62df\u673a\u5c06\u5b57\u8282\u7801\u52a0\u8f7d\u8fdb\u5185\u6838\u4e4b\u524d\uff0c\u4e5f\u53ef\u4ee5\u660e\u786e\u9009\u62e9\u542f\u7528\u6216\u8005\u7981\u7528\u67d0\u4e9b eBPF \u529f\u80fd\uff0c\u4ee5\u786e\u4fdd\u6c99\u7bb1\u7684\u5b89\u5168\u6027\u3002</p> <p>\u6240\u6709\u7684\u8fd9\u4e9b\u573a\u666f\u90fd\u4e0d\u9700\u8981\u79bb\u5f00 Wasm \u8f7b\u91cf\u7ea7\u5bb9\u5668\uff1a\u4e0d\u50cf\u4f20\u7edf\u7684\u4f7f\u7528 Wasm \u4f5c\u4e3a\u6570\u636e\u5904\u7406\u6216\u8005\u63a7\u5236\u63d2\u4ef6\u7684\u5e94\u7528\u4e2d\uff0c\u8fd9\u4e9b\u6b65\u9aa4\u7531 Wasm \u865a\u62df\u673a\u5916\u7684\u903b\u8f91\u5b9e\u73b0\uff0c\u73b0\u5728\u53ef\u4ee5\u5728 Wasm \u8f7b\u91cf\u7ea7\u5bb9\u5668\u4e2d\u5b9e\u73b0\u5bf9 eBPF \u4ee5\u53ca eBPF \u80fd\u8bbf\u95ee\u7684\u51e0\u4e4e\u6240\u6709\u7cfb\u7edf\u8d44\u6e90\uff0c\u5b8c\u6574\u7684\u63a7\u5236\u548c\u4ea4\u4e92\uff0c\u751a\u81f3\u5b9e\u65f6\u751f\u6210 eBPF \u4ee3\u7801\u6539\u53d8\u5185\u6838\u7684\u884c\u4e3a\u903b\u8f91\uff0c\u5b9e\u73b0\u6574\u4e2a\u7cfb\u7edf\u4ece\u7528\u6237\u6001\u6269\u5c55\u5230\u5185\u6838\u6001\u7684\u53ef\u7f16\u7a0b\u6027\u3002</p>"},{"location":"blogs/introduce-to-wasm-bpf-wasm.zh/#ebpf_1","title":"\u7528\u6237\u7a7a\u95f4\u548c eBPF \u7a0b\u5e8f\u7684\u4ea4\u4e92\u6d41\u7a0b","text":"<p>eBPF \u7a0b\u5e8f\u662f\u4ee5\u51fd\u6570\u4e3a\u5355\u4f4d\u7684\u3001\u4e8b\u4ef6\u9a71\u52a8\u7684\uff0c\u5f53\u5185\u6838\u6216\u7528\u6237\u7a7a\u95f4\u5e94\u7528\u7a0b\u5e8f\u901a\u8fc7\u67d0\u4e2a hook \u70b9\u65f6\u5c31\u4f1a\u8fd0\u884c\u7279\u5b9a\u7684 eBPF \u7a0b\u5e8f\u3002\u8981\u4f7f\u7528\u4e00\u4e2a eBPF \u7a0b\u5e8f\uff0c\u9996\u5148\u6211\u4eec\u9700\u8981\u4f7f\u7528 clang/LLVM \u5de5\u5177\u94fe\u5c06\u5bf9\u5e94\u7684\u6e90\u4ee3\u7801\u7f16\u8bd1\u4e3a bpf \u5b57\u8282\u7801\uff0c\u5176\u4e2d\u5305\u542b\u5bf9\u5e94\u7684\u6570\u636e\u7ed3\u6784\u5b9a\u4e49\u3001maps \u548c progs \u5b9a\u4e49\uff0cprogs \u5373\u7a0b\u5e8f\u6bb5\uff0cmaps \u53ef\u4ee5\u7528\u6765\u5b58\u50a8\u6570\u636e\u6216\u8005\u548c\u7528\u6237\u7a7a\u95f4\u5b9e\u73b0\u53cc\u5411\u901a\u4fe1\u3002\u4e4b\u540e\uff0c\u6211\u4eec\u53ef\u4ee5\u501f\u52a9\u7528\u6237\u6001\u7684\u5f00\u53d1\u6846\u67b6\u548c\u52a0\u8f7d\u6846\u67b6\uff0c\u5b9e\u73b0\u5b8c\u6574\u7684 eBPF \u5e94\u7528\u3002</p>"},{"location":"blogs/introduce-to-wasm-bpf-wasm.zh/#ebpf_2","title":"\u901a\u5e38\u7684\u7528\u6237\u6001 eBPF \u5f00\u53d1\u6846\u67b6","text":"<p>\u5bf9\u4e8e\u4e00\u4e2a\u5b8c\u6574\u7684 eBPF \u5e94\u7528\uff0c\u901a\u5e38\u9700\u8981\u5305\u542b\u7528\u6237\u6001\u548c\u5185\u6838\u6001\u4e24\u90e8\u5206\uff1a</p> <ul> <li>\u7528\u6237\u6001\u7a0b\u5e8f\u9700\u8981\u901a\u8fc7\u4e00\u7cfb\u5217\u7cfb\u7edf\u8c03\u7528\u8ddf\u5185\u6838\u8fdb\u884c\u4ea4\u4e92\uff08\u4e3b\u8981\u662f bpf \u7cfb\u7edf\u8c03\u7528\uff09\uff0c\u521b\u5efa\u5bf9\u5e94\u7684 map \u4ee5\u5728\u5185\u6838\u6001\u4fdd\u5b58\u6570\u636e\u6216\u548c\u7528\u6237\u6001\u901a\u4fe1\uff0c\u6839\u636e\u914d\u7f6e\u52a8\u6001\u9009\u62e9\u52a0\u8f7d\u4e0d\u540c\u7684\u7a0b\u5e8f\u6bb5\uff0c\u52a8\u6001\u4fee\u6539\u5b57\u8282\u7801\u6216\u914d\u7f6e eBPF \u7a0b\u5e8f\u7684\u53c2\u6570\uff0c\u5c06\u5bf9\u5e94\u7684\u5b57\u8282\u7801\u4fe1\u606f\u52a0\u8f7d\u8fdb\u5185\u6838\uff0c\u901a\u8fc7\u9a8c\u8bc1\u5668\u786e\u4fdd\u5b89\u5168\u6027\uff0c\u5e76\u901a\u8fc7 maps \u548c\u5185\u6838\u4e4b\u95f4\u5b9e\u73b0\u53cc\u5411\u901a\u4fe1\uff0c\u901a\u8fc7 ring buffer / perf buffer \u4e4b\u7c7b\u7684\u673a\u5236\u4ece\u5185\u6838\u6001\u5411\u7528\u6237\u6001\u4f20\u9012\u6570\u636e\uff08\u6216\u8005\u53cd\u4e4b\uff09\u3002</li> <li>\u5185\u6838\u6001\u4e3b\u8981\u8d1f\u8d23\u5177\u4f53\u7684\u8ba1\u7b97\u903b\u8f91\u4e0e\u6570\u636e\u6536\u96c6\u3002</li> </ul>"},{"location":"blogs/introduce-to-wasm-bpf-wasm.zh/#wasm-ebpf-ebpf","title":"\u5728\u7528\u6237\u6001 Wasm-eBPF \u7cfb\u7edf\u63a5\u53e3\u4e4b\u4e0a\u5b9a\u4e49\u7684\u5168\u65b0 eBPF \u5f00\u53d1\u6846\u67b6","text":"<p>\u8fd9\u4e2a\u9879\u76ee\u672c\u8d28\u4e0a\u53ef\u4ee5\u8bf4\u662f\u5e0c\u671b\u628a Wasm \u6c99\u7bb1\u5f53\u505a\u5728\u64cd\u4f5c\u7cfb\u7edf\u4e4b\u4e0a\u5efa\u7acb\u7684\u53e6\u4e00\u4e2a\u7528\u6237\u6001\u8fd0\u884c\u7a7a\u95f4\uff0c\u8ba9 Wasm \u5e94\u7528\u5728\u6c99\u7bb1\u4e2d\u5b9e\u73b0\u548c\u901a\u5e38\u7528\u6237\u6001\u4e2d\u8fd0\u884c\u7684 eBPF \u5e94\u7528\u4e00\u6837\u7684\u7f16\u7a0b\u6a21\u578b\u548c\u6267\u884c\u903b\u8f91\u3002Wasm-bpf \u4f1a\u9700\u8981\u4e00\u4e2a\u5728 host\uff08\u6c99\u7bb1\u5916\u90e8\uff09\u6784\u5efa\u7684\u8fd0\u884c\u65f6\u6a21\u5757\uff0c\u4ee5\u53ca\u4e00\u4e9b\u5728\u6c99\u7bb1\u5185\u90e8\u88ab\u7f16\u8bd1\u4e3a Wasm \u5b57\u8282\u7801\u7684\u8fd0\u884c\u65f6\u5e93\u6765\u63d0\u4f9b\u5b8c\u6574\u7684\u652f\u6301\u3002</p> <p></p> <p>\u8981\u5b9e\u73b0\u5b8c\u5907\u7684\u5f00\u53d1\u6a21\u578b\uff0c\u6211\u4eec\u9700\u8981\uff1a</p> <ul> <li>\u4e00\u4e2a Wasm \u6a21\u5757\u53ef\u4ee5\u5bf9\u5e94\u591a\u4e2a eBPF \u7a0b\u5e8f\uff1b</li> <li>\u4e00\u4e2a eBPF \u7a0b\u5e8f\u5b9e\u4f8b\u4e5f\u53ef\u4ee5\u88ab\u591a\u4e2a Wasm \u6a21\u5757\u6240\u5171\u7528\uff1b</li> <li>\u53ef\u4ee5\u5c06 eBPF \u7a0b\u5e8f\u4ece Wasm \u6c99\u7bb1\u4e2d\u52a8\u6001\u52a0\u8f7d\u8fdb\u5185\u6838\u3001\u9009\u62e9\u6240\u9700\u7684\u6302\u8f7d\u70b9\u6302\u8f7d\u3001\u5378\u8f7d\uff0c\u63a7\u5236\u591a\u4e2a eBPF \u5b57\u8282\u7801\u5bf9\u8c61\u7684\u5b8c\u6574\u751f\u547d\u5468\u671f\uff0c\u5e76\u652f\u6301\u5927\u591a\u6570\u7684 eBPF \u7a0b\u5e8f\u7c7b\u578b\uff1b</li> <li>\u53ef\u4ee5\u901a\u8fc7\u591a\u79cd\u7c7b\u578b\u7684 Maps \u548c\u5185\u6838\u53cc\u5411\u901a\u4fe1\uff0c\u652f\u6301\u5927\u591a\u6570\u7684 Maps \u7c7b\u578b\uff1b</li> <li>\u901a\u8fc7 ring buffer \u548c perf event polling \u4ece\u5185\u6838\u6001\u5411\u7528\u6237\u6001\u9ad8\u6548\u53d1\u9001\u4fe1\u606f\uff08\u5bf9\u4e8e ring buffer \u6765\u8bf4\uff0c\u4e5f\u53ef\u4ee5\u53cd\u4e4b\uff09\uff1b</li> <li>\u51e0\u4e4e\u53ef\u4ee5\u9002\u914d\u4e8e\u6240\u6709\u7684\u4f7f\u7528 eBPF \u7a0b\u5e8f\u7684\u5e94\u7528\u573a\u666f\uff0c\u5e76\u53ef\u4ee5\u968f\u7740\u5185\u6838\u529f\u80fd\u7684\u6dfb\u52a0\u4e0d\u65ad\u6f14\u5316\u548c\u6269\u5c55\uff0c\u540c\u65f6\u4e0d\u9700\u8981\u53d8\u52a8 Wasm \u865a\u62df\u673a\u7684\u7cfb\u7edf\u63a5\u53e3\u3002</li> </ul> <p>\u8fd9\u5c31\u662f\u76ee\u524d Wasm-bpf \u9879\u76ee\u6240\u505a\u7684\u5de5\u4f5c\u3002\u6211\u4eec\u4e5f\u63d0\u51fa\u4e86\u4e00\u4e2a\u65b0\u7684 WASI \u7684 Proposal: WASI-eBPF[7].</p> <p>\u5728 Wasm-bpf \u9879\u76ee\u4e2d\uff0c\u6240\u6709 Wasm \u548c eBPF \u865a\u62df\u673a\u4e4b\u95f4\u7684\u901a\u4fe1\u90fd\u65e0\u9700\u7ecf\u8fc7\u5e8f\u5217\u5316\u3001\u53cd\u5e8f\u5217\u5316\u673a\u5236\uff0c\u901a\u8fc7\u5de5\u5177\u94fe\u4e2d\u4ee3\u7801\u751f\u6210\u6280\u672f\u548c BTF\uff08BPF \u7c7b\u578b\u683c\u5f0f[12]\uff09\u4fe1\u606f\u7684\u652f\u6301\uff0c\u6211\u4eec\u53ef\u4ee5\u5b9e\u73b0\u5728 eBPF \u548c Wasm \u4e4b\u95f4\u53ef\u80fd\u4e0d\u540c\u7684\u7ed3\u6784\u4f53\u5185\u5b58\u5e03\u5c40\u3001\u4e0d\u540c\u7684\u5927\u5c0f\u7aef\u673a\u5236\u3001\u4e0d\u540c\u7684\u6307\u9488\u5bbd\u5ea6\u4e4b\u95f4\u7684\u6b63\u786e\u901a\u4fe1\uff0c\u5728\u8fd0\u884c\u65f6\u51e0\u4e4e\u4e0d\u4f1a\u5f15\u5165\u4efb\u4f55\u989d\u5916\u7684\u5f00\u9500\uff1b\u901a\u8fc7 eBPF Maps \u901a\u4fe1\u7684\u65f6\u5019\u6570\u636e\u53ef\u4ee5\u76f4\u63a5\u7531\u5185\u6838\u6001\u590d\u5236\u5230 Wasm \u865a\u62df\u673a\u7684\u5185\u5b58\u4e2d\uff0c\u907f\u514d\u591a\u6b21\u62f7\u8d1d\u5e26\u6765\u7684\u989d\u5916\u635f\u8017\u3002\u540c\u65f6\uff0c\u901a\u8fc7\u81ea\u52a8\u751f\u6210 skeleton \uff08bpf \u4ee3\u7801\u6846\u67b6\uff09\u548c\u7c7b\u578b\u5b9a\u4e49\u7684\u65b9\u5f0f\uff0c\u7528\u6237\u6001\u7a0b\u5e8f\u7684 eBPF-Wasm \u5f00\u53d1\u4f53\u9a8c\u4e5f\u5f97\u5230\u4e86\u975e\u5e38\u5927\u7684\u6539\u5584\u3002</p> <p>\u5f97\u76ca\u4e8e libbpf \u63d0\u4f9b\u7684 CO-RE\uff08Compile-Once, Run Everywhere\uff09\u6280\u672f\uff0c\u5728\u4e0d\u540c\u5185\u6838\u7248\u672c\u4e4b\u95f4\u79fb\u690d eBPF \u5b57\u8282\u7801\u5bf9\u8c61\uff0c\u4e5f\u4e0d\u9700\u8981\u5f15\u5165\u989d\u5916\u7684\u91cd\u65b0\u7f16\u8bd1\u6d41\u7a0b\uff0c\u8fd0\u884c\u65f6\u4e5f\u6ca1\u6709\u4efb\u4f55\u7684 LLVM/Clang \u4f9d\u8d56[12]\u3002</p> <p>\u901a\u5e38\u4e00\u4e2a\u7f16\u8bd1\u597d\u7684 eBPF-Wasm \u6a21\u5757\u53ea\u6709\u5927\u7ea6 90Kb\uff0c\u5728\u4e0d\u5230 100ms \u5185\u5373\u53ef\u4ee5\u5b8c\u6210\u52a8\u6001\u52a0\u8f7d\u8fdb\u5185\u6838\u5e76\u6267\u884c\u7684\u8fc7\u7a0b\u3002\u6211\u4eec\u4e5f\u5728\u4ed3\u5e93\u4e2d\u63d0\u4f9b\u4e86\u51e0\u4e2a\u4f8b\u5b50\uff0c\u5206\u522b\u5bf9\u5e94\u4e8e\u53ef\u89c2\u6d4b\u3001\u7f51\u7edc\u3001\u5b89\u5168\u7b49\u591a\u79cd\u573a\u666f\u3002</p> <p>\u611f\u8c22\u534e\u5357\u7406\u5de5\u5927\u5b66\u8d56\u6653\u94ee\u526f\u6559\u6388\u3001\u897f\u5b89\u90ae\u7535\u5927\u5b66\u9648\u8389\u541b\u6559\u6388\u56e2\u961f\u548c\u8fbe\u5766\u79d1\u6280\u738b\u749e\u3001\u65bd\u7ee7\u6210\u8001\u5e08\u5bf9 Wasm \u548c eBPF \u76f8\u7ed3\u5408\u7684\u6307\u5bfc\u4e0e\u5e2e\u52a9\uff0c\u5728\u63a5\u4e0b\u6765\u7684\u5de5\u4f5c\u4e2d\uff0c\u6211\u4eec\u4f1a\u548c\u53c2\u52a0 2023 \u5f00\u6e90\u6bd5\u8bbe\u4e4b\u65c5\u7684\u540c\u5b66\u4eec\u4e00\u540c\u9488\u5bf9\u4e00\u4e9b Wasm-bpf \u5177\u4f53\u7684\u5e94\u7528\u573a\u666f\uff0c\u8fdb\u884c\u66f4\u6df1\u5165\u7684\u7814\u7a76\u4e0e\u63a2\u8ba8\uff0c\u5e76\u5728\u4e0b\u4e00\u7bc7 blog \u4e2d\u7ed9\u51fa\u66f4\u8be6\u7ec6\u7684\u539f\u7406\u89e3\u6790\u4e0e\u6027\u80fd\u5206\u6790\uff0c\u4ee5\u53ca\u5bf9\u5e94\u7684\u4e00\u4e9b\u4ee3\u7801\u793a\u4f8b\u3002</p> <p>Wasm-bpf \u7f16\u8bd1\u5de5\u5177\u94fe\u4e0e\u8fd0\u884c\u65f6\u6a21\u5757\u7b49\u76ee\u524d\u7531 eunomia-bpf \u5f00\u6e90\u793e\u533a\u5f00\u53d1\u4e0e\u7ef4\u62a4\uff0c\u611f\u8c22\u4e2d\u79d1\u9662\u8f6f\u4ef6\u6240 PLCT \u5b9e\u9a8c\u5ba4\u5bf9\u793e\u533a\u7684\u5927\u529b\u652f\u6301\u548c\u8d44\u52a9\uff0c\u611f\u8c22\u793e\u533a\u540c\u4f34\u4eec\u7684\u8d21\u732e\u3002\u63a5\u4e0b\u6765\uff0c\u6211\u4eec\u4e5f\u4f1a\u5728\u5bf9\u5e94\u7684 eBPF \u548c Wasm \u76f8\u5173\u7684\u5de5\u5177\u94fe\u548c\u8fd0\u884c\u65f6\u65b9\u9762\uff0c\u8fdb\u884c\u66f4\u591a\u7684\u5b8c\u5584\u548c\u63a2\u7d22\uff0c\u5e76\u79ef\u6781\u5411\u4e0a\u6e38\u793e\u533a\u53cd\u9988\u548c\u8d21\u732e\u3002</p>"},{"location":"blogs/introduce-to-wasm-bpf-wasm.zh/#_1","title":"\u53c2\u8003\u8d44\u6599","text":"<ul> <li>[1] wasm-bpf Github \u5f00\u6e90\u5730\u5740\uff1ahttps://github.com/eunomia-bpf/wasm-bpf</li> <li>[2] \u5f53 Wasm \u9047\u89c1 eBPF \uff1a\u4f7f\u7528 WebAssembly \u7f16\u5199\u3001\u5206\u53d1\u3001\u52a0\u8f7d\u8fd0\u884c eBPF \u7a0b\u5e8f\uff1ahttps://zhuanlan.zhihu.com/p/573941739</li> <li>[3] https://ebpf.io/</li> <li>[4] \u4ec0\u4e48\u662f eBPF\uff1ahttps://ebpf.io/what-is-ebpf</li> <li>[5] Offensive BPF: Understanding and using bpf_probe_write_user https://embracethered.com/blog/posts/2021/offensive-bpf-libbpf-bpf_probe_write_user/</li> <li>[6] \u4e91\u539f\u751f\u5b89\u5168\u653b\u9632\uff5c\u4f7f\u7528eBPF\u9003\u9038\u5bb9\u5668\u6280\u672f\u5206\u6790\u4e0e\u5b9e\u8df5\uff1ahttps://security.tencent.com/index.php/blog/msg/206</li> <li>[7] kernel-versions.md: https://github.com/iovisor/bcc/blob/master/docs/kernel-versions.md</li> <li>[8] WebAssembly\uff1a\u65e0\u9700\u5bb9\u5668\u7684 Docker\uff1ahttps://zhuanlan.zhihu.com/p/595257541</li> <li>[9] \u4e91\u539f\u751f\u9879\u76ee\u53ef\u6269\u5c55\u6027\u7684\u5229\u5668 WebAssembly \u7b80\u4ecb https://mp.weixin.qq.com/s/fap0bl6GFGi8zN5BFLpkCw</li> <li>[10] WASI-eBPF: https://github.com/WebAssembly/WASI/issues/513</li> <li>[11] BPF BTF \u8be6\u89e3\uff1ahttps://www.ebpf.top/post/kernel_btf/</li> <li>[12] BPF \u53ef\u79fb\u690d\u6027\u548c CO-RE\uff08\u4e00\u6b21\u7f16\u8bd1\uff0c\u5230\u5904\u8fd0\u884c\uff09\uff1ahttps://cloud.tencent.com/developer/article/1802154</li> </ul>"},{"location":"blogs/lmp-eunomia.zh/","title":"\u5982\u4f55\u5728 Linux \u663e\u5fae\u955c\uff08LMP\uff09\u9879\u76ee\u4e2d\u5f00\u542f eBPF \u4e4b\u65c5\uff1f","text":""},{"location":"blogs/lmp-eunomia.zh/#httpszhuanlanzhihucomp589784489","title":"! https://zhuanlan.zhihu.com/p/589784489","text":"<p>eBPF \u4e3a Linux \u5185\u6838\u63d0\u4f9b\u4e86\u53ef\u6269\u5c55\u6027\uff0c\u4f7f\u5f00\u53d1\u4eba\u5458\u80fd\u591f\u5bf9 Linux \u5185\u6838\u8fdb\u884c\u7f16\u7a0b\uff0c\u4ee5\u4fbf\u6839\u636e\u4ed6\u4eec\u7684\u4e1a\u52a1\u9700\u6c42\u5feb\u901f\u6784\u5efa\u667a\u80fd\u7684\u6216\u4e30\u5bcc\u7684\u529f\u80fd\u3002</p> <p>\u6211\u4eec\u7684 LMP(Linux Microscope) \u9879\u76ee \u662f\u4e3a\u4e86\u5145\u5206\u6316\u6398 ebpf \u7684\u53ef\u80fd\u6027\u800c\u5efa\u7acb\u7684\uff0c\u9879\u76ee\u4ee5\u6784\u5efa eBPF \u5b66\u4e60\u793e\u533a\u3001\u6210\u4e3a eBPF \u5de5\u5177\u96c6\u6563\u5730\u3001\u5b75\u5316 eBPF \u60f3\u6cd5\u548c\u9879\u76ee\u4e3a\u76ee\u6807\uff0c\u6b63\u5728\u5927\u529b\u5efa\u8bbe\u4e2d\u3002\u4e4b\u524d\u6211\u4eec\u5728 LMP \u5176\u4e2d\u7684 eBPF Supermarket \u4e2d\u5305\u542b\u4e86\u5927\u91cf\u7531\u4e2a\u4eba\u5f00\u53d1\u8005\u7f16\u5199\u7684 eBPF \u5de5\u5177\uff0c\u8986\u76d6\u4e86\u7f51\u7edc\u3001\u6027\u80fd\u5206\u6790\u3001\u5b89\u5168\u7b49\u591a\u79cd\u529f\u80fd\uff0c\u6211\u4eec\u6b63\u5728\u5c1d\u8bd5\u628a\u5176\u4e2d\u7684\u4e00\u4e9b\u7a0b\u5e8f\u8fc1\u79fb\u5230 eBPF Hub\uff0c\u4e00\u4e9b\u89c4\u8303\u5316\u7684 eBPF \u7a0b\u5e8f\u5e93\uff0c\u53ef\u4ee5\u968f\u65f6\u4e0b\u8f7d\u8fd0\u884c\uff0c\u6216\u5d4c\u5165\u5927\u578b\u5e94\u7528\u7a0b\u5e8f\u4e2d\u4f5c\u4e3a\u63d2\u4ef6\u4f7f\u7528\u3002</p> <p>\u6211\u4eec\u5c1d\u8bd5\u5728 eBPF Hub \u4e2d\uff0c\u57fa\u4e8e eunomia-bpf \u5f00\u53d1\u6846\u67b6\u521b\u5efa\u7b26\u5408 OCI \u6807\u51c6\u7684 Wasm \u548c eBPF \u7a0b\u5e8f\uff0c\u5e76\u5229\u7528 ORAS \u7b80\u5316\u6269\u5c55 LMP \u7684 eBPF \u5206\u53d1\u3001\u52a0\u8f7d\u3001\u8fd0\u884c\u80fd\u529b\u3002</p>"},{"location":"blogs/lmp-eunomia.zh/#_1","title":"\u5feb\u901f\u4f7f\u7528","text":"<p>\u5982\u679c\u60a8\u60f3\u5feb\u901f\u5f00\u59cb eBPF\uff0c\u53ef\u4ee5\u4f7f\u7528\u6211\u4eec\u5f00\u53d1\u7684\u8f7b\u91cf\u7ea7\u6846\u67b6\u4e4b\u4e0a\u7684\u547d\u4ee4\u884c\u7a0b\u5e8f lmp-cli\u3002\u5f53\u4f7f\u7528\u811a\u672c\u5b89\u88c5\u597d\u6211\u4eec\u7684\u6846\u67b6\u4e4b\u540e\uff0c\u60a8\u53ea\u9700\u8981\u4e00\u6761\u547d\u4ee4\uff0c\u65e0\u9700\u4efb\u4f55\u7f16\u8bd1\uff0c\u5373\u53ef\u4f53\u4f1a\u5230 eBPF \u7684\u5f3a\u5927\u4e4b\u5904\uff1a</p> <pre><code>$ lmp run sigsnoop\ndownload with curl: https://linuxkerneltravel.github.io/lmp/sigsnoop/package.json\nrunning and waiting for the eBPF events from perf event...\ntime pid tpid sig ret comm\n00:21:41 109955 112863 28 0 gnome-terminal-\n00:21:41 109955 112862 28 0 gnome-terminal-\n...\n</code></pre> <p>\u5982\u679c\u60a8\u4f7f\u7528\u8fc7 bcc \u7b49 eBPF \u5f00\u53d1\u5de5\u5177\uff0c\u60a8\u4e00\u5b9a\u4f1a\u60ca\u559c\u4e8e LMP \u7684\u4fbf\u6377\u6027\u3002LMP \u4e2d\u5305\u542b\u4e86\u5404\u79cd\u5404\u6837\u7684 eBPF \u7a0b\u5e8f\uff0c\u8fd9\u79cd\u4fbf\u6377\u7684\u8fd0\u884c\uff0c\u79bb\u4e0d\u5f00\u6211\u4eec\u57fa\u4e8e\u7684\u5e95\u5c42\u6846\u67b6 eunomia-bpf\uff0c\u5b83\u5b8c\u5168\u5b9e\u73b0\u4e86\u201c\u4e00\u6b21\u7f16\u8bd1\uff0c\u5904\u5904\u8fd0\u884c\u201d\u7684 eBPF \u8de8\u5e73\u53f0\u76ee\u6807\u3002\u5728 eunomia-bpf \u6846\u67b6\u4e0b\uff0cLMP \u5f00\u53d1\u7684 eBPF \u5e94\u7528\u4e0d\u4ec5\u53ef\u4ee5\u9002\u914d\u4efb\u610f\u67b6\u6784\u548c\u4e0d\u540c\u5185\u6838\u7248\u672c\uff0c\u800c\u4e14\u8fd8\u5177\u6709\u8f7b\u91cf\u7ea7\u3001\u826f\u597d\u7684\u9694\u79bb\u6027\u7b49\u4f18\u70b9\uff0c\u53ef\u4ee5\u4f5c\u4e3a\u63d2\u4ef6\u5230\u5d4c\u5165\u5927\u578b\u5e94\u7528\u4e4b\u4e2d\u3002</p>"},{"location":"blogs/lmp-eunomia.zh/#eunomia-bpf-ebpf-wasm","title":"eunomia-bpf\uff1a\u7ed3\u5408 eBPF \u548c Wasm \u7684\u8f7b\u91cf\u7ea7\u5f00\u53d1\u6846\u67b6","text":"<p>\u4f5c\u4e3a\u4e00\u4e2a eBPF \u7a0b\u5e8f\u7684\u8f7b\u91cf\u7ea7\u5f00\u53d1\u52a0\u8f7d\u6846\u67b6\uff0ceunomia-bpf \u57fa\u4e8e Wasm \u8fd0\u884c\u65f6\u548c BTF \u6280\u672f\uff0c\u5305\u542b\u4e86\u4e00\u4e2a\u7528\u6237\u6001\u52a8\u6001\u52a0\u8f7d\u6846\u67b6/\u8fd0\u884c\u65f6\u5e93\uff0c\u4ee5\u53ca\u4e00\u4e2a\u7b80\u5355\u7684\u7f16\u8bd1 Wasm \u548c eBPF \u5b57\u8282\u7801\u7684\u5de5\u5177\u94fe\u5bb9\u5668\u3002</p> <p>Wasm \u662f\u4e3a\u4e86\u4e00\u4e2a\u53ef\u79fb\u690d\u7684\u76ee\u6807\u800c\u8bbe\u8ba1\u7684\uff0c\u53ef\u4f5c\u4e3a C/C+/RUST \u7b49\u9ad8\u7ea7\u8bed\u8a00\u7684\u7f16\u8bd1\u76ee\u6807\uff0c\u4f7f\u5ba2\u6237\u7aef\u548c\u670d\u52a1\u5668\u5e94\u7528\u7a0b\u5e8f\u80fd\u591f\u5728 Web \u4e0a\u90e8\u7f72\u3002\u76ee\u524d\u5df2\u7ecf\u53d1\u5c55\u6210\u4e3a\u4e00\u4e2a\u8f7b\u91cf\u7ea7\u3001\u9ad8\u6027\u80fd\u3001\u8de8\u5e73\u53f0\u548c\u591a\u8bed\u79cd\u7684\u8f6f\u4ef6\u6c99\u76d2\u73af\u5883\uff0c\u88ab\u8fd0\u7528\u4e8e\u4e91\u539f\u751f\u8f6f\u4ef6\u7ec4\u4ef6\u3002 eunomia-bpf \u5c06 eBPF \u7528\u6237\u6001\u7684\u6240\u6709\u63a7\u5236\u548c\u6570\u636e\u5904\u7406\u903b\u8f91\u5168\u90e8\u79fb\u5230 Wasm \u865a\u62df\u673a\u4e2d\uff0c\u901a\u8fc7 Wasm module \u6253\u5305\u548c\u5206\u53d1 eBPF \u5b57\u8282\u7801\uff0c\u540c\u65f6\u5728 Wasm \u865a\u62df\u673a\u5185\u90e8\u63a7\u5236\u6574\u4e2a eBPF \u7a0b\u5e8f\u7684\u52a0\u8f7d\u548c\u6267\u884c\uff0c\u5c06\u4e8c\u8005\u7684\u4f18\u52bf\u7ed3\u5408\u4e86\u8d77\u6765\u3002</p> <p>\u5728 Wasm \u6a21\u5757\u4e2d\u7f16\u5199 eBPF \u4ee3\u7801\u548c\u901a\u5e38\u719f\u6089\u7684\u4f7f\u7528 libbpf \u6846\u67b6\u6216 Coolbpf \u5f00\u53d1 eBPF \u7a0b\u5e8f\u7684\u65b9\u5f0f\u662f\u57fa\u672c\u4e00\u6837\u7684\uff0cWasm \u7684\u590d\u6742\u6027\u4f1a\u88ab\u9690\u85cf\u5728 eunomia-bpf \u7684\u7f16\u8bd1\u5de5\u5177\u94fe\u548c\u8fd0\u884c\u65f6\u5e93\u4e2d\uff0c\u5f00\u53d1\u8005\u53ef\u4ee5\u4e13\u6ce8\u4e8e eBPF \u7a0b\u5e8f\u7684\u5f00\u53d1\u548c\u8c03\u8bd5\uff0c\u4e0d\u9700\u8981\u4e86\u89e3 Wasm \u7684\u80cc\u666f\u77e5\u8bc6\uff0c\u4e5f\u4e0d\u9700\u8981\u62c5\u5fc3 Wasm \u7684\u7f16\u8bd1\u73af\u5883\u914d\u7f6e\u3002</p> <p>\u5927\u81f4\u6765\u8bf4\uff0ceunomia-bpf \u5728 Wasm \u8fd0\u884c\u65f6\u548c\u7528\u6237\u6001\u7684 libbpf \u4e2d\u95f4\u591a\u52a0\u4e86\u4e00\u5c42\u62bd\u8c61\u5c42\uff0c\u4f7f\u5f97\u4e00\u6b21\u7f16\u8bd1\u3001\u5230\u5904\u8fd0\u884c\u7684 eBPF \u4ee3\u7801\u53ef\u4ee5\u4ece JSON \u5bf9\u8c61\u4e2d\u52a8\u6001\u52a0\u8f7d\u3002JSON \u5bf9\u8c61\u4f1a\u5728\u7f16\u8bd1\u65f6\u88ab\u5305\u542b\u5728 Wasm \u6a21\u5757\u4e2d\uff0c\u56e0\u6b64\u5728\u8fd0\u884c\u65f6\uff0c\u6211\u4eec\u53ef\u4ee5\u901a\u8fc7\u89e3\u6790 JSON \u5bf9\u8c61\u6765\u83b7\u53d6 eBPF \u7a0b\u5e8f\u7684\u4fe1\u606f\uff0c\u7136\u540e\u52a8\u6001\u52a0\u8f7d eBPF \u7a0b\u5e8f\u3002\u901a\u8fc7 Wasm module \u6253\u5305\u548c\u5206\u53d1 eBPF \u5b57\u8282\u7801\uff0c\u540c\u65f6\u5728 Wasm \u865a\u62df\u673a\u5185\u90e8\u63a7\u5236\u6574\u4e2a eBPF \u7a0b\u5e8f\u7684\u52a0\u8f7d\u548c\u6267\u884c\uff0ceunomia-bpf \u5c31\u53ef\u4ee5\u5c06\u4e8c\u8005\u7684\u4f18\u52bf\u7ed3\u5408\u8d77\u6765\uff0c\u8ba9\u4efb\u610f eBPF \u7a0b\u5e8f\u80fd\u6709\u5982\u4e0b\u7279\u6027\uff1a</p> <ul> <li>\u53ef\u79fb\u690d\uff1a\u8ba9 eBPF \u5de5\u5177\u548c\u5e94\u7528\u4e0d\u9700\u8981\u8fdb\u884c\u91cd\u65b0\u7f16\u8bd1\u5373\u53ef\u4ee5\u8de8\u5e73\u53f0\u5206\u53d1\uff0c\u7701\u53bb\u4e86\u590d\u6742\u7684\u4ea4\u53c9\u7f16\u8bd1\u6d41\u7a0b\uff1b</li> <li>\u9694\u79bb\u6027\uff1a\u8ba9 eBPF \u7a0b\u5e8f\u7684\u52a0\u8f7d\u548c\u6267\u884c\u3001\u4ee5\u53ca\u7528\u6237\u6001\u7684\u6570\u636e\u5904\u7406\u6d41\u7a0b\u66f4\u52a0\u5b89\u5168\u53ef\u9760\u3002</li> <li>\u5305\u7ba1\u7406\uff1a\u5b8c\u6210 eBPF \u7a0b\u5e8f\u6216\u5de5\u5177\u7684\u5206\u53d1\u3001\u7ba1\u7406\u3001\u52a0\u8f7d\u7b49\u5de5\u4f5c\u3002</li> <li>\u654f\u6377\u6027\uff1a\u4f7f\u6bcf\u4e2a\u4eba\u90fd\u53ef\u4ee5\u4f7f\u7528\u5b98\u65b9\u548c\u672a\u7ecf\u4fee\u6539\u7684\u5e94\u7528\u7a0b\u5e8f\u6765\u52a0\u8f7d\u81ea\u5b9a\u4e49\u6269\u5c55\uff0c\u4efb\u4f55 eBPF \u7a0b\u5e8f\u7684\u9519\u8bef\u4fee\u590d\u548c/\u6216\u66f4\u65b0\u90fd\u53ef\u4ee5\u5728\u8fd0\u884c\u65f6\u63a8\u9001\u548c/\u6216\u6d4b\u8bd5\uff0c\u800c\u4e0d\u9700\u8981\u66f4\u65b0\u548c/\u6216\u91cd\u65b0\u90e8\u7f72\u4e00\u4e2a\u65b0\u7684\u4e8c\u8fdb\u5236\u3002</li> <li>\u8f7b\u91cf\u7ea7\uff1a\u4e0e Linux \u5bb9\u5668\u5e94\u7528\u76f8\u6bd4\uff0cWasm \u5fae\u670d\u52a1\u51b7\u542f\u52a8\u7684\u65f6\u95f4\u662f 1%\uff0c\u53ef\u4ee5\u5b9e\u73b0 eBPF as a service\uff0c\u8ba9 eBPF \u7a0b\u5e8f\u7684\u52a0\u8f7d\u548c\u6267\u884c\u53d8\u5f97\u66f4\u52a0\u8f7b\u91cf\u7ea7\u3001\u5feb\u901f\u3001\u7b80\u4fbf\u6613\u884c\u3002</li> </ul> <p>\u6211\u4eec\u5df2\u7ecf\u6d4b\u8bd5\u4e86\u5728 x86\u3001ARM \u7b49\u4e0d\u540c\u67b6\u6784\u4e0d\u540c\u5185\u6838\u7248\u672c\u7684 Linux \u7cfb\u7edf\u4e0a\uff0ceunomia-bpf \u6846\u67b6\u90fd\u53ef\u4ee5\u4f7f\u7528\u540c\u4e00\u4e2a\u9884\u7f16\u8bd1 eBPF \u7a0b\u5e8f\u4e8c\u8fdb\u5236\uff0c\u4ece\u4e91\u7aef\u4e00\u884c\u547d\u4ee4\u83b7\u53d6\u5230\u672c\u5730\u4e4b\u540e\u8fd0\u884c\u3002\u4e4b\u540e eunomia-bpf \u8fd8\u4f1a\u6dfb\u52a0 RISC-V \u7b49\u66f4\u591a\u67b6\u6784\u7684\u652f\u6301\u3002</p>"},{"location":"blogs/lmp-eunomia.zh/#lmp-cli-ebpf","title":"\u4f7f\u7528 lmp-cli \u6784\u5efa\u4e00\u4e2a eBPF \u9879\u76ee","text":"<p>\u5982\u679c\u60a8\u662f\u4e00\u4e2a eBPF \u5de5\u5177\u7684\u4f7f\u7528\u8005\uff0c\u60a8\u53ef\u4ee5\u65e0\u9700\u4efb\u4f55\u7f16\u8bd1\u6d41\u7a0b\uff0c\u4e5f\u4e0d\u9700\u8981\u4e86\u89e3\u4efb\u4f55 eBPF \u548c Wasm \u7684\u76f8\u5173\u77e5\u8bc6\uff0c\u4f7f\u7528 <code>lmp run &lt;name&gt;</code> \u5c31\u53ef\u4ee5\u76f4\u63a5\u8fd0\u884c LMP \u4ed3\u5e93\u7684\u5c0f\u7a0b\u5e8f\uff0c\u5176\u4e2d\u4f1a\u8c03\u7528<code>lmp pull &lt;name&gt;</code>\u547d\u4ee4\u4ece\u4e91\u7aef\u4ece\u5e93\u4e2d\u4e0b\u8f7d\u5bf9\u5e94\u7684\u5c0f\u7a0b\u5e8f\u3002</p> <p>\u5982\u679c\u60a8\u662f\u4e00\u4e2a eBPF \u7a0b\u5e8f\u7684\u5f00\u53d1\u8005\uff0c\u8ba9\u6211\u4eec\u5f00\u59cb\u521b\u5efa\u3001\u7f16\u8bd1\u5e76\u8fd0\u884c\u4e00\u4e2a\u7b80\u5355\u7684\u7a0b\u5e8f\u3002\u5728\u8fd9\u91cc\uff0c\u6211\u4eec\u4f7f\u7528\u57fa\u7b80\u5355\u547d\u4ee4\u884c\u5de5\u5177 lmp-cli\uff0c\u6982\u8ff0\u5982\u4f55\u4ece\u56db\u4e2a\u6b65\u9aa4\u5f00\u59cb\u6784\u5efa\u3002</p>"},{"location":"blogs/lmp-eunomia.zh/#1","title":"1. \u51c6\u5907\u4f60\u7684\u73af\u5883","text":"<p>eBPF \u672c\u8eab\u662f\u4e00\u79cd Linux \u5185\u6838\u6280\u672f\uff0c\u56e0\u6b64\u4efb\u4f55\u5b9e\u9645\u7684 BPF \u7a0b\u5e8f\u90fd\u5fc5\u987b\u5728 Linux \u5185\u6838\u4e2d\u8fd0\u884c\u3002\u6211\u5efa\u8bae\u60a8\u4ece\u5185\u6838 5.4 \u6216\u66f4\u65b0\u7684\u7248\u672c\u5f00\u59cb\u3002\u4ece SSH \u7ec8\u7aef\uff0c\u68c0\u67e5\u5185\u6838\u7248\u672c\uff0c\u5e76\u786e\u8ba4\u60a8\u5df2\u7ecf\u542f\u7528\u4e86 CONFIG_DEBUG_INFO_BTF\uff1a</p> <pre><code>uname -r\ncat /boot/config-$(uname -r) | grep CONFIG_DEBUG_INFO_BTF\n</code></pre> <p>\u4f60\u4f1a\u770b\u5230\u7c7b\u4f3c\u8fd9\u6837\u7684\u8f93\u51fa\uff1a</p> <pre><code>$ uname -r\n5.15.0-48-generic\n$ cat /boot/config-$(uname -r) | grep CONFIG_DEBUG_INFO_BTF\nCONFIG_DEBUG_INFO_BTF=y\nCONFIG_DEBUG_INFO_BTF_MODULES=y\n</code></pre> <p>\u5b89\u88c5\u547d\u4ee4\u884c\u5de5\u5177 lmp-cli\uff1a</p> <pre><code>curl https://github.com/GorilaMond/lmp_cli/releases/download/lmp/install.sh | sh\n</code></pre>"},{"location":"blogs/lmp-eunomia.zh/#2","title":"2. \u521b\u5efa\u9879\u76ee\u7684\u5185\u6838\u90e8\u5206","text":"<p>\u4f7f\u7528<code>lmp init</code>\u521b\u5efa\u4e00\u4e2a\u9879\u76ee\u6a21\u677f\uff0c\u6765\u521d\u59cb\u5316\u4f60\u7684\u5185\u6838\u7a0b\u5e8f\uff0c\u5feb\u901f\u5730\u6295\u5165\u5230\u4ee3\u7801\u7684\u7f16\u5199\u4e2d\uff1a</p> <pre><code>lmp init hello\n</code></pre> <p>\u6210\u529f\u521b\u5efa\u9879\u76ee\u540e\uff0c\u60a8\u5c06\u770b\u5230\u5982\u4e0b\u7c7b\u4f3c\u7684\u8f93\u51fa\uff1a</p> <pre><code>$ lmp init hello\nCloning into 'ebpm-template'...\n</code></pre> <p>\u5b83\u5b9e\u9645\u4e0a\u521b\u5efa\u4e86\u4e00\u4e2a\u9879\u76ee\u540d\u5bf9\u5e94\u7684\u6587\u4ef6\u5939\uff0c\u91cc\u9762\u6709\u8fd9\u4e9b\u6587\u4ef6\uff1a</p> <pre><code>$ cd hello/\n$ ll\n...\n-rw-rw-r--  1 a a 2910 10\u6708 17 23:18 bootstrap.bpf.c\n-rw-rw-r--  1 a a  392 10\u6708 17 23:18 bootstrap.h\n-rw-rw-r--  1 a a  221 10\u6708 17 23:18 config.json\ndrwxrwxr-x  8 a a 4096 10\u6708 17 23:18 .git/\ndrwxrwxr-x  3 a a 4096 10\u6708 17 23:18 .github/\n-rw-rw-r--  1 a a   21 10\u6708 17 23:18 .gitignore\n-rw-rw-r--  1 a a 2400 10\u6708 17 23:18 README.md\n</code></pre> <p>\u5185\u6838\u7a0b\u5e8f\u6a21\u677f bootstrap.bpf.c \u4e2d\u9ed8\u8ba4\u7684\u8ddf\u8e2a\u70b9\u4e3a <code>tp/sched/sched_process_exec</code>\u548c<code>tp/sched/sched_process_exit</code>\uff0c\u7528\u6765\u8ddf\u8e2a\u65b0\u7a0b\u5e8f\u7684\u6267\u884c\u548c\u9000\u51fa\uff0c\u8fd9\u91cc\u4e0d\u505a\u4fee\u6539\u3002</p> <p>\u6784\u5efa\u5185\u6838\u9879\u76ee\uff0c\u5982\u4e0b\u6240\u793a\u3002\u4fdd\u5b58\u60a8\u7684\u66f4\u6539\uff0c\u4f7f\u7528 <code>sudo lmp build</code> \u6784\u5efa\u5185\u6838\u7a0b\u5e8f\uff0c\u8fd9\u4f1a\u521b\u5efa\u4e00\u4e2a\u540d\u4e3a package.json \u7684\u5bf9\u8c61\u6587\u4ef6\u3002</p> <pre><code>$ sudo lmp build\nmake\n  ...\n  BINARY   client\n  DUMP_LLVM_MEMORY_LAYOUT\n  DUMP_EBPF_PROGRAM\n  FIX_TYPE_INFO_IN_EBPF\n  GENERATE_PACKAGE_JSON\n</code></pre>"},{"location":"blogs/lmp-eunomia.zh/#3","title":"3. \u8fd0\u884c\u5185\u6838\u7a0b\u5e8f","text":"<p>\u53ef\u4ee5\u4f7f\u7528<code>lmp run package.json</code>\u8fd0\u884c\u5185\u6838\u7a0b\u5e8f\uff0c\u6ca1\u6709\u7528\u6237\u7aef\u7a0b\u5e8f\u5bf9\u6570\u636e\u7684\u5904\u7406\u7684\u60c5\u51b5\u4e0b\uff0c\u8be5\u6846\u67b6\u4e0b\u5185\u6838\u7a0b\u5e8f\u5c06\u4f1a\u8f93\u51fa\u6240\u6709\u88ab output \u7684\u6570\u636e\uff1a</p> <pre><code>$ sudo lmp run ./package.json\nrunning and waiting for the ebpf events from ring buffer...\ntime pid ppid exit_code duration_ns comm filename exit_event\n</code></pre> <p>\u4e00\u5f00\u59cb\u60a8\u4e0d\u4f1a\u770b\u5230\u4efb\u4f55\u6570\u636e\uff0c\u53ea\u6709\u5f53\u5185\u6838\u7684\u8ddf\u8e2a\u70b9\u88ab\u89e6\u53d1\u65f6\uff0c\u8fd9\u91cc\u662f\u65b0\u7684\u8fdb\u7a0b\u88ab\u521b\u5efa\u6216\u9000\u51fa\u65f6\uff0c\u624d\u4f1a\u8f93\u51fa\u6570\u636e\u3002\u8fd9\u91cc\u65b0\u5efa\u4e86\u4e00\u4e2a\u865a\u62df\u7ec8\u7aef\uff0c\u8f93\u51fa\u4e86\u5982\u4e0b\u6570\u636e\uff1a</p> <pre><code>23:31:31 111788 109955 0 0 bash /bin/bash 0\n23:31:31 111790 111788 0 0 lesspipe /usr/bin/lesspipe 0\n...\n</code></pre>"},{"location":"blogs/lmp-eunomia.zh/#4","title":"4. \u6dfb\u52a0\u7528\u6237\u6001\u7a0b\u5e8f","text":"<p>\u6211\u4eec\u63d0\u4f9b\u7684\u662f demo \u662f C \u8bed\u8a00\u7248\u672c\u7684 Wasm \u5f00\u53d1\u6846\u67b6\uff0c\u5728\u6784\u5efa\u597d\u7684\u5185\u6838\u9879\u76ee\u6587\u4ef6\u5939\u5185\uff0c\u4f7f\u7528 <code>sudo lmp gen-wasm-skel</code> \u751f\u6210\u4e00\u4e2a Wasm \u7528\u6237\u6001\u9879\u76ee\u6a21\u677f\uff0capp.c\u3001eunomia-include\u3001ewasm-skel.h \u8fd9\u4e9b\u6587\u4ef6\u4f1a\u88ab\u751f\u6210\u3002ewasm-skel.h \u662f\u88ab\u6253\u5305\u4e3a\u5934\u6587\u4ef6\u7684\u5185\u6838\u7a0b\u5e8f\uff0capp.c \u662f\u7528\u6237\u6001\u7a0b\u5e8f\u7684\u6a21\u677f\u6587\u4ef6\uff0c\u6211\u4eec\u53ef\u4ee5\u4fee\u6539\u5b83\u6765\u8fdb\u884c\u81ea\u5b9a\u4e49\u7684\u6570\u636e\u5904\u7406\uff0c\u8fd9\u91cc\u4e0d\u505a\u4fee\u6539\u3002</p> <pre><code>$ sudo lmp gen-wasm-skel\nmake\n  BPF      .output/client.bpf.o\n...\n</code></pre> <p>\u4f7f\u7528<code>sudo lmp build-wasm</code>\u6784\u5efa\u7528\u6237\u6001\u7a0b\u5e8f\uff0c\u751f\u6210 app.wasm \u6587\u4ef6</p> <pre><code>$ sudo lmp build-wasm\nmake\n  BPF      .output/client.bpf.o\n...\n</code></pre> <p>\u4f7f\u7528<code>lmp run app.wasm</code>\u8fd0\u884c\u7528\u6237\u6001\u7a0b\u5e8f\uff0cjson \u683c\u5f0f\u7684\u8f93\u51fa\u4e3a\u901a\u7528\u7684\u6570\u636e\u5904\u7406\u505a\u597d\u4e86\u51c6\u5907\uff1a</p> <pre><code>$ lmp run app.wasm\nrunning and waiting for the ebpf events from ring buffer...\n{\"pid\":112665,\"ppid\":109955,\"exit_code\":0,\"duration_ns\":0,\"comm\":\"bash\",\"filename\":\"/bin/bash\",\"exit_event\":0}\n{\"pid\":112667,\"ppid\":112665,\"exit_code\":0,\"duration_ns\":0,\"comm\":\"lesspipe\",\"filename\":\"/usr/bin/lesspipe\",\"exit_event\":0}\n{\"pid\":112668,\"ppid\":112667,\"exit_code\":0,\"duration_ns\":0,\"comm\":\"basename\",\"filename\":\"/usr/bin/basename\",\"exit_event\":0}\n...\n</code></pre>"},{"location":"blogs/lmp-eunomia.zh/#ebpf","title":"\u53e6\u4e00\u4e2a\u4f8b\u5b50\uff1a\u4f7f\u7528 eBPF \u6253\u5370\u8fdb\u7a0b\u5185\u5b58\u4f7f\u7528\u72b6\u51b5","text":"<p>\u53ef\u4ee5\u5c06 bootstrap.bpf.c \u91cd\u547d\u540d\u4e3a procstat.bpf.c\uff0c\u5c06 bootstrap.h \u91cd\u547d\u540d\u4e3a procstat.h\uff0c\u7136\u540e\u7f16\u8bd1\u8fd0\u884c\u3002\u5bf9\u5e94\u7684\u6e90\u4ee3\u7801\u5982\u4e0b\uff1a</p> <p>procstat.bpf.c</p> <pre><code>#include \"vmlinux.h\"\n#include &lt;bpf/bpf_helpers.h&gt;\n#include &lt;bpf/bpf_tracing.h&gt;\n#include &lt;bpf/bpf_core_read.h&gt;\n#include \"procstat.h\"\nchar LICENSE[] SEC(\"license\") = \"Dual BSD/GPL\";\nstruct {\n__uint(type, BPF_MAP_TYPE_RINGBUF);\n__uint(max_entries, 256 * 1024);\n} rb SEC(\".maps\");\nSEC(\"kprobe/finish_task_switch\")\nint BPF_KPROBE(finish_task_switch, struct task_struct *prev)\n{\nstruct event *e;\nstruct mm_rss_stat rss = {};\nstruct mm_struct *mms;\nlong long *t;\ne = bpf_ringbuf_reserve(&amp;rb, sizeof(*e), 0);\nif (!e)\nreturn 0;\ne-&gt;pid = BPF_CORE_READ(prev, pid);\ne-&gt;vsize = BPF_CORE_READ(prev, mm, total_vm);\ne-&gt;Vdata = BPF_CORE_READ(prev, mm, data_vm);\ne-&gt;Vstk = BPF_CORE_READ(prev, mm, stack_vm);\ne-&gt;nvcsw = BPF_CORE_READ(prev, nvcsw);\ne-&gt;nivcsw = BPF_CORE_READ(prev, nivcsw);\nrss = BPF_CORE_READ(prev, mm, rss_stat);\nt = (long long *)(rss.count);\ne-&gt;rssfile = *t;\ne-&gt;rssanon = *(t + 1);\ne-&gt;vswap = *(t + 2);\ne-&gt;rssshmem = *(t + 3);\ne-&gt;size = *t + *(t + 1) + *(t + 3);\nbpf_ringbuf_submit(e, 0);\nreturn 0;\n}\n</code></pre> <p>proc.h</p> <pre><code>#ifndef __BOOTSTRAP_H\n#define __BOOTSTRAP_H\n#define TASK_COMM_LEN 16\n#define MAX_FILENAME_LEN 127\nstruct event {\n/*\u8fdb\u7a0b\u5185\u5b58\u72b6\u6001\u62a5\u544a*/\npid_t pid;\nlong nvcsw;\nlong nivcsw;\nlong vsize;              //\u865a\u62df\u5185\u5b58\nlong size;               //\u7269\u7406\u5185\u5b58\nlong long rssanon;       //\u533f\u540d\u9875\u9762\nlong long rssfile;       //\u6587\u4ef6\u9875\u9762\nlong long rssshmem;      //\u5171\u4eab\u9875\u9762\nlong long vswap;         //\u4ea4\u6362\u9875\u9762\nlong long Hpages;        //hugetlbPages\nlong Vdata;              //Private data segments\nlong Vstk;               //User stack\nlong long VPTE;\n};\n#endif /* __BOOTSTRAP_H */\n</code></pre> <p>\u5177\u4f53\u7684\u4e0a\u62a5\u4e8b\u4ef6\u4fe1\u606f\u5728 event \u7ed3\u6784\u4f53\u4e2d\u5b9a\u4e49\uff1a</p> \u53c2\u6570 \u542b\u4e49 vsize \u8fdb\u7a0b\u4f7f\u7528\u7684\u865a\u62df\u5185\u5b58 size \u8fdb\u7a0b\u4f7f\u7528\u7684\u6700\u5927\u7269\u7406\u5185\u5b58 rssanon \u8fdb\u7a0b\u4f7f\u7528\u7684\u533f\u540d\u9875\u9762 rssfile \u8fdb\u7a0b\u4f7f\u7528\u7684\u6587\u4ef6\u6620\u5c04\u9875\u9762 rssshmem \u8fdb\u7a0b\u4f7f\u7528\u7684\u5171\u4eab\u5185\u5b58\u9875\u9762 vswap \u8fdb\u7a0b\u4f7f\u7528\u7684\u4ea4\u6362\u5206\u533a\u5927\u5c0f vdata \u8fdb\u7a0b\u4f7f\u7528\u7684\u79c1\u6709\u6570\u636e\u6bb5\u5927\u5c0f vpte \u8fdb\u7a0b\u9875\u8868\u5927\u5c0f vstk \u8fdb\u7a0b\u7528\u6237\u6808\u5927\u5c0f <p>\u6302\u8f7d\u70b9\u4e0e\u6302\u8f7d\u539f\u56e0\u5206\u6790\uff1a</p> <ul> <li>\u9996\u5148\uff0c\u83b7\u53d6\u8fdb\u7a0b\u7ea7\u522b\u5185\u5b58\u4f7f\u7528\u4fe1\u606f\u9700\u8981\u83b7\u53d6\u5230\u8fdb\u7a0b\u7684 task_struct \u7ed3\u6784\u4f53\uff0c\u5176\u4e2d\u5728 mm_struct \u6210\u5458\u4e2d\u5b58\u5728\u4e00\u4e2a\u4fdd\u5b58\u8fdb\u7a0b\u5f53\u524d\u5185\u5b58\u4f7f\u7528\u72b6\u6001\u7684\u6570\u7ec4\u7ed3\u6784\uff0c\u56e0\u6b64\u6709\u5173\u8fdb\u7a0b\u7684\u5927\u90e8\u5206\u5185\u5b58\u4f7f\u7528\u4fe1\u606f\u90fd\u53ef\u4ee5\u901a\u8fc7\u8fd9\u4e2a\u6570\u7ec4\u83b7\u5f97\u3002</li> <li>\u5176\u6b21\uff0c\u9700\u8981\u6ce8\u610f\u51fd\u6570\u7684\u63d2\u5165\u70b9\uff0c\u63d2\u5165\u70b9\u7684\u9009\u53d6\u5173\u7cfb\u5230\u6570\u636e\u51c6\u786e\u6027\u662f\u5426\u5f97\u5230\u4fdd\u8bc1\uff0c\u800c\u5728\u8fdb\u7a0b\u7684\u5185\u5b58\u7533\u8bf7\uff0c\u91ca\u653e\uff0c\u89c4\u6574\u7b49\u4ee3\u7801\u8def\u5f84\u4e0a\u90fd\u5b58\u5728\u9875\u9762\u72b6\u6001\u6539\u53d8\uff0c\u4f46\u662f\u6570\u91cf\u4fe1\u606f\u8fd8\u6ca1\u6709\u66f4\u65b0\u7684\u76f8\u5173\u7ed3\u6784\u4e2d\u7684\u60c5\u51b5\uff0c\u5982\u679c\u63d2\u5165\u70b9\u8fd9\u4e24\u8005\u4e2d\u95f4\uff0c\u6570\u636e\u5c31\u4f1a\u548c\u5b9e\u9645\u60c5\u51b5\u5b58\u5728\u5dee\u5f02\uff0c\u6240\u6709\u5728\u786e\u4fdd\u53ef\u4ee5\u83b7\u53d6\u5230\u8fdb\u7a0b PCB \u7684\u524d\u63d0\u4e0b\uff0c\u9009\u62e9\u5728\u8fdb\u7a0b\u8c03\u5ea6\u4ee3\u7801\u8def\u5f84\u4e0a\u8003\u8651\u3002\u800c finish_task_switch \u51fd\u6570\u662f\u65b0\u4e00\u4e2a\u8fdb\u7a0b\u7b2c\u4e00\u4e2a\u6267\u884c\u7684\u51fd\u6570\uff0c\u505a\u7684\u4e8b\u5374\u662f\u7ed9\u4e0a\u4e00\u4e2a\u88ab\u8c03\u5ea6\u51fa\u53bb\u7684\u8fdb\u7a0b\u505a\u6536\u5c3e\u5de5\u4f5c\uff0c\u6240\u4ee5\u8fd9\u4e2a\u51fd\u6570\u7684\u53c2\u6570\u662f\u4e0a\u4e00\u4e2a\u8fdb\u7a0b\u7684 PCB\uff0c\u4ece\u8fd9\u5757\u83b7\u5f97\u4e0a\u4e00\u4e2a\u8fdb\u7a0b\u7684\u5185\u5b58\u4fe1\u606f\u5c31\u53ef\u4ee5\u786e\u4fdd\u5728\u5b83\u6ca1\u6709\u518d\u6b21\u88ab\u8c03\u5ea6\u4e0a CPU \u6267\u884c\u7684\u8fd9\u6bb5\u65f6\u95f4\u5185\u7684\u5185\u5b58\u6570\u636e\u7a33\u5b9a\u6027\u3002</li> <li>\u56e0\u6b64\u6700\u540e\u9009\u62e9\u5c06\u7a0b\u5e8f\u6302\u8f7d\u5230 finish_task_switch \u51fd\u6570\u4e0a\u3002\u6570\u636e\u6765\u6e90\u6709\u4e24\u90e8\u5206\uff0c\u4e00\u4e2a\u662f mm_struct \u7ed3\u6784\u672c\u8eab\u5b58\u5728\u7684\u72b6\u6001\u4fe1\u606f\uff0c\u53e6\u4e00\u4e2a\u662f\u5728 mm_rss_stat \u7ed3\u6784\u4e2d\u3002</li> </ul> <p>\u4e5f\u53ef\u4ee5\u5728 bolipi \u7684\u5e73\u53f0\u4e2d\u5728\u7ebf\u7f16\u8bd1\uff0c\u5728\u7ebf\u4f53\u9a8c\u8fd0\u884c eBPF \u7a0b\u5e8f\uff1ahttps://bolipi.com/ebpf/home/online</p> <p>\u5b8c\u6574\u7684\u4ee3\u7801\u3001\u6587\u6863\u548c\u8fd0\u884c\u7ed3\u679c\u53ef\u4ee5\u5728 LMP \u4e2d eBPF_Supermarket \u5904\u627e\u5230\uff1aeBPF_Supermarket/Memory_Subsystem/memstat/procstat</p>"},{"location":"blogs/lmp-eunomia.zh/#_2","title":"\u76f8\u5173\u80cc\u666f","text":"<p>LMP \u9879\u76ee\u7684\u6210\u7acb\u521d\u8877\u662f\uff1a</p> <ul> <li>\u9762\u5411 eBPF \u521d\u5b66\u8005\u548c\u7231\u597d\u8005\uff0c\u63d0\u4f9b eBPF \u5b66\u4e60\u8d44\u6599\u3001\u7a0b\u5e8f/\u9879\u76ee\u6848\u4f8b\uff0c\u6784\u5efa eBPF \u5b66\u4e60\u793e\u533a</li> <li>\u6210\u4e3a eBPF \u5de5\u5177\u96c6\u6563\u5730\uff0c\u6211\u4eec\u76f8\u4fe1\u6bcf\u4e00\u4f4d eBPF \u521d\u5b66\u8005\u548c\u7231\u597d\u8005\u90fd\u6709\u65e0\u9650\u7684\u521b\u9020\u529b</li> <li>\u5b75\u5316 eBPF \u60f3\u6cd5\u3001\u76f8\u5173\u5de5\u5177\u3001\u9879\u76ee</li> </ul> <p>LMP \u76ee\u524d\u5206\u4e3a\u56db\u4e2a\u5b50\u9879\u76ee\uff1a</p> <ul> <li>eBPF_Supermarket \u4e2d\u5305\u542b\u4e86\u5927\u91cf\u7531\u4e2a\u4eba\u5f00\u53d1\u8005\u7f16\u5199\u7684 eBPF \u5de5\u5177\uff0c\u8986\u76d6\u4e86\u7f51\u7edc\u3001\u6027\u80fd\u5206\u6790\u3001\u5b89\u5168\u7b49\u591a\u79cd\u529f\u80fd\uff1b</li> <li>eBPF_Hub \u662f\u89c4\u8303\u5316\u7684 eBPF \u7a0b\u5e8f\u5e93\uff0c\u53ef\u4ee5\u968f\u65f6\u4e0b\u8f7d\u8fd0\u884c\uff1b</li> <li>eBPF_Visualization \u662f\u4e3a eBPF \u7a0b\u5e8f\u7ba1\u7406\u800c\u5f00\u53d1\u7684 web \u7ba1\u7406\u7cfb\u7edf\uff0c\u805a\u7126 eBPF \u6570\u636e\u53ef\u89c6\u5316\u548c\u5185\u6838\u53ef\u89c6\u5316\uff1b</li> <li>eBPF_Documentation \u4e3a\u793e\u533a\u6536\u96c6\u3001\u68b3\u7406\u548c\u539f\u521b\u7684 eBPF \u76f8\u5173\u8d44\u6599\u548c\u6587\u6863\u3002</li> </ul> <p>\u5f53\u524d LMP \u9879\u76ee\u4e5f\u5b58\u5728\u4e00\u4e9b\u95ee\u9898\uff0c\u4f8b\u5982\u5bf9\u4e8e eBPF \u5de5\u5177\u7684\u5f00\u53d1\u8005\uff0c\u5b58\u5728\u975e\u5e38\u591a\u800c\u4e14\u590d\u6742\u7684\u7528\u6237\u6001\u53ef\u89c6\u5316\u3001\u5c55\u793a\u65b9\u6848\uff0c\u6709\u8bb8\u591a\u5957\u7cfb\u7edf\u63d0\u4f9b\u53ef\u89c6\u5316\u7684\u5b9e\u73b0\u5e76\u4e14\u6709\u591a\u79cd\u8bed\u8a00\u6df7\u5408\uff0c\u7f3a\u4e4f\u5c55\u793a\u6807\u51c6\u3001\u4e5f\u96be\u4ee5\u8fdb\u884c\u53ef\u89c6\u5316\u7684\u6574\u5408\u7b49\u3002\u56e0\u6b64\uff0c\u6211\u4eec\u5e0c\u671b\u5c1d\u8bd5\u501f\u52a9 eunomia-bpf \u63d0\u4f9b\u7684\u7b26\u5408 OCI \u6807\u51c6\u7684 Wasm \u548c eBPF \u7a0b\u5e8f\uff0c\u63d0\u4f9b\u6807\u51c6\u5316\u3001\u9ad8\u53ef\u6269\u5c55\u6027\u7684\u57fa\u4e8e eBPF \u7684\u53ef\u89c6\u5316\u3001\u6570\u636e\u5c55\u793a\u3001\u5206\u6790\u5e73\u53f0\uff0c\u5229\u7528 ORAS \u7b80\u5316\u6269\u5c55 eBPF \u7684\u5206\u53d1\u3001\u52a0\u8f7d\u3001\u8fd0\u884c\u80fd\u529b\uff0c\u4e3a eBPF \u5de5\u5177\u7684\u5f00\u53d1\u8005\u548c\u4f7f\u7528\u8005\u63d0\u4f9b\u66f4\u52a0\u7b80\u5355\u3001\u9ad8\u6548\u7684\u4f53\u9a8c\u3002</p>"},{"location":"blogs/lmp-eunomia.zh/#webassembly","title":"WebAssembly","text":"<p>WebAssembly \u662f\u4e00\u79cd\u65b0\u7684\u7f16\u7801\u65b9\u5f0f\uff0c\u53ef\u4ee5\u5728\u73b0\u4ee3\u7684\u7f51\u7edc\u6d4f\u89c8\u5668\u4e2d\u8fd0\u884c \uff0d \u5b83\u662f\u4e00\u79cd\u4f4e\u7ea7\u7684\u7c7b\u6c47\u7f16\u8bed\u8a00\uff0c\u5177\u6709\u7d27\u51d1\u7684\u4e8c\u8fdb\u5236\u683c\u5f0f\uff0c\u53ef\u4ee5\u63a5\u8fd1\u539f\u751f\u7684\u6027\u80fd\u8fd0\u884c\uff0c\u5e76\u4e3a\u8bf8\u5982 c\\c++ \u7b49\u8bed\u8a00\u63d0\u4f9b\u4e00\u4e2a\u7f16\u8bd1\u76ee\u6807\uff0c\u4ee5\u4fbf\u5b83\u4eec\u53ef\u4ee5\u5728 Web \u4e0a\u8fd0\u884c\u3002\u5b83\u4e5f\u88ab\u8bbe\u8ba1\u4e3a\u53ef\u4ee5\u4e0e JavaScript \u5171\u5b58\uff0c\u5141\u8bb8\u4e24\u8005\u4e00\u8d77\u5de5\u4f5c\u3002\u800c\u4e14\uff0c\u66f4\u68d2\u7684\u662f\uff0c\u8fd9\u662f\u901a\u8fc7 W3C WebAssembly Community Group \u5f00\u53d1\u7684\u4e00\u9879\u7f51\u7edc\u6807\u51c6\uff0c\u5e76\u5f97\u5230\u4e86\u6765\u81ea\u5404\u5927\u4e3b\u8981\u6d4f\u89c8\u5668\u5382\u5546\u7684\u79ef\u6781\u53c2\u4e0e\u3002</p> <p>\u5c3d\u7ba1 WebAssembly \u662f\u4e3a\u8fd0\u884c\u5728 Web \u4e0a\u8bbe\u8ba1\u7684\uff0c\u5b83\u4e5f\u53ef\u4ee5\u5728\u5176\u5b83\u7684\u73af\u5883\u4e2d\u826f\u597d\u5730\u8fd0\u884c\u3002\u5305\u62ec\u4ece\u7528\u4f5c\u6d4b\u8bd5\u7684\u6700\u5c0f\u5316 shell \uff0c\u5230\u5b8c\u5168\u7684\u5e94\u7528\u73af\u5883 \u2014\u2014 \u4f8b\u5982\uff1a\u5728\u6570\u636e\u4e2d\u5fc3\u7684\u670d\u52a1\u5668\u3001\u7269\u8054\u7f51\uff08IoT\uff09\u8bbe\u5907\u6216\u8005\u662f\u79fb\u52a8/\u684c\u9762\u5e94\u7528\u7a0b\u5e8f\u3002\u751a\u81f3\uff0c\u8fd0\u884c\u5d4c\u5165\u5728\u8f83\u5927\u7a0b\u5e8f\u91cc\u7684 WebAssembly \u4e5f\u662f\u53ef\u884c\u7684\u3002\u901a\u5e38\uff0c\u901a\u8fc7\u7ef4\u6301\u4e0d\u9700\u8981 Web API \u7684\u975e Web \u8def\u5f84\uff0cWebAssembly \u80fd\u591f\u5728\u8bb8\u591a\u5e73\u53f0\u4e0a\u7528\u4f5c\u4fbf\u643a\u5f0f\u7684\u4e8c\u8fdb\u5236\u683c\u5f0f\uff0c\u4e3a\u79fb\u690d\u6027\u3001\u5de5\u5177\u548c\u8bed\u8a00\u65e0\u5173\u6027\u5e26\u6765\u5de8\u5927\u7684\u597d\u5904\u3002\uff08\u56e0\u4e3a\u5b83\u652f\u6301 c\\c++ \u7ea7\u8bed\u4e49\uff09</p> <p>Wasm \u7684\u7f16\u8bd1\u548c\u90e8\u7f72\u6d41\u7a0b\u5982\u4e0b\uff1a</p> <p>\u200b wasm-compile-deploy</p>"},{"location":"blogs/lmp-eunomia.zh/#ociopen-container-initiative","title":"OCI(Open Container Initiative)","text":"<p>\u5f00\u653e\u5bb9\u5668\u534f\u8bae(OCI)\u662f\u4e00\u4e2a\u8f7b\u91cf\u7ea7\uff0c\u5f00\u653e\u7684\u6cbb\u7406\u7ed3\u6784\uff0c\u4e3a\u5bb9\u5668\u6280\u672f\u5b9a\u4e49\u4e86\u89c4\u8303\u548c\u6807\u51c6\u3002\u5728 Linux \u57fa\u91d1\u4f1a\u7684\u652f\u6301\u4e0b\u6210\u7acb\uff0c\u7531\u5404\u5927\u8f6f\u4ef6\u4f01\u4e1a\u6784\u6210\uff0c\u81f4\u529b\u4e8e\u56f4\u7ed5\u5bb9\u5668\u683c\u5f0f\u548c\u8fd0\u884c\u65f6\u521b\u5efa\u5f00\u653e\u7684\u884c\u4e1a\u6807\u51c6\u3002\u5176\u4e2d\u5305\u62ec\u4e86\u4f7f\u7528 Container Registries \u8fdb\u884c\u5de5\u4f5c\u7684 API\uff0c\u6b63\u5f0f\u540d\u79f0\u4e3a OCI \u5206\u53d1\u89c4\u8303(\u53c8\u540d\u201cdistribution-spec\u201d)\u3002\u8fd9\u4e2a\u53d1\u5e03\u89c4\u8303\u662f\u57fa\u4e8e Docker \u516c\u53f8\u6700\u521d\u53d1\u5e03\u7684\u5f00\u6e90\u6ce8\u518c\u670d\u52a1\u5668\u7f16\u5199\u7684\uff0c\u5b83\u5b58\u5728\u4e8e GitHub \u7684distribution/distribution\uff08\u73b0\u5728\u662fCNCF\u9879\u76ee\uff09\u4e0a\u3002</p> <p>OCI \u76ee\u524d\u63d0\u51fa\u7684\u89c4\u8303\u6709\u5982\u4e0b\u8fd9\u4e9b\uff1a</p> \u540d\u79f0 \u7248\u672c Runtime Specification v1.0.2 Image Format v1.0.2 Distribution Specification v1.0.1 <p>\u5176\u4e2d runtime \u548c image \u7684\u89c4\u8303\u90fd\u5df2\u7ecf\u6b63\u5f0f\u53d1\u5e03\uff0c\u800c distribution \u7684\u8fd8\u5728\u5de5\u4f5c\u4e4b\u4e2d\u3002runtime \u89c4\u8303\u4e2d\u4ecb\u7ecd\u4e86\u5982\u4f55\u8fd0\u884c\u89e3\u538b\u7f29\u5230\u78c1\u76d8\u4e0a\u7684 <code>Filesystem Bundle</code>\u3002\u5728 OCI \u6807\u51c6\u4e0b\uff0c\u8fd0\u884c\u4e00\u4e2a\u5bb9\u5668\u7684\u8fc7\u7a0b\u5c31\u662f\u4e0b\u8f7d\u4e00\u4e2a OCI \u7684\u955c\u50cf\uff0c\u5c06\u5176\u89e3\u538b\u5230\u67d0\u4e2a <code>Filesystem Bundle</code> \u4e2d\uff0c\u7136\u540e\u67d0\u4e2a OCI Runtime \u5c31\u4f1a\u8fd0\u884c\u8fd9\u4e2a Bundle\u3002</p> <p>\u4f34\u968f\u7740 image spec \u4e0e distribution spec \u7684\u6f14\u5316\uff0c\u4eba\u4eec\u5f00\u59cb\u9010\u6b65\u8ba4\u8bc6\u5230\u9664\u4e86 Container Images \u4e4b\u5916\uff0cRegistries \u8fd8\u80fd\u591f\u7528\u6765\u5206\u53d1 Kubernetes Deployment Files, Helm Charts, docker-compose, CNAB \u7b49\u4ea7\u7269\u3002\u5b83\u4eec\u53ef\u4ee5\u5171\u7528\u540c\u4e00\u5957 API\uff0c\u540c\u4e00\u5957\u5b58\u50a8\uff0c\u5c06 Registries \u4f5c\u4e3a\u4e00\u4e2a\u4e91\u5b58\u50a8\u7cfb\u7edf\u3002\u8fd9\u5c31\u4e3a\u5e26\u6765\u4e86 OCI Artifacts \u7684\u6982\u5ff5\uff0c\u7528\u6237\u80fd\u591f\u628a\u6240\u6709\u7684\u4ea7\u7269\u90fd\u5b58\u50a8\u5728 OCI \u517c\u5bb9\u7684 Registiry \u5f53\u4e2d\u5e76\u8fdb\u884c\u5206\u53d1\u3002\u4e3a\u6b64\uff0cMicrosoft \u5c06 oras \u4f5c\u4e3a\u4e00\u4e2a client \u7aef\u5b9e\u73b0\u6350\u8d60\u7ed9\u4e86\u793e\u533a\uff0c\u5305\u62ec Harbor \u5728\u5185\u7684\u591a\u4e2a\u9879\u76ee\u90fd\u5728\u79ef\u6781\u7684\u53c2\u4e0e\u3002</p>"},{"location":"blogs/lmp-eunomia.zh/#orasoci-registry-as-storage","title":"ORAS(OCI Registry As Storage)","text":"<p>Registries \u6b63\u5728\u9010\u6e10\u6f14\u53d8\u4e3a\u901a\u7528\u7684\u7ec4\u4ef6\u5b58\u50a8\u5e93\u3002\u4e3a\u4e86\u5b9e\u73b0\u8fd9\u4e00\u76ee\u6807\uff0cORAS \u9879\u76ee\u63d0\u4f9b\u4e86\u4e00\u79cd\u5c06 OCI Artifacts \u4ece OCI Registries \u63d0\u4ea4\u548c\u62c9\u53d6\u7684\u65b9\u6cd5\u3002\u6b63\u5728\u5bfb\u6c42\u901a\u7528 Registries \u5ba2\u6237\u7aef\u7684\u7528\u6237\u53ef\u4ee5\u4eceORAS CLI\u4e2d\u5f97\u5230\u5e2e\u52a9\uff0c\u800c\u5f00\u53d1\u4eba\u5458\u53ef\u4ee5\u5728ORAS \u5ba2\u6237\u7aef\u7684\u5f00\u53d1\u5e93\u4e4b\u4e0a\u6784\u5efa\u81ea\u5df1\u7684\u5ba2\u6237\u7aef\u3002</p> <p>ORAS \u7684\u5de5\u4f5c\u539f\u7406\u4e0e\u60a8\u53ef\u80fd\u5df2\u7ecf\u719f\u6089\u7684\u5de5\u5177(\u5982 docker)\u7c7b\u4f3c\u3002\u5b83\u5141\u8bb8\u60a8\u5411 OCI Registries \u63a8\u9001(\u4e0a\u4f20)\u548c\u63d0\u53d6(\u4e0b\u8f7d)\u5185\u5bb9\uff0c\u5e76\u5904\u7406\u767b\u5f55(\u8eab\u4efd\u9a8c\u8bc1)\u548c\u4ee4\u724c\u6d41(\u6388\u6743)\u3002ORAS \u7684\u4e0d\u540c\u4e4b\u5904\u5728\u4e8e\u5c06\u7126\u70b9\u4ece\u5bb9\u5668\u6620\u50cf\u8f6c\u79fb\u5230\u5176\u4ed6\u7c7b\u578b\u7684\u7ec4\u4ef6\u4e0a\u3002</p> <p>\u56e0\u6b64\uff0c\u9f13\u52b1\u65b0\u7684 OCI Artifacts \u7684\u4f5c\u8005\u5b9a\u4e49\u4ed6\u4eec\u81ea\u5df1\u7684\u7ec4\u4ef6\u5a92\u4f53\u7c7b\u578b\uff0c\u4ee5\u4f7f\u5f97\u4ed6\u4eec\u7684\u7528\u6237\u77e5\u9053\u5982\u4f55\u5bf9\u5176\u8fdb\u884c\u64cd\u4f5c\u3002</p> <p>\u5982\u679c\u60a8\u5e0c\u671b\u7acb\u5373\u5f00\u59cb\u53d1\u5e03 OCI Artifacts\uff0c\u8bf7\u67e5\u770bORAS CLI\u3002\u5e0c\u671b\u63d0\u4f9b\u7ed9\u81ea\u5df1\u7528\u6237\u4f53\u9a8c\u7684\u5f00\u53d1\u4eba\u5458\u5e94\u8be5\u4f7f\u7528\u4e00\u4e2a ORAS \u5ba2\u6237\u7aef\u5f00\u53d1\u5e93\u3002</p>"},{"location":"blogs/lmp-eunomia.zh/#_3","title":"\u672a\u6765\u7684\u53d1\u5c55\u65b9\u5411","text":"<p>\u672a\u6765 LMP \u4f1a\u4e13\u6ce8\u4e8e\u66f4\u591a\u7684\u57fa\u4e8e eBPF \u7684\u5e94\u7528\u5de5\u5177\u548c\u5b9e\u8df5\u7684\u5f00\u53d1\uff1a</p> <ol> <li>\u8fdb\u4e00\u6b65\u5b8c\u5584 ORAS \u548c OCI \u955c\u50cf\u76f8\u5173\u7684\u652f\u6301\uff1b</li> <li>\u91cd\u6784\u5e76\u8fc1\u79fb\u73b0\u6709\u7684 eBPF \u5de5\u5177\uff0c\u63d0\u4f9b\u5b8c\u6574\u7684\u3001\u5f00\u7bb1\u5373\u7528\u7684\u5206\u6790\u5de5\u5177\u7ec4\u4ef6\uff0c\u4f8b\u5982\u6027\u80fd\u5de5\u7a0b\u7b49\u65b9\u9762\uff1b</li> <li>\u63a2\u7d22\u548c\u5b75\u5316\u66f4\u591a\u7684 eBPF \u60f3\u6cd5\u3001\u76f8\u5173\u5de5\u5177\u3001\u9879\u76ee\uff1b</li> </ol> <p>\u6211\u4eec\u6240\u57fa\u4e8e\u7684 eunomia-bpf \u9879\u76ee\u4e5f\u4f1a\u7ee7\u7eed\u5b8c\u5584\uff0c\u4e13\u6ce8\u4e8e\u63d0\u4f9b\u4e00\u4e2a\u5e95\u5c42\u7684 eBPF \u5f00\u53d1\u5e73\u53f0\u548c\u8fd0\u884c\u65f6\u57fa\u7840\u8bbe\u65bd\uff0c\u529b\u6c42\u5e26\u6765\u66f4\u597d\u7684\u5f00\u53d1\u548c\u79fb\u690d\u4f53\u9a8c\uff1a</p> <ol> <li>\u6d4b\u8bd5\u66f4\u591a\u5e73\u53f0\u548c\u5185\u6838\u7248\u672c\u7684\u652f\u6301\uff0c\u76ee\u524d\u5df2\u7ecf\u5728 <code>ARM64</code> \u548c <code>x86_64</code> \u4e0a\u6210\u529f\u79fb\u690d\u5e76\u8fd0\u884c\uff0c\u63a5\u4e0b\u6765\u4f1a\u5bf9\u4f4e\u5185\u6838\u7248\u672c\u3001Android\u3001RISC-V \u7b49\u5e73\u53f0\uff0c\u4ee5\u53ca\u5d4c\u5165\u5f0f\u3001\u8fb9\u7f18\u8ba1\u7b97\u76f8\u5173\u7684\u8bbe\u5907\u8fdb\u884c\u66f4\u8fdb\u4e00\u6b65\u7684\u6d4b\u8bd5\uff1b\u4e5f\u8bb8\u5728\u672a\u6765\uff0c\u6211\u4eec\u8fd8\u53ef\u4ee5\u63d0\u4f9b Windows \u4e0a\u7684 eBPF \u7a0b\u5e8f\u652f\u6301\u548c\u7c7b\u4f3c\u7684\u5f00\u53d1\u4f53\u9a8c\uff1b</li> <li>\u63d0\u4f9b\u6807\u51c6\u5316\u3001\u7a33\u5b9a\u7684 JSON \u548c Wasm \u63a5\u53e3\u534f\u8bae\u89c4\u8303\u4ee5\u53ca OCI \u955c\u50cf\u89c4\u8303\uff0c\u4e0d\u548c\u4efb\u4f55\u7684\u4f9b\u5e94\u5546\u6216\u4e91\u670d\u52a1\u7ed1\u5b9a\u3002\u5982\u679c\u4e0d\u4f7f\u7528 eunomia-bpf \u76f8\u5173\u7684\u5e95\u5c42\u8fd0\u884c\u65f6\uff0c\u6216\u4f7f\u7528\u81ea\u5b9a\u4e49\u7684 Wasm \u8fd0\u884c\u65f6\uff0c\u4e5f\u53ef\u4ee5\u901a\u8fc7\u6807\u51c6\u5316\u7684\u63a5\u53e3\u6765\u4f7f\u7528 LMP \u4e2d\u5df2\u7ecf\u6709\u7684\u5927\u91cf eBPF \u7a0b\u5e8f\u751f\u6001\u3002</li> <li>\u63d0\u4f9b\u66f4\u53cb\u597d\u7684\u7528\u6237\u6001\u5f00\u53d1\u63a5\u53e3\uff0c\u4ee5\u53ca\u66f4\u591a\u7684\u7528\u6237\u6001\u5f00\u53d1\u8bed\u8a00 SDK\uff0c\u4f8b\u5982 Go\u3001Rust\u3001Python \u7b49\uff1b</li> <li>\u8fdb\u884c\u66f4\u591a\u5173\u4e8e Wasm \u548c eBPF \u7ed3\u5408\u7684\u63a2\u7d22\uff1b</li> </ol>"},{"location":"blogs/lmp-eunomia.zh/#_4","title":"\u53c2\u8003\u8d44\u6599 &amp; \u63a8\u8350\u9605\u8bfb","text":"<ul> <li>eunomia-bpf: \u4e00\u4e2a eBPF \u7a0b\u5e8f\u52a8\u6001\u52a0\u8f7d\u6846\u67b6</li> <li>LMP project: Linux \u663e\u5fae\u955c</li> <li>OCI Registry As Storage (oras.land)</li> <li>\u5f53 Wasm \u9047\u89c1 eBPF\uff1a\u4f7f\u7528 WebAssembly \u7f16\u5199\u3001\u5206\u53d1\u3001\u52a0\u8f7d\u8fd0\u884c eBPF \u7a0b\u5e8f | \u9f99\u8725\u6280\u672f (qq.com)</li> <li>\u5f00\u653e\u5bb9\u5668\u6807\u51c6(OCI) \u5185\u90e8\u5206\u4eab (xuanwo.io)</li> <li>WebAssembly | MDN (mozilla.org)</li> <li>WebAssembly \u4e2d\u6587\u7f51|Wasm \u4e2d\u6587\u6587\u6863</li> <li>eBPF \u5728\u7ebf\u5b66\u4e60\u5e73\u53f0\uff1abolipi.com/ebpf/home/online</li> </ul>"},{"location":"blogs/test-for-Android.zh/","title":"ecli \u5728\u5b89\u5353 13 \u4e0a\u7684\u8fd0\u884c\u6d4b\u8bd5","text":"<p>\u4f5c\u8005\uff1aCH3CHOHCH3</p>"},{"location":"blogs/test-for-Android.zh/#_1","title":"\u6458\u8981","text":"<p>\u672c\u6587\u4e3b\u8981\u8bb0\u5f55\u4e86\u7b14\u8005\u5728 Android Studio Emulator \u4e2d\u6d4b\u8bd5\u9ad8\u7248\u672c Android Kernel \u5bf9\u57fa\u4e8e libbpf \u7684 CO-RE \u6280\u672f\u652f\u6301\u7a0b\u5ea6\u7684\u63a2\u7d22\u8fc7\u7a0b\u3001\u7ed3\u679c\u548c\u9047\u5230\u7684\u95ee\u9898\u3002\u6d4b\u8bd5\u91c7\u7528\u7684\u65b9\u5f0f\u662f\u5728 Android Shell \u73af\u5883\u4e0b\u6784\u5efa Debian \u73af\u5883\uff0c\u5e76\u57fa\u4e8e\u6b64\u5c1d\u8bd5\u6784\u5efa eunomia-bpf \u5de5\u5177\u94fe\u3001\u8fd0\u884c\u5176\u6d4b\u8bd5\u7528\u4f8b\u3002</p>"},{"location":"blogs/test-for-Android.zh/#_2","title":"\u80cc\u666f","text":"<p>\u622a\u81f3\u76ee\u524d\uff082023-04\uff09\uff0cAndroid \u8fd8\u672a\u5bf9 eBPF \u7a0b\u5e8f\u7684\u52a8\u6001\u52a0\u8f7d\u505a\u51fa\u8f83\u597d\u7684\u652f\u6301\uff0c\u65e0\u8bba\u662f\u4ee5 bcc \u4e3a\u4ee3\u8868\u7684\u5e26\u7f16\u8bd1\u5668\u5206\u53d1\u65b9\u6848\uff0c\u8fd8\u662f\u57fa\u4e8e btf \u548c libbpf \u7684 CO-RE \u65b9\u6848\uff0c\u90fd\u5728\u8f83\u5927\u7a0b\u5ea6\u4e0a\u79bb\u4e0d\u5f00 Linux \u73af\u5883\u7684\u652f\u6301\uff0c\u65e0\u6cd5\u5728 Android \u7cfb\u7edf\u4e0a\u5f88\u597d\u5730\u8fd0\u884c2\u3002</p> <p>\u867d\u7136\u5982\u6b64\uff0c\u5728 Android \u5e73\u53f0\u4e0a\u5c1d\u8bd5 eBPF \u4e5f\u5df2\u7ecf\u6709\u4e86\u4e00\u4e9b\u6210\u529f\u6848\u4f8b\uff0c\u9664\u8c37\u6b4c\u5b98\u65b9\u63d0\u4f9b\u7684\u4fee\u6539 <code>Android.bp</code> \u4ee5\u5c06 eBPF \u7a0b\u5e8f\u968f\u6574\u4e2a\u7cfb\u7edf\u4e00\u540c\u6784\u5efa\u5e76\u6302\u8f7d\u7684\u65b9\u68481\uff0c\u4e5f\u6709\u4eba\u63d0\u51fa\u57fa\u4e8e Android \u5185\u6838\u6784\u5efa Linux \u73af\u5883\u8fdb\u800c\u8fd0\u884c eBPF \u5de5\u5177\u94fe\u7684\u601d\u8def\uff0c\u5e76\u5f00\u53d1\u4e86\u76f8\u5173\u5de5\u5177\u3002</p> <p>\u76ee\u524d\u5df2\u6709\u7684\u8d44\u6599\uff0c\u5927\u591a\u57fa\u4e8e adeb/eadb \u5728 Android \u5185\u6838\u57fa\u7840\u4e0a\u6784\u5efa Linux \u6c99\u7bb1\uff0c\u5e76\u5bf9 bcc \u548c bpftrace \u76f8\u5173\u5de5\u5177\u94fe\u8fdb\u884c\u6d4b\u8bd5\uff0c\u800c\u5bf9 CO-RE \u65b9\u6848\u7684\u6d4b\u8bd5\u5de5\u4f5c\u8f83\u5c11\u3002\u5728 Android \u4e0a\u4f7f\u7528 bcc \u5de5\u5177\u76ee\u524d\u6709\u8f83\u591a\u53c2\u8003\u8d44\u6599\uff0c\u5982\uff1a + SeeFlowerX\uff1ahttps://blog.seeflower.dev/category/eBPF/ + evilpan\uff1ahttps://bbs.kanxue.com/thread-271043.htm</p> <p>\u5176\u4e3b\u8981\u601d\u8def\u662f\u5229\u7528 chroot \u5728 Android \u5185\u6838\u4e0a\u8fd0\u884c\u4e00\u4e2a Debian \u955c\u50cf\uff0c\u5e76\u5728\u5176\u4e2d\u6784\u5efa\u6574\u4e2a bcc \u5de5\u5177\u94fe\uff0c\u4ece\u800c\u4f7f\u7528 eBPF \u5de5\u5177\u3002\u5982\u679c\u60f3\u8981\u4f7f\u7528 bpftrace\uff0c\u539f\u7406\u4e5f\u662f\u7c7b\u4f3c\u7684\u3002</p> <p>\u4e8b\u5b9e\u4e0a\uff0c\u9ad8\u7248\u672c\u7684 Android \u5185\u6838\u5df2\u652f\u6301 btf \u9009\u9879\uff0c\u8fd9\u610f\u5473\u7740 eBPF \u9886\u57df\u4e2d\u65b0\u5174\u7684 CO-RE \u6280\u672f\u4e5f\u5e94\u5f53\u80fd\u591f\u8fd0\u7528\u5230\u57fa\u4e8e Android \u5185\u6838\u7684 Linux \u7cfb\u7edf\u4e2d\u3002\u672c\u6587\u5c06\u57fa\u4e8e\u6b64\u5bf9 eunomia-bpf \u5728\u6a21\u62df\u5668\u73af\u5883\u4e0b\u8fdb\u884c\u6d4b\u8bd5\u8fd0\u884c\u3002</p> <p>eunomia-bpf \u662f\u4e00\u4e2a\u7ed3\u5408\u4e86 libbpf \u548c WebAssembly \u6280\u672f\u7684\u5f00\u6e90\u9879\u76ee\uff0c\u65e8\u5728\u7b80\u5316 eBPF \u7a0b\u5e8f\u7684\u7f16\u5199\u3001\u7f16\u8bd1\u548c\u90e8\u7f72\u3002\u8be5\u9879\u76ee\u53ef\u88ab\u89c6\u4f5c CO-RE \u7684\u4e00\u79cd\u5b9e\u8df5\u65b9\u5f0f\uff0c\u5176\u6838\u5fc3\u4f9d\u8d56\u662f libbpf\uff0c\u76f8\u4fe1\u5bf9 eunomia-bpf \u7684\u6d4b\u8bd5\u5de5\u4f5c\u80fd\u591f\u4e3a\u5176\u4ed6 CO-RE \u65b9\u6848\u63d0\u4f9b\u53c2\u8003\u3002</p>"},{"location":"blogs/test-for-Android.zh/#_3","title":"\u6d4b\u8bd5\u73af\u5883","text":"<ul> <li>Android Emulator\uff08Android Studio Flamingo | 2022.2.1\uff09</li> <li>AVD: Pixel 6</li> <li>Android Image: Tiramisu Android 13.0 x86_64\uff085.15.41-android13-8-00055-g4f5025129fe8-ab8949913\uff09</li> </ul>"},{"location":"blogs/test-for-Android.zh/#3","title":"\u73af\u5883\u642d\u5efa3","text":"<ol> <li>\u4ece eadb \u4ed3\u5e93 \u7684 releases \u9875\u9762\u83b7\u53d6 <code>debianfs-amd64-full.tar.gz</code> \u4f5c\u4e3a Linux \u73af\u5883\u7684 rootfs\uff0c\u540c\u65f6\u8fd8\u9700\u8981\u83b7\u53d6\u8be5\u9879\u76ee\u7684 <code>assets</code> \u76ee\u5f55\u6765\u6784\u5efa\u73af\u5883\uff1b</li> <li>\u4ece Android Studio \u7684 Device Manager \u914d\u7f6e\u5e76\u542f\u52a8 Android Virtual Device\uff1b</li> <li>\u901a\u8fc7 Android Studio SDK \u7684 adb \u5de5\u5177\u5c06 <code>debianfs-amd64-full.tar.gz</code> \u548c <code>assets</code> \u76ee\u5f55\u63a8\u9001\u5230 AVD \u4e2d\uff1a</li> <li><code>./adb push debianfs-amd64-full.tar.gz /data/local/tmp/deb.tar.gz</code></li> <li><code>./adb push assets /data/local/tmp/assets</code></li> <li>\u901a\u8fc7 adb \u8fdb\u5165 Android shell \u73af\u5883\u5e76\u83b7\u53d6 root \u6743\u9650\uff1a</li> <li><code>./adb shell</code></li> <li><code>su</code> </li> <li>\u5728 Android shell \u4e2d\u6784\u5efa\u5e76\u8fdb\u5165 debian \u73af\u5883\uff1a</li> <li><code>mkdir -p /data/eadb</code></li> <li><code>mv /data/local/tmp/assets/* /data/eadb</code></li> <li><code>mv /data/local/tmp/deb.tar.gz /data/eadb/deb.tar.gz</code></li> <li><code>rm -r /data/local/tmp/assets</code></li> <li><code>chmod +x /data/eadb/device-*</code></li> <li><code>/data/eadb/device-unpack</code></li> <li><code>/data/eadb/run /data/eadb/debian</code></li> </ol> <p>\u81f3\u6b64\uff0c\u6d4b\u8bd5 eBPF \u6240\u9700\u7684 Linux \u73af\u5883\u5df2\u7ecf\u6784\u5efa\u5b8c\u6bd5\u3002\u6b64\u5916\uff0c\u5728 Android shell \u4e2d\uff08\u672a\u8fdb\u5165 debian \u65f6\uff09\u53ef\u4ee5\u901a\u8fc7 <code>zcat /proc/config.gz</code> \u5e76\u914d\u5408 <code>grep</code> \u67e5\u770b\u5185\u6838\u7f16\u8bd1\u9009\u9879\u3002</p> <p>\u76ee\u524d\uff0ceadb \u6253\u5305\u7684 debian \u73af\u5883\u5b58\u5728 libc \u7248\u672c\u4f4e\uff0c\u7f3a\u5c11\u7684\u5de5\u5177\u4f9d\u8d56\u8f83\u591a\u7b49\u60c5\u51b5\uff1b\u5e76\u4e14\u7531\u4e8e\u5185\u6838\u7f16\u8bd1\u9009\u9879\u4e0d\u540c\uff0c\u4e00\u4e9b eBPF \u529f\u80fd\u53ef\u80fd\u4e5f\u65e0\u6cd5\u4f7f\u7528\u3002</p>"},{"location":"blogs/test-for-Android.zh/#_4","title":"\u5de5\u5177\u6784\u5efa","text":"<p>\u5728 debian \u73af\u5883\u4e2d\u5c06 eunomia-bpf \u4ed3\u5e93 clone \u5230\u672c\u5730\uff0c\u5177\u4f53\u7684\u6784\u5efa\u8fc7\u7a0b\uff0c\u53ef\u4ee5\u53c2\u8003\u4ed3\u5e93\u7684 build.md\u3002\u5728\u672c\u6b21\u6d4b\u8bd5\u4e2d\uff0c\u7b14\u8005\u9009\u7528\u4e86 <code>ecc</code> \u7f16\u8bd1\u751f\u6210 <code>package.json</code> \u7684\u65b9\u5f0f\uff0c\u8be5\u5de5\u5177\u7684\u6784\u5efa\u548c\u4f7f\u7528\u65b9\u5f0f\u8bf7\u53c2\u8003\u4ed3\u5e93\u9875\u9762\u3002</p> <p>\u5728\u6784\u5efa\u8fc7\u7a0b\u4e2d\uff0c\u53ef\u80fd\u9700\u8981\u81ea\u884c\u5b89\u88c5\u5305\u62ec\u4f46\u4e0d\u9650\u4e8e <code>curl</code>\uff0c<code>pkg-config</code>\uff0c<code>libssl-dev</code> \u7b49\u5de5\u5177\u3002</p>"},{"location":"blogs/test-for-Android.zh/#_5","title":"\u6d4b\u8bd5\u7ed3\u679c","text":""},{"location":"blogs/test-for-Android.zh/#_6","title":"\u6210\u529f\u6848\u4f8b","text":""},{"location":"blogs/test-for-Android.zh/#bootstrap","title":"bootstrap","text":"<p>\u8fd0\u884c\u8f93\u51fa\u5982\u4e0b\uff1a <pre><code>TIME     PID     PPID    EXIT_CODE  DURATION_NS  COMM    FILENAME  EXIT_EVENT\n09:09:19  10217  479     0          0            sh      /system/bin/sh 0\n09:09:19  10217  479     0          0            ps      /system/bin/ps 0\n09:09:19  10217  479     0          54352100     ps                1\n09:09:21  10219  479     0          0            sh      /system/bin/sh 0\n09:09:21  10219  479     0          0            ps      /system/bin/ps 0\n09:09:21  10219  479     0          44260900     ps                1\n</code></pre></p>"},{"location":"blogs/test-for-Android.zh/#tcpstates","title":"tcpstates","text":"<p>\u5f00\u59cb\u76d1\u6d4b\u540e\u5728 Linux \u73af\u5883\u4e2d\u901a\u8fc7 <code>wget</code> \u4e0b\u8f7d Web \u9875\u9762\uff1a <pre><code>TIME     SADDR   DADDR   SKADDR  TS_US   DELTA_US  PID     OLDSTATE  NEWSTATE  FAMILY  SPORT   DPORT   TASK\n09:07:46  0x4007000200005000000000000f02000a 0x5000000000000f02000a8bc53f77 18446635827774444352 3315344998 0 10115 7 2 2 0 80 wget\n09:07:46  0x40020002d98e50003d99f8090f02000a 0xd98e50003d99f8090f02000a8bc53f77 18446635827774444352 3315465870 120872 0 2 1 2 55694 80 swapper/0\n09:07:46  0x40010002d98e50003d99f8090f02000a 0xd98e50003d99f8090f02000a8bc53f77 18446635827774444352 3315668799 202929 10115 1 4 2 55694 80 wget\n09:07:46  0x40040002d98e50003d99f8090f02000a 0xd98e50003d99f8090f02000a8bc53f77 18446635827774444352 3315670037 1237 0 4 5 2 55694 80 swapper/0\n09:07:46  0x40050002000050003d99f8090f02000a 0x50003d99f8090f02000a8bc53f77 18446635827774444352 3315670225 188 0 5 7 2 55694 80 swapper/0\n09:07:47  0x400200020000bb01565811650f02000a 0xbb01565811650f02000a6aa0d9ac 18446635828348806592 3316433261 0 2546 2 7 2 49970 443 ChromiumNet\n09:07:47  0x400200020000bb01db794a690f02000a 0xbb01db794a690f02000aea2afb8e 18446635827774427776 3316535591 0 1469 2 7 2 37386 443 ChromiumNet\n</code></pre> \u5f00\u59cb\u68c0\u6d4b\u540e\u5728 Android Studio \u6a21\u62df\u754c\u9762\u6253\u5f00 Chrome \u6d4f\u89c8\u5668\u5e76\u8bbf\u95ee\u767e\u5ea6\u9875\u9762\uff1a <pre><code>TIME     SADDR   DADDR   SKADDR  TS_US   DELTA_US  PID     OLDSTATE  NEWSTATE  FAMILY  SPORT   DPORT   TASK\n07:46:58  0x400700020000bb01000000000f02000a 0xbb01000000000f02000aeb6f2270 18446631020066638144 192874641 0 3305 7 2 2 0 443 NetworkService\n07:46:58  0x40020002d28abb01494b6ebe0f02000a 0xd28abb01494b6ebe0f02000aeb6f2270 18446631020066638144 192921938 47297 3305 2 1 2 53898 443 NetworkService\n07:46:58  0x400700020000bb01000000000f02000a 0xbb01000000000f02000ae7e7e8b7 18446631020132433920 193111426 0 3305 7 2 2 0 443 NetworkService\n07:46:58  0x40020002b4a0bb0179ff85e80f02000a 0xb4a0bb0179ff85e80f02000ae7e7e8b7 18446631020132433920 193124670 13244 3305 2 1 2 46240 443 NetworkService\n07:46:58  0x40010002b4a0bb0179ff85e80f02000a 0xb4a0bb0179ff85e80f02000ae7e7e8b7 18446631020132433920 193185397 60727 3305 1 4 2 46240 443 NetworkService\n07:46:58  0x40040002b4a0bb0179ff85e80f02000a 0xb4a0bb0179ff85e80f02000ae7e7e8b7 18446631020132433920 193186122 724 3305 4 5 2 46240 443 NetworkService\n07:46:58  0x400500020000bb0179ff85e80f02000a 0xbb0179ff85e80f02000ae7e7e8b7 18446631020132433920 193186244 122 3305 5 7 2 46240 443 NetworkService\n07:46:59  0x40010002d01ebb01d0c52f5c0f02000a 0xd01ebb01d0c52f5c0f02000a51449c27 18446631020103553856 194110884 0 5130 1 8 2 53278 443 ThreadPoolForeg\n07:46:59  0x400800020000bb01d0c52f5c0f02000a 0xbb01d0c52f5c0f02000a51449c27 18446631020103553856 194121000 10116 3305 8 7 2 53278 443 NetworkService\n07:46:59  0x400700020000bb01000000000f02000a 0xbb01000000000f02000aeb6f2270 18446631020099513920 194603677 0 3305 7 2 2 0 443 NetworkService\n07:46:59  0x40020002d28ebb0182dd92990f02000a 0xd28ebb0182dd92990f02000aeb6f2270 18446631020099513920 194649313 45635 12 2 1 2 53902 443 ksoftirqd/0\n07:47:00  0x400700020000bb01000000000f02000a 0xbb01000000000f02000a26f6e878 18446631020132433920 195193350 0 3305 7 2 2 0 443 NetworkService\n07:47:00  0x40020002ba32bb01e0e09e3a0f02000a 0xba32bb01e0e09e3a0f02000a26f6e878 18446631020132433920 195206992 13642 0 2 1 2 47666 443 swapper/0\n07:47:00  0x400700020000bb01000000000f02000a 0xbb01000000000f02000ae7e7e8b7 18446631020132448128 195233125 0 3305 7 2 2 0 443 NetworkService\n07:47:00  0x40020002b4a8bb0136cac8dd0f02000a 0xb4a8bb0136cac8dd0f02000ae7e7e8b7 18446631020132448128 195246569 13444 3305 2 1 2 46248 443 NetworkService\n07:47:00  0xf02000affff00000000000000000000 0x1aca06cffff00000000000000000000 18446631019225912320 195383897 0 947 7 2 10 0 80 Thread-11\n07:47:00  0x40010002b4a8bb0136cac8dd0f02000a 0xb4a8bb0136cac8dd0f02000ae7e7e8b7 18446631020132448128 195421584 175014 3305 1 4 2 46248 443 NetworkService\n07:47:00  0x40040002b4a8bb0136cac8dd0f02000a 0xb4a8bb0136cac8dd0f02000ae7e7e8b7 18446631020132448128 195422361 777 3305 4 5 2 46248 443 NetworkService\n07:47:00  0x400500020000bb0136cac8dd0f02000a 0xbb0136cac8dd0f02000ae7e7e8b7 18446631020132448128 195422450 88 3305 5 7 2 46248 443 NetworkService\n07:47:01  0x400700020000bb01000000000f02000a 0xbb01000000000f02000aea2afb8e 18446631020099528128 196321556 0 1315 7 2 2 0 443 ChromiumNet\n</code></pre></p>"},{"location":"blogs/test-for-Android.zh/#_7","title":"\u5931\u8d25\u6848\u4f8b","text":""},{"location":"blogs/test-for-Android.zh/#fentry-link","title":"fentry-link","text":"<p>\u53ef\u4ee5\u6210\u529f build\uff0c\u4f46\u8fd0\u884c\u62a5\u9519\uff1a <pre><code>libbpf: prog 'do_unlinkat': failed to attach: Device or resource busy\nlibbpf: prog 'do_unlinkat': failed to auto-attach: -16\nfailed to attach skeleton\nError: BpfError(\"load and attach ebpf program failed\")\n</code></pre></p>"},{"location":"blogs/test-for-Android.zh/#opensnoop","title":"opensnoop","text":"<p>\u53ef\u4ee5\u6210\u529f build\uff0c\u4f46\u8fd0\u884c\u62a5\u9519\uff1a <pre><code>libbpf: failed to determine tracepoint 'syscalls/sys_enter_open' perf event ID: No such file or directory\nlibbpf: prog 'tracepoint__syscalls__sys_enter_open': failed to create tracepoint 'syscalls/sys_enter_open' perf event: No such file or directory\nlibbpf: prog 'tracepoint__syscalls__sys_enter_open': failed to auto-attach: -2\nfailed to attach skeleton\nError: BpfError(\"load and attach ebpf program failed\")\n</code></pre> \u540e\u7ecf\u67e5\u770b\u53d1\u73b0\u5185\u6838\u672a\u5f00\u542f <code>CONFIG_FTRACE_SYSCALLS</code> \u9009\u9879\uff0c\u5bfc\u81f4\u65e0\u6cd5\u4f7f\u7528 syscalls \u7684 tracepoint\u3002</p>"},{"location":"blogs/test-for-Android.zh/#runqlat","title":"runqlat","text":"<p>\u6784\u5efa\u62a5\u9519\uff1a <pre><code>Compiling bpf object...\n$ clang -g -O2 -target bpf -Wno-unknown-attributes -D__TARGET_ARCH_x86 -idirafter /usr/local/include -idirafter /usr/lib/llvm-11/lib/clang/11.0.1/include -idirafter /usr/include/x86_64-linux-gnu -idirafter /usr/include  -I/tmp/eunomia.9fwyJN/include -I/tmp/eunomia.9fwyJN/include/vmlinux/x86  -I/root/eunomia-bpf/examples/bpftools/runqlat -c examples/bpftools/runqlat/runqlat.bpf.temp.c -o examples/bpftools/runqlat/runqlat.bpf.o\n In file included from examples/bpftools/runqlat/runqlat.bpf.temp.c:10:\n/root/eunomia-bpf/examples/bpftools/runqlat/core_fixes.bpf.h:76:9: error: use of unknown builtin '__builtin_preserve_type_info' [-Wimplicit-function-declaration]\nif (bpf_core_type_exists(struct trace_event_raw_block_rq_completion___x))\n^\n/tmp/eunomia.9fwyJN/include/bpf/bpf_core_read.h:185:2: note: expanded from macro 'bpf_core_type_exists'\n__builtin_preserve_type_info(*(typeof(type) *)0, BPF_TYPE_EXISTS)\n^\n/root/eunomia-bpf/examples/bpftools/runqlat/core_fixes.bpf.h:76:9: note: did you mean '__builtin_preserve_field_info'?\n/tmp/eunomia.9fwyJN/include/bpf/bpf_core_read.h:185:2: note: expanded from macro 'bpf_core_type_exists'\n__builtin_preserve_type_info(*(typeof(type) *)0, BPF_TYPE_EXISTS)\n^\n/root/eunomia-bpf/examples/bpftools/runqlat/core_fixes.bpf.h:27:9: note: '__builtin_preserve_field_info' declared here\n    if (bpf_core_field_exists(t-&gt;__state))\n^\n/tmp/eunomia.9fwyJN/include/bpf/bpf_core_read.h:132:2: note: expanded from macro 'bpf_core_field_exists'\n__builtin_preserve_field_info(___bpf_field_ref(field), BPF_FIELD_EXISTS)\n^\nIn file included from examples/bpftools/runqlat/runqlat.bpf.temp.c:10:\n/root/eunomia-bpf/examples/bpftools/runqlat/core_fixes.bpf.h:76:9: warning: indirection of non-volatile null pointer will be deleted, not trap [-Wnull-dereference]\nif (bpf_core_type_exists(struct trace_event_raw_block_rq_completion___x))\n^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n/tmp/eunomia.9fwyJN/include/bpf/bpf_core_read.h:185:31: note: expanded from macro 'bpf_core_type_exists'\n__builtin_preserve_type_info(*(typeof(type) *)0, BPF_TYPE_EXISTS)\n^~~~~~~~~~~~~~~~~~\n/root/eunomia-bpf/examples/bpftools/runqlat/core_fixes.bpf.h:76:9: note: consider using __builtin_trap() or qualifying pointer with 'volatile'\n/tmp/eunomia.9fwyJN/include/bpf/bpf_core_read.h:185:31: note: expanded from macro 'bpf_core_type_exists'\n__builtin_preserve_type_info(*(typeof(type) *)0, BPF_TYPE_EXISTS)\n^\n1 warning and 1 error generated.\n\nthread 'main' panicked at 'called `Result::unwrap()` on an `Err` value: No such file or directory (os error 2)', src/compile_bpf.rs:171:37\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n</code></pre> \u5177\u4f53\u9519\u8bef\u539f\u56e0\u76ee\u524d\u9700\u8981\u8fdb\u4e00\u6b65\u7814\u7a76\u3002</p>"},{"location":"blogs/test-for-Android.zh/#_8","title":"\u603b\u7ed3","text":"<p>\u5728 Android shell \u4e2d\u67e5\u770b\u5185\u6838\u7f16\u8bd1\u9009\u9879\u53ef\u4ee5\u53d1\u73b0  <code>CONFIG_DEBUG_INFO_BTF</code> \u9ed8\u8ba4\u662f\u6253\u5f00\u7684\uff0c\u5728\u6b64\u57fa\u7840\u4e0a eunomia-bpf \u9879\u76ee\u63d0\u4f9b\u7684 example \u5df2\u6709\u4e00\u4e9b\u80fd\u591f\u6210\u529f\u8fd0\u884c\u7684\u6848\u4f8b\uff0c\u4f8b\u5982\u53ef\u4ee5\u76d1\u6d4b <code>exec</code> \u65cf\u51fd\u6570\u7684\u6267\u884c\u548c tcp \u8fde\u63a5\u7684\u72b6\u6001\u3002</p> <p>\u5bf9\u4e8e\u65e0\u6cd5\u8fd0\u884c\u7684\u9879\u76ee\uff0c\u539f\u56e0\u4e3b\u8981\u662f\u4ee5\u4e0b\u4e24\u4e2a\u65b9\u9762\uff1a 1. \u5185\u6838\u7f16\u8bd1\u9009\u9879\u672a\u652f\u6301\u76f8\u5173 eBPF \u529f\u80fd\uff1b 2. eadb \u6253\u5305\u7684 Linux \u73af\u5883\u8f83\u5f31\uff0c\u7f3a\u4e4f\u5fc5\u987b\u4f9d\u8d56\uff1b</p> <p>\u76ee\u524d\u5728 Android \u7cfb\u7edf\u4e2d\u4f7f\u7528 eBPF \u5de5\u5177\u57fa\u672c\u4e0a\u4ecd\u7136\u9700\u8981\u6784\u5efa\u5b8c\u6574\u7684 Linux \u8fd0\u884c\u73af\u5883\uff0c\u4f46 Android \u5185\u6838\u672c\u8eab\u5bf9 eBPF \u7684\u652f\u6301\u5df2\u8f83\u4e3a\u5168\u9762\uff0c\u672c\u6b21\u6d4b\u8bd5\u8bc1\u660e\u8f83\u9ad8\u7248\u672c\u7684 Android \u5185\u6838\u652f\u6301 BTF \u8c03\u8bd5\u4fe1\u606f\u548c\u4f9d\u8d56 CO-RE \u7684 eBPF \u7a0b\u5e8f\u7684\u8fd0\u884c\u3002</p> <p>Android \u7cfb\u7edf eBPF \u5de5\u5177\u7684\u53d1\u5c55\u9700\u8981\u5b98\u65b9\u65b0\u7279\u6027\u7684\u52a0\u5165\uff0c\u76ee\u524d\u770b\u6765\u901a\u8fc7 Android APP \u76f4\u63a5\u4f7f\u7528 eBPF \u5de5\u5177\u9700\u8981\u7684\u5de5\u4f5c\u91cf\u8f83\u5927\uff0c\u540c\u65f6\u7531\u4e8e eBPF \u5de5\u5177\u9700\u8981 root \u6743\u9650\uff0c\u666e\u901a Android \u7528\u6237\u7684\u4f7f\u7528\u4f1a\u9762\u4e34\u8f83\u591a\u56f0\u96be\u3002</p>"},{"location":"blogs/test-for-Android.zh/#_9","title":"\u53c2\u8003","text":"<ol> <li> <p>https://source.android.google.cn/docs/core/architecture/kernel/bpf\u00a0\u21a9</p> </li> <li> <p>https://mp.weixin.qq.com/s/mul4n5D3nXThjxuHV7GpMA\u00a0\u21a9</p> </li> <li> <p>https://blog.seeflower.dev/archives/138/\u00a0\u21a9</p> </li> </ol>"},{"location":"blogs/wasm-bpf/","title":"Wasm-bpf: A Common eBPF Kernel Programmability for Cloud-Native Webassembly","text":"<p>Author: Yusheng Zheng, Mao-Lin Chen</p> <p>Originally developed with a browser-safe sandbox in mind, Wasm has evolved to make WebAssembly a high-performance, cross-platform and multilingual software sandbox environment for cloud-native software components, and Wasm lightweight containers are well suited as the next-generation serverless platform runtime. Another exciting trend is the rise of eBPF, which enables cloud-native developers to build secure networks, service grids, and multiple observable components, and which is also gradually penetrating and penetrating deeper into kernel components, providing more powerful kernel-state programmable interactions.</p> <p>Wasm-bpf is a new open source project [1] that defines a set of abstractions for eBPF-related system interfaces and provides a corresponding set of development toolchains, libraries, and generic Wasm + eBPF runtime platform instances, giving applications in any Wasm virtual machine or Wasm lightweight container the ability to sink and extend usage scenarios to the kernel state, accessing almost all data in the kernel state and The eBPF runtime platform instance allows applications in any Wasm virtual machine or Wasm lightweight container to sink and expand their usage scenarios to the kernel state, access almost all data in the kernel state and user state, and achieve programmable control over the entire operating system in many aspects such as networking and security, thus greatly expanding the WebAssembly ecosystem in non-browser application scenarios.</p>"},{"location":"blogs/wasm-bpf/#ebpf-based-system-interface-for-wasm","title":"eBPF-based System Interface for Wasm","text":"<p>Perhaps you have also read this quote from Solomon Hykes (one of the founders of Docker).</p> <p>If we already had Wasm + WASI in 2008, we wouldn't have needed to create Docker at all. Wasm was that important. Server-side WebAssembly is the future of computing.</p> <p>Because it can't rely on the existing JavaScript engine interfaces available in the browser, most Wasm lightweight containers that run outside the browser today require the use of WASI (WebAssembly System Interface). These runtimes allow Wasm applications to interact with their host operating system in a manner similar (but not identical) to POSIX.</p> <p>However, compared to traditional containers where almost all system calls are available, the WASI currently provides very limited system resources, with only some basic support for file systems, socket network connections, etc. There are still significant gaps in the ability to access, control, and manage the underlying operating system resources, such as execution of Wasm modules or other external processes For example, there is still a large gap in the ability to access, control and manage the underlying resources of the operating system, such as the execution of Wasm modules or other external processes, the observation of resource limits and behavior, the fast forwarding and processing of network packets, and even the communication with other processes outside the wasm sandbox and access to peripherals. This also makes most Wasm lightweight containers in practice still mainly focus on purely compute-intensive applications, while in terms of networking, security, etc., still need to rely on traditional container technology.</p> <p>This is the reason why we want to build Wasm-bpf project: to expand the whole WASI ecological blueprint by using the system interface provided by the current kernel state eBPF and the ability to interact with the user state, to bring more possible usage scenarios for Wasm applications, and to enhance the capability of eBPF programs in the user state.</p> <p>In other words, similar to the Wasm program running in a browser, which accesses various system resources provided by the browser through the JavaScript engine interface, the Wasm-bpf solution is to access various OS resources with the help of the eBPF virtual machine; thanks to the wide support of eBPF in the Linux kernel and even other operating systems such as Windows. Thanks to the extensive support of eBPF in Linux kernels and even other operating systems such as Windows, the portability between different kernel versions and architectures, and the reliability of the kernel BPF authentication engine, we can still guarantee a certain degree of application portability and security boundaries.</p> <p>The Wasm-bpf project has implemented a complete abstraction mechanism for the system interface between the kernel-state eBPF virtual machine and the user-state, and provides a corresponding toolchain for compiling eBPF applications into Wasm modules to facilitate efficient serialization-free, memory-sharing bi-directional communication between kernel-state eBPF and user-state Wasm, as well as code generation techniques to provide almost identical functionality to other user-state eBPF development frameworks. eBPF development framework through code generation technology, providing a nearly consistent, easy and convenient development experience. With the improved ecosystem support of the Wasm component model, we can also bring more user-state development languages to the eBPF community, and eBPF applications and data processing plug-ins implemented in different languages can be easily integrated, reused, and managed in a unified way.</p> <p>On top of the libbpf library, which has almost become the de facto API standard for eBPF user states, and the WAMR (wasm-micro-runtime), a complete generic Wasm-eBPF runtime component can be built with only 300+ lines of code and supports most eBPF usage scenarios - anyone with any major Wasm runtime, or any Anyone with any major Wasm runtime, or any eBPF user state library, and any programming language, can easily add corresponding virtual machine support and reuse our toolchain to easily write and develop Wasm-eBPF programs.</p> <p>There has been some exploration of combining eBPF and Wasm in the eunomia-bpf project, but it was not designed for Wasm native application scenarios, did not fit the Wasm-eBPF general programming model, and had low performance, so we created a new open source repository for the Wasm-bpf project to focus on using eBPF to enhance and extend WebAssembly usage scenarios and further improve the corresponding toolchain and development library support: https://github.com/eunomia-bpf/wasm-bpf</p>"},{"location":"blogs/wasm-bpf/#ebpf-extending-the-kernel-securely-and-efficiently","title":"eBPF: Extending the Kernel Securely and Efficiently","text":"<p>eBPF is a revolutionary technology, originating from the Linux kernel, that allows sandboxed programs to be run in the kernel of the operating system. It is used to safely and efficiently extend the functionality of the kernel without changing the kernel's source code or loading kernel modules.</p> <p>\u4ece\u5386\u53f2\u4e0a\u770b\uff0c\u7531\u4e8e\u5185\u6838\u5177\u6709\u76d1\u7763\u548c\u63a7\u5236\u6574\u4e2a\u7cfb\u7edf\u7684\u7279\u6743\u80fd\u529b\uff0c\u6240\u4ee5\u64cd\u4f5c\u7cfb\u7edf\u4e00\u76f4\u662f\u5b9e\u73b0\u53ef\u89c2\u5bdf\u6027\u3001\u5b89\u5168\u6027\u548c\u7f51\u7edc\u529f\u80fd\u7b49\u591a\u79cd\u80fd\u529b\u7684\u7406\u60f3\u573a\u6240\u3002 \u540c\u65f6\uff0c\u7531\u4e8e\u64cd\u4f5c\u7cfb\u7edf\u5185\u6838\u5bf9\u7a33\u5b9a\u6027\u548c\u5b89\u5168\u6027\u7684\u9ad8\u8981\u6c42\uff0c\u5185\u6838\u7684\u65b0\u529f\u80fd\u8fed\u4ee3\u901a\u5e38\u975e\u5e38\u8c28\u614e\uff0c\u4e5f\u5f88\u96be\u63a5\u53d7\u81ea\u5b9a\u4e49\u7684\u3001\u8f83\u5c11\u901a\u7528\u6027\u7684\u529f\u80fd\u6539\u8fdb\u3002 \u56e0\u6b64\uff0c\u4e0e\u7528\u6237\u6001\u7684\u66f4\u591a\u529f\u80fd\u76f8\u6bd4\uff0c\u5185\u6838\u6001\u64cd\u4f5c\u7cfb\u7edf\u5c42\u9762\u7684\u521b\u65b0\u7387\u5386\u6765\u90fd\u6bd4\u8f83\u4f4e[2]\u3002</p> <p>eBPF \u4ece\u6839\u672c\u4e0a\u6539\u53d8\u4e86\u8fd9\u4e2a\u516c\u5f0f\u3002 \u901a\u8fc7\u5141\u8bb8\u5728\u64cd\u4f5c\u7cfb\u7edf\u5185\u8fd0\u884c\u6c99\u76d2\u7a0b\u5e8f\uff0c\u5e94\u7528\u7a0b\u5e8f\u5f00\u53d1\u4eba\u5458\u53ef\u4ee5\u5728\u8fd0\u884c\u65f6\uff0c\u53ef\u7f16\u7a0b\u5730\u5411\u64cd\u4f5c\u7cfb\u7edf\u52a8\u6001\u6dfb\u52a0\u989d\u5916\u7684\u529f\u80fd\u3002 \u7136\u540e\uff0c\u64cd\u4f5c\u7cfb\u7edf\u4fdd\u8bc1\u5b89\u5168\u548c\u6267\u884c\u6548\u7387\uff0c\u5c31\u50cf\u5728\u5373\u65f6\u7f16\u8bd1\uff08JIT\uff09\u7f16\u8bd1\u5668\u548c\u9a8c\u8bc1\u5f15\u64ce\u7684\u5e2e\u52a9\u4e0b\u8fdb\u884c\u672c\u5730\u7f16\u8bd1\u4e00\u6837\u3002eBPF \u7a0b\u5e8f\u5728\u5185\u6838\u7248\u672c\u4e4b\u95f4\u662f\u53ef\u79fb\u690d\u7684\uff0c\u5e76\u4e14\u53ef\u4ee5\u81ea\u52a8\u66f4\u65b0\uff0c\u4ece\u800c\u907f\u514d\u4e86\u5de5\u4f5c\u8d1f\u8f7d\u4e2d\u65ad\u548c\u8282\u70b9\u91cd\u542f\u3002</p> <p>\u4eca\u5929\uff0ceBPF\u88ab\u5e7f\u6cdb\u7528\u4e8e\u5404\u7c7b\u573a\u666f\uff1a\u5728\u73b0\u4ee3\u6570\u636e\u4e2d\u5fc3\u548c\u4e91\u539f\u751f\u73af\u5883\u4e2d\uff0c\u53ef\u4ee5\u63d0\u4f9b\u9ad8\u6027\u80fd\u7684\u7f51\u7edc\u5305\u5904\u7406\u548c\u8d1f\u8f7d\u5747\u8861\uff1b\u4ee5\u975e\u5e38\u4f4e\u7684\u8d44\u6e90\u5f00\u9500\uff0c\u505a\u5230\u5bf9\u591a\u79cd\u7ec6\u7c92\u5ea6\u6307\u6807\u7684\u53ef\u89c2\u6d4b\u6027\uff0c\u5e2e\u52a9\u5e94\u7528\u7a0b\u5e8f\u5f00\u53d1\u4eba\u5458\u8ddf\u8e2a\u5e94\u7528\u7a0b\u5e8f\uff0c\u4e3a\u6027\u80fd\u6545\u969c\u6392\u9664\u63d0\u4f9b\u6d1e\u5bdf\u529b\uff1b\u4fdd\u969c\u5e94\u7528\u7a0b\u5e8f\u548c\u5bb9\u5668\u8fd0\u884c\u65f6\u7684\u5b89\u5168\u6267\u884c\uff0c\u7b49\u7b49\u3002 \u53ef\u80fd\u6027\u662f\u65e0\u7a77\u7684\uff0c\u800c eBPF \u5728\u64cd\u4f5c\u7cfb\u7edf\u5185\u6838\u4e2d\u6240\u91ca\u653e\u7684\u521b\u65b0\u624d\u521a\u521a\u5f00\u59cb[3]\u3002</p>"},{"location":"blogs/wasm-bpf/#ebpf-javascript","title":"eBPF \u7684\u672a\u6765\uff1a\u5185\u6838\u7684 JavaScript \u53ef\u7f16\u7a0b\u63a5\u53e3","text":"<p>\u5bf9\u4e8e\u6d4f\u89c8\u5668\u800c\u8a00\uff0cJavaScript \u7684\u5f15\u5165\u5e26\u6765\u7684\u53ef\u7f16\u7a0b\u6027\u5f00\u542f\u4e86\u4e00\u573a\u5de8\u5927\u7684\u9769\u547d\uff0c\u4f7f\u6d4f\u89c8\u5668\u53d1\u5c55\u6210\u4e3a\u51e0\u4e4e\u72ec\u7acb\u7684\u64cd\u4f5c\u7cfb\u7edf\u3002 \u73b0\u5728\u8ba9\u6211\u4eec\u56de\u5230 eBPF\uff1a\u4e3a\u4e86\u7406\u89e3 eBPF \u5bf9 Linux \u5185\u6838\u7684\u53ef\u7f16\u7a0b\u6027\u5f71\u54cd\uff0c\u5bf9 Linux \u5185\u6838\u7684\u7ed3\u6784\u4ee5\u53ca\u5b83\u5982\u4f55\u4e0e\u5e94\u7528\u7a0b\u5e8f\u548c\u786c\u4ef6\u8fdb\u884c\u4ea4\u4e92\u6709\u4e00\u4e2a\u9ad8\u5c42\u6b21\u7684\u7406\u89e3\u662f\u6709\u5e2e\u52a9\u7684[4]\u3002</p> <p>Linux \u5185\u6838\u7684\u4e3b\u8981\u76ee\u7684\u662f\u62bd\u8c61\u51fa\u786c\u4ef6\u6216\u865a\u62df\u786c\u4ef6\uff0c\u5e76\u63d0\u4f9b\u4e00\u4e2a\u4e00\u81f4\u7684API\uff08\u7cfb\u7edf\u8c03\u7528\uff09\uff0c\u5141\u8bb8\u5e94\u7528\u7a0b\u5e8f\u8fd0\u884c\u548c\u5171\u4eab\u8d44\u6e90\u3002 To achieve this, a series of subsystems and layers are maintained to distribute these responsibilities. Each subsystem typically allows some degree of configuration to take into account the different needs of the user. If the desired behavior cannot be configured, it is necessary to change the kernel. Historically, changing the behavior of the kernel, or enabling user-written programs to run in the kernel, has given two options:</p> Support a kernel module locally Write a kernel module Change the kernel source code and convince the Linux kernel community that such a change is necessary. Wait a few years for a new kernel version to become a commodity. Fix it regularly, as every kernel version can break it. Risk breaking your Linux kernel due to the lack of security boundaries <p>In practice, neither option is commonly used; the former is too costly, and the latter has almost no portability.</p> <p>With eBPF, there is a new option to reprogram the behavior of the Linux kernel without changing the kernel's source code or loading kernel modules, while guaranteeing a certain degree of consistency and compatibility of behavior, as well as security, between different kernel versions. To achieve this, eBPF programs also need to have a corresponding set of APIs that allow user-defined applications to run and share resources -- in other words, in a sense, the eBPF virtual machine also provides a set of system call-like mechanisms that are available to Wasm virtual machines and user-state applications through the eBPF and user-state communication mechanisms. With the eBPF and user state communication mechanisms, Wasm VMs and user state applications can also gain full access to this set of \"system calls\", which can programmatically extend the capabilities of traditional system calls on the one hand, and achieve more efficient programmable IO processing on the other.</p> <p>! new-os</p> <p>As the diagram above shows, today's Linux kernel is evolving into a new kernel model: user-defined applications can execute in both the kernel and user states, with the user state accessing system resources through traditional system calls and the kernel state interacting with various parts of the system through BPF Helper Calls. As of early 2023, there are more than 220 Helper System Interfaces in the eBPF virtual machine in the kernel, covering a very wide range of application scenarios.</p> <p>It is important to note that BPF Helper Calls and System Calls are not in competition with each other; they have completely different programming models and scenarios where they have performance benefits, and they do not completely replace each other. The situation is similar for the Wasm and Wasi related ecosystems, where a specially designed wasi interface requires a lengthy standardization process but may yield better performance and portability guarantees for user-state applications in specific scenarios, while eBPF provides a fast and flexible solution for extending the system interface while maintaining the sandbox nature and portability.</p> <p>The eBPF is still in its early stages, but with the ability to interact between the kernel and user state provided by the current eBPF, applications in the Wasm VM can already obtain data and return values (kprobe, uprobe, ...) from almost any function call in the kernel and user state via the Wasm-bpf system interface transformation. ; collect and understand all system calls and obtain packet and socket level data for all network operations at a very low cost (tracepoint, socket...) Add additional protocol analyzers to the network packet processing solution and easily program any forwarding logic (XDP, TC...) ) to meet changing needs without leaving the packet processing environment of the Linux kernel.</p> <p>Moreover, eBPF has the ability to write data to any address of any process in user space (bpf_probe_write_user[5]), to modify the return value of kernel functions to a limited extent (bpf_override_return[6]), and even to execute some system calls directly in the kernel state [7]; fortunately, eBPF performs a bytecode analysis before loading into the Fortunately, eBPF performs strict security checks on the bytecode before loading it into the kernel to ensure that there are no memory out-of-bounds or other operations, while many features that may expand the attack surface and pose security risks need to be explicitly chosen to be enabled at compile time before the kernel can be used; certain eBPF features can also be explicitly chosen to be enabled or disabled before the Wasm VM loads the bytecode into the kernel to ensure the security of the sandbox.</p> <p>All of these scenarios do not require leaving the Wasm lightweight container: unlike traditional applications that use Wasm as a data processing or control plug-in, where these steps are implemented by logic outside the Wasm VM, it is now possible to achieve complete control and interaction with eBPF and almost all system resources that eBPF can access, even generating eBPF in real time, from within the Wasm lightweight container code to change the behavior logic of the kernel, enabling programmability of the entire system from the user state to the kernel state.</p>"},{"location":"blogs/wasm-bpf/#interaction-flow-between-user-space-and-ebpf-programs","title":"Interaction flow between user space and eBPF programs","text":"<p>eBPF programs are function-based and event-driven, and a specific eBPF program is run when a kernel or user space application passes a hook point. To use an eBPF program, we first need to compile the corresponding source code into bpf bytecode using the clang/LLVM toolchain, which contains the corresponding data structure definitions, maps and progs definitions. progs are program segments, and maps can be used to store data or for bidirectional communication with the user space. After that, we can implement a complete eBPF application with the help of the user state development framework and the loading framework.</p>"},{"location":"blogs/wasm-bpf/#common-user-state-ebpf-development-framework","title":"Common user-state eBPF development framework","text":"<p>For a complete eBPF application, there are usually two parts: the user state and the kernel state.</p> <ul> <li>The user state program needs to interact with the kernel through a series of system calls (mainly bpf system calls), create a corresponding map to store data in the kernel state or to communicate with the user state, dynamically select different segments to load according to the configuration, dynamically modify the bytecode or configure the parameters of the eBPF program, load the corresponding bytecode information into the kernel, ensure security through validators, and communicate with the kernel through maps and the kernel, passing data from the kernel state to the user state (or vice versa) through mechanisms such as ring buffer / perf buffer.</li> <li>The kernel state is mainly responsible for the specific computational logic and data collection.</li> </ul>"},{"location":"blogs/wasm-bpf/#a-new-ebpf-development-framework-defined-on-top-of-the-user-state-wasm-ebpf-system-interface","title":"A new eBPF development framework defined on top of the user-state Wasm-eBPF system interface","text":"<p>The project essentially wants to treat the Wasm sandbox as an alternative user-state runtime space on top of the OS, allowing Wasm applications to implement the same programming model and execution logic in the sandbox as eBPF applications that normally run in the user state.</p> <p>Wasm-bpf would require a runtime module built on top of the host (outside the sandbox), and some runtime libraries compiled to Wasm bytecode inside the sandbox to provide complete support.</p> <p></p> <p>To achieve a complete development model, we need.</p> <ul> <li>a Wasm module can correspond to multiple eBPF procedures.</li> <li>an instance of an eBPF procedure can also be shared by multiple Wasm modules</li> <li>The ability to dynamically load eBPF programs from the Wasm sandbox into the kernel, select the desired mount points to mount them, unmount them, control the complete lifecycle of multiple eBPF bytecode objects, and support most eBPF program types.</li> <li>Bi-directional communication with the kernel via multiple types of Maps, with support for most types of Maps.</li> <li>Efficient sending of messages from the kernel state to the user state (and vice versa for ring buffering) via ring buffering and perf event polling.</li> <li>It can be adapted to almost any application scenario that uses eBPF programs, and can evolve and extend as kernel features are added, without requiring changes to the Wasm VM's system interface.</li> </ul> <p>This is what the Wasm-bpf project is currently working on. We have also proposed a new Proposal for WASI: WASI-eBPF [7].</p> <p>In the Wasm-bpf project, all communications between Wasm and eBPF VMs do not need to go through serialization and deserialization mechanisms, and with the support of code generation techniques and BTF (BPF type format [12]) information in the toolchain, we can achieve correct communication between eBPF and Wasm with potentially different structure in vivo layouts, different size end mechanisms, different pointer widths The data can be copied directly from the kernel state to the memory of the Wasm VM when communicating through eBPF Maps, avoiding the extra loss caused by multiple copies. At the same time, the eBPF-Wasm development experience for user-state programs is greatly improved by automatically generating skeleton (bpf code framework) and type definitions.</p> <p>Thanks to the CO-RE (Compile-Once, Run Everywhere) technology provided by libbpf, porting eBPF bytecode objects between different kernel versions does not introduce an additional recompilation process, nor is there any LLVM/Clang dependency at runtime [12].</p> <p>Typically a compiled eBPF-Wasm module is only about 90Kb and can be dynamically loaded into the kernel and executed in less than 100ms. We also provide several examples in our repository, corresponding to various scenarios such as observable, network, and security.</p> <p>We would like to thank Associate Professor Xiaozheng Lai from South China University of Technology, Professor Lijun Chen's team from Xi'an University of Posts and Telecommunications, and teachers Pu Wang and Jicheng Shi from Datan Technology for their guidance and help in combining Wasm and eBPF. blog, we will give a more detailed analysis of the principle and performance, as well as some code examples.</p> <p>The Wasm-bpf compilation toolchain and runtime modules are currently developed and maintained by the eunomia-bpf open source community, and we thank the PLCT Lab of the Institute of Software of the Chinese Academy of Sciences for their support and funding, and our fellow community members for their contributions. Next, we will also improve and explore more on the corresponding eBPF and Wasm related toolchain and runtime, and actively feed back and contribute to the upstream community.</p>"},{"location":"blogs/wasm-bpf/#references","title":"References","text":"<ul> <li>[1] wasm-bpf Github open source address: https://github.com/eunomia-bpf/wasm-bpf</li> <li>[2] When Wasm meets eBPF: Writing, distributing, loading and running eBPF programs using WebAssembly: https://zhuanlan.zhihu.com/p/573941739</li> <li>[3] https://ebpf.io/</li> <li>[4] What is eBPF: https://ebpf.io/what-is-ebpf</li> <li>[5] Offensive BPF: Understanding and using bpf_probe_write_user https://embracethered.com/blog/posts/2021/offensive-bpf-libbpf-bpf_ probe_write_user/</li> <li>[6] Cloud Native Security Attack and Defense\uff5cAnalysis and practice of escape container technology using eBPF: https://security.tencent.com/index.php/blog/msg/206</li> <li>[7] kernel-versions.md: https://github.com/iovisor/bcc/blob/master/docs/kernel-versions.md</li> <li>[8] WebAssembly: Docker without containers: https://zhuanlan.zhihu.com/p/595257541</li> <li>[9] Introduction to WebAssembly, a tool for scalability in cloud-native projects https://mp.weixin.qq.com/s/fap0bl6GFGi8zN5BFLpkCw</li> <li>[10] WASI-eBPF: https://github.com/WebAssembly/WASI/issues/513</li> <li>[11] BPF BTF Explained: https://www.ebpf.top/post/kernel_btf/</li> <li>[12] BPF portability and CO-RE (compile once, run everywhere): https://cloud.tencent.com/developer/article/1802154</li> </ul>"},{"location":"ecc/","title":"eunomia-cc: compile and package ebpf programs","text":"<ul> <li>A toolchain to simplify <code>writing</code> eBPF programs:</li> <li>simplify building CO-RE[^1] <code>libbpf</code> eBPF applications: write eBPF kernel code only and automatically exposing your data with <code>perf event</code> or <code>ring buffer</code> from kernel.</li> <li>Automatically sample the data from hash maps and print <code>hists</code> in userspace.</li> <li>Automatically generate and config <code>command line arguments</code> for eBPF programs.</li> <li>You can writing the kernel part in both <code>BCC</code> and <code>libbpf</code> styles.</li> <li>Build eBPF programs with <code>Wasm</code>[^2]: see <code>Wasm-bpf</code> project</li> <li>Runtime, libraries and toolchains to write eBPF with Wasm in C/C++, Rust, Go...covering the use cases from <code>tracing</code>, <code>networking</code>, <code>security</code>.</li> </ul>"},{"location":"ecc/config-lua-depreciate.zh/","title":"lua config","text":"<p>\u7c7b\u4f3c\u4e8e xmake \u548c https://github.com/iovisor/bcc/tree/master/examples/lua \u7684\u8bbe\u8ba1\uff0c\u6211\u4eec\u6253\u7b97\u4f7f\u7528 lua \u6765\u5e2e\u52a9\u8fdb\u884c\u7528\u6237\u6001\u4e00\u4e9b\u53ef\u9009\u4fe1\u606f\u7684\u914d\u7f6e\uff0c\u4f8b\u5982\uff1a</p> <ul> <li>\u5c06\u591a\u4e2a eBPF \u7a0b\u5e8f\u6253\u5305\u6210\u4e00\u4e2a package\uff1b</li> <li>\u4fee\u6539\u5185\u6838\u6001\u4e0a\u62a5\u7684\u4fe1\u606f\uff1b</li> <li>\u63a7\u5236 eBPF \u7a0b\u5e8f\u7684\u8fd0\u884c\uff1b</li> </ul> <p>\u4f8b\u5982\uff1a</p> <pre><code>target(\"ebpf_program1\") -- basic\nadd_files(\"src/opensnoop.bpf.c\")\ntarget(\"ebpf_program1\")\nset_kind(\"uprobe\")\nattach_to(\"handler_entry_uprobe\", \"lua_pcall\") -- attach to lua_pcall in uprobe\non_event(function (event)\nsort(event)\nos.print(\"uprobe event: \", event)\nstop(\"ebpf_program1\")\nend)\nadd_files(\"src/uprobe.bpf.c\")\nentry(function (arg)   -- replace the default entry with\nif arg == \"uprobe\" then\nrun(\"ebpf_program1\")\nsleep(1000)\nrun(\"ebpf_program2\")\nelse\nrun(\"ebpf_program1\")\nend\nend)\n</code></pre> <p>\u5728 lua \u7528\u6237\u6001\u914d\u7f6e\u4e2d\u7f16\u5199\u7684\u4fe1\u606f\u5e94\u5c3d\u53ef\u80fd\u7b80\u5355\u3002</p> <p>\u8fd9\u90e8\u5206\u8fd8\u672a\u5b8c\u6210\uff0c\u76ee\u524d\u6b63\u5728\u52a0\u7d27\u8d76\u5de5</p>"},{"location":"ecc/docker-usage/","title":"use with docker","text":"<p>title: docker usage tags: [ docker, eunomia-bpf ]</p>"},{"location":"ecc/docker-usage/#docker-usage","title":"docker usage","text":"<p>The only file you will need to write is:</p> <pre><code>your_program.bpf.c\nyour_program.h  # optional, if you want to use ring buffer to export events\n</code></pre> <p>after that, simply run this:</p> <pre><code>$ docker run -it -v /path/to/repo/:/src ghcr.io/eunomia-bpf/ecc-`uname -m`:latest # use absolute path\n</code></pre> <p>you will get a <code>package.json</code> in your root dir. Just run:</p> <pre><code>$ sudo ./ecli run package.json\n</code></pre> <p>to start it you can download <code>ecli</code> tool from eunomia-bpf/releases, we have pre-build binaries for linux x86. Small and No dependencies, besides glibc and glibcxx. Or just run this:</p> <pre><code>$ wget https://aka.pw/bpf-ecli -O ecli &amp;&amp; chmod +x ecli\n</code></pre> <p>The eBPF compiled code can run on different kernel versions(CO-RE). see: github.com/eunomia-bpf/eunomia-bpf for details.</p>"},{"location":"ecc/docker-usage/#container-image","title":"container image","text":"<p>simply run:</p> <pre><code>$ docker run -it -v /path/to/repo:/src ghcr.io/eunomia-bpf/ecc-`uname -m`\n</code></pre> <p>Or you can do that without a container, which is listed below:</p>"},{"location":"ecc/docker-usage/#github-actions","title":"Github actions","text":"<p>Use this as a github action, to compile online: see eunomia-bpf/ebpm-template). Only three steps</p> <ol> <li>use this repo as a github template: see creating-a-repository-from-a-template</li> <li>modify the <code>bootstrap.bpf.c</code>, commit it and wait for the workflow to stop</li> <li>Run the <code>ecli</code> with remote url:</li> </ol> <pre><code>$ sudo ./ecli run https://eunomia-bpf.github.io/ebpm-template/package.json\n</code></pre>"},{"location":"ecc/docker-usage/#notifications","title":"Notifications","text":"<ol> <li>We use the same c ebpf code as libbpf, so most libbpf ebpf c code can run without any modification.</li> <li>Supported ebpf program types: <code>kprobe</code>, <code>tracepoint</code>, <code>fentry</code>, we will add more types in the future.</li> <li> <p>If you want to use ring buffer to export events, you need to add <code>your_program.h</code> to your repo, and    define the export data type in it, the export data type should be a C <code>struct</code>, for example:</p> <pre><code>struct process_event {\nint pid;\nint ppid;\nunsigned exit_code;\nunsigned long long duration_ns;\nchar comm[TASK_COMM_LEN];\nchar filename[MAX_FILENAME_LEN];\nint exit_event;\n};\n</code></pre> <p>The name and field types are not limited, but we will prefer use standard C types. If multiple struct exists in the header, we will use the first one. The feature is only enabled if we found a <code>BPF_MAP_TYPE_RINGBUF</code> map exists in the ebpf program.</p> </li> </ol>"},{"location":"ecc/github-template/","title":"Github Action \u6a21\u677f","text":"<p>ebpm-template\uff1a\u4f7f\u7528 Github Action \u8fdb\u884c\u8fdc\u7a0b\u7f16\u8bd1\uff0c\u672c\u5730\u4e00\u952e\u8fd0\u884c\uff1b</p> <p>\u8bf7\u53c2\u8003\uff1ahttps://github.com/eunomia-bpf/ebpm-template</p>"},{"location":"ecc/github-template/#a-template-for-eunomia-bpf-programs","title":"A template for eunomia-bpf programs","text":"<p>This is a template for eunomia-bpf eBPF programs. You can use t as a template, compile it online with <code>Github Actions</code> or offline.</p>"},{"location":"ecc/github-template/#compile-and-run-the-ebpf-code-as-simple-as-possible","title":"Compile and run the eBPF code as simple as possible!","text":"<p>Download the pre-compiled <code>ecli</code> binary from here: eunomia-bpf/eunomia-bpf</p> <p>To install, just download and use the <code>ecli</code> binary from here: eunomia-bpf/eunomia-bpf:</p> <pre><code>wget https://aka.pw/bpf-ecli -O ecli &amp;&amp; chmod +x ecli\n</code></pre>"},{"location":"ecc/github-template/#use-this-repo-as-a-github-action-to-compile-online","title":"use this repo as a github action to compile online","text":"<ol> <li>use this repo as a github template: see creating-a-repository-from-a-template</li> <li>modify the <code>bootstrap.bpf.c</code>, commit it and wait for the workflow to stop</li> <li>Run the <code>ecli</code> with remote url:</li> </ol> <pre><code>$ sudo ./ecli run https://eunomia-bpf.github.io/ebpm-template/package.json\n</code></pre>"},{"location":"ecc/github-template/#quick-start","title":"quick start","text":"<p>just write some code in the <code>bootstrap.bpf.c</code>, after that, simply run this:</p> <pre><code>$ docker run -it -v /path/to/repo:/src ghcr.io/eunomia-bpf/ecc-`uname -m`:latest # use absolute path\n</code></pre> <p>you will get a <code>package.json</code> in your root dir. Just run:</p> <pre><code>$ sudo ./ecli run package.json\n</code></pre> <p>The ebpf compiled code can run on different kernel versions(CO-RE). You can just copied the json to another machine. see: github.com/eunomia-bpf/eunomia-bpf for the runtime, and eunomia-bpf/eunomia-cc for our compiler tool chains.</p>"},{"location":"ecc/github-template/#the-code-here","title":"The code here","text":"<p>This is an example of ebpf code, we copied the bootstrap.bpf.c from libbpf-bootstrap, without any modification. You can read their <code>README</code> for details: https://github.com/libbpf/libbpf-bootstrap</p>"},{"location":"ecc/github-template/#more-examples","title":"more examples","text":"<p>for more examples, please see: eunomia-bpf/eunomia-bpf/tree/master/examples/bpftools</p>"},{"location":"ecc/usage/","title":"usage","text":"<p>title: ecc usage tags: [ecc, maunal]</p>"},{"location":"ecc/usage/#usage","title":"Usage","text":"<pre><code>ecc [OPTIONS] &lt;SOURCE_PATH&gt; [EXPORT_EVENT_HEADER]\n</code></pre> <p>Compiles and generates a bpf object from the provided SOURCE_PATH path for the specified eBPF program.</p>"},{"location":"ecc/usage/#example","title":"example","text":""},{"location":"ecc/usage/#packagejson-only","title":"package.json only","text":"<pre><code>ecc foo.bpf.c\n</code></pre>"},{"location":"ecc/usage/#source-file-and-a-header-file","title":"Source file and a header file","text":"<pre><code>ecc foo.bpf.c bar.h\n</code></pre>"},{"location":"ecc/usage/#generate-custom-btfhub-archive-and-package-into-tar","title":"Generate custom btfhub-archive and package into tar","text":"<pre><code>ecc -b client.bpf.c event.h\n</code></pre> <p>This command will compile client.bpf.c and event.h into client.bpf.o, and package them as json, export a tar containing a custom btf file.</p> <p>output in <code>OUTPUT_PATH</code>:</p> <pre><code>package.json\nclient.tar #include custom btf files\n</code></pre>"},{"location":"ecc/usage/#btfhub-support","title":"btfhub Support","text":"<p>BTF is the things that make eBPF portable.</p> <p><code>btfhub</code> provide BTF information for Linux distributions released kernels that don't have embedded BTF information.</p> <p>By using btfhub to package ebpf programs as tar file, ecc makes it possible to run ebpf programs on older kernels that do not have btf support.</p> <p>A list of existing distributions and their current status on eBPF and BTF support.</p>"},{"location":"ecc/usage/#arguments-and-options","title":"Arguments and options","text":""},{"location":"ecc/usage/#arguments","title":"Arguments","text":"<ul> <li> <p><code>SOURCE_PATH</code>: path of the bpf.c file to compile</p> </li> <li> <p><code>EXPORT_EVENT_HEADER</code>: path of the bpf.h header for defining event struct</p> </li> </ul>"},{"location":"ecc/usage/#options","title":"Options","text":"<ul> <li>-o, --output-path <code>OUTPUT_PATH</code>: path of output bpf object</li> <li>-w, --workspace-path <code>WORKSPACE_PATH</code>: specify custom workspace path</li> <li>-a, --additional-cflags <code>ADDITIONAL_CFLAGS</code>: additional cflags for clang</li> <li>example <code>-a=\"-fstack-protector\"</code>,   this avoids runtime errors on some distributions that have clang stack protection enabled by default.</li> <li>-c, --clang-bin <code>CLANG_BIN</code>: path of clang binary (default: clang)</li> <li>-l, --llvm-strip-bin <code>LLVM_STRIP_BIN</code>: path of llvm-strip binary (default: llvm-strip)</li> <li>-s, --subskeleton: do not pack bpf object in config file</li> <li>-v, --verbose: print the command execution</li> <li>-y, --yaml: output config skel file in yaml</li> <li>--header-only: generate a bpf object for struct definition in header file only</li> <li>--wasm-header: generate wasm include header</li> <li>-b, --btfgen: fetch custom btfhub archive file and package into tar</li> <li>If <code>BTFHUB_ARCHIVE</code> does not exist, it will clone   btfhub to <code>BTFHUB_ARCHIVE</code>.</li> <li>This option will take a lot of time, if you don't want to package or generate all custom btf files,   you can keep only the required btf files in <code>BTFHUB_ARCHIVE</code>.</li> <li>Don't worry, even the tar containing all the btfhub archives is only <code>5-10MB</code> in size.</li> <li>--btfhub-archive <code>BTFHUB_ARCHIVE</code>: directory to save btfhub archive file (default:<code>$HOME/.eunomia/btfhub-archive</code>)</li> <li>-h, --help: prints help documentation.</li> <li>-V, --version: prints version information.</li> </ul>"},{"location":"ecli/","title":"ecli: run ebpf programs as json or wasm","text":""},{"location":"ecli/#usage","title":"Usage","text":"<pre><code>sudo ecli &lt;COMMAND&gt;\n</code></pre>"},{"location":"ecli/#example","title":"example","text":"<p>Run the ebpf program as wasm or json.</p> <pre><code># run with wasm bpf modules\nsudo ecli run runqlat.wasm\n# run with json bpf object only\nsudo ecli run package.json\n</code></pre> <p>Or run the ebpf program as a tar file contains minimal BTF info and bpf object.</p> <pre><code>sudo ecli run client.tar\n</code></pre> <p>The ecc packaged tar contains custom btf files and <code>package.json</code>, which can be run on older kernels.</p> <p>For details, see ecc-btfgen</p>"},{"location":"ecli/#commands","title":"Commands","text":"<ul> <li>run - Run the ebpf program as tar or json.</li> <li>push - Push a container to an OCI registry.</li> <li>pull - Pull a container from an OCI registry.</li> <li>login - Login to an OCI registry.     <code>ecli</code> will check gh cache and <code>GITHUB_TOKEN</code>     env when you login to ghcr.io, either one can be logged into ghcr without entering a token.</li> <li>logout - Logout from an OCI registry.     <code>ecli logout xxx</code> will remove identity certificates stored under <code>~/.eunomia</code>.</li> </ul>"},{"location":"ecli/ecli-dockerfile-usage.zh/","title":"ecli dockerfile usage","text":"<p>bpf \u8fd0\u884c\u65f6\u9700\u8981\u6709Linux\u5185\u6838\u76f8\u5173\u652f\u6301\uff0cdocker \u4e2d\u7684\u5185\u6838\u5171\u4eab\u7684\u5bbf\u4e3b\u673a\u7684\u5185\u6838\uff0c\u56e0\u6b64\u4f7f\u7528docker\u8fd0\u884cbpf\u7a0b\u5e8f\u65f6\u9700\u8981\u4f7f\u7528\u4ee5\u4e0b\u547d\u4ee4\u4e3a\u5bb9\u5668\u8d4b\u4e88\u6743\u9650\u548c\u76f8\u5173\u5185\u6838\u652f\u6301\u3002</p> <p>\u6b64\u5904\u53c2\u8003https://github.com/iovisor/bpftrace/blob/master/INSTALL.md#kernel-headers-install</p> <pre><code>$ docker run -ti -v /usr/src:/usr/src:ro \\\n-v /lib/modules/:/lib/modules:ro \\\n-v /sys/kernel/debug/:/sys/kernel/debug:rw \\\n-v /home/admin/my:/root/my \\ //\u6302\u8f7d\u672c\u673a\u76ee\u5f55\u5230\u5bb9\u5668\u7684/root/my\u8def\u5f84\u4e0b\n       --net=host --pid=host --privileged \\\necli:1.0.1\n</code></pre>"},{"location":"ecli/ecli-dockerfile-usage.zh/#dockerfile-ubuntu","title":"dockerfile ubuntu","text":"<p>dockerfile\u7684\u57fa\u7840\u955c\u50cf\u662fUbuntu\uff0c\u56fd\u5185\u4f7f\u7528\u65f6\u56e0\u4e3a\u6709\u5899\u7684\u5b58\u5728\uff0c\u6240\u4ee5\u9700\u8981\u5bf9Linux\u8fdb\u884c\u6362\u6e90\u3002sources.list\u5982\u4e0b\uff1a</p> <pre><code>deb http://mirrors.aliyun.com/ubuntu/ jammy main restricted universe multiverse\n#deb-src http://mirrors.aliyun.com/ubuntu/ jammy main restricted universe multiverse\ndeb http://mirrors.aliyun.com/ubuntu/ jammy-security main restricted universe multiverse\n#deb-src http://mirrors.aliyun.com/ubuntu/ jammy-security main restricted universe multiverse\ndeb http://mirrors.aliyun.com/ubuntu/ jammy-updates main restricted universe multiverse\n#deb-src http://mirrors.aliyun.com/ubuntu/ jammy-updates main restricted universe multiverse\ndeb http://mirrors.aliyun.com/ubuntu/ jammy-proposed main restricted universe multiverse\n#deb-src http://mirrors.aliyun.com/ubuntu/ jammy-proposed main restricted universe multiverse\ndeb http://mirrors.aliyun.com/ubuntu/ jammy-backports main restricted universe multiverse\n#deb-src http://mirrors.aliyun.com/ubuntu/ jammy-backports main restricted universe multiverse\n</code></pre> <p>dockerfile\u4e2d\u7684\u5177\u4f53\u5185\u5bb9\u5982\u4e0b</p> <pre><code>FROM ubuntu:latest\n\nENV UBUNTU_SOURCE /etc/apt\n\nCOPY ./ /root\n\nWORKDIR /root\n\nADD sources.list $UBUNTU_SOURCE/\n\nRUN apt-get update &amp;&amp; \\\napt-get -y install gcc libelf-dev\n\n#CMD ./ecli run /root/my/package.json\nCMD [\"/bin/bash\"]\n</code></pre> <p>ubuntu.dockerfile\u6784\u5efa\u65f6\uff0c\u540c\u4e00\u7ea7\u76ee\u5f55\u4e0b\u7684\u6587\u4ef6\u5982\u4e0b</p> <p></p> <p>ecli\u53ef\u6267\u884c\u6587\u4ef6  sources.list Dockerfile\u8fd9\u4e09\u4e2a\u6587\u4ef6\u7f3a\u4e00\u4e0d\u53ef\uff0cother\u6587\u4ef6\u53ef\u5ffd\u7565\u3002docker\u5bb9\u5668\u4e2dwget\u65e0\u6cd5\u8fde\u63a5\u5916\u90e8\u7f51\u7edc\uff0c\u56e0\u6b64\u9700\u8981\u5728docker\u6784\u5efa\u65f6\u5c06ecli\u653e\u5165\u955c\u50cf\u4e2d\u3002\u4f7f\u7528\u955c\u50cf\u65f6\u53ea\u8981\u6302\u8f7d\u7684\u672c\u673a\u76ee\u5f55\u4e2d\u6709package.json\u6587\u4ef6\u5373\u53ef\u3002</p>"},{"location":"ecli/ecli-dockerfile-usage.zh/#docker-alpine","title":"docker alpine","text":"<pre><code>FROM alpine:latest\n\nCOPY ./ /root\n\nWORKDIR /root\n\nRUN sed -i 's/dl-cdn.alpinelinux.org/mirrors.aliyun.com/g' /etc/apk/repositories &amp;&amp; \\\napk update &amp;&amp; \\\napk install gcc libelf gcompat\n\n#CMD ./ecli run /root/my/package.json\n</code></pre> <p>alpine.dockerfile\u6784\u5efa\u955c\u50cf\u65f6\uff0c\u540c\u4e00\u7ea7\u76ee\u5f55\u4e0b\u5fc5\u987b\u6709ecli\u53ef\u6267\u884c\u6587\u4ef6\u3002 \u76ee\u524dalpine.dockerfile\u4ecd\u5b58\u5728\u4ee5\u4e0b\u95ee\u9898</p> <p></p>"},{"location":"ecli/ecli-dockerfile-usage.zh/#docker-build","title":"docker build","text":"<p>dockerfile\u6784\u5efa\u65f6\u4f7f\u7528\u5982\u4e0b\u547d\u4ee4</p> <pre><code>sudo docker build -t ecli:1.0.1 .\n</code></pre>"},{"location":"ecli/ecli-dockerfile-usage.zh/#_1","title":"\u53c2\u8003\u6587\u6863","text":"<p>bpftrace \u5b98\u65b9\u8bf4\u660e\uff08\u5982\u4f55\u8ba9bpf\u7a0b\u5e8f\u5728docker\u4e2d\u8fd0\u884c\uff09</p> <p>https://github.com/iovisor/bpftrace/blob/master/INSTALL.md#kernel-headers-install</p> <p>\u5982\u4f55\u5728mac\u4e2d\u8fd0\u884c\u5e26\u6709bpf\u8fd0\u884c\u73af\u5883\u7684docker</p> <p>https://petermalmgren.com/docker-mac-bpf-perf/</p>"},{"location":"ecli/server/","title":"ecli server","text":"<p>You can use server to manager and dynamically install eBPF programs.</p>"},{"location":"ecli/server/#install","title":"install","text":"<p>For example, on Ubuntu:</p> <pre><code># download the preview build server\nwget https://github.com/eunomia-bpf/eunomia-bpf/releases/latest/download/ecli-server-ubuntu-latest.tar.gz\ntar -xzf ecli-server-ubuntu-latest.tar.gz &amp;&amp; chmod +x ./ecli-server\n# download the ecli\nwget https://aka.pw/bpf-ecli -O ecli &amp;&amp; chmod +x ./ecli\n</code></pre>"},{"location":"ecli/server/#usage","title":"usage","text":"<p>start the server:</p> <pre><code>$ sudo ./ecli-server\n[2023-08-08 02:02:03.864009 +08:00] INFO [server/src/main.rs:95] Serving at 127.0.0.1:8527\n</code></pre> <p>use the ecli to control the remote server and manage multiple eBPF programs:</p> <pre><code>$ ./ecli client --help\nClient operations\nUsage: ecli client [OPTIONS] &lt;COMMAND&gt;\nCommands:\n  start   Start an ebpf program on the specified endpoint\n  stop    Stop running a task on the specified endpoint\n  log     Fetch logs of the given task\n  pause   Pause the task\n  resume  Resume the task\n  list    List tasks on the server\n  help    Print this message or the help of the given subcommand(s)\nOptions:\n  -e, --endpoint &lt;ENDPOINT&gt;  API endpoint [default: http://127.0.0.1:8527]\n  -h, --help                 Print help\n# you can download sigsnoop.json from https://eunomia-bpf.github.io/eunomia-bpf/sigsnoop/package.json\n$ ./ecli client start sigsnoop.json # start the program\n1\n$ ./ecli client log 1 # get the log of the program\nTIME     PID    TPID   SIG    RET    COMM   \n02:05:58  79725 78132  17     0      bash\n02:05:59  77325 77297  0      0      node\n02:05:59  77297 8042   0      0      node\n02:05:59  77297 8042   0      0      node\n02:05:59  79727 79726  17     0      which\n02:05:59  79726 8084   17     0      sh\n02:05:59  79731 79730  17     0      which\n$ ./ecli client start sigsnoop.json # start another program\n2\n$ ./ecli client list # list all running programs\n1 bpf-program-1691431558 Running\n2 bpf-program-1691431757 Running\n$ ./ecli client stop 1 # stop the program 1\n$ ./ecli client list\n2 bpf-program-1691431757 Running\n$ ./ecli client stop 2 # stop the program 2\n$ ./ecli client list # no program is running\n</code></pre>"},{"location":"ecli/server/#api-document","title":"API document","text":"<p>For the http api, please refer to openapi.yaml.</p> <p>You can also use curl to access the ecli server, for example:</p> <pre><code>$ curl http://127.0.0.1:8527/task # list all running tasks\n{\"tasks\":[{\"status\":\"running\",\"id\":3,\"name\":\"bpf-program-1691432359\"}]}\n$ curl -X POST   -H \"Content-Type: application/json\"   -d '{\n    \"id\": 3,\n    \"log_cursor\": 0,\n    \"maximum_count\": 100\n  }'  http://127.0.0.1:8527/log # get the log of the task 3\n[{\"cursor\":0,\"log\":{\"log\":\"TIME     PID    TPID   SIG    RET    COMM   \",\"timestamp\":1691432359,\"log_type\":\"plain\"}},{\"cursor\":1,\"log\":{\"log\":\"02:19:19  81241 \n....\n,{\"cursor\":99,\"log\":{\"log\":\"02:19:28  80808 77297  0      0      node\",\"timestamp\":1691432368,\"log_type\":\"plain\"}}]\n</code></pre>"},{"location":"exporter/","title":"eunomia-exporter","text":"<p>An prometheus and OpenTelemetry exporter for custom eBPF metrics, written in async rust: eunomia-exporter</p> <p>This is a single binary exporter, you don't need to install <code>BCC/LLVM</code> when you use it. The only thing you will need to run the exporter on another machine is the config file and pre-compiled eBPF code.</p>"},{"location":"exporter/#supported-scenarios","title":"Supported scenarios","text":"<p>Currently the only supported way of getting data out of the kernel is via maps (we call them tables in configuration).</p>"},{"location":"exporter/usage/","title":"usage","text":""},{"location":"exporter/usage/#example","title":"example","text":"<p>This is an adapted version of opensnoop from bcc/libbpf-tools, you can check our source code here: examples/bpftools/opensnoop</p> <p>You can just download the pre-compiled opensnoop package.json.</p> <p>Or you can compile the opensnoop like this:</p> <pre><code>$ cd examples/bpftools/opensnoop\n$ docker run -it -v /userpath/eunomia-bpf/examples/bpftools/opensnoop:/src ghcr.io/eunomia-bpf/ecc-`uname -m`:latest\n</code></pre> <p><code>userpath</code> needs to be replaced with your own repo path.</p> <p>After compile the eBPF code, you can define a config file like this:</p> <pre><code>programs:\n  - name: opensnoop\n    metrics:\n      counters:\n        - name: eunomia_file_open_counter\n          description: test\n          labels:\n            - name: pid\n            - name: comm\n            - name: filename\n              from: fname\n    compiled_ebpf_filename: package.json\n</code></pre> <p>use the path to <code>package.json</code> as compiled_ebpf_filename in the config file. You can find the example at config.yaml.</p> <p>Then, you can start the exporter:</p> <pre><code>$ ls\nconfig.yaml  eunomia-exporter package.json\n$ sudo ./eunomia-exporter\n\nRunning ebpf program opensnoop takes 46 ms\nListening on http://127.0.0.1:8526\nrunning and waiting for the ebpf events from perf event...\nReceiving request at path /metrics\n</code></pre> <p>Different from the bcc ebpf_exporter, the only thing you need to run on the deployment machine is the <code>config file</code> and <code>package.json</code>. There is no need to install <code>LLVM/CLang</code> for BCC.</p> <p>The result is:</p> <p></p>"},{"location":"exporter/usage/#manage-ebpf-tracing-program-via-api","title":"manage eBPF tracing program via API","text":"<p>start an eBPF exporter via web API:</p> <pre><code>$ curl -X POST http://127.0.0.1:8526/start -H \"Content-Type: application/json\" -d @examples/opensnoop/curl_post_example.json\n\n{\"id\":1}\n</code></pre> <p>see curl_post_example.json for the example of the request body.</p> <p>list all running eBPF programs:</p> <pre><code>$ curl http://127.0.0.1:8526/list\n\n[{\"id\":0,\"name\":\"bootstrap\"},{\"id\":1,\"name\":\"opensnoop\"}]\n</code></pre> <p>stop an eBPF program:</p> <pre><code>$ curl -X POST http://127.0.0.1:8526/stop -H \"Content-Type: application/json\" -d '{\"id\": 1}'\n</code></pre> <p>documents:</p> <pre><code>$ cargo build --release\n$ target/release/eunomia-exporter -h\neunomia-exporter 0.1.0\nUSAGE:\n    eunomia-exporter [OPTIONS]\nOPTIONS:\n    -c, --config &lt;CONFIG&gt;    Sets a custom config file [default: config.yaml]\n    -h, --help               Print help information\n    -V, --version            Print version information\n</code></pre>"},{"location":"miscellaneous/SUMMARY/","title":"Summary","text":"<ul> <li>Introduction</li> <li>Detail introduction</li> <li>Wasm-bpf subproject</li> </ul>"},{"location":"miscellaneous/SUMMARY/#user-manual","title":"User Manual","text":"<ul> <li>Quick Start</li> <li>Installation</li> <li>Build</li> <li>Build on Android or ARM</li> <li>ecc</li> <li>usage</li> <li>docker</li> <li>template</li> <li>lua</li> <li>ecli</li> <li>docker</li> <li>Docker manual</li> <li>Manual (Chinese)</li> <li>Online Demo</li> <li>Common problems</li> <li>External BTF support</li> <li>Benchmark</li> </ul>"},{"location":"miscellaneous/SUMMARY/#videos","title":"Videos","text":"<ul> <li>Public talk video</li> </ul>"},{"location":"miscellaneous/SUMMARY/#blogs","title":"Blogs","text":"<ul> <li>Blogs (Chinese)</li> <li>Wasm-bpf: \u67b6\u8d77 Webassembly \u548c eBPF \u5185\u6838\u53ef\u7f16\u7a0b\u7684\u6865\u6881</li> <li>\u5728 WebAssembly \u4e2d\u4f7f\u7528 C/C++ \u548c libbpf \u7f16\u5199 eBPF \u7a0b\u5e8f</li> <li>\u5728 WebAssembly \u4e2d\u4f7f\u7528 Rust \u7f16\u5199 eBPF \u7a0b\u5e8f\u5e76\u53d1\u5e03 OCI \u955c\u50cf</li> <li>\u4f7f\u7528 ChatGPT \uff0c\u901a\u8fc7\u81ea\u7136\u8bed\u8a00\u7f16\u5199 eBPF \u7a0b\u5e8f\u548c\u8ffd\u8e2a Linux \u7cfb\u7edf</li> <li>\u5f53 Wasm \u9047\u89c1 eBPF \uff1a\u4f7f\u7528 WebAssembly \u7f16\u5199\u3001\u5206\u53d1\u3001\u52a0\u8f7d\u8fd0\u884c eBPF \u7a0b\u5e8f</li> <li>\u5982\u4f55\u5728 Linux \u663e\u5fae\u955c\uff08LMP\uff09\u9879\u76ee\u4e2d\u5f00\u542f eBPF \u4e4b\u65c5</li> <li>eunomia-bpf 0.3.0 \u53d1\u5e03\uff1a\u53ea\u9700\u7f16\u5199\u5185\u6838\u6001\u4ee3\u7801\uff0c\u8f7b\u677e\u6784\u5efa\u3001\u6253\u5305\u3001\u53d1\u5e03\u5b8c\u6574\u7684 eBPF \u5e94\u7528</li> <li>eunomia-bpf\uff1a\u5c55\u671b 2023\uff0c\u8ba9 eBPF \u63d2\u4e0a Wasm \u7684\u7fc5\u8180</li> <li>eBPF \u8fdb\u9636: \u5185\u6838\u65b0\u7279\u6027\u8fdb\u5c55\u4e00\u89c8</li> <li>ecli \u5728\u5b89\u5353 13 \u4e0a\u7684\u8fd0\u884c\u6d4b\u8bd5</li> </ul>"},{"location":"miscellaneous/benchmark/","title":"benchmark","text":"<p>Most of the time, bpf-loader work as a library to load eBPF program. It will not affect eBPF program after the program has been loaded and attached.</p> <p>TODO: add more benchmark results</p>"},{"location":"miscellaneous/benchmark/#benchmark-for-loading-with-exporter","title":"benchmark for loading with exporter","text":"<p>Take opensnoop from bcc/libbpf-tools as an example. starting with BCC, you will need about 0.8s to start the exporter and attach to the probe. With out implement, you only need about <code>50-70ms</code> which is significantly faster.</p> <pre><code>$ ps -aux | grep eunomia\nroot      171562  0.0  0.0  15176  4576 pts/6    S+   01:08   0:00 sudo ./eunomia-exporter\nroot      171605  0.1  0.0 350540  7740 pts/6    Sl+  01:08   0:00 ./eunomia-exporter\n</code></pre> <p>The memory usage and CPU usage is also low. see eunomia-exporter for more details.</p>"},{"location":"miscellaneous/common_problems/","title":"common problem","text":"<p>if you get a error like <code>/usr/lib/x86_64-linux-gnu/libstdc++.so.6: version GLIBCXX_3.4.29 not found</code> on old version kernels,</p> <p>try:</p> <pre><code>sudo apt-get upgrade libstdc++6\n</code></pre> <p>see https://stackoverflow.com/questions/65349875/where-can-i-find-glibcxx-3-4-29</p>"},{"location":"miscellaneous/introduction/","title":"introduction","text":"<p><code>eunomia-bpf</code> is a dynamic loading library/runtime and a compile toolchain framework, aim at helping you build and distribute eBPF programs easier.</p>"},{"location":"miscellaneous/introduction/#simplify-building-co-re-libbpf-ebpf-applications","title":"Simplify building CO-RE libbpf eBPF applications","text":"<p>Just Write libbpf eBPF kernel code only, auto config the userspace part!</p>"},{"location":"miscellaneous/introduction/#automatically-exposing-your-data-from-kernel","title":"Automatically exposing your data from kernel","text":"<ul> <li> <p>Get data automatically from <code>perf event</code> or <code>ring buffer</code> to userspace:</p> <pre><code>struct {\n__uint(type, BPF_MAP_TYPE_RINGBUF);\n__uint(max_entries, 256 * 1024);\n} rb SEC(\".maps\");\nSEC(\"tp/sched/sched_process_exec\")\nint handle_exec(struct trace_event_raw_sched_process_exec *ctx)\n{\n....\ne = bpf_ringbuf_reserve(&amp;rb, sizeof(*e), 0);\n....\nbpf_ringbuf_submit(e, 0);\nreturn 0;\n}\n</code></pre> <p>Compile and Run the program:</p> <pre><code>$ ecc bootstrap.bpf.c bootstrap.h\nCompiling bpf object...\nGenerating export types...\nPacking ebpf object and config into package.json...\n$ sudo ./ecli examples/bpftools/bootstrap/package.json\nTIME     PID     PPID    EXIT_CODE  DURATION_NS  COMM    FILENAME  EXIT_EVENT\n22:01:04  46310  2915    0          0            sh      /bin/sh   0\n22:01:04  46311  46310   0          0            which   /usr/bin/which 0\n22:01:04  46311  46310   0          2823776      which             1\n22:01:04  46310  2915    0          6288891      sh                1\n22:01:04  46312  2915    0          0            sh      /bin/sh   0\n22:01:04  46313  46312   0          0            ps      /usr/bin/ps 0\n</code></pre> <p>see bootstrap for example. This is exactly the same as bootstrap.bpf.c in libbpf-bootstrap project, but only kernel code is needed.</p> </li> </ul>"},{"location":"miscellaneous/introduction/#automatically-sample-the-data-and-print-hists-in-userspace","title":"Automatically sample the data and print <code>hists</code> in userspace","text":"<ul> <li> <p>Sample the data from hash maps and print them in human readable format with comments:</p> <pre><code>/// @sample {\"interval\": 1000, \"type\" : \"log2_hist\"}\nstruct {\n__uint(type, BPF_MAP_TYPE_HASH);\n__uint(max_entries, MAX_ENTRIES);\n__type(key, u32);\n__type(value, struct hist);\n} hists SEC(\".maps\");\n</code></pre> <p>and Get <code>hist</code> data from <code>hists</code> map and print them in human readable format:</p> <pre><code>$ sudo ecli  examples/bpftools/runqlat/package.json --targ_per_process\nkey = 8326\ncomm = containerd\n\nusec              : count    distribution\n        0 -&gt; 1          : 0        |                                        |\n2 -&gt; 3          : 0        |                                        |\n4 -&gt; 7          : 0        |                                        |\n8 -&gt; 15         : 0        |                                        |\n16 -&gt; 31         : 2        |*************                           |\n32 -&gt; 63         : 2        |*************                           |\n64 -&gt; 127        : 6        |****************************************|\n128 -&gt; 255        : 0        |                                        |\n256 -&gt; 511        : 2        |*************                           |\n</code></pre> <p>see examples/bpftools/mdflush.bpf.c for example.</p> </li> </ul>"},{"location":"miscellaneous/introduction/#automatically-generate-and-config-command-line-arguments","title":"Automatically generate and config command line arguments","text":"<ul> <li> <p>Automatically generate and config command line arguments for your eBPF program from the comments in your kernel code:</p> <pre><code>/// Process ID to trace\nconst volatile pid_t pid_target = 0;\n/// Thread ID to trace\nconst volatile pid_t tgid_target = 0;\n/// @description User ID to trace\nconst volatile uid_t uid_target = 0;\n/// @cmdarg {\"default\": false, \"short\": \"f\", \"long\": \"failed\"}\n/// @description target pid to trace\nconst volatile bool targ_failed = false;\n</code></pre> <p>and Get:</p> <pre><code>$ sudo ecli  examples/bpftools/opensnoop/package.json -h\nUsage: opensnoop_bpf [--help] [--version] [--verbose] [--pid_target VAR] [--tgid_target VAR] [--uid_target VAR] [--failed]\nTrace open family syscalls.\nOptional arguments:\n  -h, --help    shows help message and exits\n  -v, --version prints version information and exits\n  --verbose     prints libbpf debug information\n  --pid_target  Process ID to trace\n  --tgid_target Thread ID to trace\n</code></pre> <p>see examples/bpftools/opensnoop/opensnoop.bpf.c for example.</p> </li> <li> <p><code>100%</code> compatible with <code>libbpf</code>, libbpf-bootstrap and <code>libbpf-rs</code>, etc: you can compile libbpf-tools kernel code with <code>eunomia-bpf</code> and run them without many modification!</p> </li> <li>Not limited to tracing: support <code>tracepoints</code>, <code>kprobe</code>, <code>uprobe</code>, <code>lsm</code>, <code>xdp</code>, <code>tc</code> etc...</li> </ul>"},{"location":"miscellaneous/introduction/#compile-and-pack-co-re-ebpf-kernel-code-to-a-config-file","title":"Compile and pack CO-RE eBPF kernel code to a config file","text":"<ul> <li> <p>Compile and pack CO-RE eBPF kernel code to a <code>JSON</code> or <code>YAML</code> config file:</p> <pre><code>$ ecc cmd/test/opensnoop.bpf.c opensnoop.h\nCompiling bpf object...\nGenerating export types...\nPacking ebpf object and config into package.json...\n$ docker run -it -v `pwd`/:/src/ ghcr.io/eunomia-bpf/ecc-`uname -m`:latest # build with docker for x86_64 and aarch64\nPacking ebpf object and config into package.json...\n</code></pre> <p>You can modify the config file and config the eBPF program behavior to your need.</p> </li> </ul>"},{"location":"miscellaneous/introduction/#dynamic-load-and-run-co-re-ebpf-kernel-code-from-the-cloud-with-url-or-oci-image","title":"Dynamic load and run CO-RE eBPF kernel code from the cloud with URL or OCI image","text":"<ul> <li> <p>you can dynamically load it on different kernel version without recompile, and without clang/llvm dependency:</p> <pre><code>$ sudo ecli opensnoop.json\nTIME     PID     TPID    SIG     RET     COMM\n22:58:28  77121  3168    0       0       cpptools-srv\n22:58:29  69044  3168    0       0       cpptools-srv\n22:58:29  3014   2906    0       0       code\n22:58:29  6952   4061    0       0       node\n22:58:29  4061   3937    0       0       node\n22:58:29  75263  3168    0       0       cpptools-srv\n22:58:29  2906   2488    0       0       code\n22:58:29  69149  3168    0       0       cpptools-srv\n22:58:29  73541  3168    0       0       cpptools-srv\n22:58:29  73468  3168    0       0       cpptools-srv\n22:58:29  2906   2488    0       0       code\n22:58:29  69094  3168    0       0       cpptools-srv\n</code></pre> </li> <li> <p>Get pre-compiled eBPF programs running from the cloud to the kernel in <code>1</code> line of bash, kernel version and architecture independent:</p> <pre><code># download the release from https://github.com/eunomia-bpf/eunomia-bpf/releases/latest/download/ecli\n$ wget https://aka.pw/bpf-ecli -O ecli &amp;&amp; chmod +x ./ecli\n$ sudo ./ecli https://eunomia-bpf.github.io/eunomia-bpf/sigsnoop/package.json # simply run a pre-compiled ebpf code from a url\n$ sudo ./ecli sigsnoop:latest # run with a name and download the latest version bpf tool from our repo\n</code></pre> </li> <li> <p>very small and simple! The library itself <code>&lt;1MB</code> and no <code>LLVM/Clang</code> dependence, can be embedded easily in you project</p> </li> <li>as fast as <code>&lt;100ms</code> and little resource need to dynamically load and run eBPF program</li> </ul> <p>Base on <code>eunomia-bpf</code>, we have an eBPF pacakge manager in LMP project, with OCI images and ORAS for distribution.</p>"},{"location":"miscellaneous/introduction/#wasm-bpf-write-user-space-code-for-your-ebpf-program-in-webassembly","title":"wasm-bpf: Write user space code for your eBPF program in WebAssembly","text":"<p>see wasm-bpf project:</p> <p>A WebAssembly eBPF library, toolchain and runtime powered by CO-RE(Compile Once \u2013 Run Everywhere) libbpf and WAMR.</p> <ul> <li><code>General purpose</code>: provide most abilities from eBPF to Wasm, <code>polling</code> from the ring buffer or perf buffer, bidirectional communications between <code>kernel</code> eBPF and <code>userspace</code> Wasm using <code>maps</code>, dynamically <code>loading</code>, <code>attaching</code> or <code>detaching</code>, etc. Supports a large number of eBPF program types and map types, covering the use cases from <code>tracing</code>, <code>networking</code>, <code>security</code>.</li> <li><code>High performance</code>: No <code>serialization</code> overhead for complex data types, using <code>shared memory</code> to avoid copy overhead between host and Wasm.</li> <li><code>Easy to use</code>: provide a similar developing experience as the libbpf-bootstrap, <code>auto generate</code> the Wasm-eBPF skeleton headers and type definitions for bindings.</li> <li><code>Ultralightweight</code>: the sample runtime has only <code>300+</code> lines of code, binary only <code>1.5 MB</code> in size. Compiled Wasm module would be only <code>~90K</code>. With the same toolchain, you can easily build your own Wasm-eBPF runtime in any languages and platforms!</li> </ul>"},{"location":"miscellaneous/introduction/#project-architecture","title":"Project Architecture","text":"<p>we have a loader library, a compile toolchain, and some additional tools like cli and a custom metrics exporter.</p> <p></p>"},{"location":"miscellaneous/introduction/#an-bpf-loader-rs-library","title":"An bpf-loader-rs library","text":"<p>A wrapper of main functions of libbpf-rs, provide the ability to dynamically load eBPF code to the kernel and run it with a simple JSON and a few API.</p> <p>A simple cli interface is provided for bpf-loader library, which you can use it to start any eBPF program from a url in a command. You can download it from release.</p> <p>see examples for more examples.</p>"},{"location":"miscellaneous/introduction/#a-library-to-load-and-operate-ebpf-program-from-a-wasm-module","title":"A library to load and operate eBPF program from a WASM module","text":"<p>Use the <code>eunomia-bpf</code> library to load <code>eBPF</code> program from a <code>WASM</code> module, you can write a WASM module to operate the eBPF program or process the data in user space <code>WASM</code> runtime. The idea is simple:</p> <ol> <li>compile the kernel eBPF code skeleton to the <code>JSON</code> format with <code>eunomia-cc</code> toolchain</li> <li>embed the <code>JSON</code> data in the <code>WASM</code> module, and provide some API for operating the eBPF program skeleton</li> <li>load the <code>JSON</code> data from the <code>WASM</code> module and run the eBPF program skeleton with <code>eunomia-bpf</code> library</li> </ol> <p>You can have multiple <code>eBPF</code> program in a single <code>WASM</code> module.</p> <p>See wasm-runtime for details. In fact, <code>ewasm</code> library only exports a few functions from <code>bpf-loader</code> library to the <code>VM</code>, so you can replace the <code>WASM</code> runtime with your own easily.</p> <p>For example, you can run an eBPF program with a WASM module for an URL:</p> <pre><code>sudo ./ecli run https://eunomia-bpf.github.io/eunomia-bpf/sigsnoop/app.wasm\n</code></pre> <p>You can also generate a WASM program template for eBPF or build WASM module with <code>compiler</code> container:</p> <pre><code># for x86_64 and aarch64\ndocker run -it -v `pwd`/:/src/ ghcr.io/eunomia-bpf/ecc-`uname -m`:latest gen-wasm-skel # generate WASM app template for eBPF\ndocker run -it -v `pwd`/:/src/ ghcr.io/eunomia-bpf/ecc-`uname -m`:latest build-wasm    # Build WASM module\n</code></pre> <p>see sigsnoop example for more detail.</p>"},{"location":"miscellaneous/introduction/#a-compile-toolchain-to-help-you-generate-pre-compiled-ebpf-data","title":"A compile toolchain to help you generate pre compiled eBPF data","text":"<p>The toolchain can be used as a docker to generate pre-compiled eBPF data in one command:</p> <p>see the compile toolchains compiler for details.</p> <p>you can also simply use the ebpm-template repo as a template in github, just push to it and github action can help you compile CO-RE ebpf code!</p>"},{"location":"miscellaneous/introduction/#other-related-projects","title":"other related projects","text":"<ul> <li> <p>LMP eBPF Hub: github.com/linuxkerneltravel/lmp</p> <p>a package manager for eBPF based on wasm modules</p> </li> <li> <p>bolipi online compiler &amp; runner: https://bolipi.com/ebpf/home/online</p> <p>an online compiler and runner for eBPF program newbies</p> </li> <li> <p>An Observability tool</p> <p>An prometheus and OpenTelemetry exporter for custom eBPF metrics, written in async rust: eunomia-exporter. You can compile it or download from release</p> </li> </ul>"},{"location":"miscellaneous/introduction/#build-the-project","title":"build the project","text":"<p>see build for details.</p>"},{"location":"miscellaneous/manual.zh/","title":"eunomia-bpf \u7528\u6237\u624b\u518c: \u8ba9 eBPF \u7a0b\u5e8f\u7684\u5f00\u53d1\u548c\u90e8\u7f72\u5c3d\u53ef\u80fd\u7b80\u5355","text":"<ul> <li>eunomia-bpf \u7528\u6237\u624b\u518c: \u8ba9 eBPF \u7a0b\u5e8f\u7684\u5f00\u53d1\u548c\u90e8\u7f72\u5c3d\u53ef\u80fd\u7b80\u5355</li> <li>\u4ece C \u8bed\u8a00 \u7684 Hello World \u5f00\u59cb</li> <li>eunomia-bpf \u7684 Hello World</li> <li>\u6dfb\u52a0 map \u8bb0\u5f55\u6570\u636e</li> <li>\u4f7f\u7528 ring buffer \u5f80\u7528\u6237\u6001\u53d1\u9001\u6570\u636e</li> <li>\u4f7f\u7528 perf event array \u5f80\u7528\u6237\u6001\u53d1\u9001\u6570\u636e</li> <li>\u4f7f\u7528 github-template \u5b9e\u73b0\u8fdc\u7a0b\u7f16\u8bd1</li> <li>\u901a\u8fc7 API \u8fdb\u884c\u70ed\u63d2\u62d4\u548c\u5206\u53d1</li> <li>\u4f7f\u7528 Prometheus \u6216 OpenTelemetry \u8fdb\u884c\u53ef\u89c2\u6d4b\u6027\u6570\u636e\u6536\u96c6<ul> <li>example</li> </ul> </li> <li>\u4f7f\u7528 Wasm \u6a21\u5757\u5206\u53d1\u3001\u52a8\u6001\u52a0\u8f7d eBPF \u7a0b\u5e8f</li> <li>\u4f7f\u7528 Wasm \u5f00\u53d1\u548c\u6253\u5305 eBPF \u7a0b\u5e8f<ul> <li>bootstrap</li> <li>\u7f16\u5199\u5185\u6838\u6001\u7684 eBPF \u7a0b\u5e8f</li> <li>\u6784\u5efa\u7528\u6237\u6001\u7684 Wasm \u4ee3\u7801\uff0c\u5e76\u83b7\u53d6\u5185\u6838\u6001\u6570\u636e</li> <li>bootstrap</li> <li>\u7f16\u5199\u5185\u6838\u6001\u7684 eBPF \u7a0b\u5e8f</li> <li>\u6784\u5efa\u7528\u6237\u6001\u7684 Wasm \u4ee3\u7801\uff0c\u5e76\u83b7\u53d6\u5185\u6838\u6001\u6570\u636e</li> <li>\u4ece\u7528\u6237\u6001\u7a0b\u5e8f\u4e2d\u8bbf\u95ee\u548c\u66f4\u65b0 eBPF \u7a0b\u5e8f\u7684 map \u6570\u636e</li> <li>\u4ece\u7528\u6237\u6001\u7a0b\u5e8f\u4e2d\u8bbf\u95ee\u548c\u66f4\u65b0 eBPF \u7a0b\u5e8f\u7684 map \u6570\u636e</li> <li>\u66f4\u591a\u7684\u4f8b\u5b50\uff1asocket filter \u548c lsm</li> </ul> </li> <li>\u6f14\u793a\u89c6\u9891</li> <li>\u539f\u7406</li> <li>\u4e3a\u6211\u4eec\u7684\u9879\u76ee\u8d21\u732e\u4ee3\u7801</li> </ul> <p>\u4f20\u7edf\u6765\u8bf4\uff0c eBPF \u7684\u5f00\u53d1\u65b9\u5f0f\u4e3b\u8981\u6709 BCC\u3001libbpf \u7b49\u65b9\u5f0f\u3002\u8981\u5b8c\u6210\u4e00\u4e2a BPF \u4e8c\u8fdb\u5236\u7a0b\u5e8f\u7684\u5f00\u53d1\uff0c\u9700\u8981\u642d\u5efa\u5f00\u53d1\u7f16\u8bd1\u73af\u5883\uff0c\u8981\u5173\u6ce8\u76ee\u6807\u7cfb\u7edf\u7684\u5185\u6838\u7248\u672c\u60c5\u51b5\uff0c\u9700\u8981\u638c\u63e1\u4ece BPF \u5185\u6838\u6001\u5230\u7528\u6237\u6001\u7a0b\u5e8f\u7684\u7f16\u5199\uff0c\u4ee5\u53ca\u5982\u4f55\u52a0\u8f7d\u3001\u7ed1\u5b9a\u81f3\u5bf9\u5e94\u7684 HOOK \u70b9\u7b49\u5f85\u4e8b\u4ef6\u89e6\u53d1\uff0c\u6700\u540e\u518d\u5bf9\u8f93\u51fa\u7684\u65e5\u5fd7\u53ca\u6570\u636e\u8fdb\u884c\u5904\u7406\u3002</p> <p>\u6211\u4eec\u5e0c\u671b\u6709\u8fd9\u6837\u4e00\u79cd eBPF \u7684\u7f16\u8bd1\u548c\u8fd0\u884c\u5de5\u5177\u94fe\uff0c\u5c31\u50cf\u5176\u4ed6\u5f88\u591a\u8bed\u8a00\u4e00\u6837\uff1a</p> <ul> <li> <p>\u5927\u591a\u6570\u7528\u6237\u53ea\u9700\u8981\u5173\u6ce8 <code>bpf.c</code> \u7a0b\u5e8f\u672c\u8eab\u7684\u7f16\u5199\uff0c\u4e0d\u9700\u8981\u5199\u4efb\u4f55\u5176\u4ed6\u7684\u4ec0\u4e48 Python, Clang \u4e4b\u7c7b\u7684\u7528\u6237\u6001\u8f85\u52a9\u4ee3\u7801\u6846\u67b6\uff1b   \u8fd9\u6837\u6211\u4eec\u53ef\u4ee5\u5f88\u65b9\u4fbf\u5730\u5206\u53d1\u3001\u91cd\u7528 eBPF \u7a0b\u5e8f\u672c\u8eab\uff0c\u800c\u4e0d\u9700\u8981\u548c\u67d0\u79cd\u6216\u51e0\u79cd\u8bed\u8a00\u7684\u751f\u6001\u7ed1\u5b9a\uff1b</p> </li> <li> <p>\u6700\u5927\u7a0b\u5ea6\u4e0a\u548c\u4e3b\u6d41\u7684 libbpf \u6846\u67b6\u5b9e\u73b0\u517c\u5bb9\uff0c\u539f\u5148\u4f7f\u7528 libbpf \u6846\u67b6\u7f16\u5199\u7684\u4ee3\u7801\u51e0\u4e4e\u4e0d\u9700\u8981\u6539\u52a8\u5373\u53ef\u79fb\u690d\uff1beunomia-bpf \u7f16\u5199\u7684 eBPF \u7a0b\u5e8f\u4e5f\u53ef\u4ee5\u4f7f\u7528 libbpf \u6846\u67b6\u6765\u76f4\u63a5\u7f16\u8bd1\u8fd0\u884c\uff1b</p> </li> <li> <p>\u672c\u5730\u53ea\u9700\u8981\u4e0b\u8f7d\u4e00\u4e2a\u5f88\u5c0f\u7684\u4e8c\u8fdb\u5236\u8fd0\u884c\u65f6\uff0c\u6ca1\u6709\u4efb\u4f55\u7684 Clang LLVM \u4e4b\u7c7b\u7684\u5927\u578b\u4f9d\u8d56\uff0c\u53ef\u4ee5\u652f\u6301\u70ed\u63d2\u62d4\u3001\u70ed\u66f4\u65b0\uff1b   \u4e5f\u53ef\u4ee5\u4f5c\u4e3a Lua \u865a\u62df\u673a\u90a3\u6837\u7684\u5c0f\u6a21\u5757\u76f4\u63a5\u7f16\u8bd1\u5d4c\u5165\u5176\u4ed6\u7684\u5927\u578b\u8f6f\u4ef6\u4e2d\uff0c\u63d0\u4f9b eBPF \u7a0b\u5e8f\u672c\u8eab\u7684\u670d\u52a1\uff1b\u8fd0\u884c\u548c\u542f\u52a8\u65f6\u8d44\u6e90\u5360\u7528\u7387\u90fd\u5f88\u4f4e\uff1b</p> </li> <li> <p>\u8ba9 eBPF \u7a0b\u5e8f\u7684\u5206\u53d1\u548c\u4f7f\u7528\u50cf\u7f51\u9875\u548c Web \u670d\u52a1\u4e00\u6837\u81ea\u7136\uff08Make eBPF as a service\uff09\uff1a   \u652f\u6301\u5728\u96c6\u7fa4\u73af\u5883\u4e2d\u76f4\u63a5\u901a\u8fc7\u4e00\u6b21\u8bf7\u6c42\u8fdb\u884c\u5206\u53d1\u548c\u70ed\u66f4\u65b0\uff0c\u4ec5\u9700\u6570\u5341 kB \u7684 payload\uff0c   &lt;100ms \u7684\u66f4\u65b0\u65f6\u95f4\uff0c\u548c\u5c11\u91cf\u7684 CPU \u5185\u5b58\u5360\u7528\u5373\u53ef\u5b8c\u6210 eBPF \u7a0b\u5e8f\u7684\u5206\u53d1\u3001\u90e8\u7f72\u548c\u66f4\u65b0\uff1b   \u4e0d\u9700\u8981\u6267\u884c\u989d\u5916\u7684\u7f16\u8bd1\u8fc7\u7a0b\uff0c\u5c31\u80fd\u5f97\u5230 CO-RE \u7684\u8fd0\u884c\u6548\u7387\uff1b</p> </li> </ul>"},{"location":"miscellaneous/manual.zh/#c-hello-world","title":"\u4ece C \u8bed\u8a00 \u7684 Hello World \u5f00\u59cb","text":"<p>\u8fd8\u8bb0\u5f97\u60a8\u7b2c\u4e00\u6b21\u5199 C \u8bed\u8a00 \u7684 Hello World \u7a0b\u5e8f \u5417\uff1f\u9996\u5148\uff0c\u6211\u4eec\u9700\u8981\u4e00\u4e2a <code>.c</code> \u6587\u4ef6\uff0c\u5b83\u5305\u542b\u4e00\u4e2a <code>main</code> \u51fd\u6570\uff1a</p> <pre><code>int main(void)\n{\nprintf(\"Hello, World!\\n\");\nreturn 0;\n}\n</code></pre> <p>\u6211\u4eec\u53eb\u5b83 <code>hello.c</code>\uff0c\u63a5\u4e0b\u6765\u5c31\u53ea\u9700\u8981\u8fd9\u51e0\u4e2a\u6b65\u9aa4\u5c31\u597d\uff1a</p> <pre><code># if you are using Ubuntu without a c compiler\nsudo apt insalll build-essentials\n# compile the program\ngcc -o hello hello.c\n# run the program\n./hello\n</code></pre> <p>\u53ea\u9700\u8981\u5199\u4e00\u4e2a c \u6587\u4ef6\uff0c\u6267\u884c\u4e24\u884c\u547d\u4ee4\u5c31\u53ef\u4ee5\u8fd0\u884c\uff1b\u5927\u591a\u6570\u60c5\u51b5\u4e0b\u4f60\u4e5f\u53ef\u4ee5\u628a\u7f16\u8bd1\u597d\u7684\u53ef\u6267\u884c\u6587\u4ef6\u76f4\u63a5\u79fb\u52a8\u5230\u5176\u4ed6\u540c\u6837\u67b6\u6784\u7684\u673a\u5668\u6216\u4e0d\u540c\u7248\u672c\u7684\u64cd\u4f5c\u7cfb\u7edf\u4e0a\uff0c\u7136\u540e\u8fd0\u884c\u5b83\uff0c\u4e5f\u4f1a\u5f97\u5230\u4e00\u6837\u7684\u7ed3\u679c:</p> <pre><code>Hello World!\n</code></pre>"},{"location":"miscellaneous/manual.zh/#eunomia-bpf-hello-world","title":"eunomia-bpf \u7684 Hello World","text":"<p>\u9996\u5148\uff0c\u6211\u4eec\u9700\u8981\u4e00\u4e2a <code>bpf.c</code> \u6587\u4ef6\uff0c\u5b83\u5c31\u662f\u6b63\u5e38\u7684\u3001\u5408\u6cd5\u7684 C \u8bed\u8a00\u4ee3\u7801\uff0c\u548c libbpf \u6240\u4f7f\u7528\u7684\u5b8c\u5168\u76f8\u540c\uff1a</p> <pre><code>#include &lt;linux/bpf.h&gt;\n#include &lt;bpf/bpf_helpers.h&gt;\n#include &lt;bpf/bpf_tracing.h&gt;\ntypedef int pid_t;\nchar LICENSE[] SEC(\"license\") = \"Dual BSD/GPL\";\nSEC(\"tp/syscalls/sys_enter_write\")\nint handle_tp(void *ctx)\n{\npid_t pid = bpf_get_current_pid_tgid() &gt;&gt; 32;\nbpf_printk(\"BPF triggered from PID %d.\\n\", pid);\nreturn 0;\n}\n</code></pre> <p>\u5047\u8bbe\u5b83\u53eb <code>hello.bpf.c</code>\uff0c\u65b0\u5efa\u4e00\u4e2a <code>/path/to/repo</code> \u7684\u6587\u4ef6\u5939\u5e76\u4e14\u628a\u5b83\u653e\u8fdb\u53bb\uff0c\u63a5\u4e0b\u6765\u7684\u6b65\u9aa4\uff1a</p> <pre><code># \u4e0b\u8f7d\u5b89\u88c5 ecli \u4e8c\u8fdb\u5236\nwget https://aka.pw/bpf-ecli -O /usr/local/ecli &amp;&amp; chmod +x /usr/local/ecli\n# \u4f7f\u7528\u5bb9\u5668\u8fdb\u884c\u7f16\u8bd1\uff0c\u751f\u6210\u4e00\u4e2a package.json \u6587\u4ef6\uff0c\u91cc\u9762\u662f\u5df2\u7ecf\u7f16\u8bd1\u597d\u7684\u4ee3\u7801\u548c\u4e00\u4e9b\u8f85\u52a9\u4fe1\u606f\ndocker run -it -v /path/to/repo:/src ghcr.io/eunomia-bpf/ecc-`uname -m`:latest\n# \u8fd0\u884c eBPF \u7a0b\u5e8f\uff08root shell\uff09\nsudo ecli run package.json\n</code></pre> <p>\u4f7f\u7528 docker \u7684\u65f6\u5019\u9700\u8981\u628a\u5305\u542b .bpf.c \u6587\u4ef6\u7684\u76ee\u5f55\u6302\u8f7d\u5230\u5bb9\u5668\u7684 /src \u76ee\u5f55\u4e0b\uff0c\u76ee\u5f55\u4e2d\u53ea\u6709\u4e00\u4e2a .bpf.c \u6587\u4ef6\uff1b</p> <p>\u5b83\u4f1a\u8ffd\u8e2a\u6240\u6709\u8fdb\u884c write \u7cfb\u7edf\u8c03\u7528\u7684\u8fdb\u7a0b\u7684 pid\uff1a</p> <pre><code>$ sudo cat /sys/kernel/debug/tracing/trace_pipe\ncat-42755   [003] d...1 48755.529860: bpf_trace_printk: BPF triggered from PID 42755.\n             cat-42755   [003] d...1 48755.529874: bpf_trace_printk: BPF triggered from PID 42755.\n</code></pre> <p>\u6211\u4eec\u7f16\u8bd1\u597d\u7684 eBPF \u4ee3\u7801\u540c\u6837\u53ef\u4ee5\u9002\u914d\u591a\u79cd\u5185\u6838\u7248\u672c\uff0c\u53ef\u4ee5\u76f4\u63a5\u628a package.json \u590d\u5236\u5230\u53e6\u5916\u4e00\u4e2a\u673a\u5668\u4e0a\uff0c\u7136\u540e\u4e0d\u9700\u8981\u91cd\u65b0\u7f16\u8bd1\u5c31\u53ef\u4ee5\u76f4\u63a5\u8fd0\u884c\uff08CO-RE\uff1aCompile Once Run Every Where\uff09\uff1b\u4e5f\u53ef\u4ee5\u901a\u8fc7\u7f51\u7edc\u4f20\u8f93\u548c\u5206\u53d1 package.json\uff0c\u901a\u5e38\u60c5\u51b5\u4e0b\uff0c\u538b\u7f29\u540e\u7684\u7248\u672c\u53ea\u6709\u51e0 kb \u5230\u51e0\u5341 kb\u3002</p>"},{"location":"miscellaneous/manual.zh/#map","title":"\u6dfb\u52a0 map \u8bb0\u5f55\u6570\u636e","text":"<p>\u53c2\u8003\uff1ahttps://github.com/eunomia-bpf/eunomia-bpf/tree/master/examples/bpftools/bootstrap</p> <pre><code>struct {\n__uint(type, BPF_MAP_TYPE_HASH);\n__uint(max_entries, 8192);\n__type(key, pid_t);\n__type(value, u64);\n} exec_start SEC(\".maps\");\n</code></pre> <p>\u6dfb\u52a0 map \u7684\u529f\u80fd\u548c libbpf \u6ca1\u6709\u4efb\u4f55\u533a\u522b\uff0c\u53ea\u9700\u8981\u5728 .bpf.c \u4e2d\u5b9a\u4e49\u5373\u53ef\u3002</p>"},{"location":"miscellaneous/manual.zh/#ring-buffer","title":"\u4f7f\u7528 ring buffer \u5f80\u7528\u6237\u6001\u53d1\u9001\u6570\u636e","text":"<p>\u53c2\u8003\uff1ahttps://github.com/eunomia-bpf/eunomia-bpf/tree/master/examples/bpftools/bootstrap</p> <p>\u53ea\u9700\u8981\u5b9a\u4e49\u4e00\u4e2a\u5934\u6587\u4ef6\uff0c\u5305\u542b\u4f60\u60f3\u8981\u53d1\u9001\u7ed9\u7528\u6237\u6001\u7684\u6570\u636e\u683c\u5f0f\uff0c\u4ee5 <code>.h</code> \u4f5c\u4e3a\u540e\u7f00\u540d\uff1a</p> <pre><code>/* SPDX-License-Identifier: (LGPL-2.1 OR BSD-2-Clause) */\n/* Copyright (c) 2020 Facebook */\n#ifndef __BOOTSTRAP_H\n#define __BOOTSTRAP_H\n#define TASK_COMM_LEN 16\n#define MAX_FILENAME_LEN 127\nstruct event {\nint pid;\nint ppid;\nunsigned exit_code;\nunsigned long long duration_ns;\nchar comm[TASK_COMM_LEN];\nchar filename[MAX_FILENAME_LEN];\nunsigned char exit_event;\n};\n#endif /* __BOOTSTRAP_H */\n</code></pre> <p>\u5728\u4ee3\u7801\u4e2d\u5b9a\u4e49\u73af\u5f62\u7f13\u51b2\u533a\u4e4b\u540e\uff0c\u5c31\u53ef\u4ee5\u76f4\u63a5\u4f7f\u7528\u5b83\uff1a</p> <pre><code>struct {\n__uint(type, BPF_MAP_TYPE_RINGBUF);\n__uint(max_entries, 256 * 1024);\n} rb SEC(\".maps\");\nSEC(\"tp/sched/sched_process_exec\")\nint handle_exec(struct trace_event_raw_sched_process_exec *ctx)\n{\n......\ne-&gt;exit_event = false;\ne-&gt;pid = pid;\ne-&gt;ppid = BPF_CORE_READ(task, real_parent, tgid);\nbpf_get_current_comm(&amp;e-&gt;comm, sizeof(e-&gt;comm));\n/* successfully submit it to user-space for post-processing */\nbpf_ringbuf_submit(e, 0);\nreturn 0;\n}\n</code></pre> <p>eunomia-bpf \u4f1a\u81ea\u52a8\u53bb\u6e90\u4ee3\u7801\u4e2d\u627e\u5230\u5bf9\u5e94\u7684 ring buffer map\uff0c\u5e76\u4e14\u628a ring buffer \u548c\u7c7b\u578b\u4fe1\u606f\u8bb0\u5f55\u5728\u7f16\u8bd1\u597d\u7684\u4fe1\u606f\u4e2d\uff0c\u5e76\u5728\u8fd0\u884c\u7684\u65f6\u5019\u81ea\u52a8\u5b8c\u6210\u5bf9\u4e8e ring buffer \u7684\u52a0\u8f7d\u3001\u5bfc\u51fa\u4e8b\u4ef6\u7b49\u5de5\u4f5c\u3002\u6240\u6709\u7684 eBPF \u4ee3\u7801\u548c\u539f\u751f\u7684 libbpf \u7a0b\u5e8f\u6ca1\u6709\u4efb\u4f55\u533a\u522b\uff0c\u4f7f\u7528 eunomia-bpf \u5f00\u53d1\u7684\u4ee3\u7801\u4e5f\u53ef\u4ee5\u5728 libbpf \u4e2d\u65e0\u9700\u4efb\u4f55\u6539\u52a8\u5373\u53ef\u7f16\u8bd1\u8fd0\u884c\u3002</p>"},{"location":"miscellaneous/manual.zh/#perf-event-array","title":"\u4f7f\u7528 perf event array \u5f80\u7528\u6237\u6001\u53d1\u9001\u6570\u636e","text":"<p>\u4f7f\u7528 perf event \u7684\u539f\u7406\u548c\u4f7f\u7528 ring buffer \u975e\u5e38\u7c7b\u4f3c\uff0c\u4f7f\u7528\u6211\u4eec\u7684\u6846\u67b6\u65f6\uff0c\u4e5f\u53ea\u9700\u8981\u5728\u5934\u6587\u4ef6\u4e2d\u5b9a\u4e49\u597d\u6240\u9700\u5bfc\u51fa\u7684\u4e8b\u4ef6\uff0c\u7136\u540e\u5b9a\u4e49\u4e00\u4e0b perf event map\uff1a</p> <pre><code>struct {\n__uint(type, BPF_MAP_TYPE_PERF_EVENT_ARRAY);\n__uint(key_size, sizeof(u32));\n__uint(value_size, sizeof(u32));\n} events SEC(\".maps\");\n</code></pre> <p>\u53ef\u4ee5\u53c2\u8003\uff1ahttps://github.com/eunomia-bpf/eunomia-bpf/tree/master/examples/bpftools/opensnoop \u5b83\u662f\u76f4\u63a5\u4ece libbpf-tools \u4e2d\u79fb\u690d\u7684\u5b9e\u73b0\uff1b</p>"},{"location":"miscellaneous/manual.zh/#github-template","title":"\u4f7f\u7528 github-template \u5b9e\u73b0\u8fdc\u7a0b\u7f16\u8bd1","text":"<p>\u7531\u4e8e eunomia-bpf \u7684\u7f16\u8bd1\u548c\u8fd0\u884c\u9636\u6bb5\u5b8c\u5168\u5206\u79bb\uff0c\u53ef\u4ee5\u5b9e\u73b0\u5728 github \u7f51\u9875\u4e0a\u7f16\u8f91\u4e4b\u540e\uff0c\u901a\u8fc7 github actions \u6765\u5b8c\u6210\u7f16\u8bd1\uff0c\u4e4b\u540e\u5728\u672c\u5730\u4e00\u884c\u547d\u4ee4\u5373\u53ef\u542f\u52a8\uff1a</p> <ol> <li>\u5c06\u6b64 github.com/eunomia-bpf/ebpm-template \u7528\u4f5c github \u6a21\u677f\uff1a\u8bf7\u53c2\u9605 creating-a-repository-from-a-template</li> <li>\u4fee\u6539 bootstrap.bpf.c\uff0c commit \u5e76\u7b49\u5f85\u5de5\u4f5c\u6d41\u505c\u6b62</li> <li>\u6211\u4eec\u914d\u7f6e\u4e86 github pages \u6765\u5b8c\u6210\u7f16\u8bd1\u597d\u7684 json \u7684\u5bfc\u51fa\uff0c\u4e4b\u540e\u5c31\u53ef\u4ee5\u5b9e\u73b0 ecli \u4f7f\u7528\u8fdc\u7a0b url \u4e00\u884c\u547d\u4ee4\u5373\u53ef\u8fd0\u884c\uff1a</li> </ol> <pre><code>sudo ./ecli run https://eunomia-bpf.github.io/ebpm-template/package.json\n</code></pre>"},{"location":"miscellaneous/manual.zh/#api","title":"\u901a\u8fc7 API \u8fdb\u884c\u70ed\u63d2\u62d4\u548c\u5206\u53d1","text":"<p>\u7531\u4e8e eunomia-cc \u7f16\u8bd1\u51fa\u6765\u7684 ebpf \u7a0b\u5e8f\u4ee3\u7801\u548c\u9644\u52a0\u4fe1\u606f\u5f88\u5c0f\uff08\u7ea6\u6570\u5341 kb\uff09\uff0c\u4e14\u4e0d\u9700\u8981\u540c\u65f6\u4f20\u9012\u4efb\u4f55\u7684\u989d\u5916\u4f9d\u8d56\uff0c\u56e0\u6b64\u6211\u4eec\u53ef\u4ee5\u975e\u5e38\u65b9\u4fbf\u5730\u901a\u8fc7\u7f51\u7edc API \u76f4\u63a5\u8fdb\u884c\u5206\u53d1\uff0c\u4e5f\u53ef\u4ee5\u5728\u5f88\u77ed\u7684\u65f6\u95f4\uff08\u5927\u7ea6 100ms\uff09\u5185\u5b9e\u73b0\u70ed\u63d2\u62d4\u548c\u70ed\u66f4\u65b0\u3002\u6211\u4eec\u63d0\u4f9b\u4e86\u4e00\u4e2a\u7b80\u5355\u7684 client \u548c server\uff0c\u8bf7\u53c2\u8003;</p> <p>ecli-dockerfile-usage.md</p> <p>\u4e4b\u524d\u4e5f\u6709\u4e00\u7bc7\u6bd4\u8d5b\u9879\u76ee\u7684\u53ef\u884c\u6027\u9a8c\u8bc1\u7684\u6587\u7ae0\uff1a</p> <p>https://zhuanlan.zhihu.com/p/555362934</p>"},{"location":"miscellaneous/manual.zh/#prometheus-opentelemetry","title":"\u4f7f\u7528 Prometheus \u6216 OpenTelemetry \u8fdb\u884c\u53ef\u89c2\u6d4b\u6027\u6570\u636e\u6536\u96c6","text":"<p>\u57fa\u4e8e async Rust \u7684 Prometheus \u6216 OpenTelemetry \u81ea\u5b9a\u4e49\u53ef\u89c2\u6d4b\u6027\u6570\u636e\u6536\u96c6\u5668: eunomia-exporter</p> <p>\u53ef\u4ee5\u81ea\u884c\u7f16\u8bd1\u6216\u901a\u8fc7 release \u4e0b\u8f7d</p>"},{"location":"miscellaneous/manual.zh/#example","title":"example","text":"<p>\u8fd9\u662f\u4e00\u4e2a <code>opensnoop</code> \u7a0b\u5e8f\uff0c\u8ffd\u8e2a\u6240\u6709\u7684\u6253\u5f00\u6587\u4ef6\uff0c\u6e90\u4ee3\u7801\u6765\u81ea bcc/libbpf-tools, \u6211\u4eec\u4fee\u6539\u8fc7\u540e\u7684\u6e90\u4ee3\u7801\u5728\u8fd9\u91cc: examples/bpftools/opensnoop</p> <p>\u5728\u7f16\u8bd1\u4e4b\u540e\uff0c\u53ef\u4ee5\u5b9a\u4e49\u4e00\u4e2a\u8fd9\u6837\u7684\u914d\u7f6e\u6587\u4ef6:</p> <pre><code>programs:\n  - name: opensnoop\n    metrics:\n      counters:\n        - name: eunomia_file_open_counter\n          description: test\n          labels:\n            - name: pid\n            - name: comm\n            - name: filename\n              from: fname\n    compiled_ebpf_filename: examples/bpftools/opensnoop/package.json\n</code></pre> <p>\u7136\u540e\uff0c\u60a8\u53ef\u4ee5\u5728\u4efb\u4f55\u5730\u65b9\u4f7f\u7528 <code>config.yaml</code> \u548c\u9884\u7f16\u8bd1\u7684 eBPF \u6570\u636e <code>package.json</code> \u542f\u52a8 Prometheus \u5bfc\u51fa\u5668\uff0c\u60a8\u53ef\u4ee5\u770b\u5230\u5982\u4e0b\u6307\u6807\uff1a</p> <p></p> <p>\u60a8\u53ef\u4ee5\u5728\u4efb\u4f55\u5185\u6838\u7248\u672c\u4e0a\u90e8\u7f72\u5bfc\u51fa\u5668\uff0c\u800c\u65e0\u9700\u4f9d\u8d56 <code>LLVM/Clang</code>\u3002 \u6709\u5173\u8be6\u7ec6\u4fe1\u606f\uff0c\u8bf7\u53c2\u9605 eunomia-exporter\u3002</p>"},{"location":"miscellaneous/manual.zh/#wasm-ebpf","title":"\u4f7f\u7528 Wasm \u6a21\u5757\u5206\u53d1\u3001\u52a8\u6001\u52a0\u8f7d eBPF \u7a0b\u5e8f","text":"<p>\u501f\u52a9 Wasm-bpf \u7f16\u8bd1\u5de5\u5177\u94fe\u548c\u8fd0\u884c\u65f6\uff0c\u6211\u4eec\u53ef\u4ee5\u4f7f\u7528 Wasm \u5c06 eBPF \u7a0b\u5e8f\u7f16\u5199\u4e3a\u8de8\u5e73\u53f0\u7684\u6a21\u5757\uff0c\u540c\u65f6\u4f7f\u7528 C/C++ \u6216 Rust \u6765\u7f16\u5199 Wasm \u7a0b\u5e8f\u3002\u901a\u8fc7\u5728 WebAssembly \u4e2d\u4f7f\u7528 eBPF \u7a0b\u5e8f\uff0c\u6211\u4eec\u4e0d\u4ec5\u80fd\u8ba9 Wasm \u5e94\u7528\u4eab\u53d7\u5230 eBPF \u7684\u9ad8\u6027\u80fd\u548c\u5bf9\u7cfb\u7edf\u63a5\u53e3\u7684\u8bbf\u95ee\u80fd\u529b\uff0c\u8fd8\u53ef\u4ee5\u8ba9 eBPF \u7a0b\u5e8f\u4f7f\u7528\u5230 Wasm \u7684\u6c99\u7bb1\u3001\u7075\u6d3b\u6027\u3001\u8de8\u5e73\u53f0\u6027\u3001\u548c\u52a8\u6001\u52a0\u8f7d\uff0c\u5e76\u4e14\u4f7f\u7528 Wasm \u7684 OCI \u955c\u50cf\u6765\u65b9\u4fbf\u3001\u5feb\u6377\u5730\u5206\u53d1\u548c\u7ba1\u7406 eBPF \u7a0b\u5e8f\u3002\u7ed3\u5408\u8fd9\u4e24\u79cd\u6280\u672f\uff0c\u6211\u4eec\u5c06\u4f1a\u7ed9 eBPF \u548c Wasm \u751f\u6001\u6765\u4e00\u4e2a\u5168\u65b0\u7684\u5f00\u53d1\u4f53\u9a8c\uff01</p> <p>Wasm-bpf \u662f\u4e00\u4e2a\u65b0\u7684\u5f00\u6e90\u9879\u76ee\uff1ahttps://github.com/eunomia-bpf/wasm-bpf\u3002\u5b83\u5b9a\u4e49\u4e86\u4e00\u5957 eBPF \u76f8\u5173\u7cfb\u7edf\u63a5\u53e3\u7684\u62bd\u8c61\uff0c\u5e76\u63d0\u4f9b\u4e86\u4e00\u5957\u5bf9\u5e94\u7684\u5f00\u53d1\u5de5\u5177\u94fe\u3001\u5e93\u4ee5\u53ca\u901a\u7528\u7684 Wasm + eBPF \u8fd0\u884c\u65f6\u5b9e\u4f8b\u3002\u5b83\u53ef\u4ee5\u63d0\u4f9b\u548c libbpf-bootstrap \u76f8\u4f3c\u7684\u5f00\u53d1\u4f53\u9a8c\uff0c\u81ea\u52a8\u751f\u6210\u5bf9\u5e94\u7684 skeleton \u5934\u6587\u4ef6\uff0c\u4ee5\u53ca\u7528\u4e8e\u5728 Wasm \u548c eBPF \u4e4b\u95f4\u65e0\u5e8f\u5217\u5316\u901a\u4fe1\u7684\u6570\u636e\u7ed3\u6784\u5b9a\u4e49\u3002\u4f60\u53ef\u4ee5\u975e\u5e38\u5bb9\u6613\u5730\u4f7f\u7528\u4efb\u4f55\u8bed\u8a00\uff0c\u5728\u4efb\u4f55\u5e73\u53f0\u4e0a\u5efa\u7acb\u4f60\u81ea\u5df1\u7684 Wasm-eBPF \u8fd0\u884c\u65f6\uff0c\u4f7f\u7528\u76f8\u540c\u7684\u5de5\u5177\u94fe\u6765\u6784\u5efa\u5e94\u7528\u3002\u66f4\u8be6\u7ec6\u7684\u4ecb\u7ecd\uff0c\u8bf7\u53c2\u8003\u6211\u4eec\u7684\u4e0a\u4e00\u7bc7\u535a\u5ba2\uff1aWasm-bpf: \u67b6\u8d77 Webassembly \u548c eBPF \u5185\u6838\u53ef\u7f16\u7a0b\u7684\u6865\u6881\u3002</p> <p>\u57fa\u4e8e Wasm\uff0c\u6211\u4eec\u53ef\u4ee5\u4f7f\u7528\u591a\u79cd\u8bed\u8a00\u6784\u5efa eBPF \u5e94\u7528\uff0c\u5e76\u4ee5\u7edf\u4e00\u3001\u8f7b\u91cf\u7ea7\u7684\u65b9\u5f0f\u7ba1\u7406\u548c\u53d1\u5e03\u3002\u4ee5\u6211\u4eec\u6784\u5efa\u7684\u793a\u4f8b\u5e94\u7528 bootstrap.wasm \u4e3a\u4f8b\uff0c\u5927\u5c0f\u4ec5\u4e3a ~90K\uff0c\u5f88\u5bb9\u6613\u901a\u8fc7\u7f51\u7edc\u5206\u53d1\uff0c\u5e76\u53ef\u4ee5\u5728\u4e0d\u5230 100ms \u7684\u65f6\u95f4\u5185\u5728\u53e6\u4e00\u53f0\u673a\u5668\u4e0a\u52a8\u6001\u90e8\u7f72\u3001\u52a0\u8f7d\u548c\u8fd0\u884c\uff0c\u5e76\u4e14\u4fdd\u7559\u8f7b\u91cf\u7ea7\u5bb9\u5668\u7684\u9694\u79bb\u7279\u6027\u3002\u8fd0\u884c\u65f6\u4e0d\u9700\u8981\u5185\u6838\u5934\u6587\u4ef6\u3001LLVM\u3001clang \u7b49\u4f9d\u8d56\uff0c\u4e5f\u4e0d\u9700\u8981\u505a\u4efb\u4f55\u6d88\u8017\u8d44\u6e90\u7684\u91cd\u91cf\u7ea7\u7684\u7f16\u8bd1\u5de5\u4f5c\u3002</p> <p>\u672c\u6587\u5c06\u4ee5 C/C++ \u8bed\u8a00\u4e3a\u4f8b\uff0c\u8ba8\u8bba C/C++ \u7f16\u5199 eBPF \u7a0b\u5e8f\u5e76\u7f16\u8bd1\u4e3a Wasm \u6a21\u5757\u3002\u4f7f\u7528 Rust \u8bed\u8a00\u7f16\u5199 eBPF \u7a0b\u5e8f\u5e76\u7f16\u8bd1\u4e3a Wasm \u6a21\u5757\u7684\u5177\u4f53\u793a\u4f8b\uff0c\u5c06\u5728\u4e0b\u4e00\u7bc7\u6587\u7ae0\u4e2d\u63cf\u8ff0\u3002</p> <p>\u6211\u4eec\u5728\u4ed3\u5e93\u4e2d\u63d0\u4f9b\u4e86\u51e0\u4e2a\u793a\u4f8b\u7a0b\u5e8f\uff0c\u5206\u522b\u5bf9\u5e94\u4e8e\u53ef\u89c2\u6d4b\u3001\u7f51\u7edc\u3001\u5b89\u5168\u7b49\u591a\u79cd\u573a\u666f\u3002</p>"},{"location":"miscellaneous/manual.zh/#wasm-ebpf_1","title":"\u4f7f\u7528 Wasm \u5f00\u53d1\u548c\u6253\u5305 eBPF \u7a0b\u5e8f","text":"<p>libbpf \u662f\u4e00\u4e2a C/C++ \u7684 eBPF \u7528\u6237\u6001\u52a0\u8f7d\u548c\u63a7\u5236\u5e93\uff0c\u968f\u7740\u5185\u6838\u4e00\u8d77\u5206\u53d1\uff0c\u51e0\u4e4e\u5df2\u7ecf\u6210\u4e3a eBPF \u7528\u6237\u6001\u4e8b\u5b9e\u4e0a\u7684 API \u6807\u51c6\uff0clibbpf \u4e5f\u652f\u6301 CO-RE(Compile Once \u2013 Run Everywhere) \u7684\u89e3\u51b3\u65b9\u6848\uff0c\u5373\u9884\u7f16\u8bd1\u7684 bpf \u4ee3\u7801\u53ef\u4ee5\u5728\u4e0d\u540c\u5185\u6838\u7248\u672c\u4e0a\u6b63\u5e38\u5de5\u4f5c\uff0c\u800c\u65e0\u9700\u4e3a\u6bcf\u4e2a\u7279\u5b9a\u5185\u6838\u91cd\u65b0\u7f16\u8bd1\u3002\u6211\u4eec\u5e0c\u671b\u5c3d\u53ef\u80fd\u7684\u4fdd\u6301\u4e0e libbpf \u7684\u7528\u6237\u6001 API \u4ee5\u53ca\u884c\u4e3a\u4e00\u81f4\uff0c\u5c3d\u53ef\u80fd\u51cf\u5c11\u5e94\u7528\u8fc1\u79fb\u5230 Wasm \uff08\u5982\u679c\u9700\u8981\u7684\u8bdd\uff09\u7684\u6210\u672c\u3002</p> <p>libbpf-bootstrap \u4e3a\u751f\u6210\u57fa\u4e8e libbpf \u7684 bpf \u7a0b\u5e8f\u63d0\u4f9b\u4e86\u6a21\u677f,\u5f00\u53d1\u8005\u53ef\u4ee5\u5f88\u65b9\u4fbf\u7684\u4f7f\u7528\u8be5\u6a21\u677f\u751f\u6210\u81ea\u5b9a\u4e49\u7684 bpf \u7a0b\u5e8f\u3002\u4e00\u822c\u8bf4\u6765\uff0c\u5728\u975e Wasm \u6c99\u7bb1\u7684\u7528\u6237\u6001\u7a7a\u95f4\uff0c\u4f7f\u7528 libbpf-bootstrap \u811a\u624b\u67b6\uff0c\u53ef\u4ee5\u5feb\u901f\u3001\u8f7b\u677e\u5730\u4f7f\u7528 C/C++\u6784\u5efa BPF \u5e94\u7528\u7a0b\u5e8f\u3002</p> <p>\u7f16\u8bd1\u3001\u6784\u5efa\u548c\u8fd0\u884c eBPF \u7a0b\u5e8f\uff08\u65e0\u8bba\u662f\u91c7\u7528\u4ec0\u4e48\u8bed\u8a00\uff09\uff0c\u901a\u5e38\u5305\u542b\u4ee5\u4e0b\u51e0\u4e2a\u6b65\u9aa4\uff1a</p> <ul> <li>\u7f16\u5199\u5185\u6838\u6001 eBPF \u7a0b\u5e8f\u7684\u4ee3\u7801\uff0c\u4e00\u822c\u4f7f\u7528 C/C++ \u6216 Rust \u8bed\u8a00</li> <li>\u4f7f\u7528 clang \u7f16\u8bd1\u5668\u6216\u8005\u76f8\u5173\u5de5\u5177\u94fe\u7f16\u8bd1 eBPF \u7a0b\u5e8f\uff08\u8981\u5b9e\u73b0\u8de8\u5185\u6838\u7248\u672c\u79fb\u690d\u7684\u8bdd\uff0c\u9700\u8981\u5305\u542b BTF \u4fe1\u606f\uff09\u3002</li> <li>\u5728\u7528\u6237\u6001\u7684\u5f00\u53d1\u7a0b\u5e8f\u4e2d\uff0c\u7f16\u5199\u5bf9\u5e94\u7684\u52a0\u8f7d\u3001\u63a7\u5236\u3001\u6302\u8f7d\u3001\u6570\u636e\u5904\u7406\u903b\u8f91\uff1b</li> <li>\u5728\u5b9e\u9645\u8fd0\u884c\u7684\u9636\u6bb5\uff0c\u4ece\u7528\u6237\u6001\u5c06 eBPF \u7a0b\u5e8f\u52a0\u8f7d\u8fdb\u5165\u5185\u6838\uff0c\u5e76\u5b9e\u9645\u6267\u884c\u3002</li> </ul>"},{"location":"miscellaneous/manual.zh/#bootstrap","title":"bootstrap","text":"<p><code>bootstrap</code>\u662f\u4e00\u4e2a\u7b80\u5355\uff08\u4f46\u5b9e\u7528\uff09\u7684BPF\u5e94\u7528\u7a0b\u5e8f\u7684\u4f8b\u5b50\u3002\u5b83\u8ddf\u8e2a\u8fdb\u7a0b\u7684\u542f\u52a8\uff08\u51c6\u786e\u5730\u8bf4\uff0c\u662f <code>exec()</code> \u7cfb\u5217\u7684\u7cfb\u7edf\u8c03\u7528\uff09\u548c\u9000\u51fa\uff0c\u5e76\u53d1\u9001\u5173\u4e8e\u6587\u4ef6\u540d\u3001PID \u548c \u7236 PID \u7684\u6570\u636e\uff0c\u4ee5\u53ca\u9000\u51fa\u72b6\u6001\u548c\u8fdb\u7a0b\u7684\u6301\u7eed\u65f6\u95f4\u3002\u7528<code>-d &lt;min-duration-ms&gt;</code> \u4f60\u53ef\u4ee5\u6307\u5b9a\u8981\u8bb0\u5f55\u7684\u8fdb\u7a0b\u7684\u6700\u5c0f\u6301\u7eed\u65f6\u95f4\u3002</p> <p><code>bootstrap</code> \u662f\u5728 libbpf-bootstrap \u4e2d\uff0c\u6839\u636e BCC \u8f6f\u4ef6\u5305\u4e2d\u7684libbpf-tools\u7684\u7c7b\u4f3c\u601d\u60f3\u521b\u5efa\u7684\uff0c\u4f46\u5b83\u88ab\u8bbe\u8ba1\u6210\u66f4\u72ec\u7acb\u7684\uff0c\u5e76\u4e14\u6709\u66f4\u7b80\u5355\u7684 Makefile \u4ee5\u7b80\u5316\u7528\u6237\u7684\u7279\u6b8a\u9700\u6c42\u3002\u5b83\u6f14\u793a\u4e86\u5178\u578b\u7684BPF\u7279\u6027\uff0c\u5305\u542b\u4f7f\u7528\u591a\u4e2a BPF \u7a0b\u5e8f\u6bb5\u8fdb\u884c\u5408\u4f5c\uff0c\u4f7f\u7528 BPF map \u6765\u7ef4\u62a4\u72b6\u6001\uff0c\u4f7f\u7528 BPF ring buffer \u6765\u53d1\u9001\u6570\u636e\u5230\u7528\u6237\u7a7a\u95f4\uff0c\u4ee5\u53ca\u4f7f\u7528\u5168\u5c40\u53d8\u91cf\u6765\u53c2\u6570\u5316\u5e94\u7528\u7a0b\u5e8f\u884c\u4e3a\u3002</p> <p>\u4ee5\u4e0b\u662f\u6211\u4eec\u4f7f\u7528 Wasm \u7f16\u8bd1\u8fd0\u884c <code>bootstrap</code> \u7684\u4e00\u4e2a\u8f93\u51fa\u793a\u4f8b\uff1a</p> <pre><code>$ sudo sudo ./wasm-bpf bootstrap.wasm -h\nBPF bootstrap demo application.\nIt traces process start and exits and shows associated\ninformation (filename, process duration, PID and PPID, etc).\nUSAGE: ./bootstrap [-d &lt;min-duration-ms&gt;] -v\n$ sudo ./wasm-bpf bootstrap.wasm\nTIME     EVENT COMM             PID     PPID    FILENAME/EXIT CODE\n18:57:58 EXEC  sed              74911   74910   /usr/bin/sed\n18:57:58 EXIT  sed              74911   74910   [0] (2ms)\n18:57:58 EXIT  cat              74912   74910   [0] (0ms)\n18:57:58 EXEC  cat              74913   74910   /usr/bin/cat\n18:57:59 EXIT  cat              74913   74910   [0] (0ms)\n18:57:59 EXEC  cat              74914   74910   /usr/bin/cat\n18:57:59 EXIT  cat              74914   74910   [0] (0ms)\n18:57:59 EXEC  cat              74915   74910   /usr/bin/cat\n18:57:59 EXIT  cat              74915   74910   [0] (1ms)\n18:57:59 EXEC  sleep            74916   74910   /usr/bin/sleep\n</code></pre> <p>\u6211\u4eec\u53ef\u4ee5\u63d0\u4f9b\u4e0e libbpf-bootstrap \u5f00\u53d1\u76f8\u4f3c\u7684\u5f00\u53d1\u4f53\u9a8c\u3002\u53ea\u9700\u8fd0\u884c make \u5373\u53ef\u6784\u5efa wasm \u4e8c\u8fdb\u5236\u6587\u4ef6\uff1a</p> <pre><code>git clone https://github.com/eunomia-bpf/wasm-bpf --recursive\ncd examples/bootstrap\nmake\n</code></pre>"},{"location":"miscellaneous/manual.zh/#ebpf","title":"\u7f16\u5199\u5185\u6838\u6001\u7684 eBPF \u7a0b\u5e8f","text":"<p>\u8981\u6784\u5efa\u4e00\u4e2a\u5b8c\u6574\u7684 eBPF \u7a0b\u5e8f\uff0c\u9996\u5148\u8981\u7f16\u5199\u5185\u6838\u6001\u7684 bpf \u4ee3\u7801\u3002\u901a\u5e38\u4f7f\u7528 C \u8bed\u8a00\u7f16\u5199\uff0c\u5e76\u4f7f\u7528 clang \u5b8c\u6210\u7f16\u8bd1\uff1a</p> <pre><code>char LICENSE[] SEC(\"license\") = \"Dual BSD/GPL\";\nstruct {\n__uint(type, BPF_MAP_TYPE_HASH);\n__uint(max_entries, 8192);\n__type(key, pid_t);\n__type(value, u64);\n} exec_start SEC(\".maps\");\nstruct {\n__uint(type, BPF_MAP_TYPE_RINGBUF);\n__uint(max_entries, 256 * 1024);\n} rb SEC(\".maps\");\nconst volatile unsigned long long min_duration_ns = 0;\nconst volatile int *name_ptr;\nSEC(\"tp/sched/sched_process_exec\")\nint handle_exec(struct trace_event_raw_sched_process_exec *ctx)\n{\nstruct task_struct *task;\nunsigned fname_off;\nstruct event *e;\npid_t pid;\nu64 ts;\n....\n</code></pre> <p>\u53d7\u7bc7\u5e45\u6240\u9650\uff0c\u8fd9\u91cc\u6ca1\u6709\u8d34\u51fa\u5b8c\u6574\u7684\u4ee3\u7801\u3002\u5185\u6838\u6001\u4ee3\u7801\u7684\u7f16\u5199\u65b9\u5f0f\u548c\u5176\u4ed6\u57fa\u4e8e libbpf \u7684\u7a0b\u5e8f\u5b8c\u5168\u76f8\u540c\uff0c\u4e00\u822c\u6765\u8bf4\u4f1a\u5305\u542b\u4e00\u4e9b\u5168\u5c40\u53d8\u91cf\uff0c\u901a\u8fc7 <code>SEC</code> \u58f0\u660e\u6302\u8f7d\u70b9\u7684 eBPF \u51fd\u6570\uff0c\u4ee5\u53ca\u7528\u4e8e\u4fdd\u5b58\u72b6\u6001\uff0c\u6216\u8005\u5728\u7528\u6237\u6001\u548c\u5185\u6838\u6001\u4e4b\u95f4\u76f8\u4e92\u901a\u4fe1\u7684 map \u5bf9\u8c61\uff08\u6211\u4eec\u8fd8\u5728\u8fdb\u884c\u53e6\u5916\u4e00\u9879\u5de5\u4f5c\uff1abcc to libbpf converter\uff0c\u7b49\u5b83\u5b8c\u6210\u540e\u5c31\u53ef\u4ee5\u4ee5\u8fd9\u79cd\u65b9\u5f0f\u7f16\u8bd1 BCC \u98ce\u683c\u7684 eBPF \u5185\u6838\u6001\u7a0b\u5e8f\uff09\u3002\u5728\u7f16\u5199\u5b8c eBPF \u7a0b\u5e8f\u4e4b\u540e\uff0c\u8fd0\u884c <code>make</code> \u4f1a\u5728 <code>Makefile</code> \u8c03\u7528 clang \u548c llvm-strip \u6784\u5efaBPF\u7a0b\u5e8f\uff0c\u4ee5\u5265\u79bb\u8c03\u8bd5\u4fe1\u606f\uff1a</p> <pre><code>clang -g -O2 -target bpf -D__TARGET_ARCH_x86 -I../../third_party/vmlinux/x86/ -idirafter /usr/local/include -idirafter /usr/include -c bootstrap.bpf.c -o bootstrap.bpf.o\nllvm-strip -g bootstrap.bpf.o # strip useless DWARF info\n</code></pre> <p>\u4e4b\u540e\uff0c\u6211\u4eec\u4f1a\u63d0\u4f9b\u4e00\u4e2a\u4e3a\u4e86 Wasm \u4e13\u95e8\u5b9e\u73b0\u7684 bpftool\uff0c\u7528\u4e8e\u4ece BPF \u7a0b\u5e8f\u751f\u6210C\u5934\u6587\u4ef6\uff1a</p> <pre><code>../../third_party/bpftool/src/bpftool gen skeleton -j bootstrap.bpf.o &gt; bootstrap.skel.h\n</code></pre> <p>\u7531\u4e8e eBPF \u672c\u8eab\u7684\u6240\u6709 C \u5185\u5b58\u5e03\u5c40\u662f\u548c\u5f53\u524d\u6240\u5728\u673a\u5668\u7684\u6307\u4ee4\u96c6\u4e00\u6837\u7684\uff0c\u4f46\u662f wasm \u662f\u6709\u4e00\u5957\u786e\u5b9a\u7684\u5185\u5b58\u5e03\u5c40\uff08\u6bd4\u5982\u5f53\u524d\u6240\u5728\u673a\u5668\u662f 64 \u4f4d\u7684\uff0cWasm \u865a\u62df\u673a\u91cc\u9762\u662f 32 \u4f4d\u7684\uff0cC struct layout \u3001\u6307\u9488\u5bbd\u5ea6\u3001\u5927\u5c0f\u7aef\u7b49\u7b49\u90fd\u53ef\u80fd\u4e0d\u4e00\u6837\uff09\uff0c\u4e3a\u4e86\u786e\u4fdd eBPF \u7a0b\u5e8f\u80fd\u6b63\u786e\u548c Wasm \u4e4b\u95f4\u8fdb\u884c\u76f8\u4e92\u901a\u4fe1\uff0c\u6211\u4eec\u9700\u8981\u5b9a\u5236\u4e00\u4e2a\u4e13\u95e8\u7684 bpftool \u7b49\u5de5\u5177\uff0c\u5b9e\u73b0\u6b63\u786e\u751f\u6210\u53ef\u4ee5\u5728 Wasm \u4e2d\u5de5\u4f5c\u7684\u7528\u6237\u6001\u5f00\u53d1\u6846\u67b6\u3002</p> <p>skel \u5305\u542b\u4e00\u4e2a BPF \u7a0b\u5e8f\u7684skeleton\uff0c\u7528\u4e8e\u64cd\u4f5c BPF \u5bf9\u8c61\uff0c\u5e76\u63a7\u5236 BPF \u7a0b\u5e8f\u7684\u751f\u547d\u5468\u671f\uff0c\u4f8b\u5982\uff1a</p> <pre><code>    struct bootstrap_bpf {\nstruct bpf_object_skeleton *skeleton;\nstruct bpf_object *obj;\nstruct {\nstruct bpf_map *exec_start;\nstruct bpf_map *rb;\nstruct bpf_map *rodata;\n} maps;\nstruct {\nstruct bpf_program *handle_exec;\nstruct bpf_program *handle_exit;\n} progs;\nstruct bootstrap_bpf__rodata {\nunsigned long long min_duration_ns;\n} *rodata;\nstruct bootstrap_bpf__bss {\nuint64_t /* pointer */ name_ptr;\n} *bss;\n};\n</code></pre> <p>\u6211\u4eec\u4f1a\u5c06\u6240\u6709\u6307\u9488\u90fd\u5c06\u6839\u636e eBPF \u7a0b\u5e8f\u76ee\u6807\u6240\u5728\u7684\u6307\u4ee4\u96c6\u7684\u6307\u9488\u5927\u5c0f\u8f6c\u6362\u4e3a\u6574\u6570\uff0c\u4f8b\u5982\uff0c<code>name_ptr</code>\u3002\u6b64\u5916\uff0c\u586b\u5145\u5b57\u8282\u5c06\u660e\u786e\u6dfb\u52a0\u5230\u7ed3\u6784\u4f53\u4e2d\u4ee5\u786e\u4fdd\u7ed3\u6784\u4f53\u5e03\u5c40\u4e0e\u76ee\u6807\u7aef\u76f8\u540c\uff0c\u4f8b\u5982\u4f7f\u7528 <code>char __pad0[4];</code>\u3002\u6211\u4eec\u8fd8\u4f1a\u4f7f\u7528 <code>static_assert</code> \u6765\u786e\u4fdd\u7ed3\u6784\u4f53\u7684\u5185\u5b58\u957f\u5ea6\u548c\u539f\u5148 BTF \u4fe1\u606f\u4e2d\u7684\u7c7b\u578b\u957f\u5ea6\u76f8\u540c\u3002</p>"},{"location":"miscellaneous/manual.zh/#wasm","title":"\u6784\u5efa\u7528\u6237\u6001\u7684 Wasm \u4ee3\u7801\uff0c\u5e76\u83b7\u53d6\u5185\u6838\u6001\u6570\u636e","text":"<p>libbpf \u662f\u4e00\u4e2a C/C++ \u7684 eBPF \u7528\u6237\u6001\u52a0\u8f7d\u548c\u63a7\u5236\u5e93\uff0c\u968f\u7740\u5185\u6838\u4e00\u8d77\u5206\u53d1\uff0c\u51e0\u4e4e\u5df2\u7ecf\u6210\u4e3a eBPF \u7528\u6237\u6001\u4e8b\u5b9e\u4e0a\u7684 API \u6807\u51c6\uff0clibbpf \u4e5f\u652f\u6301 CO-RE(Compile Once \u2013 Run Everywhere) \u7684\u89e3\u51b3\u65b9\u6848\uff0c\u5373\u9884\u7f16\u8bd1\u7684 bpf \u4ee3\u7801\u53ef\u4ee5\u5728\u4e0d\u540c\u5185\u6838\u7248\u672c\u4e0a\u6b63\u5e38\u5de5\u4f5c\uff0c\u800c\u65e0\u9700\u4e3a\u6bcf\u4e2a\u7279\u5b9a\u5185\u6838\u91cd\u65b0\u7f16\u8bd1\u3002\u6211\u4eec\u5e0c\u671b\u5c3d\u53ef\u80fd\u7684\u4fdd\u6301\u4e0e libbpf \u7684\u7528\u6237\u6001 API \u4ee5\u53ca\u884c\u4e3a\u4e00\u81f4\uff0c\u5c3d\u53ef\u80fd\u51cf\u5c11\u5e94\u7528\u8fc1\u79fb\u5230 Wasm \uff08\u5982\u679c\u9700\u8981\u7684\u8bdd\uff09\u7684\u6210\u672c\u3002</p> <p>libbpf-bootstrap \u4e3a\u751f\u6210\u57fa\u4e8e libbpf \u7684 bpf \u7a0b\u5e8f\u63d0\u4f9b\u4e86\u6a21\u677f,\u5f00\u53d1\u8005\u53ef\u4ee5\u5f88\u65b9\u4fbf\u7684\u4f7f\u7528\u8be5\u6a21\u677f\u751f\u6210\u81ea\u5b9a\u4e49\u7684 bpf \u7a0b\u5e8f\u3002\u4e00\u822c\u8bf4\u6765\uff0c\u5728\u975e Wasm \u6c99\u7bb1\u7684\u7528\u6237\u6001\u7a7a\u95f4\uff0c\u4f7f\u7528 libbpf-bootstrap \u811a\u624b\u67b6\uff0c\u53ef\u4ee5\u5feb\u901f\u3001\u8f7b\u677e\u5730\u4f7f\u7528 C/C++\u6784\u5efa BPF \u5e94\u7528\u7a0b\u5e8f\u3002</p> <p>\u7f16\u8bd1\u3001\u6784\u5efa\u548c\u8fd0\u884c eBPF \u7a0b\u5e8f\uff08\u65e0\u8bba\u662f\u91c7\u7528\u4ec0\u4e48\u8bed\u8a00\uff09\uff0c\u901a\u5e38\u5305\u542b\u4ee5\u4e0b\u51e0\u4e2a\u6b65\u9aa4\uff1a</p> <ul> <li>\u7f16\u5199\u5185\u6838\u6001 eBPF \u7a0b\u5e8f\u7684\u4ee3\u7801\uff0c\u4e00\u822c\u4f7f\u7528 C/C++ \u6216 Rust \u8bed\u8a00</li> <li>\u4f7f\u7528 clang \u7f16\u8bd1\u5668\u6216\u8005\u76f8\u5173\u5de5\u5177\u94fe\u7f16\u8bd1 eBPF \u7a0b\u5e8f\uff08\u8981\u5b9e\u73b0\u8de8\u5185\u6838\u7248\u672c\u79fb\u690d\u7684\u8bdd\uff0c\u9700\u8981\u5305\u542b BTF \u4fe1\u606f\uff09\u3002</li> <li>\u5728\u7528\u6237\u6001\u7684\u5f00\u53d1\u7a0b\u5e8f\u4e2d\uff0c\u7f16\u5199\u5bf9\u5e94\u7684\u52a0\u8f7d\u3001\u63a7\u5236\u3001\u6302\u8f7d\u3001\u6570\u636e\u5904\u7406\u903b\u8f91\uff1b</li> <li>\u5728\u5b9e\u9645\u8fd0\u884c\u7684\u9636\u6bb5\uff0c\u4ece\u7528\u6237\u6001\u5c06 eBPF \u7a0b\u5e8f\u52a0\u8f7d\u8fdb\u5165\u5185\u6838\uff0c\u5e76\u5b9e\u9645\u6267\u884c\u3002</li> </ul>"},{"location":"miscellaneous/manual.zh/#bootstrap_1","title":"bootstrap","text":"<p><code>bootstrap</code>\u662f\u4e00\u4e2a\u7b80\u5355\uff08\u4f46\u5b9e\u7528\uff09\u7684BPF\u5e94\u7528\u7a0b\u5e8f\u7684\u4f8b\u5b50\u3002\u5b83\u8ddf\u8e2a\u8fdb\u7a0b\u7684\u542f\u52a8\uff08\u51c6\u786e\u5730\u8bf4\uff0c\u662f <code>exec()</code> \u7cfb\u5217\u7684\u7cfb\u7edf\u8c03\u7528\uff09\u548c\u9000\u51fa\uff0c\u5e76\u53d1\u9001\u5173\u4e8e\u6587\u4ef6\u540d\u3001PID \u548c \u7236 PID \u7684\u6570\u636e\uff0c\u4ee5\u53ca\u9000\u51fa\u72b6\u6001\u548c\u8fdb\u7a0b\u7684\u6301\u7eed\u65f6\u95f4\u3002\u7528<code>-d &lt;min-duration-ms&gt;</code> \u4f60\u53ef\u4ee5\u6307\u5b9a\u8981\u8bb0\u5f55\u7684\u8fdb\u7a0b\u7684\u6700\u5c0f\u6301\u7eed\u65f6\u95f4\u3002</p> <p><code>bootstrap</code> \u662f\u5728 libbpf-bootstrap \u4e2d\uff0c\u6839\u636e BCC \u8f6f\u4ef6\u5305\u4e2d\u7684libbpf-tools\u7684\u7c7b\u4f3c\u601d\u60f3\u521b\u5efa\u7684\uff0c\u4f46\u5b83\u88ab\u8bbe\u8ba1\u6210\u66f4\u72ec\u7acb\u7684\uff0c\u5e76\u4e14\u6709\u66f4\u7b80\u5355\u7684 Makefile \u4ee5\u7b80\u5316\u7528\u6237\u7684\u7279\u6b8a\u9700\u6c42\u3002\u5b83\u6f14\u793a\u4e86\u5178\u578b\u7684BPF\u7279\u6027\uff0c\u5305\u542b\u4f7f\u7528\u591a\u4e2a BPF \u7a0b\u5e8f\u6bb5\u8fdb\u884c\u5408\u4f5c\uff0c\u4f7f\u7528 BPF map \u6765\u7ef4\u62a4\u72b6\u6001\uff0c\u4f7f\u7528 BPF ring buffer \u6765\u53d1\u9001\u6570\u636e\u5230\u7528\u6237\u7a7a\u95f4\uff0c\u4ee5\u53ca\u4f7f\u7528\u5168\u5c40\u53d8\u91cf\u6765\u53c2\u6570\u5316\u5e94\u7528\u7a0b\u5e8f\u884c\u4e3a\u3002</p> <p>\u4ee5\u4e0b\u662f\u6211\u4eec\u4f7f\u7528 Wasm \u7f16\u8bd1\u8fd0\u884c <code>bootstrap</code> \u7684\u4e00\u4e2a\u8f93\u51fa\u793a\u4f8b\uff1a</p> <pre><code>$ sudo sudo ./wasm-bpf bootstrap.wasm -h\nBPF bootstrap demo application.\nIt traces process start and exits and shows associated\ninformation (filename, process duration, PID and PPID, etc).\nUSAGE: ./bootstrap [-d &lt;min-duration-ms&gt;] -v\n$ sudo ./wasm-bpf bootstrap.wasm\nTIME     EVENT COMM             PID     PPID    FILENAME/EXIT CODE\n18:57:58 EXEC  sed              74911   74910   /usr/bin/sed\n18:57:58 EXIT  sed              74911   74910   [0] (2ms)\n18:57:58 EXIT  cat              74912   74910   [0] (0ms)\n18:57:58 EXEC  cat              74913   74910   /usr/bin/cat\n18:57:59 EXIT  cat              74913   74910   [0] (0ms)\n18:57:59 EXEC  cat              74914   74910   /usr/bin/cat\n18:57:59 EXIT  cat              74914   74910   [0] (0ms)\n18:57:59 EXEC  cat              74915   74910   /usr/bin/cat\n18:57:59 EXIT  cat              74915   74910   [0] (1ms)\n18:57:59 EXEC  sleep            74916   74910   /usr/bin/sleep\n</code></pre> <p>\u6211\u4eec\u53ef\u4ee5\u63d0\u4f9b\u4e0e libbpf-bootstrap \u5f00\u53d1\u76f8\u4f3c\u7684\u5f00\u53d1\u4f53\u9a8c\u3002\u53ea\u9700\u8fd0\u884c make \u5373\u53ef\u6784\u5efa wasm \u4e8c\u8fdb\u5236\u6587\u4ef6\uff1a</p> <pre><code>git clone https://github.com/eunomia-bpf/wasm-bpf --recursive\ncd examples/bootstrap\nmake\n</code></pre>"},{"location":"miscellaneous/manual.zh/#ebpf_1","title":"\u7f16\u5199\u5185\u6838\u6001\u7684 eBPF \u7a0b\u5e8f","text":"<p>\u8981\u6784\u5efa\u4e00\u4e2a\u5b8c\u6574\u7684 eBPF \u7a0b\u5e8f\uff0c\u9996\u5148\u8981\u7f16\u5199\u5185\u6838\u6001\u7684 bpf \u4ee3\u7801\u3002\u901a\u5e38\u4f7f\u7528 C \u8bed\u8a00\u7f16\u5199\uff0c\u5e76\u4f7f\u7528 clang \u5b8c\u6210\u7f16\u8bd1\uff1a</p> <pre><code>char LICENSE[] SEC(\"license\") = \"Dual BSD/GPL\";\nstruct {\n__uint(type, BPF_MAP_TYPE_HASH);\n__uint(max_entries, 8192);\n__type(key, pid_t);\n__type(value, u64);\n} exec_start SEC(\".maps\");\nstruct {\n__uint(type, BPF_MAP_TYPE_RINGBUF);\n__uint(max_entries, 256 * 1024);\n} rb SEC(\".maps\");\nconst volatile unsigned long long min_duration_ns = 0;\nconst volatile int *name_ptr;\nSEC(\"tp/sched/sched_process_exec\")\nint handle_exec(struct trace_event_raw_sched_process_exec *ctx)\n{\nstruct task_struct *task;\nunsigned fname_off;\nstruct event *e;\npid_t pid;\nu64 ts;\n....\n</code></pre> <p>\u53d7\u7bc7\u5e45\u6240\u9650\uff0c\u8fd9\u91cc\u6ca1\u6709\u8d34\u51fa\u5b8c\u6574\u7684\u4ee3\u7801\u3002\u5185\u6838\u6001\u4ee3\u7801\u7684\u7f16\u5199\u65b9\u5f0f\u548c\u5176\u4ed6\u57fa\u4e8e libbpf \u7684\u7a0b\u5e8f\u5b8c\u5168\u76f8\u540c\uff0c\u4e00\u822c\u6765\u8bf4\u4f1a\u5305\u542b\u4e00\u4e9b\u5168\u5c40\u53d8\u91cf\uff0c\u901a\u8fc7 <code>SEC</code> \u58f0\u660e\u6302\u8f7d\u70b9\u7684 eBPF \u51fd\u6570\uff0c\u4ee5\u53ca\u7528\u4e8e\u4fdd\u5b58\u72b6\u6001\uff0c\u6216\u8005\u5728\u7528\u6237\u6001\u548c\u5185\u6838\u6001\u4e4b\u95f4\u76f8\u4e92\u901a\u4fe1\u7684 map \u5bf9\u8c61\uff08\u6211\u4eec\u8fd8\u5728\u8fdb\u884c\u53e6\u5916\u4e00\u9879\u5de5\u4f5c\uff1abcc to libbpf converter\uff0c\u7b49\u5b83\u5b8c\u6210\u540e\u5c31\u53ef\u4ee5\u4ee5\u8fd9\u79cd\u65b9\u5f0f\u7f16\u8bd1 BCC \u98ce\u683c\u7684 eBPF \u5185\u6838\u6001\u7a0b\u5e8f\uff09\u3002\u5728\u7f16\u5199\u5b8c eBPF \u7a0b\u5e8f\u4e4b\u540e\uff0c\u8fd0\u884c <code>make</code> \u4f1a\u5728 <code>Makefile</code> \u8c03\u7528 clang \u548c llvm-strip \u6784\u5efaBPF\u7a0b\u5e8f\uff0c\u4ee5\u5265\u79bb\u8c03\u8bd5\u4fe1\u606f\uff1a</p> <pre><code>clang -g -O2 -target bpf -D__TARGET_ARCH_x86 -I../../third_party/vmlinux/x86/ -idirafter /usr/local/include -idirafter /usr/include -c bootstrap.bpf.c -o bootstrap.bpf.o\nllvm-strip -g bootstrap.bpf.o # strip useless DWARF info\n</code></pre> <p>\u4e4b\u540e\uff0c\u6211\u4eec\u4f1a\u63d0\u4f9b\u4e00\u4e2a\u4e3a\u4e86 Wasm \u4e13\u95e8\u5b9e\u73b0\u7684 bpftool\uff0c\u7528\u4e8e\u4ece BPF \u7a0b\u5e8f\u751f\u6210C\u5934\u6587\u4ef6\uff1a</p> <pre><code>../../third_party/bpftool/src/bpftool gen skeleton -j bootstrap.bpf.o &gt; bootstrap.skel.h\n</code></pre> <p>\u7531\u4e8e eBPF \u672c\u8eab\u7684\u6240\u6709 C \u5185\u5b58\u5e03\u5c40\u662f\u548c\u5f53\u524d\u6240\u5728\u673a\u5668\u7684\u6307\u4ee4\u96c6\u4e00\u6837\u7684\uff0c\u4f46\u662f wasm \u662f\u6709\u4e00\u5957\u786e\u5b9a\u7684\u5185\u5b58\u5e03\u5c40\uff08\u6bd4\u5982\u5f53\u524d\u6240\u5728\u673a\u5668\u662f 64 \u4f4d\u7684\uff0cWasm \u865a\u62df\u673a\u91cc\u9762\u662f 32 \u4f4d\u7684\uff0cC struct layout \u3001\u6307\u9488\u5bbd\u5ea6\u3001\u5927\u5c0f\u7aef\u7b49\u7b49\u90fd\u53ef\u80fd\u4e0d\u4e00\u6837\uff09\uff0c\u4e3a\u4e86\u786e\u4fdd eBPF \u7a0b\u5e8f\u80fd\u6b63\u786e\u548c Wasm \u4e4b\u95f4\u8fdb\u884c\u76f8\u4e92\u901a\u4fe1\uff0c\u6211\u4eec\u9700\u8981\u5b9a\u5236\u4e00\u4e2a\u4e13\u95e8\u7684 bpftool \u7b49\u5de5\u5177\uff0c\u5b9e\u73b0\u6b63\u786e\u751f\u6210\u53ef\u4ee5\u5728 Wasm \u4e2d\u5de5\u4f5c\u7684\u7528\u6237\u6001\u5f00\u53d1\u6846\u67b6\u3002</p> <p>skel \u5305\u542b\u4e00\u4e2a BPF \u7a0b\u5e8f\u7684skeleton\uff0c\u7528\u4e8e\u64cd\u4f5c BPF \u5bf9\u8c61\uff0c\u5e76\u63a7\u5236 BPF \u7a0b\u5e8f\u7684\u751f\u547d\u5468\u671f\uff0c\u4f8b\u5982\uff1a</p> <pre><code>    struct bootstrap_bpf {\nstruct bpf_object_skeleton *skeleton;\nstruct bpf_object *obj;\nstruct {\nstruct bpf_map *exec_start;\nstruct bpf_map *rb;\nstruct bpf_map *rodata;\n} maps;\nstruct {\nstruct bpf_program *handle_exec;\nstruct bpf_program *handle_exit;\n} progs;\nstruct bootstrap_bpf__rodata {\nunsigned long long min_duration_ns;\n} *rodata;\nstruct bootstrap_bpf__bss {\nuint64_t /* pointer */ name_ptr;\n} *bss;\n};\n</code></pre> <p>\u6211\u4eec\u4f1a\u5c06\u6240\u6709\u6307\u9488\u90fd\u5c06\u6839\u636e eBPF \u7a0b\u5e8f\u76ee\u6807\u6240\u5728\u7684\u6307\u4ee4\u96c6\u7684\u6307\u9488\u5927\u5c0f\u8f6c\u6362\u4e3a\u6574\u6570\uff0c\u4f8b\u5982\uff0c<code>name_ptr</code>\u3002\u6b64\u5916\uff0c\u586b\u5145\u5b57\u8282\u5c06\u660e\u786e\u6dfb\u52a0\u5230\u7ed3\u6784\u4f53\u4e2d\u4ee5\u786e\u4fdd\u7ed3\u6784\u4f53\u5e03\u5c40\u4e0e\u76ee\u6807\u7aef\u76f8\u540c\uff0c\u4f8b\u5982\u4f7f\u7528 <code>char __pad0[4];</code>\u3002\u6211\u4eec\u8fd8\u4f1a\u4f7f\u7528 <code>static_assert</code> \u6765\u786e\u4fdd\u7ed3\u6784\u4f53\u7684\u5185\u5b58\u957f\u5ea6\u548c\u539f\u5148 BTF \u4fe1\u606f\u4e2d\u7684\u7c7b\u578b\u957f\u5ea6\u76f8\u540c\u3002</p>"},{"location":"miscellaneous/manual.zh/#wasm_1","title":"\u6784\u5efa\u7528\u6237\u6001\u7684 Wasm \u4ee3\u7801\uff0c\u5e76\u83b7\u53d6\u5185\u6838\u6001\u6570\u636e","text":"<p>\u6211\u4eec\u9ed8\u8ba4\u4f7f\u7528 wasi-sdk \u4ece C/C++ \u4ee3\u7801\u6784\u5efa wasm \u4e8c\u8fdb\u5236\u6587\u4ef6\u3002\u60a8\u4e5f\u53ef\u4ee5\u4f7f\u7528 emcc \u5de5\u5177\u94fe\u6765\u6784\u5efa wasm \u4e8c\u8fdb\u5236\u6587\u4ef6\uff0c\u547d\u4ee4\u5e94\u8be5\u662f\u76f8\u4f3c\u7684\u3002\u60a8\u53ef\u4ee5\u8fd0\u884c\u4ee5\u4e0b\u547d\u4ee4\u6765\u5b89\u88c5 wasi-sdk\uff1a</p> <pre><code>wget https://github.com/WebAssembly/wasi-sdk/releases/download/wasi-sdk-17/wasi-sdk-17.0-linux.tar.gz\ntar -zxf wasi-sdk-17.0-linux.tar.gz\nsudo mkdir -p /opt/wasi-sdk/ &amp;&amp; sudo mv wasi-sdk-17.0/* /opt/wasi-sdk/\n</code></pre> <p>\u7136\u540e\u8fd0\u884c <code>make</code> \u4f1a\u5728 <code>Makefile</code> \u4e2d\u4f7f\u7528 wasi-clang \u7f16\u8bd1 C \u4ee3\u7801\uff0c\u751f\u6210 Wasm \u5b57\u8282\u7801\uff1a</p> <pre><code>/opt/wasi-sdk/bin/clang -O2 --sysroot=/opt/wasi-sdk/share/wasi-sysroot -Wl,--allow-undefined -o bootstrap.wasm bootstrap.c\n</code></pre> <p>\u7531\u4e8e\u5bbf\u4e3b\u673a\uff08\u6216 eBPF \u7aef\uff09\u7684 C \u7ed3\u6784\u5e03\u5c40\u53ef\u80fd\u4e0e\u76ee\u6807\uff08Wasm \u7aef\uff09\u7684\u7ed3\u6784\u5e03\u5c40\u4e0d\u540c\uff0c\u56e0\u6b64\u60a8\u53ef\u4ee5\u4f7f\u7528 ecc \u548c\u6211\u4eec\u7684 wasm-bpftool \u751f\u6210\u7528\u6237\u7a7a\u95f4\u4ee3\u7801\u7684 C \u5934\u6587\u4ef6\uff1a</p> <pre><code>ecc bootstrap.h --header-only\n../../third_party/bpftool/src/bpftool btf dump file bootstrap.bpf.o format c -j &gt; bootstrap.wasm.h\n</code></pre> <p>\u4f8b\u5982\uff0c\u539f\u5148\u5185\u6838\u6001\u7684\u5934\u6587\u4ef6\u4e2d\u7ed3\u6784\u4f53\u5b9a\u4e49\u5982\u4e0b\uff1a</p> <pre><code>struct event {\nint pid;\nint ppid;\nunsigned exit_code;\nunsigned long long duration_ns;\nchar comm[TASK_COMM_LEN];\nchar filename[MAX_FILENAME_LEN];\nchar exit_event;\n};\n</code></pre> <p>\u6211\u4eec\u7684\u5de5\u5177\u4f1a\u5c06\u5176\u8f6c\u6362\u4e3a\uff1a</p> <pre><code>struct event {\nint pid;\nint ppid;\nunsigned int exit_code;\nchar __pad0[4];\nunsigned long long duration_ns;\nchar comm[16];\nchar filename[127];\nchar exit_event;\n} __attribute__((packed));\nstatic_assert(sizeof(struct event) == 168, \"Size of event is not 168\");\n</code></pre> <p>\u6ce8\u610f\uff1a\u6b64\u8fc7\u7a0b\u548c\u5de5\u5177\u5e76\u4e0d\u603b\u662f\u5fc5\u9700\u7684\uff0c\u5bf9\u4e8e\u7b80\u5355\u7684\u5e94\u7528\uff0c\u4f60\u53ef\u4ee5\u624b\u52a8\u5b8c\u6210\u3002\u5bf9\u4e8e\u5185\u6838\u6001\u548c Wasm \u5e94\u7528\u90fd\u4f7f\u7528 C/C++ \u8bed\u8a00\u7684\u60c5\u51b5\u4e0b\uff0c\u4f60\u53ef\u4ee5\u624b\u52a8\u7f16\u5199\u6240\u6709\u4e8b\u4ef6\u7ed3\u6784\u4f53\u5b9a\u4e49\uff0c\u4f7f\u7528 <code>__attribute__((packed))</code> \u907f\u514d\u586b\u5145\u5b57\u8282\uff0c\u5e76\u5728\u4e3b\u673a\u548c wasm \u7aef\u4e4b\u95f4\u8f6c\u6362\u6240\u6709\u6307\u9488\u4e3a\u6b63\u786e\u7684\u6574\u6570\u3002\u6240\u6709\u7c7b\u578b\u5fc5\u987b\u5728 wasm \u4e2d\u5b9a\u4e49\u4e0e\u4e3b\u673a\u7aef\u76f8\u540c\u7684\u5927\u5c0f\u548c\u5e03\u5c40\u3002</p> <p>\u5bf9\u4e8e\u590d\u6742\u7684\u7a0b\u5e8f\uff0c\u624b\u52a8\u786e\u8ba4\u5185\u5b58\u5e03\u5c40\u7684\u6b63\u786e\u662f\u5206\u56f0\u96be\uff0c\u56e0\u6b64\u6211\u4eec\u521b\u5efa\u4e86 wasm \u7279\u5b9a\u7684 <code>bpftool</code>\uff0c\u7528\u4e8e\u4ece <code>BTF</code> \u4fe1\u606f\u4e2d\u751f\u6210\u5305\u542b\u6240\u6709\u7c7b\u578b\u5b9a\u4e49\u548c\u6b63\u786e\u7ed3\u6784\u4f53\u5e03\u5c40\u7684 C \u5934\u6587\u4ef6\uff0c\u4ee5\u4fbf\u7528\u6237\u7a7a\u95f4\u4ee3\u7801\u4f7f\u7528\u3002\u53ef\u4ee5\u901a\u8fc7\u7c7b\u4f3c\u7684\u65b9\u6848\uff0c\u4e00\u6b21\u6027\u5c06 eBPF \u7a0b\u5e8f\u4e2d\u6240\u6709\u7684\u7ed3\u6784\u4f53\u5b9a\u4e49\u8f6c\u6362\u4e3a Wasm \u7aef\u7684\u5185\u5b58\u5e03\u5c40\uff0c\u5e76\u786e\u4fdd\u5927\u5c0f\u7aef\u4e00\u81f4\uff0c\u5373\u53ef\u6b63\u786e\u8bbf\u95ee\u3002</p> <p>\u5bf9\u4e8e Wasm \u4e2d\u4e0d\u662f\u7531 C \u8bed\u8a00\u8fdb\u884c\u5f00\u53d1\u7684\u60c5\u51b5\u4e0b\uff0c\u501f\u52a9 Wasm \u7684\u7ec4\u4ef6\u6a21\u578b\uff0c\u6211\u4eec\u8fd8\u53ef\u4ee5\u5c06\u8fd9\u4e9b BTF \u4fe1\u606f\u7ed3\u6784\u4f53\u5b9a\u4e49\u4f5c\u4e3a wit \u7c7b\u578b\u58f0\u660e\u8f93\u51fa\uff0c\u7136\u540e\u5728\u7528\u6237\u7a7a\u95f4\u4ee3\u7801\u4e2d\u4f7f\u7528 wit-bindgen \u5de5\u5177\u4e00\u6b21\u6027\u751f\u6210\u591a\u79cd\u8bed\u8a00\uff08\u5982 C/C++/Rust/Go\uff09\u7684\u7c7b\u578b\u5b9a\u4e49\u3002\u8fd9\u90e8\u5206\u4f1a\u5728\u5173\u4e8e\u5982\u4f55\u4f7f\u7528 Rust \u5728 Wasm \u4e2d\u7f16\u5199 eBPF \u7a0b\u5e8f\u7684\u90e8\u5206\u8be6\u7ec6\u63cf\u8ff0\uff0c\u6211\u4eec\u4e5f\u4f1a\u5c06\u8fd9\u4e9b\u6b65\u9aa4\u548c\u5de5\u5177\u94fe\u7ee7\u7eed\u5b8c\u5584\uff0c\u4ee5\u6539\u8fdb Wasm-bpf \u7a0b\u5e8f\u7684\u7f16\u7a0b\u4f53\u9a8c\u3002</p> <p>\u6211\u4eec\u4e3a wasm \u7a0b\u5e8f\u63d0\u4f9b\u4e86\u4e00\u4e2a\u4ec5\u5305\u542b\u5934\u6587\u4ef6\u7684 libbpf API \u5e93\uff0c\u60a8\u53ef\u4ee5\u5728 libbpf-wasm.h\uff08wasm-include/libbpf-wasm.h\uff09\u4e2d\u627e\u5230\u5b83\uff0c\u5b83\u5305\u542b\u4e86\u4e00\u90e8\u5206 libbpf \u5e38\u7528\u7684\u7528\u6237\u6001 API \u548c\u7c7b\u578b\u5b9a\u4e49\u3002Wasm \u7a0b\u5e8f\u53ef\u4ee5\u4f7f\u7528 libbpf API \u64cd\u4f5c BPF \u5bf9\u8c61\uff0c\u4f8b\u5982\uff1a</p> <pre><code>/* Load and verify BPF application */\nskel = bootstrap_bpf__open();\n/* Parameterize BPF code with minimum duration parameter */\nskel-&gt;rodata-&gt;min_duration_ns = env.min_duration_ms * 1000000ULL;\n/* Load &amp; verify BPF programs */\nerr = bootstrap_bpf__load(skel);\n/* Attach tracepoints */\nerr = bootstrap_bpf__attach(skel);\n</code></pre> <p>rodata \u90e8\u5206\u7528\u4e8e\u5b58\u50a8 BPF \u7a0b\u5e8f\u4e2d\u7684\u5e38\u91cf\uff0c\u8fd9\u4e9b\u503c\u5c06\u5728 bpftool gen skeleton \u7684\u65f6\u5019\u7531\u4ee3\u7801\u751f\u6210\u6620\u5c04\u5230 object \u4e2d\u6b63\u786e\u7684\u504f\u79fb\u91cf,\u7136\u540e\u5728 open \u4e4b\u540e\u901a\u8fc7\u5185\u5b58\u6620\u5c04\u4fee\u6539\u5bf9\u5e94\u7684\u503c\uff0c\u56e0\u6b64\u4e0d\u9700\u8981\u5728 Wasm \u4e2d\u7f16\u8bd1 libelf \u5e93\uff0c\u8fd0\u884c\u65f6\u4ecd\u53ef\u52a8\u6001\u52a0\u8f7d\u548c\u64cd\u4f5c BPF \u5bf9\u8c61\u3002</p> <p>Wasm \u7aef\u7684 C \u4ee3\u7801\u4e0e\u672c\u5730 libbpf \u4ee3\u7801\u7565\u6709\u4e0d\u540c\uff0c\u4f46\u5b83\u53ef\u4ee5\u4ece eBPF \u7aef\u63d0\u4f9b\u5927\u90e8\u5206\u529f\u80fd\uff0c\u4f8b\u5982\uff0c\u4ece\u73af\u5f62\u7f13\u51b2\u533a\u6216 perf \u7f13\u51b2\u533a\u8f6e\u8be2\uff0c\u4ece Wasm \u7aef\u548c eBPF \u7aef\u8bbf\u95ee\u6620\u5c04\uff0c\u52a0\u8f7d\u3001\u9644\u52a0\u548c\u5206\u79bb BPF \u7a0b\u5e8f\u7b49\u3002\u5b83\u53ef\u4ee5\u652f\u6301\u5927\u91cf\u7684 eBPF \u7a0b\u5e8f\u7c7b\u578b\u548c\u6620\u5c04\uff0c\u6db5\u76d6\u4ece\u8ddf\u8e2a\u3001\u7f51\u7edc\u3001\u5b89\u5168\u7b49\u65b9\u9762\u7684\u5927\u591a\u6570 eBPF \u7a0b\u5e8f\u7684\u4f7f\u7528\u573a\u666f\u3002</p> <p>\u7531\u4e8e Wasm \u7aef\u7f3a\u5c11\u4e00\u4e9b\u529f\u80fd\uff0c\u4f8b\u5982 signal handler \u8fd8\u4e0d\u652f\u6301\uff082023\u5e742\u6708\uff09\uff0c\u539f\u59cb\u7684C\u4ee3\u7801\u6709\u53ef\u80fd\u65e0\u6cd5\u76f4\u63a5\u7f16\u8bd1\u4e3a wasm\uff0c\u60a8\u9700\u8981\u7a0d\u5fae\u4fee\u6539\u4ee3\u7801\u4ee5\u4f7f\u5176\u5de5\u4f5c\u3002\u6211\u4eec\u5c06\u5c3d\u6700\u5927\u52aa\u529b\u4f7f wasm \u7aef\u7684 libbpf API \u4e0e\u901a\u5e38\u5728\u7528\u6237\u7a7a\u95f4\u8fd0\u884c\u7684 libbpf API\u5c3d\u53ef\u80fd\u76f8\u4f3c\uff0c\u4ee5\u4fbf\u7528\u6237\u7a7a\u95f4\u4ee3\u7801\u53ef\u4ee5\u5728\u672a\u6765\u76f4\u63a5\u7f16\u8bd1\u4e3a wasm\u3002\u6211\u4eec\u8fd8\u5c06\u5c3d\u5feb\u63d0\u4f9b\u66f4\u591a\u8bed\u8a00\u7ed1\u5b9a\uff08Go\u7b49\uff09\u7684 wasm \u4fa7 eBPF \u7a0b\u5e8f\u5f00\u53d1\u5e93\u3002</p> <p>\u53ef\u4ee5\u5728\u7528\u6237\u6001\u7a0b\u5e8f\u4e2d\u4f7f\u7528 polling API \u83b7\u53d6\u5185\u6838\u6001\u4e0a\u4f20\u7684\u6570\u636e\u3002\u5b83\u5c06\u662f ring buffer \u548c perf buffer \u7684\u4e00\u4e2a\u5c01\u88c5\uff0c\u7528\u6237\u7a7a\u95f4\u4ee3\u7801\u53ef\u4ee5\u4f7f\u7528\u76f8\u540c\u7684 API \u4ece\u73af\u5f62\u7f13\u51b2\u533a\u6216\u6027\u80fd\u7f13\u51b2\u533a\u4e2d\u8f6e\u8be2\u4e8b\u4ef6\uff0c\u5177\u4f53\u53d6\u51b3\u4e8eBPF\u7a0b\u5e8f\u4e2d\u6307\u5b9a\u7684\u7c7b\u578b\u3002\u4f8b\u5982\uff0c\u73af\u5f62\u7f13\u51b2\u533a\u8f6e\u8be2\u5b9a\u4e49\u4e3a<code>BPF_MAP_TYPE_RINGBUF</code>\uff1a</p> <pre><code>struct {\n__uint(type, BPF_MAP_TYPE_RINGBUF);\n__uint(max_entries, 256 * 1024);\n} rb SEC(\".maps\");\n</code></pre> <p>\u4f60\u53ef\u4ee5\u5728\u7528\u6237\u6001\u4f7f\u7528\u4ee5\u4e0b\u4ee3\u7801\u4ece ring buffer \u4e2d\u8f6e\u8be2\u4e8b\u4ef6\uff1a</p> <pre><code>rb = bpf_buffer__open(skel-&gt;maps.rb, handle_event, NULL);\n/* Process events */\nprintf(\"%-8s %-5s %-16s %-7s %-7s %s\\n\", \"TIME\", \"EVENT\", \"COMM\", \"PID\",\n\"PPID\", \"FILENAME/EXIT CODE\");\nwhile (!exiting) {\n// poll buffer\nerr = bpf_buffer__poll(rb, 100 /* timeout, ms */);\n</code></pre> <p>ring buffer polling \u4e0d\u9700\u8981\u5e8f\u5217\u5316\u5f00\u9500\u3002bpf_buffer__poll API \u5c06\u8c03\u7528 handle_event \u56de\u8c03\u51fd\u6570\u6765\u5904\u7406\u73af\u5f62\u7f13\u51b2\u533a\u4e2d\u7684\u4e8b\u4ef6\u6570\u636e\uff1a</p> <pre><code>static int\nhandle_event(void *ctx, void *data, size_t data_sz)\n{\nconst struct event *e = data;\n...\nif (e-&gt;exit_event) {\nprintf(\"%-8s %-5s %-16s %-7d %-7d [%u]\", ts, \"EXIT\", e-&gt;comm, e-&gt;pid,\ne-&gt;ppid, e-&gt;exit_code);\nif (e-&gt;duration_ns)\nprintf(\" (%llums)\", e-&gt;duration_ns / 1000000);\nprintf(\"\\n\");\n}\n...\nreturn 0;\n}\n</code></pre> <p>\u8fd0\u884c\u65f6\u57fa\u4e8e libbpf CO-RE\uff08Compile Once, Run Everywhere\uff09API\uff0c\u7528\u4e8e\u5c06 bpf \u5bf9\u8c61\u52a0\u8f7d\u5230\u5185\u6838\u4e2d\uff0c\u56e0\u6b64 wasm-bpf \u7a0b\u5e8f\u4e0d\u53d7\u5b83\u7f16\u8bd1\u7684\u5185\u6838\u7248\u672c\u7684\u5f71\u54cd\uff0c\u53ef\u4ee5\u5728\u4efb\u4f55\u652f\u6301 BPF CO-RE \u7684\u5185\u6838\u7248\u672c\u4e0a\u8fd0\u884c\u3002</p>"},{"location":"miscellaneous/manual.zh/#ebpf-map","title":"\u4ece\u7528\u6237\u6001\u7a0b\u5e8f\u4e2d\u8bbf\u95ee\u548c\u66f4\u65b0 eBPF \u7a0b\u5e8f\u7684 map \u6570\u636e","text":"<p>runqlat \u662f\u4e00\u4e2a\u66f4\u590d\u6742\u7684\u793a\u4f8b\uff0c\u8fd9\u4e2a\u7a0b\u5e8f\u901a\u8fc7\u76f4\u65b9\u56fe\u5c55\u793a\u8c03\u5ea6\u5668\u8fd0\u884c\u961f\u5217\u5ef6\u8fdf\uff0c\u7ed9\u6211\u4eec\u5c55\u73b0\u4e86\u4efb\u52a1\u7b49\u4e86\u591a\u4e45\u624d\u80fd\u8fd0\u884c\u3002</p> <pre><code>$ sudo ./wasm-bpf runqlat.wasm -h\nSummarize run queue (scheduler) latency as a histogram.\nUSAGE: runqlat [--help] [interval] [count]\nEXAMPLES:\n    runqlat         # summarize run queue latency as a histogram\n    runqlat 1 10    # print 1 second summaries, 10 times\n$ sudo ./wasm-bpf runqlat.wasm 1\nTracing run queue latency... Hit Ctrl-C to end.\n     usecs               : count    distribution\n         0 -&gt; 1          : 72       |*****************************           |\n         2 -&gt; 3          : 93       |*************************************   |\n         4 -&gt; 7          : 98       |****************************************|\n         8 -&gt; 15         : 96       |*************************************** |\n        16 -&gt; 31         : 38       |***************                         |\n        32 -&gt; 63         : 4        |*                                       |\n        64 -&gt; 127        : 5        |**                                      |\n       128 -&gt; 255        : 6        |**                                      |\n       256 -&gt; 511        : 0        |                                        |\n       512 -&gt; 1023       : 0        |                                        |\n      1024 -&gt; 2047       : 0        |                                        |\n      2048 -&gt; 4095       : 1        |                                        |\n</code></pre> <p>runqlat \u4e2d\u4f7f\u7528 <code>map</code> API \u6765\u4ece\u7528\u6237\u6001\u8bbf\u95ee\u5185\u6838\u91cc\u7684 <code>map</code> \u5e76\u76f4\u63a5\u8bfb\u53d6\u6570\u636e\uff0c\u4f8b\u5982\uff1a</p> <pre><code>    while (!bpf_map_get_next_key(fd, &amp;lookup_key, &amp;next_key)) {\nerr = bpf_map_lookup_elem(fd, &amp;next_key, &amp;hist);\n...\nlookup_key = next_key;\n}\nlookup_key = -2;\nwhile (!bpf_map_get_next_key(fd, &amp;lookup_key, &amp;next_key)) {\nerr = bpf_map_delete_elem(fd, &amp;next_key);\n...\nlookup_key = next_key;\n}\n</code></pre> <p>\u8fd0\u884c\u65f6 wasm \u4ee3\u7801\u5c06\u4f1a\u4f7f\u7528\u5171\u4eab\u5185\u5b58\u6765\u8bbf\u95ee\u5185\u6838 map\uff0c\u5185\u6838\u6001\u53ef\u4ee5\u76f4\u63a5\u628a\u6570\u636e\u62f7\u8d1d\u5230\u7528\u6237\u6001 Wasm \u865a\u62df\u673a\u7684\u5806\u6808\u4e2d\uff0c\u800c\u4e0d\u9700\u8981\u9762\u5bf9\u7528\u6237\u6001\u4e3b\u673a\u4fa7\u7a0b\u5e8f\u548c Wasm \u8fd0\u884c\u65f6\u4e4b\u95f4\u7684\u989d\u5916\u62f7\u8d1d\u5f00\u9500\u3002\u540c\u6837\uff0c\u5bf9\u4e8e Wasm \u865a\u62df\u673a\u548c\u5185\u6838\u6001\u4e4b\u95f4\u5171\u4eab\u7684\u7c7b\u578b\u5b9a\u4e49\uff0c\u9700\u8981\u7ecf\u8fc7\u4ed4\u7ec6\u68c0\u67e5\u4ee5\u786e\u4fdd\u5b83\u4eec\u5728 Wasm \u548c\u5185\u6838\u6001\u4e2d\u7684\u7c7b\u578b\u662f\u4e00\u81f4\u7684\u3002</p> <p>\u53ef\u4ee5\u4f7f\u7528 <code>bpf_map_update_elem</code> \u5728\u7528\u6237\u6001\u7a0b\u5e8f\u5185\u66f4\u65b0\u5185\u6838\u7684 eBPF map\uff0c\u6bd4\u5982:</p> <pre><code>        cg_map_fd = bpf_map__fd(obj-&gt;maps.cgroup_map);\ncgfd = open(env.cgroupspath, O_RDONLY);\nif (cgfd &lt; 0) {\n...\n}\nif (bpf_map_update_elem(cg_map_fd, &amp;idx, &amp;cgfd, BPF_ANY)) {\n...\n}\n</code></pre> <p>\u56e0\u6b64\u5185\u6838\u7684 eBPF \u7a0b\u5e8f\u53ef\u4ee5\u4ece Wasm \u4fa7\u7684\u7a0b\u5e8f\u83b7\u53d6\u914d\u7f6e\uff0c\u6216\u8005\u5728\u8fd0\u884c\u7684\u65f6\u5019\u63a5\u6536\u6d88\u606f\u3002</p>"},{"location":"miscellaneous/manual.zh/#ebpf-map_1","title":"\u4ece\u7528\u6237\u6001\u7a0b\u5e8f\u4e2d\u8bbf\u95ee\u548c\u66f4\u65b0 eBPF \u7a0b\u5e8f\u7684 map \u6570\u636e","text":"<p>runqlat \u662f\u4e00\u4e2a\u66f4\u590d\u6742\u7684\u793a\u4f8b\uff0c\u8fd9\u4e2a\u7a0b\u5e8f\u901a\u8fc7\u76f4\u65b9\u56fe\u5c55\u793a\u8c03\u5ea6\u5668\u8fd0\u884c\u961f\u5217\u5ef6\u8fdf\uff0c\u7ed9\u6211\u4eec\u5c55\u73b0\u4e86\u4efb\u52a1\u7b49\u4e86\u591a\u4e45\u624d\u80fd\u8fd0\u884c\u3002</p> <pre><code>$ sudo ./wasm-bpf runqlat.wasm -h\nSummarize run queue (scheduler) latency as a histogram.\nUSAGE: runqlat [--help] [interval] [count]\nEXAMPLES:\n    runqlat         # summarize run queue latency as a histogram\n    runqlat 1 10    # print 1 second summaries, 10 times\n$ sudo ./wasm-bpf runqlat.wasm 1\nTracing run queue latency... Hit Ctrl-C to end.\n     usecs               : count    distribution\n         0 -&gt; 1          : 72       |*****************************           |\n         2 -&gt; 3          : 93       |*************************************   |\n         4 -&gt; 7          : 98       |****************************************|\n         8 -&gt; 15         : 96       |*************************************** |\n        16 -&gt; 31         : 38       |***************                         |\n        32 -&gt; 63         : 4        |*                                       |\n        64 -&gt; 127        : 5        |**                                      |\n       128 -&gt; 255        : 6        |**                                      |\n       256 -&gt; 511        : 0        |                                        |\n       512 -&gt; 1023       : 0        |                                        |\n      1024 -&gt; 2047       : 0        |                                        |\n      2048 -&gt; 4095       : 1        |                                        |\n</code></pre> <p>runqlat \u4e2d\u4f7f\u7528 <code>map</code> API \u6765\u4ece\u7528\u6237\u6001\u8bbf\u95ee\u5185\u6838\u91cc\u7684 <code>map</code> \u5e76\u76f4\u63a5\u8bfb\u53d6\u6570\u636e\uff0c\u4f8b\u5982\uff1a</p> <pre><code>    while (!bpf_map_get_next_key(fd, &amp;lookup_key, &amp;next_key)) {\nerr = bpf_map_lookup_elem(fd, &amp;next_key, &amp;hist);\n...\nlookup_key = next_key;\n}\nlookup_key = -2;\nwhile (!bpf_map_get_next_key(fd, &amp;lookup_key, &amp;next_key)) {\nerr = bpf_map_delete_elem(fd, &amp;next_key);\n...\nlookup_key = next_key;\n}\n</code></pre> <p>\u8fd0\u884c\u65f6 wasm \u4ee3\u7801\u5c06\u4f1a\u4f7f\u7528\u5171\u4eab\u5185\u5b58\u6765\u8bbf\u95ee\u5185\u6838 map\uff0c\u5185\u6838\u6001\u53ef\u4ee5\u76f4\u63a5\u628a\u6570\u636e\u62f7\u8d1d\u5230\u7528\u6237\u6001 Wasm \u865a\u62df\u673a\u7684\u5806\u6808\u4e2d\uff0c\u800c\u4e0d\u9700\u8981\u9762\u5bf9\u7528\u6237\u6001\u4e3b\u673a\u4fa7\u7a0b\u5e8f\u548c Wasm \u8fd0\u884c\u65f6\u4e4b\u95f4\u7684\u989d\u5916\u62f7\u8d1d\u5f00\u9500\u3002\u540c\u6837\uff0c\u5bf9\u4e8e Wasm \u865a\u62df\u673a\u548c\u5185\u6838\u6001\u4e4b\u95f4\u5171\u4eab\u7684\u7c7b\u578b\u5b9a\u4e49\uff0c\u9700\u8981\u7ecf\u8fc7\u4ed4\u7ec6\u68c0\u67e5\u4ee5\u786e\u4fdd\u5b83\u4eec\u5728 Wasm \u548c\u5185\u6838\u6001\u4e2d\u7684\u7c7b\u578b\u662f\u4e00\u81f4\u7684\u3002</p> <p>\u53ef\u4ee5\u4f7f\u7528 <code>bpf_map_update_elem</code> \u5728\u7528\u6237\u6001\u7a0b\u5e8f\u5185\u66f4\u65b0\u5185\u6838\u7684 eBPF map\uff0c\u6bd4\u5982:</p> <pre><code>        cg_map_fd = bpf_map__fd(obj-&gt;maps.cgroup_map);\ncgfd = open(env.cgroupspath, O_RDONLY);\nif (cgfd &lt; 0) {\n...\n}\nif (bpf_map_update_elem(cg_map_fd, &amp;idx, &amp;cgfd, BPF_ANY)) {\n...\n}\n</code></pre> <p>\u56e0\u6b64\u5185\u6838\u7684 eBPF \u7a0b\u5e8f\u53ef\u4ee5\u4ece Wasm \u4fa7\u7684\u7a0b\u5e8f\u83b7\u53d6\u914d\u7f6e\uff0c\u6216\u8005\u5728\u8fd0\u884c\u7684\u65f6\u5019\u63a5\u6536\u6d88\u606f\u3002</p>"},{"location":"miscellaneous/manual.zh/#socket-filter-lsm","title":"\u66f4\u591a\u7684\u4f8b\u5b50\uff1asocket filter \u548c lsm","text":"<p>\u5728\u4ed3\u5e93\u4e2d\uff0c\u6211\u4eec\u8fd8\u63d0\u4f9b\u4e86\u66f4\u591a\u7684\u793a\u4f8b\uff0c\u4f8b\u5982\u4f7f\u7528 socket filter \u76d1\u63a7\u548c\u8fc7\u6ee4\u6570\u636e\u5305\uff1a</p> <pre><code>SEC(\"socket\")\nint socket_handler(struct __sk_buff *skb)\n{\nstruct so_event *e;\n__u8 verlen;\n__u16 proto;\n__u32 nhoff = ETH_HLEN;\nbpf_skb_load_bytes(skb, 12, &amp;proto, 2);\n...\nbpf_skb_load_bytes(skb, nhoff + 0, &amp;verlen, 1);\nbpf_skb_load_bytes(skb, nhoff + ((verlen &amp; 0xF) &lt;&lt; 2), &amp;(e-&gt;ports), 4);\ne-&gt;pkt_type = skb-&gt;pkt_type;\ne-&gt;ifindex = skb-&gt;ifindex;\nbpf_ringbuf_submit(e, 0);\nreturn skb-&gt;len;\n}\n</code></pre> <p>Linux Security Modules\uff08LSM\uff09\u662f\u4e00\u4e2a\u57fa\u4e8e\u94a9\u5b50\u7684\u6846\u67b6\uff0c\u7528\u4e8e\u5728Linux\u5185\u6838\u4e2d\u5b9e\u73b0\u5b89\u5168\u7b56\u7565\u548c\u5f3a\u5236\u8bbf\u95ee\u63a7\u5236\u3002\u76f4\u5230\u73b0\u5728\uff0c\u80fd\u591f\u5b9e\u73b0\u5b9e\u65bd\u5b89\u5168\u7b56\u7565\u76ee\u6807\u7684\u65b9\u5f0f\u53ea\u6709\u4e24\u79cd\u9009\u62e9\uff0c\u914d\u7f6e\u73b0\u6709\u7684LSM\u6a21\u5757\uff08\u5982AppArmor\u3001SELinux\uff09\uff0c\u6216\u7f16\u5199\u81ea\u5b9a\u4e49\u5185\u6838\u6a21\u5757\u3002</p> <p>Linux Kernel 5.7 \u5f15\u5165\u4e86\u7b2c\u4e09\u79cd\u65b9\u5f0f\uff1aLSM eBPF\u3002LSM BPF \u5141\u8bb8\u5f00\u53d1\u4eba\u5458\u7f16\u5199\u81ea\u5b9a\u4e49\u7b56\u7565\uff0c\u800c\u65e0\u9700\u914d\u7f6e\u6216\u52a0\u8f7d\u5185\u6838\u6a21\u5757\u3002LSM BPF \u7a0b\u5e8f\u5728\u52a0\u8f7d\u65f6\u88ab\u9a8c\u8bc1\uff0c\u7136\u540e\u5728\u8c03\u7528\u8def\u5f84\u4e2d\uff0c\u5230\u8fbeLSM\u94a9\u5b50\u65f6\u88ab\u6267\u884c\u3002\u4f8b\u5982\uff0c\u6211\u4eec\u53ef\u4ee5\u5728 Wasm \u8f7b\u91cf\u7ea7\u5bb9\u5668\u4e2d\uff0c\u4f7f\u7528 lsm \u9650\u5236\u6587\u4ef6\u7cfb\u7edf\u64cd\u4f5c\uff1a</p> <pre><code>// all lsm the hook point refer https://www.kernel.org/doc/html/v5.2/security/LSM.html\nSEC(\"lsm/path_rmdir\")\nint path_rmdir(const struct path *dir, struct dentry *dentry) {\nchar comm[16];\nbpf_get_current_comm(comm, sizeof(comm));\nunsigned char dir_name[] = \"can_not_rm\";\nunsigned char d_iname[32];\nbpf_probe_read_kernel(&amp;d_iname[0], sizeof(d_iname),\n&amp;(dir-&gt;dentry-&gt;d_iname[0]));\nbpf_printk(\"comm %s try to rmdir %s\", comm, d_iname);\nfor (int i = 0;i&lt;sizeof(dir_name);i++){\nif (d_iname[i]!=dir_name[i]){\nreturn 0;\n}\n}\nreturn -1;\n}\n</code></pre>"},{"location":"miscellaneous/manual.zh/#_1","title":"\u6f14\u793a\u89c6\u9891","text":"<p>\u6211\u4eec\u4e5f\u6709\u4e00\u4e2a\u5728 B \u7ad9\u4e0a\u7684\u6f14\u793a\u89c6\u9891\uff0c\u6f14\u793a\u4e86\u5982\u4f55\u4ece bcc/libbpf-tools \u4e2d\u79fb\u690d\u4e00\u4e2a eBPF \u5de5\u5177\u7a0b\u5e8f\u5230 eunomia-bpf \u4e2d\uff0c\u5e76\u4e14\u4f7f\u7528 Wasm \u6216 JSON \u6587\u4ef6\u6765\u5206\u53d1\u3001\u52a0\u8f7d eBPF \u7a0b\u5e8f\uff1ahttps://www.bilibili.com/video/BV1JN4y1A76k</p> <p><code>ecli</code> \u662f\u57fa\u4e8e\u6211\u4eec\u5e95\u5c42\u7684 eunomia-bpf \u5e93\u548c\u8fd0\u884c\u65f6\u5b9e\u73b0\u7684\u4e00\u4e2a\u7b80\u5355\u7684\u547d\u4ee4\u884c\u5de5\u5177\u3002\u6211\u4eec\u7684\u9879\u76ee\u67b6\u6784\u5982\u4e0b\u56fe\u6240\u793a\uff1a</p> <p></p> <p><code>ecli</code> \u5de5\u5177\u57fa\u4e8e <code>ewasm</code> \u5e93\u5b9e\u73b0\uff0c<code>ewasm</code> \u5e93\u5305\u542b\u4e00\u4e2a WAMR(wasm-micro-runtime) \u8fd0\u884c\u65f6\uff0c\u4ee5\u53ca\u57fa\u4e8e libbpf \u5e93\u6784\u5efa\u7684 eBPF \u52a8\u6001\u88c5\u8f7d\u6a21\u5757\u3002\u5927\u81f4\u6765\u8bf4\uff0c\u6211\u4eec\u5728 <code>Wasm</code> \u8fd0\u884c\u65f6\u548c\u7528\u6237\u6001\u7684 <code>libbpf</code> \u4e2d\u95f4\u591a\u52a0\u4e86\u4e00\u5c42\u62bd\u8c61\u5c42\uff08<code>eunomia-bpf</code> \u5e93\uff09\uff0c\u4f7f\u5f97\u4e00\u6b21\u7f16\u8bd1\u3001\u5230\u5904\u8fd0\u884c\u7684 eBPF \u4ee3\u7801\u53ef\u4ee5\u4ece JSON \u5bf9\u8c61\u4e2d\u52a8\u6001\u52a0\u8f7d\u3002JSON \u5bf9\u8c61\u4f1a\u5728\u7f16\u8bd1\u65f6\u88ab\u5305\u542b\u5728 Wasm \u6a21\u5757\u4e2d\uff0c\u56e0\u6b64\u5728\u8fd0\u884c\u65f6\uff0c\u6211\u4eec\u53ef\u4ee5\u901a\u8fc7\u89e3\u6790 JSON \u5bf9\u8c61\u6765\u83b7\u53d6 eBPF \u7a0b\u5e8f\u7684\u4fe1\u606f\uff0c\u7136\u540e\u52a8\u6001\u52a0\u8f7d eBPF \u7a0b\u5e8f\u3002</p> <p>\u4f7f\u7528 Wasm \u6216 JSON \u7f16\u8bd1\u5206\u53d1 eBPF \u7a0b\u5e8f\u7684\u6d41\u7a0b\u56fe\u5927\u81f4\u5982\u4e0b\uff1a</p> <p></p> <p>\u5927\u81f4\u6765\u8bf4\uff0c\u6574\u4e2a eBPF \u7a0b\u5e8f\u7684\u7f16\u5199\u548c\u52a0\u8f7d\u5206\u4e3a\u4e09\u4e2a\u90e8\u5206\uff1a</p> <ol> <li>\u7528 eunomia-cc \u5de5\u5177\u94fe\u5c06\u5185\u6838\u7684 eBPF \u4ee3\u7801\u9aa8\u67b6\u548c\u5b57\u8282\u7801\u7f16\u8bd1\u4e3a JSON \u683c\u5f0f</li> <li>\u5728\u7528\u6237\u6001\u5f00\u53d1\u7684\u9ad8\u7ea7\u8bed\u8a00\uff08\u4f8b\u5982 C \u8bed\u8a00\uff09\u4e2d\u5d4c\u5165 JSON \u6570\u636e\uff0c\u5e76\u63d0\u4f9b\u4e00\u4e9b API \u7528\u4e8e\u64cd\u4f5c JSON \u5f62\u6001\u7684 eBPF \u7a0b\u5e8f\u9aa8\u67b6</li> <li>\u5c06\u7528\u6237\u6001\u7a0b\u5e8f\u548c JSON \u6570\u636e\u4e00\u8d77\u7f16\u8bd1\u4e3a Wasm \u5b57\u8282\u7801\u5e76\u6253\u5305\u4e3a Wasm \u6a21\u5757\uff0c\u7136\u540e\u5728\u76ee\u6807\u673a\u5668\u4e0a\u52a0\u8f7d\u5e76\u8fd0\u884c Wasm \u7a0b\u5e8f</li> <li>\u4ece Wasm \u6a21\u5757\u4e2d\u52a0\u8f7d\u5185\u5d4c\u7684 JSON \u6570\u636e\uff0c\u7528 eunomia-bpf \u5e93\u52a8\u6001\u88c5\u8f7d\u548c\u914d\u7f6e eBPF \u7a0b\u5e8f\u9aa8\u67b6\u3002</li> </ol> <p>\u6211\u4eec\u9700\u8981\u5b8c\u6210\u7684\u4ec5\u4ec5\u662f\u5c11\u91cf\u7684 native API \u548c Wasm \u8fd0\u884c\u65f6\u7684\u7ed1\u5b9a\uff0c\u5e76\u4e14\u5728 Wasm \u4ee3\u7801\u4e2d\u5904\u7406 JSON \u6570\u636e\u3002\u4f60\u53ef\u4ee5\u5728\u4e00\u4e2a\u5355\u4e00\u7684 <code>Wasm</code> \u6a21\u5757\u4e2d\u62e5\u6709\u591a\u4e2a <code>eBPF</code> \u7a0b\u5e8f\u3002\u5982\u679c\u4e0d\u4f7f\u7528\u6211\u4eec\u63d0\u4f9b\u7684 Wasm \u8fd0\u884c\u65f6\uff0c\u6216\u8005\u60f3\u8981\u4f7f\u7528\u5176\u4ed6\u8bed\u8a00\u8fdb\u884c\u7528\u6237\u6001\u7684 eBPF \u8f85\u52a9\u4ee3\u7801\u7684\u5f00\u53d1\uff0c\u5728\u6211\u4eec\u63d0\u4f9b\u7684 <code>eunomia-bpf</code> \u5e93\u57fa\u7840\u4e0a\u5b8c\u6210\u4e00\u4e9b WebaAssembly \u7684\u7ed1\u5b9a\u5373\u53ef\u3002</p> <p>\u53e6\u5916\uff0c\u5bf9\u4e8e eunomia-bpf \u5e93\u800c\u8a00\uff0c\u4e0d\u9700\u8981 Wasm \u6a21\u5757\u548c\u8fd0\u884c\u65f6\u540c\u6837\u53ef\u4ee5\u542f\u52a8\u548c\u52a8\u6001\u52a0\u8f7d eBPF \u7a0b\u5e8f\uff0c\u4e0d\u8fc7\u6b64\u65f6\u52a8\u6001\u52a0\u8f7d\u8fd0\u884c\u7684\u5c31\u53ea\u662f\u5185\u6838\u6001\u7684 eBPF \u7a0b\u5e8f\u5b57\u8282\u7801\u3002\u4f60\u53ef\u4ee5\u624b\u52a8\u6216\u4f7f\u7528\u4efb\u610f\u8bed\u8a00\u4fee\u6539 JSON \u5bf9\u8c61\u6765\u63a7\u5236 eBPF \u7a0b\u5e8f\u7684\u52a0\u8f7d\u548c\u53c2\u6570\uff0c\u5e76\u4e14\u901a\u8fc7 eunomia-bpf \u81ea\u52a8\u83b7\u53d6\u5185\u6838\u6001\u4e0a\u62a5\u7684\u8fd4\u56de\u6570\u636e\u3002\u5bf9\u4e8e\u521d\u5b66\u8005\u800c\u8a00\uff0c\u8fd9\u53ef\u80fd\u6bd4\u4f7f\u7528 WebAssembly \u66f4\u52a0\u7b80\u5355\u65b9\u4fbf\uff1a\u53ea\u9700\u8981\u7f16\u5199\u5185\u6838\u6001\u7684 eBPF \u7a0b\u5e8f\uff0c\u7136\u540e\u4f7f\u7528 eunomia-cc \u5de5\u5177\u94fe\u5c06\u5176\u7f16\u8bd1\u4e3a JSON \u683c\u5f0f\uff0c\u6700\u540e\u4f7f\u7528 eunomia-bpf \u5e93\u52a0\u8f7d\u548c\u8fd0\u884c\u5373\u53ef\u3002\u5b8c\u5168\u4e0d\u7528\u8003\u8651\u4efb\u4f55\u7528\u6237\u6001\u7684\u8f85\u52a9\u7a0b\u5e8f\uff0c\u5305\u62ec Wasm \u5728\u5185\u3002\u5177\u4f53\u53ef\u4ee5\u53c2\u8003\u6211\u4eec\u7684\u4f7f\u7528\u624b\u518c[7]\u6216\u793a\u4f8b\u4ee3\u7801[8]\u3002</p>"},{"location":"miscellaneous/manual.zh/#_2","title":"\u539f\u7406","text":"<p><code>ecli</code> \u662f\u57fa\u4e8e\u6211\u4eec\u5e95\u5c42\u7684 eunomia-bpf \u5e93\u548c\u8fd0\u884c\u65f6\u5b9e\u73b0\u7684\u4e00\u4e2a\u7b80\u5355\u7684\u547d\u4ee4\u884c\u5de5\u5177\u3002\u6211\u4eec\u7684\u9879\u76ee\u67b6\u6784\u5982\u4e0b\u56fe\u6240\u793a\uff1a</p> <p></p> <p><code>ecli</code> \u5de5\u5177\u57fa\u4e8e <code>ewasm</code> \u5e93\u5b9e\u73b0\uff0c<code>ewasm</code> \u5e93\u5305\u542b\u4e00\u4e2a WAMR(wasm-micro-runtime) \u8fd0\u884c\u65f6\uff0c\u4ee5\u53ca\u57fa\u4e8e libbpf \u5e93\u6784\u5efa\u7684 eBPF \u52a8\u6001\u88c5\u8f7d\u6a21\u5757\u3002\u5927\u81f4\u6765\u8bf4\uff0c\u6211\u4eec\u5728 <code>Wasm</code> \u8fd0\u884c\u65f6\u548c\u7528\u6237\u6001\u7684 <code>libbpf</code> \u4e2d\u95f4\u591a\u52a0\u4e86\u4e00\u5c42\u62bd\u8c61\u5c42\uff08<code>eunomia-bpf</code> \u5e93\uff09\uff0c\u4f7f\u5f97\u4e00\u6b21\u7f16\u8bd1\u3001\u5230\u5904\u8fd0\u884c\u7684 eBPF \u4ee3\u7801\u53ef\u4ee5\u4ece JSON \u5bf9\u8c61\u4e2d\u52a8\u6001\u52a0\u8f7d\u3002JSON \u5bf9\u8c61\u4f1a\u5728\u7f16\u8bd1\u65f6\u88ab\u5305\u542b\u5728 Wasm \u6a21\u5757\u4e2d\uff0c\u56e0\u6b64\u5728\u8fd0\u884c\u65f6\uff0c\u6211\u4eec\u53ef\u4ee5\u901a\u8fc7\u89e3\u6790 JSON \u5bf9\u8c61\u6765\u83b7\u53d6 eBPF \u7a0b\u5e8f\u7684\u4fe1\u606f\uff0c\u7136\u540e\u52a8\u6001\u52a0\u8f7d eBPF \u7a0b\u5e8f\u3002</p> <p>\u4f7f\u7528 Wasm \u6216 JSON \u7f16\u8bd1\u5206\u53d1 eBPF \u7a0b\u5e8f\u7684\u6d41\u7a0b\u56fe\u5927\u81f4\u5982\u4e0b\uff1a</p> <pre><code>graph TD\n  b3--&gt;package\n  b4--&gt;a3\n  package--&gt;a1\n  package(\u53ef\u901a\u8fc7\u7f51\u7edc\u6216\u5176\u4ed6\u4efb\u610f\u65b9\u5f0f\u8fdb\u884c\u5206\u53d1: CO-RE)\n\n  subgraph \u8fd0\u884c\u65f6\u52a0\u8f7d\u5668\u5e93\n  a3(\u8fd0\u884c Wasm \u6a21\u5757\u914d\u7f6e eBPF \u7a0b\u5e8f\u6216\u548c eBPF \u7a0b\u5e8f\u4ea4\u4e92)\n  a1(\u6839\u636e JSON \u914d\u7f6e\u4fe1\u606f\u52a8\u6001\u88c5\u8f7d eBPF \u7a0b\u5e8f)\n  a2(\u6839\u636e\u7c7b\u578b\u4fe1\u606f\u548c\u5185\u5b58\u5e03\u5c40\u4fe1\u606f\u5bf9\u5185\u6838\u6001\u5bfc\u51fa\u4e8b\u4ef6\u8fdb\u884c\u52a8\u6001\u5904\u7406)\n  a1--&gt;a2\n  a3--&gt;a1\n  a2--&gt;a3\n  end\n\n  subgraph eBPF\u7f16\u8bd1\u5de5\u5177\u94fe\n  b1(\u4f7f\u7528 Clang \u7f16\u8bd1 eBPF \u7a0b\u5e8f\u83b7\u5f97\u5305\u542b\u91cd\u5b9a\u4f4d\u4fe1\u606f\u7684 bpf.o)\n  b2(\u6dfb\u52a0\u4ece eBPF \u6e90\u4ee3\u7801\u83b7\u53d6\u7684\u5185\u6838\u6001\u5bfc\u51fa\u6570\u636e\u7684\u5185\u5b58\u5e03\u5c40, \u7c7b\u578b\u4fe1\u606f\u7b49)\n  b3(\u6253\u5305\u751f\u6210 JSON \u6570\u636e)\n  b4(\u6253\u5305\u6210 Wasm \u6a21\u5757\u8fdb\u884c\u5206\u53d1)\n  b5(\u53ef\u9009\u7684\u7528\u6237\u6001\u6570\u636e\u5904\u7406\u7a0b\u5e8f\u7f16\u8bd1\u4e3a Wasm)\n  b2--&gt;b3\n  b3--&gt;b5\n  b5--&gt;b4\n  b1--&gt;b2\n  end\n</code></pre> <p>\u5927\u81f4\u6765\u8bf4\uff0c\u6574\u4e2a eBPF \u7a0b\u5e8f\u7684\u7f16\u5199\u548c\u52a0\u8f7d\u5206\u4e3a\u4e09\u4e2a\u90e8\u5206\uff1a</p> <ol> <li>\u7528 eunomia-cc \u5de5\u5177\u94fe\u5c06\u5185\u6838\u7684 eBPF \u4ee3\u7801\u9aa8\u67b6\u548c\u5b57\u8282\u7801\u7f16\u8bd1\u4e3a JSON \u683c\u5f0f</li> <li>\u5728\u7528\u6237\u6001\u5f00\u53d1\u7684\u9ad8\u7ea7\u8bed\u8a00\uff08\u4f8b\u5982 C \u8bed\u8a00\uff09\u4e2d\u5d4c\u5165 JSON \u6570\u636e\uff0c\u5e76\u63d0\u4f9b\u4e00\u4e9b API \u7528\u4e8e\u64cd\u4f5c JSON \u5f62\u6001\u7684 eBPF \u7a0b\u5e8f\u9aa8\u67b6</li> <li>\u5c06\u7528\u6237\u6001\u7a0b\u5e8f\u548c JSON \u6570\u636e\u4e00\u8d77\u7f16\u8bd1\u4e3a Wasm \u5b57\u8282\u7801\u5e76\u6253\u5305\u4e3a Wasm \u6a21\u5757\uff0c\u7136\u540e\u5728\u76ee\u6807\u673a\u5668\u4e0a\u52a0\u8f7d\u5e76\u8fd0\u884c Wasm \u7a0b\u5e8f</li> <li>\u4ece Wasm \u6a21\u5757\u4e2d\u52a0\u8f7d\u5185\u5d4c\u7684 JSON \u6570\u636e\uff0c\u7528 eunomia-bpf \u5e93\u52a8\u6001\u88c5\u8f7d\u548c\u914d\u7f6e eBPF \u7a0b\u5e8f\u9aa8\u67b6\u3002</li> </ol> <p>\u6211\u4eec\u9700\u8981\u5b8c\u6210\u7684\u4ec5\u4ec5\u662f\u5c11\u91cf\u7684 native API \u548c Wasm \u8fd0\u884c\u65f6\u7684\u7ed1\u5b9a\uff0c\u5e76\u4e14\u5728 Wasm \u4ee3\u7801\u4e2d\u5904\u7406 JSON \u6570\u636e\u3002\u4f60\u53ef\u4ee5\u5728\u4e00\u4e2a\u5355\u4e00\u7684 <code>Wasm</code> \u6a21\u5757\u4e2d\u62e5\u6709\u591a\u4e2a <code>eBPF</code> \u7a0b\u5e8f\u3002\u5982\u679c\u4e0d\u4f7f\u7528\u6211\u4eec\u63d0\u4f9b\u7684 Wasm \u8fd0\u884c\u65f6\uff0c\u6216\u8005\u60f3\u8981\u4f7f\u7528\u5176\u4ed6\u8bed\u8a00\u8fdb\u884c\u7528\u6237\u6001\u7684 eBPF \u8f85\u52a9\u4ee3\u7801\u7684\u5f00\u53d1\uff0c\u5728\u6211\u4eec\u63d0\u4f9b\u7684 <code>eunomia-bpf</code> \u5e93\u57fa\u7840\u4e0a\u5b8c\u6210\u4e00\u4e9b WebaAssembly \u7684\u7ed1\u5b9a\u5373\u53ef\u3002</p> <p>\u53e6\u5916\uff0c\u5bf9\u4e8e eunomia-bpf \u5e93\u800c\u8a00\uff0c\u4e0d\u9700\u8981 Wasm \u6a21\u5757\u548c\u8fd0\u884c\u65f6\u540c\u6837\u53ef\u4ee5\u542f\u52a8\u548c\u52a8\u6001\u52a0\u8f7d eBPF \u7a0b\u5e8f\uff0c\u4e0d\u8fc7\u6b64\u65f6\u52a8\u6001\u52a0\u8f7d\u8fd0\u884c\u7684\u5c31\u53ea\u662f\u5185\u6838\u6001\u7684 eBPF \u7a0b\u5e8f\u5b57\u8282\u7801\u3002\u4f60\u53ef\u4ee5\u624b\u52a8\u6216\u4f7f\u7528\u4efb\u610f\u8bed\u8a00\u4fee\u6539 JSON \u5bf9\u8c61\u6765\u63a7\u5236 eBPF \u7a0b\u5e8f\u7684\u52a0\u8f7d\u548c\u53c2\u6570\uff0c\u5e76\u4e14\u901a\u8fc7 eunomia-bpf \u81ea\u52a8\u83b7\u53d6\u5185\u6838\u6001\u4e0a\u62a5\u7684\u8fd4\u56de\u6570\u636e\u3002\u5bf9\u4e8e\u521d\u5b66\u8005\u800c\u8a00\uff0c\u8fd9\u53ef\u80fd\u6bd4\u4f7f\u7528 WebAssembly \u66f4\u52a0\u7b80\u5355\u65b9\u4fbf\uff1a\u53ea\u9700\u8981\u7f16\u5199\u5185\u6838\u6001\u7684 eBPF \u7a0b\u5e8f\uff0c\u7136\u540e\u4f7f\u7528 eunomia-cc \u5de5\u5177\u94fe\u5c06\u5176\u7f16\u8bd1\u4e3a JSON \u683c\u5f0f\uff0c\u6700\u540e\u4f7f\u7528 eunomia-bpf \u5e93\u52a0\u8f7d\u548c\u8fd0\u884c\u5373\u53ef\u3002\u5b8c\u5168\u4e0d\u7528\u8003\u8651\u4efb\u4f55\u7528\u6237\u6001\u7684\u8f85\u52a9\u7a0b\u5e8f\uff0c\u5305\u62ec Wasm \u5728\u5185\u3002\u5177\u4f53\u53ef\u4ee5\u53c2\u8003\u6211\u4eec\u7684\u4f7f\u7528\u624b\u518c[7]\u6216\u793a\u4f8b\u4ee3\u7801[8]\u3002</p>"},{"location":"miscellaneous/manual.zh/#_3","title":"\u4e3a\u6211\u4eec\u7684\u9879\u76ee\u8d21\u732e\u4ee3\u7801","text":"<p>\u6211\u4eec\u7684\u9879\u76ee\u8fd8\u5728\u65e9\u671f\u9636\u6bb5\uff0c\u56e0\u6b64\u975e\u5e38\u5e0c\u671b\u6709\u60a8\u7684\u5e2e\u52a9\uff1a</p> <ul> <li>\u8fd0\u884c\u65f6\u5e93\u5730\u5740\uff1a https://github.com/eunomia-bpf/eunomia-bpf</li> <li>\u7f16\u8bd1\u5668\u5730\u5740\uff1a https://github.com/eunomia-bpf/eunomia-cc</li> <li>\u6587\u6863\uff1ahttps://github.com/eunomia-bpf/eunomia-bpf.github.io</li> </ul> <p>eunomia-bpf \u4e5f\u5df2\u7ecf\u52a0\u5165\u4e86\u9f99\u8725\u793e\u533a\uff1a</p> <ul> <li>gitee \u955c\u50cf\uff1ahttps://gitee.com/anolis/eunomia</li> </ul> <p>\u60a8\u53ef\u4ee5\u5e2e\u52a9\u6211\u4eec\u6dfb\u52a0\u6d4b\u8bd5\u6216\u8005\u793a\u4f8b\uff0c\u53ef\u4ee5\u53c2\u8003\uff1a</p> <ul> <li>examples/bpftools</li> <li>bpftools/tests</li> </ul> <p>\u7531\u4e8e\u73b0\u5728 API \u8fd8\u4e0d\u7a33\u5b9a\uff0c\u5982\u679c\u60a8\u5728\u8bd5\u7528\u4e2d\u9047\u5230\u4efb\u4f55\u95ee\u9898\u6216\u8005\u4efb\u4f55\u6d41\u7a0b/\u6587\u6863\u4e0d\u5b8c\u5584\u7684\u5730\u65b9\uff0c\u8bf7\u5728 gitee \u6216 github issue \u7559\u8a00\uff0c \u6211\u4eec\u4f1a\u5c3d\u5feb\u4fee\u590d\uff1b\u4e5f\u975e\u5e38\u6b22\u8fce\u8fdb\u4e00\u6b65\u7684 PR \u63d0\u4ea4\u548c\u8d21\u732e\uff01\u4e5f\u975e\u5e38\u5e0c\u671b\u60a8\u80fd\u63d0\u51fa\u4e00\u4e9b\u5b9d\u8d35\u7684\u610f\u89c1\u6216\u8005\u5efa\u8bae\uff01</p>"},{"location":"miscellaneous/online.zh/","title":"\u5728\u7ebf\u4f53\u9a8c\u7f51\u7ad9","text":"<p>\u53ef\u4f7f\u7528 bolipi \u63d0\u4f9b\u7684\u5728\u7ebf\u4f53\u9a8c\u670d\u52a1\uff0c\u5728\u7ebf\u7f16\u8bd1\uff0c\u5728\u7ebf\u8fd0\u884c\u3001\u5728\u7ebf\u83b7\u53d6\u53ef\u89c6\u5316\u7ed3\u679c\uff1ahttps://bolipi.com/ebpf/home/online</p> <p></p>"},{"location":"miscellaneous/online.zh/#ebpf","title":"\u901a\u8fc7\u5728\u7ebf\u7f16\u8bd1\u8fd0\u884c\u5feb\u901f\u4f53\u9a8c eBPF \u548c\u53ef\u89c6\u5316","text":"<p>\u672c\u5728\u7ebf\u7f16\u8bd1\u5e73\u53f0\u7531 <code>eunomia-bpf</code> \u5de5\u5177\u94fe\u63d0\u4f9b\u652f\u6301\uff0c\u8be6\u7ec6\u6587\u6863\u8bf7\u53c2\u8003 eunomia-bpf.github.io/</p>"},{"location":"miscellaneous/online.zh/#_2","title":"\u5728\u7ebf\u7f16\u8bd1","text":"<p>\u5728\u4ee3\u7801\u7f16\u8f91\u5668\u4e2d\u7f16\u5199 eBPF \u7684\u5185\u6838\u6001\u7a0b\u5e8f\uff0c\u5e94\u5f53\u9075\u5faa libbpf-tools \u7684\u5185\u6838\u6001\u4ee3\u7801\u7f16\u5199\u7ea6\u5b9a\uff0c\u5373\uff1a</p> <ul> <li><code>\u4ee3\u7801\u7f16\u8f91\u5668</code> (*.bpf.c) \u5305\u542b BPF C \u4ee3\u7801\uff0c\u5b83\u88ab\u7f16\u8bd1\u6210 package.json</li> <li><code>\u5934\u6587\u4ef6\u7f16\u8f91\u5668</code> (*.h) \u53ef\u4ee5\u9009\u62e9\u5305\u542b\u901a\u8fc7 perf event \u6216\u73af\u5f62\u7f13\u51b2\u533a\u5bfc\u51fa\u5230\u7528\u6237\u7a7a\u95f4\u7684\u7c7b\u578b</li> </ul> <p>\u6211\u4eec\u76ee\u524d\u53ea\u652f\u6301\u4f7f\u7528\u57fa\u4e8e libbpf \u7684\u5185\u6838\u6001\u4ee3\u7801\uff0cBCC \u4ee3\u7801\u652f\u6301\u7531\u4e8e\u5b58\u5728\u4e00\u4e9b\u8bed\u6cd5\u4e0a\u7684\u5dee\u5f02\uff0c\u8fd8\u5728\u5f00\u53d1\u4e2d\u3002</p> <p>\u7f16\u5199\u5b8c\u6210\u4ee3\u7801\u540e\uff0c\u70b9\u51fb <code>\u7f16\u8bd1</code> \u6309\u94ae\u5373\u53ef\u7f16\u8bd1\u6210 eBPF \u7684\u5185\u6838\u6001\u7a0b\u5e8f\uff0c\u5728 <code>\u7f16\u8bd1\u8f93\u51fa</code> \u4e2d\u67e5\u770b\u7f16\u8bd1\u8f93\u51fa\uff1a</p> <p></p> <p>\u66f4\u591a\u4fe1\u606f\u8bf7\u53c2\u8003\uff1aeunomia-bpf.github.io/mannual.html</p> <p>\u66f4\u591a\u4f8b\u5b50\u8bf7\u53c2\u8003\uff1ahttps://github.com/eunomia-bpf/eunomia-bpf/tree/master/examples/bpftools</p>"},{"location":"miscellaneous/online.zh/#_3","title":"\u5728\u7ebf\u8fd0\u884c","text":"<p>\u70b9\u51fb\u53f3\u4fa7\u7684\u7eff\u8272\u8fd0\u884c\u6309\u94ae\u8fd0\u884c\uff1a</p> <p></p> <p>\u4e5f\u53ef\u4ee5\u901a\u8fc7 <code>\u4e0b\u8f7d\u7f16\u8bd1\u540e\u7684\u6587\u4ef6</code> \u67e5\u770b\u7f16\u8bd1\u597d\u7684\u7a0b\u5e8f\uff0c\u5e76\u5728\u672c\u5730\u4f7f\u7528 <code>ecli</code> \u76f4\u63a5\u8fd0\u884c\uff1a</p> <pre><code>$ # \u4e0b\u8f7d\u5b89\u88c5 ecli \u4e8c\u8fdb\u5236\n$ wget https://aka.pw/bpf-ecli -O ./ecli &amp;&amp; chmod +x ./ecli\n$ # \u8fd0\u884c eBPF \u7a0b\u5e8f\uff08root shell\uff09\n$ sudo ./ecli run package.json\n</code></pre>"},{"location":"miscellaneous/online.zh/#prometheus","title":"\u4f7f\u7528 Prometheus \u5728\u7ebf\u83b7\u53d6\u53ef\u89c6\u5316\u7ed3\u679c","text":"<p>\u70b9\u51fb <code>\u8fd0\u884c\u53ef\u89c6\u5316\u7ec4\u4ef6</code> \u6309\u94ae\uff0c\u5728\u5f39\u51fa\u7684\u7a97\u53e3\u4e2d\u914d\u7f6e prometheus metrics \u4fe1\u606f:</p> <p></p> <p>\u70b9\u51fb <code>\u786e\u5b9a</code> \u5373\u53ef\u8df3\u8f6c\u5230 Prometheus \u754c\u9762\uff0c\u53ef\u901a\u8fc7\u9009\u62e9 graph \u67e5\u770b\u53ef\u89c6\u5316\u7ed3\u679c\uff1a</p> <p></p>"},{"location":"miscellaneous/online.zh/#eunomia-bpf","title":"\u5173\u4e8e eunomia-bpf","text":"<p>eunomia-bpf \u662f\u4e00\u5957\u7f16\u8bd1\u5de5\u5177\u94fe\u548c\u8fd0\u884c\u65f6\uff0c\u4ee5\u53ca\u4e00\u4e9b\u9644\u52a0\u9879\u76ee\uff0c\u6211\u4eec\u5e0c\u671b\u505a\u5230\u8ba9 eBPF \u7a0b\u5e8f\uff1a</p> <ul> <li>\u8ba9 eBPF \u7a0b\u5e8f\u7684\u7f16\u8bd1\u548c\u8fd0\u884c\u8fc7\u7a0b\u5927\u5927\u7b80\u5316\uff0c\u629b\u53bb\u7e41\u7410\u7684\u7528\u6237\u6001\u6a21\u677f\u7f16\u5199\u3001\u7e41\u7410\u7684 BCC \u5b89\u88c5\u6d41\u7a0b\uff0c\u53ea\u9700\u8981\u7f16\u5199\u5185\u6838\u6001 eBPF \u7a0b\u5e8f\uff0c\u7f16\u8bd1\u540e\u5373\u53ef\u5728\u4e0d\u540c\u673a\u5668\u4e0a\u4efb\u610f\u5185\u6838\u7248\u672c\u4e0b\u8fd0\u884c\uff0c\u5e76\u4e14\u8f7b\u677e\u83b7\u53d6\u53ef\u89c6\u5316\u7ed3\u679c\u3002</li> <li>\u771f\u6b63\u50cf JavaScript \u6216\u8005 Wasm \u90a3\u6837\u6613\u4e8e\u5206\u53d1\u548c\u8fd0\u884c\uff0c\u6216\u8005\u8bf4\u5185\u6838\u6001\u6216\u53ef\u89c2\u6d4b\u6027\u5c42\u9762\u7684 FaaS\uff1aeBPF \u5373\u670d\u52a1\uff0c\u901a\u8fc7 API \u8bf7\u6c42\u5feb\u901f\u5206\u53d1\u548c\u8fd0\u884c\uff0c\u65e0\u9700\u7ba1\u7406\u57fa\u7840\u8bbe\u65bd\u548c\u7528\u6237\u6001\u52a0\u8f7d\u7a0b\u5e8f\uff1b</li> </ul>"},{"location":"miscellaneous/quickstart/","title":"Quick Start","text":"<ul> <li>Github Template\uff1aeunomia-bpf/ebpm-template</li> <li>example bpf programs: examples/bpftools</li> <li>tutorial: eunomia-bpf/bpf-developer-tutorial</li> </ul> <p>You can get pre-compiled eBPF programs running from the cloud to the kernel in <code>1</code> line of bash:</p> <pre><code>    # download the release from https://github.com/eunomia-bpf/eunomia-bpf/releases/latest/download/ecli\n$ wget https://aka.pw/bpf-ecli -O ecli &amp;&amp; chmod +x ./ecli\n    $ sudo ./ecli https://eunomia-bpf.github.io/eunomia-bpf/sigsnoop/package.json # simply run a pre-compiled ebpf code from a url\n$ sudo ./ecli sigsnoop:latest # run with a name and download the latest version bpf tool from our repo\n</code></pre>"},{"location":"miscellaneous/supporting-external-BTF.zh/","title":"supporting external BTF","text":"<p>1.\u786e\u8ba4\u5185\u6838BTF\u9009\u9879\u5df2\u7ecf\u6253\u5f00</p> <pre><code>CONFIG_DEBUG_INFO=y\nCONFIG_DEBUG_INFO_BTF=y\n</code></pre> <p>\u5982\u679c\u5185\u6838\u9009\u9879\u672a\u5f00\u542f\uff0c\u5c31\u9700\u8981\u91cd\u65b0\u7f16\u8bd1\u5185\u6838</p> <ol> <li>\u786e\u8ba4\u5f53\u524d\u5185\u6838BTF\u4fe1\u606f\u662f\u5426\u53ef\u7528\uff0c\u5982\u4e0d\u53ef\u7528\u9700\u6dfb\u52a0\u5916\u6e90BTF\u4fe1\u606f</li> </ol> <p>\u82e5/sys/kernel/btf/vmlinux\u5b58\u5728\uff0c\u5219BTF\u53ef\u7528\uff0c\u53ef\u901a\u8fc7bpftool\u751f\u6210vmlinux.h</p> <pre><code>apt install linux-tools-(uname -r)-generic\napt install linux-tools-generic\nbpftool btf dump file /sys/kernel/btf/vmlinux format c &gt; vmlinux.h\n</code></pre> <p>\u82e5/sys/kernel/btf/vmlinux\u4e0d\u5b58\u5728\uff0c\u5219BTF\u4e0d\u53ef\u7528\uff0c\u53ef\u901a\u8fc7btfhub\u6dfb\u52a0\u5916\u6e90BTF\u4fe1\u606f\u6216\u751f\u6210\u5f53\u524d\u5185\u6838\u7684\u5b9a\u5236\u5316BTF\u4fe1\u606f</p> <p>\uff081\uff09\u6dfb\u52a0\u5916\u6e90BTF\u4fe1\u606f</p> <p>\u53c2\u8003 BTFgen tool to create smaller BTF files</p> <pre><code>$ git clone git@github.com:aquasecurity/btfhub.git\n$ git clone git@github.com:aquasecurity/btfhub-archive.git\n$ cd btfhub ; ls\n//\u5c06\u514b\u9686\u7684\u5f52\u6863\u6587\u4ef6\u653e\u5165 btfhub \u76ee\u5f55\n$ rsync -avz ../btfhub-archive/ --exclude=.git* --exclude=README.md ./archive/\n</code></pre> <p>\u6574\u4e2abtfhub-archive\u76ee\u5f55\u76f8\u5f53\u5e9e\u5927\uff0c\u53ef\u4ee5\u5355\u72ec\u4e0b\u8f7d\u67d0\u4e2aBTF\u5f52\u6863\u6587\u4ef6\u653e\u5165btfhub \u76ee\u5f55</p> <pre><code>$ rsync -avz ../5.11.0-1027-azure.btf.tar.xz --exclude=.git* --exclude=README.md ./archive/\nsending incremental file list\n\nsent 77 bytes  received 12 bytes  178.00 bytes/sec\ntotal size is 144,419  speedup is 1,622.69\n</code></pre> <p>\u4e4b\u540e\u5c31\u53ef\u4ee5\u6839\u636e\u67d0\u4e2a\u5bf9\u5e94\u7684eBPF \u5bf9\u8c61\u751f\u6210\u5b9a\u5236\u7684BTF \u6587\u4ef6</p> <pre><code>#\u751f\u6210\u5b9a\u5236\u7684 eBPF \u5bf9\u8c61\u7684 BTF \u6587\u4ef6:\n$ ./tools/btfgen.sh -a AARCH64 -o $HOME/****.bpf.core.o\n</code></pre> <p>\u68c0\u67e5\u5b9a\u5236\u7684\u65b0\u751f\u6210\u7684 BTF \u6587\u4ef6\u53ca\u5176\u5c3a\u5bf8</p> <pre><code>$ find custom-archive | grep ubuntu | tail -10\n$ls -lah custom-archive/ubuntu/20.04/x86_64/5.8.0-1041-azure.btf\n</code></pre> <p>\uff082\uff09\u751f\u6210\u5f53\u524d\u5185\u6838\u7684\u5b9a\u5236\u5316BTF\u4fe1\u606f</p> <pre><code>$ sudo ./example-static\n$ sudo ./example-c-static\n$ sudo EXAMPLE_BTF_FILE=5.8.0-63-generic.btf ./example-static\n$ sudo EXAMPLE_BTF_FILE=5.8.0-63-generic.btf ./example-c-static\n</code></pre>"},{"location":"miscellaneous/video/","title":"videos","text":"<ul> <li>eunomia-bpf: \u4e00\u4e2a\u5f00\u6e90\u7684 ebpf \u52a8\u6001\u52a0\u8f7d\u8fd0\u884c\u65f6\u548c\u5f00\u53d1\u5de5\u5177\u94fe</li> <li>eunomia-bpf\uff1aeBPF\u8f7b\u91cf\u7ea7\u5f00\u53d1\u6846\u67b6</li> <li>wasm-bpf\uff1aeBPF \u7a0b\u5e8f\u7684 WebAssembly \u7f16\u8bd1\u5de5\u5177\u94fe\u4e0e\u8fd0\u884c\u65f6</li> <li>\u4f7f\u7528 WASM \u5f00\u53d1\u548c\u5206\u53d1 eBPF \u5e94\u7528</li> <li>\u3010\u8fbe\u5766\u79d1\u6280DatenLord\u3011eunomia-bpf: \u7ed3\u5408 wasm \u7684 ebpf \u8f7b\u91cf\u7ea7\u5f00\u53d1\u6846\u67b6</li> <li>eunomia-bpf\uff1a\u8d85\u7b80\u6d01\u7684\u4e91\u7aefeBPF\u90e8\u7f72\u65b9\u5f0f</li> </ul>"},{"location":"setup/build-android-arm/","title":"Build on  Android","text":"<p>Android\u4e0abuild\u9700\u8981\u5148Installing Debian on Android in Termux </p> <p>\u5728Android\u4e0a\u6784\u5efa\u65f6\uff0c\u9700\u8981\u5148Installing Debian on Android in Termux </p> <ol> <li>install termux</li> </ol> <p>https://github.com/termux/termux-app/releases/tag/v0.118.0</p> <ol> <li>install proot-distro</li> </ol> <p>select debian distro</p> <pre><code>pkg install proot-distro\nproot-distro install debian\nproot-distro login debian\n</code></pre> <ol> <li>install packages</li> </ol> <p>remember <code>proot-distro login debian</code> first</p> <pre><code>apk update\napt install clang cmake libelf1 libelf-dev zlib1g-dev\n</code></pre> <p>\u4e4b\u540e\u7684\u6b65\u9aa4\u548c\u5728ARM\u4e0abuild\u4e0a\u76f8\u540c</p>"},{"location":"setup/build-android-arm/#build-on-arm","title":"Build on  ARM","text":"<ol> <li>\u540c\u6b65 eunomia-bpf \u5230\u672c\u5730</li> </ol> <pre><code>git clone https://github.com/eunomia-bpf/eunomia-bpf.git\ncd eunomia-bpf\ngit submodule update --init --recursive --remote\n</code></pre> <p>2.\u914d\u7f6e\u73af\u5883\u53d8\u91cf</p> <pre><code>export PKG_CONFIG_PATH=/usr/lib/aarch64-linux-gnu/pkgconfig\n</code></pre> <p>3.\u5b89\u88c5\u4f9d\u8d56</p> <pre><code>apt update\napt install clang cmake libelf1 libelf-dev zlib1g-dev\n</code></pre> <p>4.\u4fee\u6539wasm-runtime/CMakeLists.txt<code>\u4e2d\u7684</code>WAMR_BUILD_TARGET\uff08may not required)</p> <p>change <code>set (WAMR_BUILD_TARGET \"X86_64\")</code> to <code>set (WAMR_BUILD_TARGET \"AARCH64\")</code></p> <p>5.\u7f16\u8bd1</p> <pre><code>make bpf-loader\nmake ecli\n</code></pre> <p>6.\u68c0\u67e5\u8f93\u51fa</p> <pre><code>root@localhost:~/eunomia-bpf# file ecli/build/bin/Release/ecli\necli: ELF 64-bit LSB pie executable, ARM aarch64, version 1 (SYSV), dynamically linked, interpreter /lib/ld-linux-aarch64.so.1, BuildID[sha1]=eab42b79be75951e3a573aa7c61136239d35c868, for GNU/Linux 3.7.0, with debug_info, not stripped\n</code></pre>"},{"location":"setup/build/","title":"build","text":"<p>If you want to run the cli, in most cases, you don't need to build your own.</p>"},{"location":"setup/build/#building","title":"Building","text":"<p>libbpf-bootstrap supports multiple build systems that do the same thing. This serves as a cross reference for folks coming from different backgrounds.</p>"},{"location":"setup/build/#install-dependencies","title":"Install Dependencies","text":"<p>You will need <code>clang</code>, <code>libelf</code> and <code>zlib</code> to build the examples, package names may vary across distros.</p> <p>On Ubuntu/Debian, you need: <pre><code>$ apt install clang libelf1 libelf-dev zlib1g-dev\n</code></pre></p> <p>On CentOS/Fedora, you need: <pre><code>$ dnf install clang elfutils-libelf elfutils-libelf-devel zlib-devel\n</code></pre></p> <p>install rust toolchain</p> <pre><code>curl https://sh.rustup.rs -sSf | sh -s\n</code></pre>"},{"location":"setup/build/#build-bpf-loader-rs","title":"build bpf-loader-rs","text":"<p>bpf-loader is our core library written in C++17. It has no other dependencies except libbpf.</p> <pre><code>$ make bpf-loader-rs # build ebpf-loader-rs\n</code></pre> <p>The recommended compiler is gcc9 or later.</p>"},{"location":"setup/build/#build-ecli","title":"build ecli:","text":"<p>After compile the bpf-loader, you can build the cli tool in C++:</p> <pre><code>$ make ecli\n</code></pre> <p>reference: https://github.com/libbpf/libbpf-bootstrap</p>"},{"location":"setup/build/#build-wasm-lib","title":"build wasm lib","text":"<pre><code>$ make wasm-runtime\n</code></pre> <p>Please install WASI SDK, download the wasi-sdk release and extract the archive to default path /opt/wasi-sdk if you want to compile c code to wasm.</p>"},{"location":"setup/build/#build-compiler","title":"build compiler","text":"<pre><code>$ make ecc\n</code></pre>"},{"location":"setup/build/#more-details","title":"more details","text":"<ul> <li>You can check the Makefile at project root for more details: Makefile</li> <li>You may want to refer to our CI for more build info: ecc.yml</li> </ul>"},{"location":"setup/doc/","title":"eunomia-bpf readme","text":""},{"location":"setup/doc/#eunomia-bpf-simplify-and-enhance-ebpf-with-co-re1-and-webassembly2","title":"eunomia-bpf: simplify and enhance eBPF with CO-RE1 and WebAssembly2","text":"<p>A compiler and runtime framework to help you build and distribute eBPF program easier.</p>"},{"location":"setup/doc/#introduction","title":"Introduction","text":"<p><code>eunomia-bpf</code> is a dynamic loading library/runtime and a compile toolchain framework, aim at helping you build and distribute eBPF programs easier.</p> <p>With eunnomia-bpf, you can:</p> <ul> <li>A library to simplify <code>writing</code> eBPF programs:</li> <li>simplify building CO-RE1 <code>libbpf</code> eBPF applications: write eBPF kernel code only and automatically exposing your data with <code>perf event</code> or <code>ring buffer</code> from kernel.</li> <li>Automatically sample the data from hash maps and print <code>hists</code> in userspace.</li> <li>Automatically generate and config <code>command line arguments</code> for eBPF programs.</li> <li>You can writing the kernel part in both <code>BCC</code> and <code>libbpf</code> styles.</li> <li>Build eBPF programs with <code>Wasm</code>2: see <code>Wasm-bpf</code> project</li> <li>Runtime, libraries and toolchains to write eBPF with Wasm in C/C++, Rust, Go...covering the use cases from <code>tracing</code>, <code>networking</code>, <code>security</code>.</li> <li>simplify <code>distributing</code> eBPF programs:</li> <li>A tool for push, pull and run pre-compiled eBPF programs as <code>OCI</code> images in Wasm module</li> <li>Run eBPF programs from <code>cloud</code> or <code>URL</code> within <code>1</code> line of bash without recompiling, kernel version and architecture independent.</li> <li>Dynamically load eBPF programs with <code>JSON</code> config file or <code>Wasm</code> module.</li> </ul> <p>For more information, see next.</p> <ol> <li> <p>CO-RE: Compile Once \u2013 Run Everywhere \u21a9\u21a9</p> </li> <li> <p>WebAssembly or Wasm: https://webassembly.org/\u00a0\u21a9\u21a9</p> </li> </ol>"},{"location":"tutorials/","title":"Summary","text":""},{"location":"tutorials/#ebpf-practice-tutorial-based-on-libbpf-and-co-re","title":"eBPF Practice Tutorial: Based on libbpf and CO-RE","text":"<ul> <li>Introduction to basic concepts of eBPF and common development tools</li> <li>eBPF Hello World, basic framework and development process</li> <li>Monitoring and capturing unlink system calls using kprobe</li> <li>Monitoring and capturing unlink system calls using fentry</li> <li>Collection of system calls for capturing processes opening files, filtering process pid using global variables</li> <li>Capturing readline function calls of bash using uprobe</li> <li>Collection of system calls for capturing process signal sending, saving state using hash map</li> <li>Capturing process execution/exit time, printing output to user space using perf event array</li> <li>Monitoring process exit events using exitsnoop, printing output to user space using ring buffer</li> <li>A Linux kernel BPF program that summarizes scheduler run queue latency using histograms, displaying time length tasks wait to run on the CPU</li> <li>Capturing interrupt events using hardirqs or softirqs</li> <li>Developing user space programs and tracing exec() and exit() system calls using bootstrap</li> <li>Developing programs to measure TCP connection latency using libbpf-bootstrap</li> <li>Recording TCP connection state and TCP RTT using libbpf-bootstrap</li> <li>Capturing user space Java GC event duration using USDT</li> <li>Writing eBPF program Memleak to monitor memory leaks</li> <li>Writing eBPF program Biopattern to measure random/sequential disk I/O</li> <li>More reference materials</li> <li>Performing security detection and defense using LSM</li> <li>Performing traffic control using eBPF and tc</li> </ul>"},{"location":"tutorials/#advanced-features-and-advanced-topics-of-ebpf","title":"Advanced Features and Advanced Topics of eBPF","text":"<ul> <li>Using eBPF programs on Android</li> <li>Tracing HTTP requests or other layer 7 protocols using eBPF</li> <li>Accelerating network request forwarding using sockops</li> <li>Hiding process or file information using eBPF</li> <li>Terminating processes by sending signals using bpf_send_signal</li> <li>Adding sudo users using eBPF</li> <li>Replacing text read or written by any program using eBPF</li> <li>BPF lifecycle: Running eBPF programs continuously after the user space application exits using Detached mode</li> </ul>"},{"location":"tutorials/#bcc-tutorial","title":"bcc tutorial","text":"<ul> <li>BPF Features by Linux Kernel Version</li> <li>Kernel Configuration for BPF Features</li> <li>bcc Reference Guide</li> <li>Special Filtering</li> <li>bcc Tutorial\".- bcc Python Developer Tutorial</li> </ul>"},{"location":"tutorials/0-introduce/","title":"eBPF Beginner's Development Tutorial 0: Introduction to the Basic Concepts of eBPF and Common Development Tools","text":""},{"location":"tutorials/0-introduce/#1-introduction-to-ebpf-secure-and-efficient-kernel-extension","title":"1. Introduction to eBPF: Secure and Efficient Kernel Extension","text":"<p>eBPF is a revolutionary technology that originated in the Linux kernel and allows sandbox programs to run in the kernel of an operating system. It is used to securely and efficiently extend the functionality of the kernel without the need to modify the kernel's source code or load kernel modules. By allowing the execution of sandbox programs in the operating system, eBPF enables application developers to dynamically add additional functionality to the operating system at runtime. The operating system then ensures security and execution efficiency, similar to performing native compilation with the help of a Just-In-Time (JIT) compiler and verification engine. eBPF programs are portable between kernel versions and can be automatically updated, avoiding workload interruptions and node restarts.</p> <p>Today, eBPF is widely used in various scenarios: in modern data centers and cloud-native environments, it provides high-performance network packet processing and load balancing; it achieves observability of various fine-grained metrics with very low resource overhead, helping application developers trace applications and provide insights for performance troubleshooting; it ensures secure execution of application and container runtimes, and more. The possibilities are endless, and the innovation unleashed by eBPF in the operating system kernel has only just begun [3].</p>"},{"location":"tutorials/0-introduce/#the-future-of-ebpf-kernels-javascript-programmable-interface","title":"The Future of eBPF: Kernel's JavaScript Programmable Interface","text":"<p>For browsers, the introduction of JavaScript brought programmability and initiated a tremendous revolution, transforming browsers into almost independent operating systems. Now let's return to eBPF: in order to understand the programmability impact of eBPF on the Linux kernel, it is helpful to have a high-level understanding of the structure of the Linux kernel and how it interacts with applications and hardware [4].</p> <p></p> <p>The main purpose of the Linux kernel is to abstract hardware or virtual hardware and provide a consistent API (system calls) that allows applications to run and share resources. To achieve this goal, we maintain a series of subsystems and layers to distribute these responsibilities [5]. Each subsystem typically allows some level of configuration to cater to different user requirements. If the desired behavior cannot be achieved through configuration, there are two options: either modify the kernel source code and convince the Linux kernel community that the change is necessary (waiting for several years for the new kernel version to become a commodity), or write a kernel module and regularly fix it because each kernel version may break it. In practice, neither of the two solutions is commonly used: the former is too costly, and the latter lacks portability.</p> <p>With eBPF, there is a new option to reprogram the behavior of the Linux kernel without modifying the kernel's source code or loading kernel modules, while ensuring a certain degree of behavioral consistency, compatibility, and security across different kernel versions [6]. To achieve this, eBPF programs also need a corresponding API that allows the execution and sharing of resources for user-defined applications. In other words, in a sense, the eBPF virtual machine also provides a mechanism similar to system calls. With the help of the communication mechanism between eBPF and user space, both the Wasm virtual machine and user space applications can have full access to this set of \"system calls.\" On the one hand, it can programmatically extend the capabilities of traditional system calls, and on the other hand, it can achieve more efficient programmable IO processing in many layers such as networking and file systems.</p> <p></p> <p>As shown in the above figure, the Linux kernel of today is evolving towards a new kernel model: user-defined applications can run in both kernel space and user space, with user space accessing system resources through traditional system calls and kernel space interacting with various parts of the system through BPF Helper Calls. As of early 2023, there are already more than 220 helper system interfaces in the eBPF virtual machine in the kernel, covering a wide range of application scenarios.## Note It is worth noting that BPF Helper Call and system calls are not competitive. Their programming models and performance advantages are completely different and they do not completely replace each other. For the Wasm and Wasi related ecosystems, the situation is similar. The specially designed wasi interface needs to go through a long standardization process. However, it may provide better performance and portability guarantees for user-mode applications in specific scenarios. On the other hand, eBPF can provide a fast and flexible solution for extending system interfaces, while ensuring sandbox nature and portability.</p> <p>Currently, eBPF is still in the early stages. However, with the help of the kernel interfaces provided by eBPF and the ability to interact with user space, applications in the Wasm virtual machine can almost access the data and return values of any kernel or user mode function call (kprobe, uprobe...). It can collect and understand all system calls at a low cost and obtain packet-level data and socket-level data for all network operations (tracepoint, socket...). It can also add additional protocol analyzers and easily program any forwarding logic in the network packet processing solution (XDP, TC...), without leaving the packet processing environment of the Linux kernel.</p> <p>Moreover, eBPF has the ability to write data to any address of a user space process (bpf_probe_write_user[7]), partially modify the return value of a kernel function (bpf_override_return[8]), and even directly execute certain system calls in kernel mode[9]. Fortunately, eBPF performs strict security checks on the bytecode before loading it into the kernel to ensure that there are no operations such as memory out-of-bounds. Moreover, many features that may expand the attack surface and pose security risks need to be explicitly enabled during kernel compilation. Before loading the bytecode into the kernel, the Wasm virtual machine can also choose to enable or disable certain eBPF features to ensure the security of the sandbox.</p>"},{"location":"tutorials/0-introduce/#2-some-tips-on-learning-ebpf-development","title":"2. Some Tips on Learning eBPF Development","text":"<p>This article will not provide a more detailed introduction to the principles of eBPF, but here is a learning plan and reference materials that may be of value:</p>"},{"location":"tutorials/0-introduce/#introduction-to-ebpf-5-7h","title":"Introduction to eBPF (5-7h)","text":"<ul> <li>Google or other search engines: eBPF</li> <li>Ask ChatGPT-like things: What is eBPF?</li> </ul> <p>Recommended:</p> <ul> <li>Read the introduction to ebpf: https://ebpf.io/ (30min)</li> <li>Briefly understand the ebpf kernel-related documentation: https://prototype-kernel.readthedocs.io/en/latest/bpf/ (Know where to queries, 30min)</li> <li>Read the Chinese ebpf beginner's guide: https://www.modb.pro/db/391570 (1h)</li> <li>There are a lot of reference materials: https://github.com/zoidbergwill/awesome-ebpf (2-3h)</li> <li>You can choose to flip through PPTs that interest you: https://github.com/gojue/ebpf-slide (1-2h)</li> </ul> <p>Answer three questions:</p> <ol> <li>Understand what eBPF is? Why do we need it? Can't we use kernel modules?</li> <li>What functions does it have? What can it do in the Linux kernel? What are the types of eBPF programs and helpers (not all of them need to be known, but need to know where to find them)?</li> <li>What can it be used for? For example, in which scenarios can it be used? Networking, security, observability?</li> </ol>"},{"location":"tutorials/0-introduce/#understand-how-to-develop-ebpf-programs-10-15h","title":"Understand how to develop eBPF programs (10-15h)","text":"<p>Understand and try eBPF development frameworks:</p> <ul> <li>Examples of developing various tools with BCC: https://github.com/iovisor/bcc/blob/master/docs/tutorial_bcc_python_developer.md (Run through, 3-4h)</li> <li>Some examples of libbpf: https://github.com/libbpf/libbpf-bootstrap (Run any interesting one and read the source code, 2h)</li> <li>Tutorial based on libbpf and eunomia-bpf: https://github.com/eunomia-bpf/bpf-developer-tutorial (Read part 1-10, 3-4h)</li> </ul> <p>Other development frameworks: Go or Rust language, please search and try on your own (0-2h)</p> <p>Have questions or things you want to know, whether or not they are related to this project, you can start discussing in the discussions of this project.</p> <p>Answer some questions and try some experiments (2-5h):</p> <ol> <li>How to develop the simplest eBPF program?</li> <li>How to trace a kernel feature or function with eBPF? There are many ways, provide corresponding code examples;</li> <li>What are the solutions for communication between user mode and kernel mode? How to send information from user mode to kernel mode? How to pass information from kernel mode to user mode? Provide code examples;</li> <li>Write your own eBPF program to implement a feature;</li> <li>In the entire lifecycle of an eBPF program, what does it do in user mode and kernel mode?## 3. How to use eBPF programming</li> </ol> <p>Writing original eBPF programs is very tedious and difficult. To change this situation, llvm introduced in 2015 the ability to compile code written in high-level languages into eBPF bytecode, and the eBPF community wrapped primitive system calls such as <code>bpf()</code> and provided the <code>libbpf</code> library. These libraries include functions for loading bytecode into the kernel and other key functions. In the Linux source code package, there are numerous eBPF sample codes provided by Linux based on <code>libbpf</code>, located in the <code>samples/bpf/</code> directory.</p> <p>A typical <code>libbpf</code>-based eBPF program consists of two files: <code>*_kern.c</code> and <code>*_user.c</code>. The mounting points and processing functions in the kernel are written in <code>*_kern.c</code>, while the user code for injecting kernel code and performing various tasks in user space is written in <code>*_user.c</code>. For more detailed tutorials, refer to this video. However, due to the difficulty in understanding and the entry barrier, most eBPF program development at the current stage is based on tools such as:</p> <ul> <li>BCC</li> <li>BPFtrace</li> <li>libbpf-bootstrap</li> <li>Go eBPF library</li> </ul> <p>And there are newer tools such as <code>eunomia-bpf</code>.</p>"},{"location":"tutorials/0-introduce/#writing-ebpf-programs","title":"Writing eBPF programs","text":"<p>eBPF programs consist of a kernel space part and a user space part. The kernel space part contains the actual logic of the program, while the user space part is responsible for loading and managing the kernel space part. With the eunomia-bpf development tool, only the kernel space part needs to be written.</p> <p>The code in the kernel space part needs to conform to the syntax and instruction set of eBPF. eBPF programs mainly consist of several functions, each with its own specific purpose. The available function types include:</p> <ul> <li>kprobe: probe function, executed before or after a specified kernel function.</li> <li>tracepoint: tracepoint function, executed at a specified kernel tracepoint.</li> <li>raw_tracepoint: raw tracepoint function, executed at a specified kernel raw tracepoint.</li> <li>xdp: network data processing function, intercepting and processing network packets.</li> <li>perf_event: performance event function, used to handle kernel performance events.</li> <li>kretprobe: return probe function, executed when a specified kernel function returns.</li> <li>tracepoint_return: tracepoint return function, executed when a specified kernel tracepoint returns.</li> <li>raw_tracepoint_return: raw tracepoint return function, executed when a specified kernel raw tracepoint returns.</li> </ul>"},{"location":"tutorials/0-introduce/#bcc","title":"BCC","text":"<p>BCC stands for BPF Compiler Collection. The project is a Python library that includes a complete toolchain for writing, compiling, and loading BPF programs, as well as tools for debugging and diagnosing performance issues.</p> <p>Since its release in 2015, BCC has been continuously improved by hundreds of contributors and now includes a large number of ready-to-use tracing tools. The official project repository provides a handy tutorial for users to quickly get started with BCC.</p> <p>Users can program in high-level languages such as Python and Lua on BCC. Compared to programming directly in C, these high-level languages are much more convenient. Users only need to design BPF programs in C, and the rest, including compilation, parsing, loading, etc., can be done by BCC.</p> <p>However, a drawback of using BCC is its compatibility. Each time an eBPF program based on BCC is executed, it needs to be compiled, and compiling requires users to configure related header files and corresponding implementations. In practical applications, as you may have experienced, dependency issues in compilation can be quite tricky. Therefore, in the development of this project, we have abandoned BCC and chosen the libbpf-bootstrap tool, which allows for one-time compilation and multiple runs.</p>"},{"location":"tutorials/0-introduce/#ebpf-go-library","title":"eBPF Go library","text":"<p>The eBPF Go library provides a general-purpose eBPF library that decouples the process of obtaining eBPF bytecode from the loading and management of eBPF programs, and implements similar CO- functionality as libbpf. eBPF programs are usually created by writing high-level languages and then compiled into eBPF bytecode using the clang/LLVM compiler.</p>"},{"location":"tutorials/0-introduce/#libbpf","title":"libbpf","text":"<p><code>libbpf-bootstrap</code> is a BPF development scaffold based on the <code>libbpf</code> library, and its source code can be obtained from its GitHub.</p> <p><code>libbpf-bootstrap</code> combines years of practice from the BPF community and provides a modern and convenient workflow for developers, achieving the goal of one-time compilation and reuse.</p> <p>BPF programs based on <code>libbpf-bootstrap</code> have certain naming conventions for the source files. The file for generating kernel space bytecode ends with <code>.bpf.c</code>, and the file for loading bytecode in user space ends with <code>.c</code>, and the prefixes of these two files must be the same.Instructions: Translate the following Chinese text to English  while maintaining the original formatting: \"Based on <code>libbpf-bootstrap</code>, BPF programs will compile <code>*.bpf.c</code> files into corresponding <code>.o</code> files, and then generate the <code>skeleton</code> file based on this file, i.e. <code>*.skel.h</code>. This file will contain some data structures defined in the kernel space, as well as the key functions used to load kernel space code. After the user-space code includes this file, it can call the corresponding loading function to load the bytecode into the kernel. Similarly, <code>libbpf-bootstrap</code> also has a comprehensive introduction tutorial that users can refer to here for detailed introductory operations.</p>"},{"location":"tutorials/0-introduce/#eunomia-bpf","title":"eunomia-bpf","text":"<p>Developing, building, and distributing eBPF has always been a high-threshold task. The use of tools such as BCC and bpftrace has high development efficiency and good portability. However, when it comes to distribution and deployment, it requires the installation of LLVM, Clang, and other compilation environments, and the compilation process needs to be executed locally or remotely every time, resulting in substantial resource consumption. On the other hand, using the native CO-RE libbpf requires writing a considerable amount of user-mode loading code to help properly load eBPF programs and obtain reported information from the kernel. At the same time, there is no good solution for distributing and managing eBPF programs.</p> <p>eunomia-bpf is an open-source eBPF dynamic loading runtime and development toolchain designed to simplify the development, building, distribution, and execution of eBPF programs. It is based on the libbpf CO-RE lightweight development framework.</p> <p>With eunomia-bpf, you can:</p> <ul> <li>When writing eBPF programs or tools, only write kernel space code, automatically retrieve kernel space export information, and dynamically load it as a module.</li> <li>Use WASM for user space interactive program development to control the loading and execution of the entire eBPF program, as well as the processing of related data inside the WASM virtual machine.</li> <li>eunomia-bpf can package pre-compiled eBPF programs into universal JSON or WASM modules for distribution across architectures and kernel versions. They can be dynamically loaded and run without the need for recompilation.</li> </ul> <p>eunomia-bpf consists of a compilation toolchain and a runtime library. Compared with traditional frameworks such as BCC and native libbpf, it greatly simplifies the development process of eBPF programs. In most cases, only writing kernel space code is required to easily build, package, and publish complete eBPF applications. At the same time, kernel space eBPF code ensures 100% compatibility with mainstream development frameworks such as libbpf, libbpfgo, libbpf-rs, etc. When there is a need to write user-space code, it can also be developed in multiple languages with the help of WebAssembly. Compared with script tools such as bpftrace, eunomia-bpf retains similar convenience, while not only limited to tracing but also applicable to more scenarios, such as networking, security, etc.</p> <ul> <li>eunomia-bpf project Github address: https://github.com/eunomia-bpf/eunomia-bpf</li> <li>gitee mirror: https://gitee.com/anolis/eunomia</li> </ul>"},{"location":"tutorials/0-introduce/#references","title":"References","text":"<ul> <li>eBPF Introduction: https://ebpf.io/</li> <li>BPF Compiler Collection (BCC): https://github.com/iovisor/bcc</li> <li>eunomia-bpf: https://github.com/eunomia-bpf/eunomia-bpf</li> </ul> <p>You can also visit our tutorial code repository https://github.com/eunomia-bpf/bpf-developer-tutorial for more examples and complete tutorial source code. All content is open source. We will continue to share more content about eBPF development practices to help you better understand and master eBPF technology.\".</p>"},{"location":"tutorials/1-helloworld/","title":"eBPF Getting Started Tutorial 1 Hello World, Basic Framework and Development Process","text":"<p>In this blog post, we will delve into the basic framework and development process of eBPF (Extended Berkeley Packet Filter). eBPF is a powerful network and performance analysis tool that runs on the Linux kernel, providing developers with the ability to dynamically load, update, and run user-defined code at kernel runtime. This enables developers to implement efficient, secure kernel-level network monitoring, performance analysis, and troubleshooting functionalities.</p> <p>This article is the second part of the eBPF Getting Started Tutorial, where we will focus on how to write a simple eBPF program and demonstrate the entire development process through practical examples. Before reading this tutorial, it is recommended that you first learn the concepts of eBPF by studying the first tutorial.</p> <p>When developing eBPF programs, there are multiple development frameworks to choose from, such as BCC (BPF Compiler Collection) libbpf, cilium/ebpf, eunomia-bpf, etc. Although these tools have different characteristics, their basic development process is similar. In the following content, we will delve into these processes and use the Hello World program as an example to guide readers in mastering the basic skills of eBPF development.</p> <p>This tutorial will help you understand the basic structure of eBPF programs, the compilation and loading process, the interaction between user space and kernel space, as well as debugging and optimization techniques. By studying this tutorial, you will master the basic knowledge of eBPF development and lay a solid foundation for further learning and practice.</p>"},{"location":"tutorials/1-helloworld/#preparation-of-ebpf-development-environment-and-basic-development-process","title":"Preparation of eBPF Development Environment and Basic Development Process","text":"<p>Before starting to write eBPF programs, we need to prepare a suitable development environment and understand the basic development process of eBPF programs. This section will provide a detailed introduction to these subjects.</p>"},{"location":"tutorials/1-helloworld/#installing-the-necessary-software-and-tools","title":"Installing the necessary software and tools","text":"<p>To develop eBPF programs, you need to install the following software and tools:</p> <ul> <li>Linux kernel: Since eBPF is a kernel technology, you need to have a relatively new version of the Linux kernel (recommended version 4.8 and above) to support eBPF functionality.</li> <li>LLVM and Clang: These tools are used to compile eBPF programs. Installing the latest version of LLVM and Clang ensures that you get the best eBPF support.</li> </ul> <p>An eBPF program consists of two main parts: the kernel space part and the user space part. The kernel space part contains the actual logic of the eBPF program, while the user space part is responsible for loading, running, and monitoring the kernel space program.</p> <p>Once you have chosen a suitable development framework, such as BCC (BPF Compiler Collection), libbpf, cilium/ebpf, or eunomia-bpf, you can begin developing the user space and kernel space programs. Taking the BCC tool as an example, we will introduce the basic development process of eBPF programs:</p> <ol> <li>Installing the BCC tool: Depending on your Linux distribution, follow the guidelines in the BCC documentation to install the BCC tool and its dependencies.</li> <li>Writing an eBPF program (C language): Use the C language to write a simple eBPF program, such as the Hello World program. This program can be executed in kernel space and perform specific tasks, such as counting network packets.</li> <li>Writing a user space program (Python or C, etc.): Use languages like Python or C to write a user space program that is responsible for loading, running, and interacting with the eBPF program. In this program, you need to use the API provided by BCC to load and manipulate the kernel space eBPF program.</li> <li>Compiling the eBPF program: Use the BCC tool to compile the eBPF program written in C language into bytecode that can be executed by the kernel. BCC dynamically compiles the eBPF program from source code at runtime.</li> <li>Loading and running the eBPF program: In the user space program, use the API provided by BCC to load the compiled eBPF program into kernel space and then run it.</li> <li>Interacting with the eBPF program: The user space program interacts with the eBPF program through the API provided by BCC, implementing data collection, analysis, and display functions. For example, you can use the BCC API to read map data in the eBPF program to obtain network packet statistics.</li> <li>Unloading the eBPF program: When the eBPF program is no longer needed, the user space program should unload it from the kernel space using the BCC API.</li> <li>Debugging and optimization: Use tools like bpftool to debug and optimize eBPF programs, improving program performance and stability.</li> </ol> <p>Through the above process, you can develop, compile, run, and debug eBPF programs using the BCC tool. Note that the development process of other frameworks, such as libbpf, cilium/ebpf, and eunomia-bpf, is similar but slightly different. Therefore, when choosing a framework, please refer to the respective official documentation and examples.</p> <p>By following this process, you can develop an eBPF program that runs in the kernel. eunomia-bpf is an open-source eBPF dynamic loading runtime and development toolchain. It aims to simplify the development, building, distribution, and running of eBPF programs. It is based on the libbpf CO-RE lightweight development framework, supports loading and executing eBPF programs through a user space WebAssembly (WASM) virtual machine, and packages precompiled eBPF programs into universal JSON or WASM modules for distribution. We will use eunomia-bpf for demonstration purposes.</p>"},{"location":"tutorials/1-helloworld/#download-and-install-eunomia-bpf-development-tools","title":"Download and Install eunomia-bpf Development Tools","text":"<p>You can download and install eunomia-bpf using the following steps:</p> <p>Download the ecli tool for running eBPF programs:</p> <pre><code>$ wget https://aka.pw/bpf-ecli -O ecli &amp;&amp; chmod +x ./ecli\n$ ./ecli -h\nUsage: ecli [--help] [--version] [--json] [--no-cache] url-and-args\n</code></pre> <p>Download the compiler toolchain for compiling eBPF kernel code into config files or WASM modules:</p> <pre><code>$ wget https://github.com/eunomia-bpf/eunomia-bpf/releases/latest/download/ecc &amp;&amp; chmod +x ./ecc\n$ ./ecc -h\neunomia-bpf compiler\nUsage: ecc [OPTIONS] &lt;SOURCE_PATH&gt; [EXPORT_EVENT_HEADER]\n....\n</code></pre> <p>You can also compile using the docker image:</p> <pre><code>$ docker run -it -v `pwd`/:/src/ ghcr.io/eunomia-bpf/ecc-`uname -m`:latest # Compile using docker. `pwd` should contain *.bpf.c files and *.h files.\nexport PATH=PATH:~/.eunomia/bin\nCompiling bpf object...\nPacking ebpf object and config into /src/package.json...\n</code></pre>"},{"location":"tutorials/1-helloworld/#hello-world-minimal-ebpf-program","title":"Hello World - minimal eBPF program","text":"<p>We will start with a simple eBPF program that prints a message in the kernel. We will use the eunomia-bpf compiler toolchain to compile it into a BPF bytecode file, and then load and run the program using the ecli tool. For the sake of the example, we can temporarily disregard the user space program.</p> <pre><code>/* SPDX-License-Identifier: (LGPL-2.1 OR BSD-2-Clause) */\n#define BPF_NO_GLOBAL_DATA\n#include &lt;linux/bpf.h&gt;\n#include &lt;bpf/bpf_helpers.h&gt;\n#include &lt;bpf/bpf_tracing.h&gt;\ntypedef unsigned int u32;\ntypedef int pid_t;\nconst pid_t pid_filter = 0;\nchar LICENSE[] SEC(\"license\") = \"Dual BSD/GPL\";\nSEC(\"tp/syscalls/sys_enter_write\")\nint handle_tp(void *ctx)\n{\npid_t pid = bpf_get_current_pid_tgid() &gt;&gt; 32;\nif (pid_filter &amp;&amp; pid != pid_filter)\nreturn 0;\nbpf_printk(\"BPF triggered sys_enter_write from PID %d.\\n\", pid);\nreturn 0;\n}\n</code></pre> <p>This program defines a handle_tp function and attaches it to the sys_enter_write tracepoint using the SEC macro (i.e., it is executed when the write system call is entered). The function retrieves the process ID of the write system call invocation using the bpf_get_current_pid_tgid and bpf_printk functions, and prints it in the kernel log.</p> <ul> <li><code>bpf_trace_printk()</code>: A simple mechanism to output information to the trace_pipe (/sys/kernel/debug/tracing/trace_pipe). This is fine for simple use cases, but it has limitations: a maximum of 3 parameters; the first parameter must be %s (i.e., a string); and the trace_pipe is globally shared in the kernel, so other programs using the trace_pipe concurrently might disrupt its output. A better approach is to use BPF_PERF_OUTPUT(), which will be discussed later.</li> <li><code>void *ctx</code>: ctx is originally a parameter of a specific type, but since it is not used here, it is written as void *.</li> <li><code>return 0;</code>: This is necessary, returning 0 (to know why, refer to #139 https://github.com/iovisor/bcc/issues/139).</li> </ul> <p>To compile and run this program, you can use the ecc tool and ecli command. First, on Ubuntu/Debian, execute the following command:</p> <pre><code>sudo apt install clang llvm\n</code></pre> <p>Compile the program using ecc:\".```console $ ./ecc minimal.bpf.c Compiling bpf object... Packing ebpf object and config into package.json... <pre><code>Or compile using a docker image:\n\n```shell\ndocker run -it -v `pwd`/:/src/ ghcr.io/eunomia-bpf/ecc-`uname -m`:latest\n</code></pre></p> <p>Then run the compiled program using ecli:</p> <pre><code>$ sudo ./ecli run package.json\nRunning eBPF program...\n</code></pre> <p>After running this program, you can view the output of the eBPF program by checking the /sys/kernel/debug/tracing/trace_pipe file:</p> <pre><code>$ sudo cat /sys/kernel/debug/tracing/trace_pipe | grep \"BPF triggered sys_enter_write\"\n           &lt;...&gt;-3840345 [010] d... 3220701.101143: bpf_trace_printk: write system call from PID 3840345.\n           &lt;...&gt;-3840345 [010] d... 3220701.101143: bpf_trace_printk: write system call from PID 3840345.\n</code></pre> <p>Once you stop the ecli process by pressing Ctrl+C, the corresponding output will also stop.</p> <p>Note: If your Linux distribution (e.g. Ubuntu) does not have the tracing subsystem enabled by default, you may not see any output. Use the following command to enable this feature:</p> <pre><code>$ sudo su\n# echo 1 &gt; /sys/kernel/debug/tracing/tracing_on\n</code></pre>"},{"location":"tutorials/1-helloworld/#basic-framework-of-ebpf-program","title":"Basic Framework of eBPF Program","text":"<p>As mentioned above, the basic framework of an eBPF program includes:</p> <ul> <li>Including header files: You need to include  and  header files, among others. <li>Defining a license: You need to define a license, typically using \"Dual BSD/GPL\".</li> <li>Defining a BPF function: You need to define a BPF function, for example, named handle_tp, which takes void *ctx as a parameter and returns int. This is usually written in the C language.</li> <li>Using BPF helper functions: In the BPF function, you can use BPF helper functions such as bpf_get_current_pid_tgid() and bpf_printk().</li> <li>Return value</li>"},{"location":"tutorials/1-helloworld/#tracepoints","title":"Tracepoints","text":"<p>Tracepoints are a kernel static instrumentation technique, technically just trace functions placed in the kernel source code, which are essentially probe points with control conditions inserted into the source code, allowing post-processing with additional processing functions. For example, the most common static tracing method in the kernel is printk, which outputs log messages. For example, there are tracepoints at the start and end of system calls, scheduler events, file system operations, and disk I/O. Tracepoints were first introduced in Linux version 2.6.32 in 2009. Tracepoints are a stable API and their number is limited.</p>"},{"location":"tutorials/1-helloworld/#github-templates-build-ebpf-projects-and-development-environments-easily","title":"GitHub Templates: Build eBPF Projects and Development Environments Easily","text":"<p>When faced with creating an eBPF project, are you confused about how to set up the environment and choose a programming language? Don't worry, we have prepared a series of GitHub templates to help you quickly start a brand new eBPF project. Just click the <code>Use this template</code> button on GitHub to get started.</p> <ul> <li>https://github.com/eunomia-bpf/libbpf-starter-template: eBPF project template based on the C language and libbpf framework.</li> <li>https://github.com/eunomia-bpf/cilium-ebpf-starter-template: eBPF project template based on the C language and cilium/ebpf framework.</li> <li>https://github.com/eunomia-bpf/libbpf-rs-starter-template: eBPF project template based on the Rust language and libbpf-rs framework.</li> <li>https://github.com/eunomia-bpf/eunomia-template: eBPF project template based on the C language and eunomia-bpf framework.</li> </ul> <p>These starter templates include the following features:</p> <ul> <li>A Makefile for building the project with one command.</li> <li>A Dockerfile for automatically creating a containerized environment for your eBPF project and publishing it to Github Packages.- GitHub Actions, used for automating build, test, and release processes</li> <li>All dependencies required for eBPF development</li> </ul> <p>By setting an existing repository as a template, you and others can quickly generate new repositories with the same underlying structure, eliminating the tedious process of manual creation and configuration. With GitHub template repositories, developers can focus on the core functionality and logic of their projects without wasting time on setup and structure. For more information about template repositories, please refer to the official documentation: https://docs.github.com/en/repositories/creating-and-managing-repositories/creating-a-template-repository</p>"},{"location":"tutorials/1-helloworld/#summary","title":"Summary","text":"<p>The development and usage process of eBPF programs can be summarized in the following steps:</p> <ul> <li>Define the interface and types of eBPF programs: This includes defining the interface functions of eBPF programs, defining and implementing eBPF kernel maps and shared memory (perf events), and defining and using eBPF kernel helper functions.</li> <li>Write the code for eBPF programs: This includes writing the main logic of the eBPF program, implementing read and write operations on eBPF kernel maps, and using eBPF kernel helper functions.</li> <li>Compile the eBPF program: This includes using an eBPF compiler (such as clang) to compile the eBPF program code into eBPF bytecode and generate an executable eBPF kernel module. ecc essentially calls the clang compiler to compile eBPF programs.</li> <li>Load the eBPF program into the kernel: This includes loading the compiled eBPF kernel module into the Linux kernel and attaching the eBPF program to the specified kernel events.</li> <li>Use the eBPF program: This includes monitoring the execution of the eBPF program and exchanging and sharing data using eBPF kernel maps and shared memory.</li> <li>In practical development, there may be additional steps such as configuring compilation and loading parameters, managing eBPF kernel modules and kernel maps, and using other advanced features.</li> </ul> <p>It should be noted that the execution of BPF programs occurs in the kernel space, so special tools and techniques are needed to write, compile, and debug BPF programs. eunomia-bpf is an open-source BPF compiler and toolkit that can help developers write and run BPF programs quickly and easily.</p> <p>You can also visit our tutorial code repository https://github.com/eunomia-bpf/bpf-developer-tutorial for more examples and complete tutorials, all of which are open-source. We will continue to share more about eBPF development practices to help you better understand and master eBPF technology.</p>"},{"location":"tutorials/10-hardirqs/","title":"eBPF Beginner's Development Tutorial Ten: Capturing Interrupt Events in eBPF Using hardirqs or softirqs","text":"<p>eBPF (Extended Berkeley Packet Filter) is a powerful network and performance analysis tool on the Linux kernel. It allows developers to dynamically load, update, and run user-defined code at runtime in the kernel.</p> <p>This article is the tenth part of the eBPF Beginner's Development Tutorial, focusing on capturing interrupt events using hardirqs or softirqs in eBPF. hardirqs and softirqs are two different types of interrupt handlers in the Linux kernel. They are used to handle interrupt requests generated by hardware devices, as well as asynchronous events in the kernel. In eBPF, we can use the eBPF tools hardirqs and softirqs to capture and analyze information related to interrupt handling in the kernel.</p>"},{"location":"tutorials/10-hardirqs/#what-are-hardirqs-and-softirqs","title":"What are hardirqs and softirqs?","text":"<p>hardirqs are hardware interrupt handlers. When a hardware device generates an interrupt request, the kernel maps it to a specific interrupt vector and executes the associated hardware interrupt handler. Hardware interrupt handlers are commonly used to handle events in device drivers, such as completion of device data transfer or device errors.</p> <p>softirqs are software interrupt handlers. They are a low-level asynchronous event handling mechanism in the kernel, used for handling high-priority tasks in the kernel. softirqs are commonly used to handle events in the network protocol stack, disk subsystem, and other kernel components. Compared to hardware interrupt handlers, software interrupt handlers have more flexibility and configurability.</p>"},{"location":"tutorials/10-hardirqs/#implementation-details","title":"Implementation Details","text":"<p>In eBPF, we can capture and analyze hardirqs and softirqs by attaching specific kprobes or tracepoints. To capture hardirqs and softirqs, eBPF programs need to be placed on relevant kernel functions. These functions include:</p> <ul> <li>For hardirqs: irq_handler_entry and irq_handler_exit.</li> <li>For softirqs: softirq_entry and softirq_exit.</li> </ul> <p>When the kernel processes hardirqs or softirqs, these eBPF programs are executed to collect relevant information such as interrupt vectors, execution time of interrupt handlers, etc. The collected information can be used for analyzing performance issues and other interrupt handling related problems in the kernel.</p> <p>To capture hardirqs and softirqs, the following steps can be followed:</p> <ol> <li>Define data structures and maps in eBPF programs for storing interrupt information.</li> <li>Write eBPF programs and attach them to the corresponding kernel functions to capture hardirqs or softirqs.</li> <li>In eBPF programs, collect relevant information about interrupt handlers and store this information in the maps.</li> <li>In user space applications, read the data from the maps to analyze and display the interrupt handling information.</li> </ol> <p>By following the above approach, we can use hardirqs and softirqs in eBPF to capture and analyze interrupt events in the kernel, identifying potential performance issues and interrupt handling related problems.</p>"},{"location":"tutorials/10-hardirqs/#implementation-of-hardirqs-code","title":"Implementation of hardirqs Code","text":"<p>The main purpose of the hardirqs program is to obtain the name, execution count, and execution time of interrupt handlers and display the distribution of execution time in the form of a histogram. Let's analyze this code step by step.</p> <pre><code>// SPDX-License-Identifier: GPL-2.0\n// Copyright (c) 2020 Wenbo Zhang\n#include &lt;vmlinux.h&gt;\n#include &lt;bpf/bpf_core_read.h&gt;\n#include &lt;bpf/bpf_helpers.h&gt;\n#include &lt;bpf/bpf_tracing.h&gt;\n#include \"hardirqs.h\"\n#include \"bits.bpf.h\"\n#include \"maps.bpf.h\"\n#define MAX_ENTRIES 256\nconst volatile bool filter_cg = false;\nconst volatile bool targ_dist = false;\nconst volatile bool targ_ns = false;\nconst volatile bool do_count = false;\nstruct {\n__uint(type, BPF_MAP_TYPE_CGROUP_ARRAY);\n__type(key, u32);\n__type(value, u32);\n__uint(max_entries, 1);\n} cgroup_map SEC(\".maps\");\nstruct {\n__uint(type, BPF_MAP_TYPE_PERCPU_ARRAY);\n__uint(max_entries, 1);\n__type(key, u32);\n__type(value, u64);\n``````c\n} start SEC(\".maps\");\nstruct {\n__uint(type, BPF_MAP_TYPE_HASH);\n__uint(max_entries, MAX_ENTRIES);\n__type(key, struct irq_key);\n__type(value, struct info);\n} infos SEC(\".maps\");\nstatic struct info zero;\nstatic int handle_entry(int irq, struct irqaction *action)\n{\nif (filter_cg &amp;&amp; !bpf_current_task_under_cgroup(&amp;cgroup_map, 0))\nreturn 0;\nif (do_count) {\nstruct irq_key key = {};\nstruct info *info;\nbpf_probe_read_kernel_str(&amp;key.name, sizeof(key.name), BPF_CORE_READ(action, name));\ninfo = bpf_map_lookup_or_try_init(&amp;infos, &amp;key, &amp;zero);\nif (!info)\nreturn 0;\ninfo-&gt;count += 1;\nreturn 0;\n} else {\nu64 ts = bpf_ktime_get_ns();\nu32 key = 0;\nif (filter_cg &amp;&amp; !bpf_current_task_under_cgroup(&amp;cgroup_map, 0))\nreturn 0;\nbpf_map_update_elem(&amp;start, &amp;key, &amp;ts, BPF_ANY);\nreturn 0;\n}\n}\nstatic int handle_exit(int irq, struct irqaction *action)\n{\nstruct irq_key ikey = {};\nstruct info *info;\nu32 key = 0;\nu64 delta;\nu64 *tsp;\nif (filter_cg &amp;&amp; !bpf_current_task_under_cgroup(&amp;cgroup_map, 0))\nreturn 0;\ntsp = bpf_map_lookup_elem(&amp;start, &amp;key);\nif (!tsp)\nreturn 0;\ndelta = bpf_ktime_get_ns() - *tsp;\nif (!targ_ns)\ndelta /= 1000U;\nbpf_probe_read_kernel_str(&amp;ikey.name, sizeof(ikey.name), BPF_CORE_READ(action, name));\ninfo = bpf_map_lookup_or_try_init(&amp;infos, &amp;ikey, &amp;zero);\nif (!info)\nreturn 0;\nif (!targ_dist) {\ninfo-&gt;count += delta;\n} else {\nu64 slot;\nslot = log2(delta);\nif (slot &gt;= MAX_SLOTS)\nslot = MAX_SLOTS - 1;\ninfo-&gt;slots[slot]++;\n}\nreturn 0;\n}\nSEC(\"tp_btf/irq_handler_entry\")\nint BPF_PROG(irq_handler_entry_btf, int irq, struct irqaction *action)\n{\nreturn handle_entry(irq, action);\n}\nSEC(\"tp_btf/irq_handler_exit\")\nint BPF_PROG(irq_handler_exit_btf, int irq, struct irqaction *action)\n{\nreturn handle_exit(irq, action);\n}\nSEC(\"raw_tp/irq_handler_entry\")\nint BPF_PROG(irq_handler_entry, int irq, struct irqaction *action)\n{\nreturn handle_entry(irq, action);\n}\nSEC(\"raw_tp/irq_handler_exit\")\n```int BPF_PROG(irq_handler_exit, int irq, struct irqaction *action)\n{\nreturn handle_exit(irq, action);\n}\nchar LICENSE[] SEC(\"license\") = \"GPL\";\n</code></pre> <p>This code is an eBPF program used to capture and analyze the execution information of hardware interrupt handlers (hardirqs) in the kernel. The main purpose of the program is to obtain the name, execution count, and execution time of the interrupt handler, and display the distribution of execution time in the form of a histogram. Let's analyze this code step by step.</p> <ol> <li> <p>Include necessary header files and define data structures:</p> <pre><code>#include &lt;vmlinux.h&gt;\n#include &lt;bpf/bpf_core_read.h&gt;\n#include &lt;bpf/bpf_helpers.h&gt;\n#include &lt;bpf/bpf_tracing.h&gt;\n#include \"hardirqs.h\"\n#include \"bits.bpf.h\"\n#include \"maps.bpf.h\"\n</code></pre> <p>This program includes the standard header files required for eBPF development, as well as custom header files for defining data structures and maps.</p> </li> <li> <p>Define global variables and maps:</p> <pre><code>#define MAX_ENTRIES 256\nconst volatile bool filter_cg = false;\nconst volatile bool targ_dist = false;\nconst volatile bool targ_ns = false;\nconst volatile bool do_count = false;\n...\n</code></pre> <p>This program defines some global variables that are used to configure the behavior of the program. For example, <code>filter_cg</code> controls whether to filter cgroups, <code>targ_dist</code> controls whether to display the distribution of execution time, etc. Additionally, the program defines three maps for storing cgroup information, start timestamps, and interrupt handler information.</p> </li> <li> <p>Define two helper functions <code>handle_entry</code> and <code>handle_exit</code>:</p> <p>These two functions are called at the entry and exit points of the interrupt handler. <code>handle_entry</code> records the start timestamp or updates the interrupt count, while <code>handle_exit</code> calculates the execution time of the interrupt handler and stores the result in the corresponding information map.</p> </li> <li> <p>Define the entry points of the eBPF program:</p> <pre><code>SEC(\"tp_btf/irq_handler_entry\")\nint BPF_PROG(irq_handler_entry_btf, int irq, struct irqaction *action)\n{\nreturn handle_entry(irq, action);\n}\nSEC(\"tp_btf/irq_handler_exit\")\nint BPF_PROG(irq_handler_exit_btf, int irq, struct irqaction *action)\n{\nreturn handle_exit(irq, action);\n}\nSEC(\"raw_tp/irq_handler_entry\")\nint BPF_PROG(irq_handler_entry, int irq, struct irqaction *action)\n{\nreturn handle_entry(irq, action);\n}\nSEC(\"raw_tp/irq_handler_exit\")\nint BPF_PROG(irq_handler_exit, int irq, struct irqaction *action)\n{\nreturn handle_exit(irq, action);\n}\n</code></pre> <p>Here, four entry points of the eBPF program are defined, which are used to capture the entry and exit events of the interrupt handler. <code>tp_btf</code> and <code>raw_tp</code> represent capturing events using BPF Type Format (BTF) and raw tracepoints, respectively. This ensures that the program can be ported and run on different kernel versions.</p> </li> </ol> <p>The code for Softirq is similar, and I won't elaborate on it here.</p>"},{"location":"tutorials/10-hardirqs/#run-codetranslated-content","title":"Run code.Translated content:","text":"<p>\"eunomia-bpf is an open-source eBPF dynamic loading runtime and development toolchain that combines Wasm. Its purpose is to simplify the development, building, distribution, and execution of eBPF programs. You can refer to https://github.com/eunomia-bpf/eunomia-bpf to download and install the ecc compilation toolchain and ecli runtime. We use eunomia-bpf to compile and run this example.</p> <p>To compile this program, use the ecc tool:</p> <pre><code>$ ecc hardirqs.bpf.c\nCompiling bpf object...\nPacking ebpf object and config into package.json...\n</code></pre> <p>Then run:</p> <pre><code>sudo ecli run ./package.json\n</code></pre>"},{"location":"tutorials/10-hardirqs/#summary","title":"Summary","text":"<p>In this chapter (eBPF Getting Started Tutorial Ten: Capturing Interrupt Events in eBPF with Hardirqs or Softirqs), we learned how to capture and analyze the execution information of hardware interrupt handlers (hardirqs) in the kernel using eBPF programs. We explained the example code in detail, including how to define data structures, mappings, eBPF program entry points, and how to call helper functions to record execution information at the entry and exit points of interrupt handlers.</p> <p>By studying the content of this chapter, you should have mastered the methods of capturing interrupt events with hardirqs or softirqs in eBPF, as well as how to analyze these events to identify performance issues and other problems related to interrupt handling in the kernel. These skills are crucial for analyzing and optimizing the performance of the Linux kernel.</p> <p>To better understand and practice eBPF programming, we recommend reading the official documentation of eunomia-bpf: https://github.com/eunomia-bpf/eunomia-bpf. In addition, we provide a complete tutorial and source code for you to view and learn from at https://github.com/eunomia-bpf/bpf-developer-tutorial. We hope this tutorial can help you get started with eBPF development smoothly and provide useful references for your further learning and practice.\"</p>"},{"location":"tutorials/11-bootstrap/","title":"eBPF Beginner's Development Practice Tutorial 11: Using libbpf to Develop User-Space Programs in eBPF and Trace exec() and exit() System Calls","text":"<p>eBPF (Extended Berkeley Packet Filter) is a powerful network and performance analysis tool on the Linux kernel. It allows developers to dynamically load, update, and run user-defined code during kernel runtime.</p> <p>In this tutorial, we will learn how kernel-space and user-space eBPF programs work together. We will also learn how to use the native libbpf to develop user-space programs, package eBPF applications into executable files, and distribute them across different kernel versions.</p>"},{"location":"tutorials/11-bootstrap/#the-libbpf-library-and-why-we-need-to-use-it","title":"The libbpf Library and Why We Need to Use It","text":"<p>libbpf is a C language library that is distributed with the kernel version to assist in loading and running eBPF programs. It provides a set of C APIs for interacting with the eBPF system, allowing developers to write user-space programs more easily to load and manage eBPF programs. These user-space programs are typically used for system performance analysis, monitoring, or optimization.</p> <p>There are several advantages to using the libbpf library:</p> <ul> <li>It simplifies the process of loading, updating, and running eBPF programs.</li> <li>It provides a set of easy-to-use APIs, allowing developers to focus on writing core logic instead of dealing with low-level details.</li> <li>It ensures compatibility with the eBPF subsystem in the kernel, reducing maintenance costs.</li> </ul> <p>At the same time, libbpf and BTF (BPF Type Format) are important components of the eBPF ecosystem. They play critical roles in achieving compatibility across different kernel versions. BTF is a metadata format used to describe type information in eBPF programs. The primary purpose of BTF is to provide a structured way to describe data structures in the kernel so that eBPF programs can access and manipulate them more easily.</p> <p>The key roles of BTF in achieving compatibility across different kernel versions are as follows:</p> <ul> <li>BTF allows eBPF programs to access detailed type information of kernel data structures without hardcoding specific kernel versions. This enables eBPF programs to adapt to different kernel versions, achieving compatibility across kernel versions.</li> <li>By using BPF CO-RE (Compile Once, Run Everywhere) technology, eBPF programs can leverage BTF to parse the type information of kernel data structures during compilation, thereby generating eBPF programs that can run on different kernel versions.</li> </ul> <p>By combining libbpf and BTF, eBPF programs can run on various kernel versions without the need for separate compilation for each kernel version. This greatly improves the portability and compatibility of the eBPF ecosystem and reduces the difficulty of development and maintenance.</p>"},{"location":"tutorials/11-bootstrap/#what-is-bootstrap","title":"What is Bootstrap","text":"<p>Bootstrap is a complete application that utilizes libbpf. It uses eBPF programs to trace the exec() system call in the kernel (handled by the SEC(\"tp/sched/sched_process_exec\") handle_exec BPF program), which mainly corresponds to the creation of new processes (excluding the fork() part). In addition, it also traces the exit() system call of processes (handled by the SEC(\"tp/sched/sched_process_exit\") handle_exit BPF program) to understand when each process exits.</p> <p>These two BPF programs work together to capture interesting information about new processes, such as the file name of the binary and measure the lifecycle of processes. They also collect interesting statistics, such as exit codes or resource consumption, when a process exits. This is a good starting point to gain a deeper understanding of the inner workings of the kernel and observe how things actually operate.</p> <p>Bootstrap also uses the argp API (part of libc) for command-line argument parsing, allowing users to configure the behavior of the application through command-line options. This provides flexibility and allows users to customize the program behavior according to their specific needs. While these functionalities can also be achieved using the eunomia-bpf tool, using libbpf here provides higher scalability in user space at the cost of additional complexity.</p>"},{"location":"tutorials/11-bootstrap/#bootstrap","title":"Bootstrap","text":"<p>Bootstrap consists of two parts: kernel space and user space. The kernel space part is an eBPF program that traces the exec() and exit() system calls. The user space part is a C language program that uses the libbpf library to load and run the kernel space program and process the data collected from the kernel space program.</p>"},{"location":"tutorials/11-bootstrap/#kernel-space-ebpf-program-bootstrapbpfc","title":"Kernel-space eBPF Program bootstrap.bpf.c","text":"<pre><code>// SPDX-License-Identifier: GPL-2.0 OR BSD-3-Clause\n/* Copyright (c) 2020 Facebook */\n#include \"vmlinux.h\"\n#include &lt;bpf/bpf_helpers.h&gt;\n#include &lt;bpf/bpf_tracing.h&gt;\n#include &lt;bpf/bpf_core_read.h&gt;\n#include \"bootstrap.h\"\nchar LICENSE[] SEC(\"license\") = \"Dual BSD/GPL\";\nstruct {\n__uint(type, BPF_MAP_TYPE_HASH);\n__uint(max_entries, 8192);\n__type(key, pid_t);\n__type(value, u64);\n} exec_start SEC(\".maps\");\nstruct {\n__uint(type, BPF_MAP_TYPE_RINGBUF);\n__uint(max_entries, 256 * 1024);\n} rb SEC(\".maps\");\nconst volatile unsigned long long min_duration_ns = 0;\nSEC(\"tp/sched/sched_process_exec\")\nint handle_exec(struct trace_event_raw_sched_process_exec *ctx)\n{\nstruct task_struct *task;\nunsigned fname_off;\nstruct event *e;\npid_t pid;\nu64 ts;\n/* remember time exec() was executed for this PID */\npid = bpf_get_current_pid_tgid() &gt;&gt; 32;\nts = bpf_ktime_get_ns();\nbpf_map_update_elem(&amp;exec_start, &amp;pid, &amp;ts, BPF_ANY);\n/* don't emit exec events when minimum duration is specified */\nif (min_duration_ns)\nreturn 0;\n/* reserve sample from BPF ringbuf */\ne = bpf_ringbuf_reserve(&amp;rb, sizeof(*e), 0);\nif (!e)\nreturn 0;\n/* fill out the sample with data */\ntask = (struct task_struct *)bpf_get_current_task();\ne-&gt;exit_event = false;\ne-&gt;pid = pid;\ne-&gt;ppid = BPF_CORE_READ(task, real_parent, tgid);\nbpf_get_current_comm(&amp;e-&gt;comm, sizeof(e-&gt;comm));\nfname_off = ctx-&gt;__data_loc_filename &amp; 0xFFFF;\nbpf_probe_read_str(&amp;e-&gt;filename, sizeof(e-&gt;filename), (void *)ctx + fname_off);\n/* successfully submit it to user-space for post-processing */\nbpf_ringbuf_submit(e, 0);\nreturn 0;\n}\nSEC(\"tp/sched/sched_process_exit\")\nint handle_exit(struct trace_event_raw_sched_process_template* ctx)\n{\nstruct task_struct *task;\nstruct event *e;\npid_t pid, tid;\nu64 id, ts, *start_ts, duration_ns = 0;\n/* get PID and TID of exiting thread/process */\nid = bpf_get_current_pid_tgid();\npid = id &gt;&gt; 32;\ntid = (u32)id;\n/* ignore thread exits */\nif (pid != tid)\nreturn 0;\n/* if we recorded start of the process, calculate lifetime duration */\nstart_ts = bpf_map_lookup_elem(&amp;exec_start, &amp;pid);\nif (start_ts)duration_ns = bpf_ktime_get_ns() - *start_ts;\nelse if (min_duration_ns)\nreturn 0;\nbpf_map_delete_elem(&amp;exec_start, &amp;pid);\n/* if process didn't live long enough, return early */\nif (min_duration_ns &amp;&amp; duration_ns &lt; min_duration_ns)\nreturn 0;\n/* reserve sample from BPF ringbuf */\ne = bpf_ringbuf_reserve(&amp;rb, sizeof(*e), 0);\nif (!e)\nreturn 0;\n/* fill out the sample with data */\ntask = (struct task_struct *)bpf_get_current_task();\ne-&gt;exit_event = true;\ne-&gt;duration_ns = duration_ns;\ne-&gt;pid = pid;\ne-&gt;ppid = BPF_CORE_READ(task, real_parent, tgid);\ne-&gt;exit_code = (BPF_CORE_READ(task, exit_code) &gt;&gt; 8) &amp; 0xff;\nbpf_get_current_comm(&amp;e-&gt;comm, sizeof(e-&gt;comm));\n/* send data to user-space for post-processing */\nbpf_ringbuf_submit(e, 0);\nreturn 0;\n}\n</code></pre> <p>This code is a kernel-level eBPF program (<code>bootstrap.bpf.c</code>) used to trace <code>exec()</code> and <code>exit()</code> system calls. It captures process creation and exit events using an eBPF program and sends the relevant information to a user-space program for processing. Below is a detailed explanation of the code.</p> <p>First, we include the necessary headers and define the license for the eBPF program. We also define two eBPF maps: <code>exec_start</code> and <code>rb</code>. <code>exec_start</code> is a hash type eBPF map used to store the timestamp when a process starts executing. <code>rb</code> is a ring buffer type eBPF map used to store captured event data and send it to the user-space program.</p> <pre><code>#include \"vmlinux.h\"\n#include &lt;bpf/bpf_helpers.h&gt;\n#include &lt;bpf/bpf_tracing.h&gt;\n#include &lt;bpf/bpf_core_read.h&gt;\n#include \"bootstrap.h\"\nchar LICENSE[] SEC(\"license\") = \"Dual BSD/GPL\";\nstruct {\n__uint(type, BPF_MAP_TYPE_HASH);\n__uint(max_entries, 8192);\n__type(key, pid_t);\n__type(value, u64);\n} exec_start SEC(\".maps\");\nstruct {\n__uint(type, BPF_MAP_TYPE_RINGBUF);\n__uint(max_entries, 256 * 1024);\n} rb SEC(\".maps\");\nconst volatile unsigned long long min_duration_ns = 0;\n</code></pre> <p>Next, we define an eBPF program named <code>handle_exec</code> which is triggered when a process executes the <code>exec()</code> system call. First, we retrieve the PID from the current process, record the timestamp when the process starts executing, and store it in the <code>exec_start</code> map.</p> <pre><code>SEC(\"tp/sched/sched_process_exec\")\nint handle_exec(struct trace_event_raw_sched_process_exec *ctx)\n{\n// ...\npid = bpf_get_current_pid_tgid() &gt;&gt; 32;\nts = bpf_ktime_get_ns();\nbpf_map_update_elem(&amp;exec_start, &amp;pid, &amp;ts, BPF_ANY);\n// ...\n}\n```Then, we reserve an event structure from the circular buffer map `rb` and fill in the relevant data, such as the process ID, parent process ID, and process name. Afterwards, we send this data to the user-mode program for processing.\n```c\n// reserve sample from BPF ringbuf\ne = bpf_ringbuf_reserve(&amp;rb, sizeof(*e), 0);\nif (!e)\nreturn 0;\n// fill out the sample with data\ntask = (struct task_struct *)bpf_get_current_task();\ne-&gt;exit_event = false;\ne-&gt;pid = pid;\ne-&gt;ppid = BPF_CORE_READ(task, real_parent, tgid);\nbpf_get_current_comm(&amp;e-&gt;comm, sizeof(e-&gt;comm));\nfname_off = ctx-&gt;__data_loc_filename &amp; 0xFFFF;\nbpf_probe_read_str(&amp;e-&gt;filename, sizeof(e-&gt;filename), (void *)ctx + fname_off);\n// successfully submit it to user-space for post-processing\nbpf_ringbuf_submit(e, 0);\nreturn 0;\n</code></pre> <p>Finally, we define an eBPF program named <code>handle_exit</code> that will be triggered when a process executes the <code>exit()</code> system call. First, we retrieve the PID and TID (thread ID) from the current process. If the PID and TID are not equal, it means that this is a thread exit, and we will ignore this event.</p> <pre><code>SEC(\"tp/sched/sched_process_exit\")\nint handle_exit(struct trace_event_raw_sched_process_template* ctx)\n{\n// ...\nid = bpf_get_current_pid_tgid();\npid = id &gt;&gt; 32;\ntid = (u32)id;\n/* ignore thread exits */\nif (pid != tid)\nreturn 0;\n// ...\n}\n</code></pre> <p>Next, we look up the timestamp of when the process started execution, which was previously stored in the <code>exec_start</code> map. If a timestamp is found, we calculate the process's lifetime duration and then remove the record from the <code>exec_start</code> map. If a timestamp is not found and a minimum duration is specified, we return directly.</p> <pre><code>    // if we recorded start of the process, calculate lifetime duration\nstart_ts = bpf_map_lookup_elem(&amp;exec_start, &amp;pid);\nif (start_ts)\nduration_ns = bpf_ktime_get_ns() - *start_ts;\nelse if (min_duration_ns)\nreturn 0;\nbpf_map_delete_elem(&amp;exec_start, &amp;pid);\n// if process didn't live long enough, return early\nif (min_duration_ns &amp;&amp; duration_ns &lt; min_duration_ns)\nreturn 0;\n</code></pre> <p>Then, we reserve an event structure from the circular buffer map <code>rb</code> and fill in the relevant data, such as the process ID, parent process ID, process name, and process duration. Finally, we send this data to the user-mode program for processing.</p> <pre><code>    /* reserve sample from BPF ringbuf */\ne = bpf_ringbuf_reserve(&amp;rb, sizeof(*e), 0);\nif (!e)\nreturn 0;\n/* fill out the sample with data */\ntask = (struct task_struct *)bpf_get_current_task();\ne-&gt;exit_event = true;\ne-&gt;duration_ns = duration_ns;```\ne-&gt;pid = pid;\ne-&gt;ppid = BPF_CORE_READ(task, real_parent, tgid);\ne-&gt;exit_code = (BPF_CORE_READ(task, exit_code) &gt;&gt; 8) &amp; 0xff;\nbpf_get_current_comm(&amp;e-&gt;comm, sizeof(e-&gt;comm));\n/* send data to user-space for post-processing */\nbpf_ringbuf_submit(e, 0);\nreturn 0;\n}\n</code></pre> <p>This way, when a process executes the exec() or exit() system calls, our eBPF program captures the corresponding events and sends detailed information to the user space program for further processing. This allows us to easily monitor process creation and termination and obtain detailed information about the processes.</p> <p>In addition, in the bootstrap.h file, we also define the data structures for interaction with user space:</p> <pre><code>/* SPDX-License-Identifier: (LGPL-2.1 OR BSD-2-Clause) */\n/* Copyright (c) 2020 Facebook */\n#ifndef __BOOTSTRAP_H\n#define __BOOTSTRAP_H\n#define TASK_COMM_LEN 16\n#define MAX_FILENAME_LEN 127\nstruct event {\nint pid;\nint ppid;\nunsigned exit_code;\nunsigned long long duration_ns;\nchar comm[TASK_COMM_LEN];\nchar filename[MAX_FILENAME_LEN];\nbool exit_event;\n};\n#endif /* __BOOTSTRAP_H */\n</code></pre>"},{"location":"tutorials/11-bootstrap/#user-space-bootstrapc","title":"User space, bootstrap.c","text":"<pre><code>// SPDX-License-Identifier: (LGPL-2.1 OR BSD-2-Clause)\n/* Copyright (c) 2020 Facebook */\n#include &lt;argp.h&gt;\n#include &lt;signal.h&gt;\n#include &lt;stdio.h&gt;\n#include &lt;time.h&gt;\n#include &lt;sys/resource.h&gt;\n#include &lt;bpf/libbpf.h&gt;\n#include \"bootstrap.h\"\n#include \"bootstrap.skel.h\"\nstatic struct env {\nbool verbose;\nlong min_duration_ms;\n} env;\nconst char *argp_program_version = \"bootstrap 0.0\";\nconst char *argp_program_bug_address = \"&lt;bpf@vger.kernel.org&gt;\";\nconst char argp_program_doc[] =\n\"BPF bootstrap demo application.\\n\"\n\"\\n\"\n\"It traces process start and exits and shows associated \\n\"\n\"information (filename, process duration, PID and PPID, etc).\\n\"\n\"\\n\"\n\"USAGE: ./bootstrap [-d &lt;min-duration-ms&gt;] [-v]\\n\";\nstatic const struct argp_option opts[] = {\n{ \"verbose\", 'v', NULL, 0, \"Verbose debug output\" },\n{ \"duration\", 'd', \"DURATION-MS\", 0, \"Minimum process duration (ms) to report\" },\n{},\n};\nstatic error_t parse_arg(int key, char *arg, struct argp_state *state)\n{\nswitch (key) {\ncase 'v':\nenv.verbose = true;\nbreak;\ncase 'd':\nerrno = 0;\nenv.min_duration_ms = strtol(arg, NULL, 10);\nif (errno || env.min_duration_ms &lt;= 0) {\nfprintf(stderr, \"Invalid duration: %s\\n\", arg);\nargp_usage(state);\n}\nbreak;\ncase ARGP_KEY_ARG:\nargp_usage(state);\nbreak;\ndefault:\nreturn ARGP_ERR_UNKNOWN;\n}\nreturn 0;\n}\nstatic const struct argp argp = {\n.options = opts,\n.parser = parse_arg,\n.doc = argp_program_doc,\n};\nstatic int libbpf_print_fn(enum libbpf_print_level level, const char *format, va_list args)\n{\nif (level == LIBBPF_DEBUG &amp;&amp; !env.verbose)\nreturn 0;\nreturn vfprintf(stderr, format, args);\n}\nstatic volatile bool exiting = false;\nstatic void sig_handler(int sig)\n{\nexiting = true;\n}\nstatic int handle_event(void *ctx, void *data, size_t data_sz)\n{\nconst struct event *e = data;\nstruct tm *tm;\nchar ts[32];\ntime_t t;\ntime(&amp;t);\ntm = localtime(&amp;t);\nstrftime(ts, sizeof(ts), \"%H:%M:%S\", tm);\nif (e-&gt;exit_event) {\nprintf(\"%-8s %-5s %-16s %-7d %-7d [%u]\",\nts, \"EXIT\", e-&gt;comm, e-&gt;pid, e-&gt;ppid, e-&gt;exit_code);\nif (e-&gt;duration_ns)\nprintf(\" (%llums)\", e-&gt;duration_ns / 1000000);\nprintf(\"\\n\");\n} else {\nprintf(\"%-8s %-5s %-16s %-7d %-7d %s\\n\",\nts, \"EXEC\", e-&gt;comm, e-&gt;pid, e-&gt;ppid, e-&gt;filename);\n}\nreturn 0;\n}\nint main(int argc, char **argv)\n{\nstruct ring_buffer *rb = NULL;\nstruct bootstrap_bpf *skel;\nint err;\n/* Parse command line arguments */\nerr = argp_parse(&amp;argp, argc, argv, 0, NULL, NULL);\nif (err)\nreturn err;\n/* Set up libbpf errors and debug info callback */\nlibbpf_set_print(libbpf_print_fn);\n/* Cleaner handling of Ctrl-C */\nsignal(SIGINT, sig_handler);\nsignal(SIGTERM, sig_handler);\n/* Load and verify BPF application */\nskel = bootstrap_bpf__open();\nif (!skel) {\nfprintf(stderr, \"Failed to open and load BPF skeleton\\n\");\nreturn 1;\n}\n/* Parameterize BPF code with minimum duration parameter */\nskel-&gt;rodata-&gt;min_duration_ns = env.min_duration_ms * 1000000ULL;\n/* Load &amp; verify BPF programs */\nerr = bootstrap_bpf__load(skel);\nif (err) {\nfprintf(stderr, \"Failed to load and verify BPF skeleton\\n\");\ngoto cleanup;\n}\n/* Attach tracepoints */\nerr = bootstrap_bpf__attach(skel);\nif (err) {\nfprintf(stderr, \"Failed to attach BPF skeleton\\n\");\ngoto cleanup;\n}\n/* Set up ring buffer polling */\nrb = ring_buffer__new(bpf_map__fd(skel-&gt;maps.rb), handle_event, NULL, NULL);\nif (!rb) {\nerr = -1;\nfprintf(stderr, \"Failed to create ring buffer\\n\");\ngoto cleanup;\n}\n/* Process events */\nprintf(\"%-8s %-5s %-16s %-7s %-7s %s\\n\",\n\"TIME\", \"EVENT\", \"COMM\", \"PID\", \"PPID\", \"FILENAME/EXIT CODE\");\nwhile (!exiting) {\nerr = ring_buffer__poll(rb, 100 /* timeout, ms */);\n/* Ctrl-C will cause -EINTR */\nif (err == -EINTR) {\nerr = 0;\nbreak;\n}\nif (err &lt; 0) {\nprintf(\"Error polling perf buffer: %d\\n\", err);\nbreak;\n}\n}\ncleanup:\n/* Clean up */\nring_buffer__free(rb);\nbootstrap_bpf__destroy(skel);\nreturn err &lt; 0 ? -err : 0;\n}\n</code></pre> <p>This user-level program is mainly used to load, verify, attach eBPF programs, and receive event data collected by eBPF programs and print it out. We will analyze some key parts.</p> <p>First, we define an env structure to store command line arguments:</p> <pre><code>static struct env {\nbool verbose;\nlong min_duration_ms;\n} env;\n</code></pre> <p>Next, we use the argp library to parse command line arguments:</p> <pre><code>static const struct argp_option opts[] = {\n{ \"verbose\", 'v', NULL, 0, \"Verbose debug output\" },\n{ \"duration\", 'd', \"DURATION-MS\", 0, \"Minimum process duration (ms) to report\" },\n{},\n};\nstatic error_t parse_arg(int key, char *arg, struct argp_state *state)\n{\n// ...\n}\nstatic const struct argp argp = {\n.options = opts,\n.parser = parse_arg,\n.doc = argp_program_doc,\n};\n</code></pre> <p>In the main() function, we first parse the command line arguments, and then set the libbpf print callback function libbpf_print_fn to output debug information when needed:</p> <pre><code>err = argp_parse(&amp;argp, argc, argv, 0, NULL, NULL);\nif (err)\nreturn err;```c\nlibbpf_set_print(libbpf_print_fn);\nNext, we open the eBPF skeleton file, pass the minimum duration parameter to the eBPF program, and load and attach the eBPF program:\n```c\nskel = bootstrap_bpf__open();\nif (!skel) {\nfprintf(stderr, \"Failed to open and load BPF skeleton\\n\");\nreturn 1;\n}\nskel-&gt;rodata-&gt;min_duration_ns = env.min_duration_ms * 1000000ULL;\nerr = bootstrap_bpf__load(skel);\nif (err) {\nfprintf(stderr, \"Failed to load and verify BPF skeleton\\n\");\ngoto cleanup;\n}\nerr = bootstrap_bpf__attach(skel);\nif (err) {\nfprintf(stderr, \"Failed to attach BPF skeleton\\n\");\ngoto cleanup;\n}\n</code></pre> <p>Then, we create a ring buffer to receive event data sent by the eBPF program:</p> <pre><code>rb = ring_buffer__new(bpf_map__fd(skel-&gt;maps.rb), handle_event, NULL, NULL);\nif (!rb) {\nerr = -1;\nfprintf(stderr, \"Failed to create ring buffer\\n\");\ngoto cleanup;\n}\n</code></pre> <p>The handle_event() function handles events received from the eBPF program. Depending on the event type (process execution or exit), it extracts and prints event information such as timestamp, process name, process ID, parent process ID, file name, or exit code.</p> <p>Finally, we use the ring_buffer__poll() function to poll the ring buffer and process the received event data:</p> <pre><code>while (!exiting) {\nerr = ring_buffer__poll(rb, 100 /* timeout, ms */);\n// ...\n}\n</code></pre> <p>When the program receives the SIGINT or SIGTERM signal, it completes the final cleanup and exit operations, and closes and unloads the eBPF program:</p> <pre><code>cleanup:\n/* Clean up */\nring_buffer__free(rb);\nbootstrap_bpf__destroy(skel);\nreturn err &lt; 0 ? -err : 0;\n}\n</code></pre>"},{"location":"tutorials/11-bootstrap/#dependency-installation","title":"Dependency Installation","text":"<p>Building the example requires clang, libelf, and zlib. The package names may vary in different distributions.</p> <p>On Ubuntu/Debian, you need to execute the following command:</p> <pre><code>sudo apt install clang libelf1 libelf-dev zlib1g-dev\n</code></pre> <p>On CentOS/Fedora, you need to execute the following command:</p> <pre><code>sudo dnf install clang elfutils-libelf elfutils-libelf-devel zlib-devel\n</code></pre>"},{"location":"tutorials/11-bootstrap/#compile-and-run","title":"Compile and Run","text":"<p>Compile and run the above code:</p> <pre><code>$ make\n  BPF      .output/bootstrap.bpf.o\n  GEN-SKEL .output/bootstrap.skel.h\n  CC       .output/bootstrap.o\n  BINARY   bootstrap\n$ sudo ./bootstrap [sudo] password for yunwei: \nTIME     EVENT COMM             PID     PPID    FILENAME/EXIT CODE\n03:16:41 EXEC  sh               110688  80168   /bin/sh\n03:16:41 EXEC  which            110689  110688  /usr/bin/which\n03:16:41 EXIT  which            110689  110688  [0] (0ms)\n03:16:41 EXIT  sh               110688  80168   [0] (0ms)\".\n</code></pre> <p>The complete source code can be found at https://github.com/eunomia-bpf/bpf-developer-tutorial</p>"},{"location":"tutorials/11-bootstrap/#summary","title":"Summary","text":"<p>Through this example, we have learned how to combine eBPF programs with user-space programs. This combination provides developers with a powerful toolkit for efficient data collection and processing across the kernel and user space. By using eBPF and libbpf, you can build more efficient, scalable, and secure monitoring and performance analysis tools.</p> <p>In the following tutorials, we will continue to explore the advanced features of eBPF and share more about eBPF development practices. Through continuous learning and practice, you will have a better understanding and mastery of eBPF technology and apply it to solve real-world problems.</p> <p>If you would like to learn more about eBPF knowledge and practices, please refer to the official documentation of eunomia-bpf: https://github.com/eunomia-bpf/eunomia-bpf. You can also visit our tutorial code repository at https://github.com/eunomia-bpf/bpf-developer-tutorial for more examples and complete tutorials.</p>"},{"location":"tutorials/11-bootstrap/#reference","title":"Reference","text":"<ul> <li>Building BPF applications with libbpf-bootstrap</li> <li>https://github.com/libbpf/libbpf-bootstrap</li> </ul>"},{"location":"tutorials/12-profile/","title":"eBPF Beginner's Practical Tutorial 12: Using eBPF Program Profile for Performance Analysis","text":"<p>This tutorial will guide you on using libbpf and eBPF programs for performance analysis. We will leverage the perf mechanism in the kernel to learn how to capture the execution time of functions and view performance data.</p> <p>libbpf is a C library for interacting with eBPF. It provides the basic functionality for creating, loading, and using eBPF programs. In this tutorial, we will mainly use libbpf for development. Perf is a performance analysis tool in the Linux kernel that allows users to measure and analyze the performance of kernel and user space programs, as well as obtain corresponding call stacks. It collects performance data using hardware counters and software events in the kernel.</p>"},{"location":"tutorials/12-profile/#ebpf-tool-profile-performance-analysis-example","title":"eBPF Tool: profile Performance Analysis Example","text":"<p>The <code>profile</code> tool is implemented based on eBPF and utilizes the perf events in the Linux kernel for performance analysis. The <code>profile</code> tool periodically samples each processor to capture the execution of kernel and user space functions. It provides the following information for stack traces:</p> <ul> <li>Address: memory address of the function call</li> <li>Symbol: function name</li> <li>File Name: name of the source code file</li> <li>Line Number: line number in the source code</li> </ul> <p>This information helps developers locate performance bottlenecks and optimize code. Furthermore, flame graphs can be generated based on this information for a more intuitive view of performance data.</p> <p>In this example, you can compile and run it with the libbpf library (using Ubuntu/Debian as an example):</p> <pre><code>$ git submodule update --init --recursive\n$ sudo apt install clang libelf1 libelf-dev zlib1g-dev\n$ make\n$ sudo ./profile COMM: chronyd (pid=156) @ CPU 1\nKernel:\n  0 [&lt;ffffffff81ee9f56&gt;] _raw_spin_lock_irqsave+0x16\n  1 [&lt;ffffffff811527b4&gt;] remove_wait_queue+0x14\n  2 [&lt;ffffffff8132611d&gt;] poll_freewait+0x3d\n  3 [&lt;ffffffff81326d3f&gt;] do_select+0x7bf\n  4 [&lt;ffffffff81327af2&gt;] core_sys_select+0x182\n  5 [&lt;ffffffff81327f3a&gt;] __x64_sys_pselect6+0xea\n  6 [&lt;ffffffff81ed9e38&gt;] do_syscall_64+0x38\n  7 [&lt;ffffffff82000099&gt;] entry_SYSCALL_64_after_hwframe+0x61\nUserspace:\n  0 [&lt;00007fab187bfe09&gt;]\n  1 [&lt;000000000ee6ae98&gt;]\nCOMM: profile (pid=9843) @ CPU 6\nNo Kernel Stack\nUserspace:\n  0 [&lt;0000556deb068ac8&gt;]\n  1 [&lt;0000556dec34cad0&gt;]\n</code></pre>"},{"location":"tutorials/12-profile/#implementation-principle","title":"Implementation Principle","text":"<p>The <code>profile</code> tool consists of two parts: the eBPF program in kernel space and the <code>profile</code> symbol handling program in user space. The <code>profile</code> symbol handling program is responsible for loading the eBPF program and processing the data outputted by the eBPF program.</p>"},{"location":"tutorials/12-profile/#kernel-space-part","title":"Kernel Space Part","text":"<p>The implementation logic of the eBPF program in kernel space mainly relies on perf events to periodically sample the stack of the program, thereby capturing its execution flow.</p> <pre><code>// SPDX-License-Identifier: GPL-2.0 OR BSD-3-Clause\n/* Copyright (c) 2022 Meta Platforms, Inc. */\n#include \"vmlinux.h\"\n#include &lt;bpf/bpf_helpers.h&gt;\n#include &lt;bpf/bpf_tracing.h&gt;\n#include &lt;bpf/bpf_core_read.h&gt;\n#include \"profile.h\"\nchar LICENSE[] SEC(\"license\") = \"Dual BSD/GPL\";\nstruct {\n__uint(type, BPF_MAP_TYPE_RINGBUF);\n__uint(max_entries, 256 * 1024);\n} events SEC(\".maps\");\nSEC(\"perf_event\")\nint profile(void *ctx)\n{\nint pid = bpf_get_current_pid_tgid() &gt;&gt; 32;\nint cpu_id = bpf_get_smp_processor_id();\nstruct stacktrace_event *event;\nint cp;\nevent = bpf_ringbuf_reserve(&amp;events, sizeof(*event), 0);\nif (!event)\nreturn 1;\nevent-&gt;pid = pid;\nevent-&gt;cpu_id = cpu_id;\nif (bpf_get_current_comm(event-&gt;comm, sizeof(event-&gt;comm)))\nevent-&gt;comm[0] = 0;\nevent-&gt;kstack_sz = bpf_get_stack(ctx, event-&gt;kstack, sizeof(event-&gt;kstack), 0);\nevent-&gt;ustack_sz = bpf_get_stack(ctx, event-&gt;ustack, sizeof(event-&gt;ustack), BPF_F_USER_STACK);\nbpf_ringbuf_submit(event, 0);\nreturn 0;\n}\n</code></pre> <p>Next, we will focus on the key part of the kernel code.</p> <ol> <li>Define eBPF maps <code>events</code>:</li> </ol> <pre><code>struct {\n__uint(type, BPF_MAP_TYPE_RINGBUF);\n__uint(max_entries, 256 * 1024);\n} events SEC(\".maps\");\n</code></pre> <p>Here, a eBPF maps of type <code>BPF_MAP_TYPE_RINGBUF</code> is defined. The Ring Buffer is a high-performance circular buffer used to transfer data between the kernel and user space. <code>max_entries</code> sets the maximum size of the Ring Buffer.</p> <ol> <li>Define <code>perf_event</code> eBPF program:</li> </ol> <pre><code>SEC(\"perf_event\")\nint profile(void *ctx)\n</code></pre> <p>Here, a eBPF program named <code>profile</code> is defined, which will be executed when a perf event is triggered.</p> <ol> <li>Get process ID and CPU ID:</li> </ol> <pre><code>int pid = bpf_get_current_pid_tgid() &gt;&gt; 32;\nint cpu_id = bpf_get_smp_processor_id();\n</code></pre> <p>The function <code>bpf_get_current_pid_tgid()</code> returns the PID and TID of the current process. By right shifting 32 bits, we get the PID. The function <code>bpf_get_smp_processor_id()</code> returns the ID of the current CPU.</p> <ol> <li>Reserve space in the Ring Buffer:</li> </ol> <pre><code>event = bpf_ringbuf_reserve(&amp;events, sizeof(*event), 0);\nif (!event)\nreturn 1;\n</code></pre> <p>Use the <code>bpf_ringbuf_reserve()</code> function to reserve space in the Ring Buffer for storing the collected stack information. If the reservation fails, return an error.</p> <ol> <li>Get the current process name:</li> </ol> <pre><code>if (bpf_get_current_comm(event-&gt;comm, sizeof(event-&gt;comm)))\nevent-&gt;comm[0] = 0;\n</code></pre> <p>Use the <code>bpf_get_current_comm()</code> function to get the current process name and store it in <code>event-&gt;comm</code>.</p> <ol> <li>Get kernel stack information:</li> </ol> <pre><code>event-&gt;kstack_sz = bpf_get_stack(ctx, event-&gt;kstack, sizeof(event-&gt;kstack), 0);\n</code></pre> <p>Use the <code>bpf_get_stack()</code> function to get kernel stack information. Store the result in <code>event-&gt;kstack</code> and the size in <code>event-&gt;kstack_sz</code>.</p> <ol> <li>Get user space stack information:</li> </ol> <pre><code>event-&gt;ustack_sz = bpf_get_stack(ctx, event-&gt;ustack, sizeof(event-&gt;ustack), BPF_F_USER_STACK);\n```Using the `bpf_get_stack()` function with the `BPF_F_USER_STACK` flag retrieves information about the user space stack. Store the result in `event-&gt;ustack` and its size in `event-&gt;ustack_sz`.\n8. Submit the event to the Ring Buffer:\n```c\nbpf_ringbuf_submit(event, 0);\n```\nFinally, use the `bpf_ringbuf_submit()` function to submit the event to the Ring Buffer for the user space program to read and process.\nThis kernel mode eBPF program captures the program's execution flow by sampling the kernel stack and user space stack of the program periodically. These data are stored in the Ring Buffer for the user mode `profile` program to read.\n### User Mode Section\nThis code is mainly responsible for setting up perf events for each online CPU and attaching eBPF programs:\n```c\nstatic long perf_event_open(struct perf_event_attr *hw_event, pid_t pid,\nint cpu, int group_fd, unsigned long flags)\n{\nint ret;\nret = syscall(__NR_perf_event_open, hw_event, pid, cpu, group_fd, flags);\nreturn ret;\n}\nint main(){\n...\nfor (cpu = 0; cpu &lt; num_cpus; cpu++) {\n/* skip offline/not present CPUs */\nif (cpu &gt;= num_online_cpus || !online_mask[cpu])\ncontinue;\n/* Set up performance monitoring on a CPU/Core */\npefd = perf_event_open(&amp;attr, pid, cpu, -1, PERF_FLAG_FD_CLOEXEC);\nif (pefd &lt; 0) {\nfprintf(stderr, \"Fail to set up performance monitor on a CPU/Core\\n\");\nerr = -1;\ngoto cleanup;\n}\npefds[cpu] = pefd;\n/* Attach a BPF program on a CPU */\nlinks[cpu] = bpf_program__attach_perf_event(skel-&gt;progs.profile, pefd);\nif (!links[cpu]) {\nerr = -1;\ngoto cleanup;\n}\n}\n...\n}\n</code></pre> <p>The <code>perf_event_open</code> function is a wrapper for the perf_event_open system call. It takes a pointer to a perf_event_attr structure to specify the type and attributes of the perf event. The pid parameter is used to specify the process ID to monitor (-1 for monitoring all processes), and the cpu parameter is used to specify the CPU to monitor. The group_fd parameter is used to group perf events, and we use -1 here to indicate no grouping is needed. The flags parameter is used to set some flags, and we use PERF_FLAG_FD_CLOEXEC to ensure file descriptors are closed when executing exec series system calls.</p> <p>In the main function:</p> <pre><code>for (cpu = 0; cpu &lt; num_cpus; cpu++) {\n// ...\n}\n</code></pre> <p>This loop sets up perf events and attaches eBPF programs for each online CPU. Firstly, it checks if the current CPU is online and skips if it's not. Then, it uses the perf_event_open() function to set up perf events for the current CPU and stores the returned file descriptor in the pefds array. Finally, it attaches the eBPF program to the perf event using the bpf_program__attach_perf_event() function. The links array is used to store the BPF links for each CPU so that they can be destroyed when the program ends.By doing so, user-mode programs set perf events for each online CPU and attach eBPF programs to these perf events to monitor all online CPUs in the system.</p> <p>The following two functions are used to display stack traces and handle events received from the ring buffer:</p> <pre><code>static void show_stack_trace(__u64 *stack, int stack_sz, pid_t pid)\n{\nconst struct blazesym_result *result;\nconst struct blazesym_csym *sym;\nsym_src_cfg src;\nint i, j;\nif (pid) {\nsrc.src_type = SRC_T_PROCESS;\nsrc.params.process.pid = pid;\n} else {\nsrc.src_type = SRC_T_KERNEL;\nsrc.params.kernel.kallsyms = NULL;\nsrc.params.kernel.kernel_image = NULL;\n}\nresult = blazesym_symbolize(symbolizer, &amp;src, 1, (const uint64_t *)stack, stack_sz);\nfor (i = 0; i &lt; stack_sz; i++) {\nif (!result || result-&gt;size &lt;= i || !result-&gt;entries[i].size) {\nprintf(\"  %d [&lt;%016llx&gt;]\\n\", i, stack[i]);\ncontinue;\n}\nif (result-&gt;entries[i].size == 1) {\nsym = &amp;result-&gt;entries[i].syms[0];\nif (sym-&gt;path &amp;&amp; sym-&gt;path[0]) {\nprintf(\"  %d [&lt;%016llx&gt;] %s+0x%llx %s:%ld\\n\",\ni, stack[i], sym-&gt;symbol,\nstack[i] - sym-&gt;start_address,\nsym-&gt;path, sym-&gt;line_no);\n} else {\nprintf(\"  %d [&lt;%016llx&gt;] %s+0x%llx\\n\",\ni, stack[i], sym-&gt;symbol,\nstack[i] - sym-&gt;start_address);\n}\ncontinue;\n}\nprintf(\"  %d [&lt;%016llx&gt;]\\n\", i, stack[i]);\nfor (j = 0; j &lt; result-&gt;entries[i].size; j++) {\nsym = &amp;result-&gt;entries[i].syms[j];\nif (sym-&gt;path &amp;&amp; sym-&gt;path[0]) {\nprintf(\"        %s+0x%llx %s:%ld\\n\",\nsym-&gt;symbol, stack[i] - sym-&gt;start_address,\nsym-&gt;path, sym-&gt;line_no);\n} else {\nprintf(\"        %s+0x%llx\\n\", sym-&gt;symbol,\nstack[i] - sym-&gt;start_address);\n}\n}\n}\nblazesym_result_free(result);\n}\n``` /* Receive events from the ring buffer. */\".```c\nstatic int event_handler(void *_ctx, void *data, size_t size)\n{\nstruct stacktrace_event *event = data;\nif (event-&gt;kstack_sz &lt;= 0 &amp;&amp; event-&gt;ustack_sz &lt;= 0)\nreturn 1;\nprintf(\"COMM: %s (pid=%d) @ CPU %d\\n\", event-&gt;comm, event-&gt;pid, event-&gt;cpu_id);\nif (event-&gt;kstack_sz &gt; 0) {\nprintf(\"Kernel:\\n\");\nshow_stack_trace(event-&gt;kstack, event-&gt;kstack_sz / sizeof(__u64), 0);\n} else {\nprintf(\"No Kernel Stack\\n\");\n}\nif (event-&gt;ustack_sz &gt; 0) {\nprintf(\"Userspace:\\n\");\nshow_stack_trace(event-&gt;ustack, event-&gt;ustack_sz / sizeof(__u64), event-&gt;pid);\n} else {\nprintf(\"No Userspace Stack\\n\");\n}\nprintf(\"\\n\");\nreturn 0;\n}\n</code></pre> <p>The <code>show_stack_trace()</code> function is used to display the stack trace of the kernel or userspace. It takes a <code>stack</code> parameter, which is a pointer to the kernel or userspace stack, and a <code>stack_sz</code> parameter, which represents the size of the stack. The <code>pid</code> parameter represents the ID of the process to be displayed (set to 0 when displaying the kernel stack). In the function, the source of the stack (kernel or userspace) is determined based on the <code>pid</code> parameter, and then the <code>blazesym_symbolize()</code> function is called to resolve the addresses in the stack to symbol names and source code locations. Finally, the resolved results are traversed and the symbol names and source code location information are outputted.</p> <p>The <code>event_handler()</code> function is used to handle events received from the ring buffer. It takes a <code>data</code> parameter, which points to the data in the ring buffer, and a <code>size</code> parameter, which represents the size of the data. The function first converts the <code>data</code> pointer to a pointer of type <code>stacktrace_event</code>, and then checks the sizes of the kernel and userspace stacks. If the stacks are empty, it returns directly. Next, the function outputs the process name, process ID, and CPU ID information. Then it displays the stack traces of the kernel and userspace respectively. When calling the <code>show_stack_trace()</code> function, the addresses, sizes, and process ID of the kernel and userspace stacks are passed in separately.</p> <p>These two functions are part of the eBPF profiling tool, used to display and process stack trace information collected by eBPF programs, helping users understand program performance and bottlenecks.</p>"},{"location":"tutorials/12-profile/#summary","title":"Summary","text":"<p>Through this introductory tutorial on eBPF, we have learned how to use eBPF programs for performance analysis. In this process, we explained in detail how to create eBPF programs, monitor process performance, and retrieve data from the ring buffer for analyzing stack traces. We also learned how to use the <code>perf_event_open()</code> function to set up performance monitoring and attach BPF programs to performance events. In this tutorial, we also demonstrated how to write eBPF programs to capture the kernel and userspace stack information of processes in order to analyze program performance bottlenecks. With this example, you can understand the powerful features of eBPF in performance analysis.</p> <p>If you want to learn more about eBPF knowledge and practices, please refer to the official documentation of eunomia-bpf: https://github.com/eunomia-bpf/eunomia-bpf. You can also visit our tutorial code repository https://github.com/eunomia-bpf/bpf-developer-tutorial for more examples and complete tutorials.</p> <p>The next tutorial will further explore advanced features of eBPF. We will continue to share more content about eBPF development practices to help you better understand and master eBPF technology. We hope these contents will be helpful for your learning and practice on the eBPF development journey.</p>"},{"location":"tutorials/13-tcpconnlat/","title":"eBPF Beginner's Development Practice Tutorial 13: Statistics of TCP Connection Delay and Data Processing in User Space Using libbpf","text":"<p>eBPF (Extended Berkeley Packet Filter) is a powerful network and performance analysis tool used in the Linux kernel. eBPF allows developers to dynamically load, update, and run user-defined code without restarting the kernel or changing the kernel source code.</p> <p>This article is the thirteenth installment of the eBPF beginner's development practice tutorial, mainly about how to use eBPF to statistics TCP connection delay and process data in user space using libbpf.</p>"},{"location":"tutorials/13-tcpconnlat/#background","title":"Background","text":"<p>When developing backends, regardless of the programming language used, we often need to call databases such as MySQL and Redis, perform RPC remote calls, or call other RESTful APIs. The underlying implementation of these calls is usually based on the TCP protocol. This is because TCP protocol has advantages such as reliable connection, error retransmission, congestion control, etc., so TCP is more widely used in network transport layer protocols than UDP. However, TCP also has some drawbacks, such as longer connection establishment delay. Therefore, some alternative solutions have emerged, such as QUIC (Quick UDP Internet Connections).</p> <p>Analyzing TCP connection delay is very useful for network performance analysis, optimization, and troubleshooting.</p>"},{"location":"tutorials/13-tcpconnlat/#overview-of-tcpconnlat-tool","title":"Overview of tcpconnlat Tool","text":"<p>The <code>tcpconnlat</code> tool can trace the functions in the kernel that perform active TCP connections (such as using the <code>connect()</code> system call), measure and display connection delay, i.e., the time from sending SYN to receiving response packets.</p>"},{"location":"tutorials/13-tcpconnlat/#tcp-connection-principle","title":"TCP Connection Principle","text":"<p>The process of establishing a TCP connection is often referred to as the \"three-way handshake\". Here are the steps of the entire process:</p> <ol> <li>Client sends SYN packet to the server: The client sends SYN through the <code>connect()</code> system call. This involves local system call and CPU time cost of software interrupts.</li> <li>SYN packet is transmitted to the server: This is a network transmission that depends on network latency.</li> <li>Server handles the SYN packet: The server kernel receives the packet through a software interrupt, then puts it into the listen queue and sends SYN/ACK response. This mainly involves CPU time cost.</li> <li>SYN/ACK packet is transmitted to the client: This is another network transmission.</li> <li>Client handles the SYN/ACK: The client kernel receives and handles the SYN/ACK packet, then sends ACK. This mainly involves software interrupt handling cost.</li> <li>ACK packet is transmitted to the server: This is the third network transmission.</li> <li>Server receives ACK: The server kernel receives and handles the ACK, then moves the corresponding connection from the listen queue to the established queue. This involves CPU time cost of a software interrupt.</li> <li>Wake up the server-side user process: The user process blocked by the <code>accept()</code> system call is awakened, and then the established connection is taken out from the established queue. This involves CPU cost of a context switch.</li> </ol> <p>The complete flowchart is shown below:</p> <p></p> <p>From the client's perspective, under normal circumstances, the total time for a TCP connection is approximately the time consumed by one network round-trip. However, in some cases, it may cause an increase in network transmission time, an increase in CPU processing overhead, or even connection failure. When a long delay is detected, it can be analyzed in conjunction with other information.</p>"},{"location":"tutorials/13-tcpconnlat/#ebpf-implementation-of-tcpconnlat","title":"eBPF Implementation of tcpconnlat","text":"<p>To understand the process of establishing a TCP connection, we need to understand two queues used by the Linux kernel when handling TCP connections:</p> <ul> <li>Listen queue (SYN queue): Stores TCP connections that are in the process of performing three-way handshake. After the server receives the SYN packet, it stores the connection information in this queue.</li> <li>Established queue (Accept queue): Stores TCP connections that have completed three-way handshake and are waiting for the application to call the <code>accept()</code> function. After the server receives the ACK packet, it creates a new connection and adds it to this queue.</li> </ul> <p>With an understanding of the purpose of these two queues, we can begin to explore the specific implementation of tcpconnlat. The implementation of tcpconnlat can be divided into two parts: kernel space and user space, which include several main trace points: <code>tcp_v4_connect</code>, <code>tcp_v6_connect</code>, and <code>tcp_rcv_state_process</code>.</p> <p>These trace points are mainly located in the TCP/IP network stack in the kernel. When executing the corresponding system call or kernel function, these trace points are activated, triggering the execution of eBPF programs. This allows us to capture and measure the entire process of establishing a TCP connection.</p> <p>Let's take a look at the source code of these mounting points first:</p> <pre><code>SEC(\"kprobe/tcp_v4_connect\")\nint BPF_KPROBE(tcp_v4_connect, struct sock *sk)\n{\nreturn trace_connect(sk);\n}\nSEC(\"kprobe/tcp_v6_connect\")\nint BPF_KPROBE(tcp_v6_connect, struct sock *sk)\n{\nreturn trace_connect(sk);\n}\nSEC(\"kprobe/tcp_rcv_state_process\")\nint BPF_KPROBE(tcp_rcv_state_process, struct sock *sk)\n{\nreturn handle_tcp_rcv_state_process(ctx, sk);\n}\n</code></pre> <p>This code snippet shows the definition of three kernel probes (kprobe). <code>tcp_v4_connect</code> and <code>tcp_v6_connect</code> are triggered when the corresponding IPv4 and IPv6 connections are initialized, invoking the <code>trace_connect()</code> function. On the other hand, <code>tcp_rcv_state_process</code> is triggered when the TCP connection state changes in the kernel, calling the <code>handle_tcp_rcv_state_process()</code> function.</p> <p>The following section will be divided into two parts: one part analyzes the kernel part of these mount points, where we will delve into the kernel source code to explain how these functions work in detail. The other part analyzes the user part, focusing on how eBPF programs collect data from these mount points and interact with user-space programs.</p>"},{"location":"tutorials/13-tcpconnlat/#analysis-of-tcp_v4_connect-function","title":"Analysis of tcp_v4_connect function","text":"<p>The <code>tcp_v4_connect</code> function is the main way that the Linux kernel handles TCP IPv4 connection requests. When a user-space program creates a socket through the <code>socket</code> system call and then attempts to connect to a remote server through the <code>connect</code> system call, the <code>tcp_v4_connect</code> function is triggered.</p> <pre><code>/* This will initiate an outgoing connection. */\nint tcp_v4_connect(struct sock *sk, struct sockaddr *uaddr, int addr_len)\n{\nstruct sockaddr_in *usin = (struct sockaddr_in *)uaddr;\nstruct inet_timewait_death_row *tcp_death_row;\nstruct inet_sock *inet = inet_sk(sk);\nstruct tcp_sock *tp = tcp_sk(sk);\nstruct ip_options_rcu *inet_opt;\nstruct net *net = sock_net(sk);\n__be16 orig_sport, orig_dport;\n__be32 daddr, nexthop;\nstruct flowi4 *fl4;\nstruct rtable *rt;\nint err;\nif (addr_len &lt; sizeof(struct sockaddr_in))\nreturn -EINVAL;\nif (usin-&gt;sin_family != AF_INET)\nreturn -EAFNOSUPPORT;\nnexthop = daddr = usin-&gt;sin_addr.s_addr;\ninet_opt = rcu_dereference_protected(inet-&gt;inet_opt,\nlockdep_sock_is_held(sk));\nif (inet_opt &amp;&amp; inet_opt-&gt;opt.srr) {\nif (!daddr)\nreturn -EINVAL;\nnexthop = inet_opt-&gt;opt.faddr;\n}\norig_sport = inet-&gt;inet_sport;\norig_dport = usin-&gt;sin_port;\nfl4 = &amp;inet-&gt;cork.fl.u.ip4;\nrt = ip_route_connect(fl4, nexthop, inet-&gt;inet_saddr,\nsk-&gt;sk_bound_dev_if, IPPROTO_TCP, orig_sport,\norig_dport, sk);\nif (IS_ERR(rt)) {\nerr = PTR_ERR(rt);\nif (err == -ENETUNREACH)\nIP_INC_STATS(net, IPSTATS_MIB_OUTNOROUTES);\nreturn err;\n}\nif (rt-&gt;rt_flags &amp; (RTCF_MULTICAST | RTCF_BROADCAST)) {\nip_rt_put(rt);\nreturn -ENETUNREACH;\n}\nif (!inet_opt || !inet_opt-&gt;opt.srr)\ndaddr = fl4-&gt;daddr;\ntcp_death_row = &amp;sock_net(sk)-&gt;ipv4.tcp_death_row;\nif (!inet-&gt;inet_saddr) {\nerr = inet_bhash2_update_saddr(sk,  &amp;fl4-&gt;saddr, AF_INET);\nif (err) {\nip_rt_put(rt);\nreturn err;\n}\n} else {\nsk_rcv_saddr_set(sk, inet-&gt;inet_saddr);\n}\nif (tp-&gt;rx_opt.ts_recent_stamp &amp;&amp; inet-&gt;inet_daddr != daddr) {\n/* Reset inherited state */\ntp-&gt;rx_opt.ts_recent    = 0;\ntp-&gt;rx_opt.ts_recent_stamp = 0;\nif (likely(!tp-&gt;repair))\nWRITE_ONCE(tp-&gt;write_seq, 0);\n}\ninet-&gt;inet_dport = usin-&gt;sin_port;\nsk_daddr_set(sk, daddr);\ninet_csk(sk)-&gt;icsk_ext_hdr_len = 0;\nif (inet_opt)\ninet_csk(sk)-&gt;icsk_ext_hdr_len = inet_opt-&gt;opt.optlen;\ntp-&gt;rx_opt.mss_clamp = TCP_MSS_DEFAULT;\n/* Socket identity is still unknown (sport may be zero).\n   * However we set state to SYN-SENT and not releasing socket\n   * lock select source port, enter ourselves into the hash tables and\n   * complete initialization after this.\n   */\ntcp_set_state(sk, TCP_SYN_SENT);\nerr = inet_hash_connect(tcp_death_row, sk);\nif (err)\ngoto failure;\nsk_set_txhash(sk);\nrt = ip_route_newports(fl4, rt, orig_sport, orig_dport,\ninet-&gt;inet_sport, inet-&gt;inet_dport, sk);\nif (IS_ERR(rt)) {\nerr = PTR_ERR(rt);\nrt = NULL;\ngoto failure;\n}\n/* OK, now commit destination to socket.  */\nsk-&gt;sk_gso_type = SKB_GSO_TCPV4;\nsk_setup_caps(sk, &amp;rt-&gt;dst);\nrt = NULL;\nif (likely(!tp-&gt;repair)) {\nif (!tp-&gt;write_seq)\nWRITE_ONCE(tp-&gt;write_seq,\nsecure_tcp_seq(inet-&gt;inet_saddr,\ninet-&gt;inet_daddr,\ninet-&gt;inet_sport,\nusin-&gt;sin_port));\ntp-&gt;tsoffset = secure_tcp_ts_off(net, inet-&gt;inet_saddr,\ninet-&gt;inet_daddr);\n}\ninet-&gt;inet_id = get_random_u16();\nif (tcp_fastopen_defer_connect(sk, &amp;err))\nreturn err;\nif (err)\ngoto failure;\nerr = tcp_connect(sk);\nif (err)\ngoto failure;\nreturn 0;\nfailure:\n/*\".* This unhashes the socket and releases the local port,\n  * if necessary.\n  */\ntcp_set_state(sk, TCP_CLOSE);\ninet_bhash2_reset_saddr(sk);\nip_rt_put(rt);\nsk-&gt;sk_route_caps = 0;\ninet-&gt;inet_dport = 0;\nreturn err;\n}\nEXPORT_SYMBOL(tcp_v4_connect);\n</code></pre> <p>Reference link: https://elixir.bootlin.com/linux/latest/source/net/ipv4/tcp_ipv4.c#L340</p> <p>Next, let's analyze this function step by step:</p> <p>First, this function takes three parameters: a socket pointer <code>sk</code>, a pointer to the socket address structure <code>uaddr</code>, and the length of the address <code>addr_len</code>.</p> <pre><code>int tcp_v4_connect(struct sock *sk, struct sockaddr *uaddr, int addr_len)\n</code></pre> <p>The function starts by checking the parameters, making sure the address length is correct and the address family is IPv4. If these conditions are not met, the function returns an error.</p> <p>Next, the function retrieves the destination address and, if a source routing option is set (an advanced IP feature that is typically not used), it also retrieves the next hop address for the source route.</p> <pre><code>nexthop = daddr = usin-&gt;sin_addr.s_addr;\ninet_opt = rcu_dereference_protected(inet-&gt;inet_opt,\nlockdep_sock_is_held(sk));\nif (inet_opt &amp;&amp; inet_opt-&gt;opt.srr) {\nif (!daddr)\nreturn -EINVAL;\nnexthop = inet_opt-&gt;opt.faddr;\n}\n</code></pre> <p>Then, using this information, the function looks for a route entry to the destination address. If a route entry cannot be found or the route entry points to a multicast or broadcast address, the function returns an error.</p> <p>Next, it updates the source address, handles the state of some TCP timestamp options, and sets the destination port and address. After that, it updates some other socket and TCP options and sets the connection state to <code>SYN-SENT</code>.</p> <p>Then, the function tries to add the socket to the connected sockets hash table using the <code>inet_hash_connect</code> function. If this step fails, it restores the socket state and returns an error.</p> <p>If all the previous steps succeed, it then updates the route entry with the new source and destination ports. If this step fails, it cleans up resources and returns an error.</p> <p>Next, it commits the destination information to the socket and selects a secure random value for the sequence offset for future segments.</p> <p>Then, the function tries to establish the connection using TCP Fast Open (TFO), and if TFO is not available or the TFO attempt fails, it falls back to the regular TCP three-way handshake for connection.</p> <p>Finally, if all the above steps succeed, the function returns success; otherwise, it cleans up all resources and returns an error.</p> <p>In summary, the <code>tcp_v4_connect</code> function is a complex function that handles TCP connection requests. It handles many cases, including parameter checking, route lookup, source address selection, source routing, TCP option handling, TCP Fast Open, and more. Its main goal is to establish TCP connections as safely and efficiently as possible.</p>"},{"location":"tutorials/13-tcpconnlat/#kernel-code","title":"Kernel Code","text":"<pre><code>// SPDX-License-Identifier: GPL-2.0\n// Copyright (c) 2020 Wenbo Zhang\n#include &lt;vmlinux.h&gt;\n#include &lt;bpf/bpf_helpers.h&gt;\n#include &lt;bpf/bpf_core_read.h&gt;\n#include &lt;bpf/bpf_tracing.h&gt;\n#include \"tcpconnlat.h\"\n#define AF_INET    2\n#define AF_INET6   10\nconst volatile __u64 targ_min_us = 0;\nconst volatile pid_t targ_tgid = 0;\nstruct piddata {\nchar comm[TASK_COMM_LEN];\nu64 ts;\nu32 tgid;\n};\nstruct {\n__uint(type, BPF_MAP_TYPE_HASH);\n__uint(max_entries, 4096);\n__type(key, struct sock *);\n__type(value, struct piddata);\n} start SEC(\".maps\");\nstruct {\n__uint(type, BPF_MAP_TYPE_PERF_EVENT_ARRAY);\n__uint(key_size, sizeof(u32));\n__uint(value_size, sizeof(u32));\n} events SEC(\".maps\");\nstatic int trace_connect(struct sock *sk)\n{\nu32 tgid = bpf_get_current_pid_tgid() &gt;&gt; 32;\nstruct piddata piddata = {};\nif (targ_tgid &amp;&amp; targ_tgid != tgid)\nreturn 0;\nbpf_get_current_comm(&amp;piddata.comm, sizeof(piddata.comm));\npiddata.ts = bpf_ktime_get_ns();\npiddata.tgid = tgid;\nbpf_map_update_elem(&amp;start, &amp;sk, &amp;piddata, 0);\nreturn 0;\n}\nstatic int handle_tcp_rcv_state_process(void *ctx, struct sock *sk)\n{\nstruct piddata *piddatap;\nstruct event event = {};\ns64 delta;\nu64 ts;\nif (BPF_CORE_READ(sk, __sk_common.skc_state) != TCP_SYN_SENT)\nreturn 0;\npiddatap = bpf_map_lookup_elem(&amp;start, &amp;sk);\nif (!piddatap)\nreturn 0;\nts = bpf_ktime_get_ns();\ndelta = (s64)(ts - piddatap-&gt;ts);\nif (delta &lt; 0)\ngoto cleanup;\nevent.delta_us = delta / 1000U;\nif (targ_min_us &amp;&amp; event.delta_us &lt; targ_min_us)\ngoto cleanup;\n__builtin_memcpy(&amp;event.comm, piddatap-&gt;comm,\nsizeof(event.comm));\nevent.ts_us = ts / 1000;\nevent.tgid = piddatap-&gt;tgid;\nevent.lport = BPF_CORE_READ(sk, __sk_common.skc_num);\nevent.dport = BPF_CORE_READ(sk, __sk_common.skc_dport);\nevent.af = BPF_CORE_READ(sk, __sk_common.skc_family);\nif (event.af == AF_INET) {\nevent.saddr_v4 = BPF_CORE_READ(sk, __sk_common.skc_rcv_saddr);\nevent.daddr_v4 = BPF_CORE_READ(sk, __sk_common.skc_daddr);\n} else {\nBPF_CORE_READ_INTO(&amp;event.saddr_v6, sk,\n__sk_common.skc_v6_rcv_saddr.in6_u.u6_addr32);\nBPF_CORE_READ_INTO(&amp;event.daddr_v6, sk,\n__sk_common.skc_v6_daddr.in6_u.u6_addr32);\n}\nbpf_perf_event_output(ctx, &amp;events, BPF_F_CURRENT_CPU,\n&amp;event, sizeof(event));\ncleanup:\nbpf_map_delete_elem(&amp;start, &amp;sk);\nreturn 0;\n}\nSEC(\"kprobe/tcp_v4_connect\")\nint BPF_KPROBE(tcp_v4_connect, struct sock *sk)\n{\nreturn trace_connect(sk);\n}\nSEC(\"kprobe/tcp_v6_connect\")\nint BPF_KPROBE(tcp_v6_connect, struct sock *sk)\n{\nreturn trace_connect(sk);\n}\nSEC(\"kprobe/tcp_rcv_state_process\")\nint BPF_KPROBE(tcp_rcv_state_process, struct sock *sk)\n{\nreturn handle_tcp_rcv_state_process(ctx, sk);\n}\nSEC(\"fentry/tcp_v4_connect\")\nint BPF_PROG(fentry_tcp_v4_connect, struct sock *sk)\n{\nreturn trace_connect(sk);\n}\nSEC(\"fentry/tcp_v6_connect\")\nint BPF_PROG(fentry_tcp_v6_connect, struct sock *sk)\n{\nreturn trace_connect(sk);\n}\nSEC(\"fentry/tcp_rcv_state_process\")\nint BPF_PROG(fentry_tcp_rcv_state_process, struct sock *sk)\n{\nreturn handle_tcp_rcv_state_process(ctx, sk);\n}\nchar LICENSE[] SEC(\"license\") = \"GPL\";\n</code></pre> <p>This eBPF (Extended Berkeley Packet Filter) program is mainly used to monitor and collect the time it takes to establish TCP connections, i.e., the time interval from initiating a TCP connection request (connect system call) to the completion of the connection establishment (SYN-ACK handshake process). This is very useful for monitoring network latency, service performance analysis, and other aspects.</p> <p>First, two eBPF maps are defined: <code>start</code> and <code>events</code>. <code>start</code> is a hash table used to store the process information and timestamp of the initiating connection request, while <code>events</code> is a map of type <code>PERF_EVENT_ARRAY</code> used to transfer event data to user space.</p> <pre><code>struct {\n__uint(type, BPF_MAP_TYPE_HASH);\n__uint(max_entries, 4096);\n__type(key, struct sock *);\n__type(value, struct piddata);\n} start SEC(\".maps\");\nstruct {\n__uint(type, BPF_MAP_TYPE_PERF_EVENT_ARRAY);\n__uint(key_size, sizeof(u32));\n__uint(value_size, sizeof(u32));\n} events SEC(\".maps\");\n</code></pre> <p>In the kprobe handling functions <code>trace_connect</code> of <code>tcp_v4_connect</code> and <code>tcp_v6_connect</code>, the process information (process name, process ID, and current timestamp) of the initiating connection request is recorded and stored in the <code>start</code> map with the socket structure as the key.</p> <pre><code>static int trace_connect(struct sock *sk)\n{\nu32 tgid = bpf_get_current_pid_tgid() &gt;&gt; 32;\nstruct piddata piddata = {};\nif (targ_tgid &amp;&amp; targ_tgid != tgid)\nreturn 0;\nbpf_get_current_comm(&amp;piddata.comm, sizeof(piddata.comm));\npiddata.ts = bpf_ktime_get_ns();\npiddata.tgid = tgid;\nbpf_map_update_elem(&amp;start, &amp;sk, &amp;piddata, 0);\nreturn 0;\n}\n</code></pre> <p>When the TCP state machine processes the SYN-ACK packet, i.e., when the connection is established, the kprobe handling function <code>handle_tcp_rcv_state_process</code> of <code>tcp_rcv_state_process</code> is triggered. In this function, it first checks if the socket state is <code>SYN-SENT</code>. If it is, it looks up the process information for the socket in the <code>start</code> map. Then it calculates the time interval from the initiation of the connection to the present and sends this time interval, process information, and TCP connection details (source port, destination port, source IP, destination IP, etc.) as an event to user space using the <code>bpf_perf_event_output</code> function.</p> <pre><code>static int handle_tcp_rcv_state_process(void *ctx, struct sock *sk)\n{\nstruct piddata *piddatap;\nstruct event event = {};\ns64 delta;\nu64 ts;\nif (BPF_CORE_READ(sk, __sk_common.skc_state) != TCP_SYN_SENT)\nreturn 0;\npiddatap = bpf_map_lookup_elem(&amp;start, &amp;sk);\nif (!piddatap)\nreturn 0;\nts = bpf_ktime_get_ns();\ndelta = (s64)(ts - piddatap-&gt;ts);\nif (delta &lt; 0)\ngoto cleanup;\nevent.delta_us = delta / 1000U;\nif (targ_min_us &amp;&amp; event.delta_us &lt; targ_min_us)\ngoto cleanup;\n__builtin_memcpy(&amp;event.comm, piddatap-&gt;comm,\nsizeof(event.comm));\nevent.ts_us = ts / 1000;\nevent.tgid = piddatap-&gt;tgid;\nevent.lport = BPF_CORE_READ(sk, __sk_common.skc_num);\nevent.dport = BPF_CORE_READ(sk, __sk_common.skc_dport);\nevent.af = BPF_CORE_READ(sk, __sk_common.skc_family);\nif (event.af == AF_INET) {\nevent.saddr_v4 = BPF_CORE_READ(sk, __sk_common.skc_rcv_saddr);\nevent.daddr_v4 = BPF_CORE_READ(sk, __sk_common.skc_daddr);\n} else {\nBPF_CORE_READ_INTO(&amp;event.saddr_v6, sk,\n__sk_common.skc_v6_rcv_saddr.in6_u.u6_addr32);\nBPF_CORE_READ_INTO(&amp;event.daddr_v6, sk,\n__sk_common.skc_v6_daddr.in6_u.u6_addr32);\n}\nbpf_perf_event_output(ctx, &amp;events, BPF_F_CURRENT_CPU,\n&amp;event, sizeof(event));\ncleanup:\nbpf_map_delete_elem(&amp;start, &amp;sk);\nreturn 0;\n}\n</code></pre> <p>This program uses a while loop to repeatedly poll the perf event buffer. If there is an error during polling (e.g., due to a signal interruption), an error message will be printed. This polling process continues until an exit flag <code>exiting</code> is received.</p> <p>Next, let's take a look at the <code>handle_event</code> function, which handles every eBPF event sent from the kernel to user space:</p> <pre><code>void handle_event(void* ctx, int cpu, void* data, __u32 data_sz) {\nconst struct event* e = data;\nchar src[INET6_ADDRSTRLEN];\nchar dst[INET6_ADDRSTRLEN];\nunion {\nstruct in_addr x4;\nstruct in6_addr x6;\n} s, d;\nstatic __u64 start_ts;\nif (env.timestamp) {\nif (start_ts == 0)\nstart_ts = e-&gt;ts_us;\nprintf(\"%-9.3f \", (e-&gt;ts_us - start_ts) / 1000000.0);\n}\nif (e-&gt;af == AF_INET) {\ns.x4.s_addr = e-&gt;saddr_v4;\nd.x4.s_addr = e-&gt;daddr_v4;\n} else if (e-&gt;af == AF_INET6) {\nmemcpy(&amp;s.x6.s6_addr, e-&gt;saddr_v6, sizeof(s.x6.s6_addr));\nmemcpy(&amp;d.x6.s6_addr, e-&gt;daddr_v6, sizeof(d.x6.s6_addr));\n} else {\nfprintf(stderr, \"broken event: event-&gt;af=%d\", e-&gt;af);\nreturn;\n}\nif (env.lport) {\nprintf(\"%-6d %-12.12s %-2d %-16s %-6d %-16s %-5d %.2f\\n\", e-&gt;tgid,\ne-&gt;comm, e-&gt;af == AF_INET ? 4 : 6,\ninet_ntop(e-&gt;af, &amp;s, src, sizeof(src)), e-&gt;lport,\ninet_ntop(e-&gt;af, &amp;d, dst, sizeof(dst)), ntohs(e-&gt;dport),\ne-&gt;delta_us / 1000.0);\n} else {\nprintf(\"%-6d %-12.12s %-2d %-16s %-16s %-5d %.2f\\n\", e-&gt;tgid, e-&gt;comm,\ne-&gt;af == AF_INET ? 4 : 6, inet_ntop(e-&gt;af, &amp;s, src, sizeof(src)),\ninet_ntop(e-&gt;af, &amp;d, dst, sizeof(dst)), ntohs(e-&gt;dport),\ne-&gt;delta_us / 1000.0);\n}\n}\n</code></pre> <p>The <code>handle_event</code> function takes arguments including the CPU number, a pointer to the data, and the size of the data. The data is a <code>event</code> structure that contains information about TCP connections computed in the kernel space.</p> <p>First, it compares the timestamp of the received event with the start timestamp (if available) to calculate the relative time of the event, and then prints it. Next, it converts the source address and destination address from network byte order to host byte order based on the IP address type (IPv4 or IPv6).</p> <p>Finally, depending on whether the user chooses to display the local port, it prints the process ID, process name, IP version, source IP address, local port (if available), destination IP address, destination port, and connection establishment time. This connection establishment time is calculated in the eBPF program running in the kernel space and sent to the user space.</p>"},{"location":"tutorials/13-tcpconnlat/#compilation-and-execution","title":"Compilation and Execution","text":"<pre><code>$ make\n...\n  BPF      .output/tcpconnlat.bpf.o\".GEN-SKEL .output/tcpconnlat.skel.h\n  CC       .output/tcpconnlat.o\n  BINARY   tcpconnlat\n$ sudo ./tcpconnlat PID    COMM         IP SADDR            DADDR            DPORT LAT(ms)\n222564 wget         4  192.168.88.15    110.242.68.3     80    25.29\n222684 wget         4  192.168.88.15    167.179.101.42   443   246.76\n222726 ssh          4  192.168.88.15    167.179.101.42   22    241.17\n222774 ssh          4  192.168.88.15    1.15.149.151     22    25.31\n</code></pre> <p>Source code: https://github.com/eunomia-bpf/bpf-developer-tutorial/tree/main/src/13-tcpconnlat</p> <p>References:</p> <ul> <li>tcpconnlat in bcc</li> </ul>"},{"location":"tutorials/13-tcpconnlat/#summary","title":"Summary","text":"<p>In this eBPF introductory tutorial, we learned how to use eBPF to track and measure the latency of TCP connections. We first explored how eBPF programs can attach to specific kernel functions in kernel-space and capture the start and end times of connection establishment to calculate latency.</p> <p>We also learned how to use BPF maps to store and retrieve data in kernel-space, enabling data sharing among different parts of the eBPF program. Additionally, we discussed how to use perf events to send data from kernel-space to user-space for further processing and display.</p> <p>In user-space, we introduced the usage of libbpf library APIs, such as perf_buffer__poll, to receive and process data sent from the kernel-space. We also demonstrated how to parse and print this data in a human-readable format.</p> <p>If you are interested in learning more about eBPF and its practical applications, please refer to the official documentation of eunomia-bpf: https://github.com/eunomia-bpf/eunomia-bpf. You can also visit our tutorial code repository at https://github.com/eunomia-bpf/bpf-developer-tutorial for more examples and complete tutorials.</p> <p>In the upcoming tutorials, we will dive deeper into advanced features of eBPF, such as tracing the path of network packets and fine-grained system performance monitoring. We will continue to share more content on eBPF development practices to help you better understand and master eBPF technology. We hope these resources will be valuable in your learning and practical journey with eBPF.</p>"},{"location":"tutorials/14-tcpstates/","title":"eBPF Introductory Practice Tutorial 14: Recording TCP Connection Status and TCP RTT","text":"<p>eBPF (Extended Berkeley Packet Filter) is a powerful network and performance analysis tool widely used in the Linux kernel. eBPF allows developers to dynamically load, update, and run user-defined code without restarting the kernel or changing the kernel source code.</p> <p>In this article of our eBPF introductory practice tutorial series, we will introduce two sample programs: <code>tcpstates</code> and <code>tcprtt</code>. <code>tcpstates</code> is used to record the state changes of TCP connections, while <code>tcprtt</code> is used to record the Round-Trip Time (RTT) of TCP.</p>"},{"location":"tutorials/14-tcpstates/#tcprtt-and-tcpstates","title":"<code>tcprtt</code> and <code>tcpstates</code>","text":"<p>Network quality is crucial in the current Internet environment. There are many factors that affect network quality, including hardware, network environment, and the quality of software programming. To help users better locate network issues, we introduce the tool <code>tcprtt</code>. <code>tcprtt</code> can monitor the Round-Trip Time of TCP connections, evaluate network quality, and help users identify potential problems.</p> <p>When a TCP connection is established, <code>tcprtt</code> automatically selects the appropriate execution function based on the current system conditions. In the execution function, <code>tcprtt</code> collects various basic information of the TCP connection, such as source address, destination address, source port, destination port, and time elapsed, and updates this information to a histogram-like BPF map. After the execution is completed, <code>tcprtt</code> presents the collected information graphically to users through user-mode code.</p> <p><code>tcpstates</code> is a tool specifically designed to track and print changes in TCP connection status. It can display the duration of TCP connections in each state, measured in milliseconds. For example, for a single TCP session, <code>tcpstates</code> can print output similar to the following:</p> <pre><code>SKADDR           C-PID C-COMM     LADDR           LPORT RADDR           RPORT OLDSTATE    -&gt; NEWSTATE    MS\nffff9fd7e8192000 22384 curl       100.66.100.185  0     52.33.159.26    80    CLOSE       -&gt; SYN_SENT    0.000\nffff9fd7e8192000 0     swapper/5  100.66.100.185  63446 52.33.159.26    80    SYN_SENT    -&gt; ESTABLISHED 1.373\nffff9fd7e8192000 22384 curl       100.66.100.185  63446 52.33.159.26    80    ESTABLISHED -&gt; FIN_WAIT1   176.042\nffff9fd7e8192000 0     swapper/5  100.66.100.185  63446 52.33.159.26    80    FIN_WAIT1   -&gt; FIN_WAIT2   0.536\nffff9fd7e8192000 0     swapper/5  100.66.100.185  63446 52.33.159.26    80    FIN_WAIT2   -&gt; CLOSE       0.006\n</code></pre> <p>In the above output, the most time is spent in the ESTABLISHED state, which indicates that the connection has been established and data transmission is in progress. The transition from this state to the FIN_WAIT1 state (the beginning of connection closure) took 176.042 milliseconds.</p> <p>In our upcoming tutorials, we will delve deeper into these two tools, explaining their implementation principles, and hopefully, these contents will help you in your work with eBPF for network and performance analysis.</p>"},{"location":"tutorials/14-tcpstates/#tcpstate","title":"tcpstate","text":"<p>Due to space constraints, here we mainly discuss and analyze the corresponding eBPF kernel-mode code implementation. The following is the eBPF code for tcpstate:</p> <pre><code>const volatile bool filter_by_sport = false;\nconst volatile bool filter_by_dport = false;\nconst volatile short target_family = 0;\nstruct {\n__uint(type, BPF_MAP_TYPE_HASH);\n__uint(max_entries, MAX_ENTRIES);\n__type(key, __u16);\n__type(value, __u16);\n} sports SEC(\".maps\");\nstruct {\n__uint(type, BPF_MAP_TYPE_HASH);\n__uint(max_entries, MAX_ENTRIES);\n...\n```__type(key, __u16);\n__type(value, __u16);\n} dports SEC(\".maps\");\nstruct {\n__uint(type, BPF_MAP_TYPE_HASH);\n__uint(max_entries, MAX_ENTRIES);\n__type(key, struct sock *);\n__type(value, __u64);\n} timestamps SEC(\".maps\");\nstruct {\n__uint(type, BPF_MAP_TYPE_PERF_EVENT_ARRAY);\n__uint(key_size, sizeof(__u32));\n__uint(value_size, sizeof(__u32));\n} events SEC(\".maps\");\nSEC(\"tracepoint/sock/inet_sock_set_state\")\nint handle_set_state(struct trace_event_raw_inet_sock_set_state *ctx)\n{\nstruct sock *sk = (struct sock *)ctx-&gt;skaddr;\n__u16 family = ctx-&gt;family;\n__u16 sport = ctx-&gt;sport;\n__u16 dport = ctx-&gt;dport;\n__u64 *tsp, delta_us, ts;\nstruct event event = {};\nif (ctx-&gt;protocol != IPPROTO_TCP)\nreturn 0;\nif (target_family &amp;&amp; target_family != family)\nreturn 0;\nif (filter_by_sport &amp;&amp; !bpf_map_lookup_elem(&amp;sports, &amp;sport))\nreturn 0;\nif (filter_by_dport &amp;&amp; !bpf_map_lookup_elem(&amp;dports, &amp;dport))\nreturn 0;\ntsp = bpf_map_lookup_elem(&amp;timestamps, &amp;sk);\nts = bpf_ktime_get_ns();\nif (!tsp)\ndelta_us = 0;\nelse\ndelta_us = (ts - *tsp) / 1000;\nevent.skaddr = (__u64)sk;\nevent.ts_us = ts / 1000;\nevent.delta_us = delta_us;\nevent.pid = bpf_get_current_pid_tgid() &gt;&gt; 32;\nevent.oldstate = ctx-&gt;oldstate;\nevent.newstate = ctx-&gt;newstate;\nevent.family = family;\nevent.sport = sport;\nevent.dport = dport;\nbpf_get_current_comm(&amp;event.task, sizeof(event.task));\nif (family == AF_INET) {\nbpf_probe_read_kernel(&amp;event.saddr, sizeof(event.saddr), &amp;sk-&gt;__sk_common.skc_rcv_saddr);\nbpf_probe_read_kernel(&amp;event.daddr, sizeof(event.daddr), &amp;sk-&gt;__sk_common.skc_daddr);\n} else { /* family == AF_INET6 */\nbpf_probe_read_kernel(&amp;event.saddr, sizeof(event.saddr), &amp;sk-&gt;__sk_common.skc_v6_rcv_saddr.in6_u.u6_addr32);\nbpf_probe_read_kernel(&amp;event.daddr, sizeof(event.daddr), &amp;sk-&gt;__sk_common.skc_v6_daddr.in6_u.u6_addr32);\n}.`bpf_perf_event_output(ctx, &amp;events, BPF_F_CURRENT_CPU, &amp;event, sizeof(event));\nif (ctx-&gt;newstate == TCP_CLOSE)\nbpf_map_delete_elem(&amp;timestamps, &amp;sk);\nelse\nbpf_map_update_elem(&amp;timestamps, &amp;sk, &amp;ts, BPF_ANY);\nreturn 0;\n}\n</code></pre> <p>The <code>tcpstates</code> program relies on eBPF Tracepoints to capture the state changes of TCP connections, in order to track the time spent in each state of the TCP connection.</p>"},{"location":"tutorials/14-tcpstates/#define-bpf-maps","title":"Define BPF Maps","text":"<p>In the <code>tcpstates</code> program, several BPF Maps are defined, which are the primary way of interaction between the eBPF program and the user-space program. <code>sports</code> and <code>dports</code> are used to store the source and destination ports for filtering TCP connections; <code>timestamps</code> is used to store the timestamps for each TCP connection to calculate the time spent in each state; <code>events</code> is a map of type <code>perf_event</code>, used to send event data to the user-space.</p>"},{"location":"tutorials/14-tcpstates/#trace-tcp-connection-state-changes","title":"Trace TCP Connection State Changes","text":"<p>The program defines a function called <code>handle_set_state</code>, which is a program of type tracepoint and is mounted on the <code>sock/inet_sock_set_state</code> kernel tracepoint. Whenever the TCP connection state changes, this tracepoint is triggered and the <code>handle_set_state</code> function is executed.</p> <p>In the <code>handle_set_state</code> function, it first determines whether the current TCP connection needs to be processed through a series of conditional judgments, then retrieves the previous timestamp of the current connection from the <code>timestamps</code> map, and calculates the time spent in the current state. Then, the program places the collected data in an event structure and sends the event to the user-space using the <code>bpf_perf_event_output</code> function.</p>"},{"location":"tutorials/14-tcpstates/#update-timestamps","title":"Update Timestamps","text":"<p>Finally, based on the new state of the TCP connection, the program performs different operations: if the new state is TCP_CLOSE, it means the connection has been closed and the program deletes the timestamp of that connection from the <code>timestamps</code> map; otherwise, the program updates the timestamp of the connection.</p>"},{"location":"tutorials/14-tcpstates/#user-space-processing","title":"User-Space Processing","text":"<p>The user-space part is mainly about loading the eBPF program using libbpf and receiving event data from the kernel using perf_event:</p> <pre><code>static void handle_event(void* ctx, int cpu, void* data, __u32 data_sz) {\nchar ts[32], saddr[26], daddr[26];\nstruct event* e = data;\nstruct tm* tm;\nint family;\ntime_t t;\nif (emit_timestamp) {\ntime(&amp;t);\ntm = localtime(&amp;t);\nstrftime(ts, sizeof(ts), \"%H:%M:%S\", tm);\nprintf(\"%8s \", ts);\n}\ninet_ntop(e-&gt;family, &amp;e-&gt;saddr, saddr, sizeof(saddr));\ninet_ntop(e-&gt;family, &amp;e-&gt;daddr, daddr, sizeof(daddr));\nif (wide_output) {\nfamily = e-&gt;family == AF_INET ? 4 : 6;\nprintf(\n\"%-16llx %-7d %-16s %-2d %-26s %-5d %-26s %-5d %-11s -&gt; %-11s \"\n\"%.3f\\n\",\ne-&gt;skaddr, e-&gt;pid, e-&gt;task, family, saddr, e-&gt;sport, daddr,\ne-&gt;dport, tcp_states[e-&gt;oldstate], tcp_states[e-&gt;newstate],\n(double)e-&gt;delta_us / 1000);\n} else {\nprintf(\n\"%-16llx %-7d %-10.10s %-15s %-5d %-15s %-5d %-11s -&gt; %-11s %.3f\\n\",\n...\n</code></pre> <p>handle_event` is a callback function that is called by perf_event. It handles new events that arrive in the kernel.</p> <p>In the <code>handle_event</code> function, we first use the <code>inet_ntop</code> function to convert the binary IP address to a human-readable format. Then, based on whether the wide format is needed or not, we print different information. This information includes the timestamp of the event, source IP address, source port, destination IP address, destination port, old state, new state, and the time spent in the old state.</p> <p>This allows users to see the changes in TCP connection states and the duration of each state, helping them diagnose network issues.</p> <p>In summary, the user-space part of the processing involves the following steps:</p> <ol> <li>Use libbpf to load and run the eBPF program.</li> <li>Set up a callback function to receive events sent by the kernel.</li> <li>Process the received events, convert them into a human-readable format, and print them.</li> </ol> <p>The above is the main implementation logic of the user-space part of the <code>tcpstates</code> program. Through this chapter, you should have gained a deeper understanding of how to handle kernel events in user space. In the next chapter, we will introduce more knowledge about using eBPF for network monitoring.</p>"},{"location":"tutorials/14-tcpstates/#tcprtt","title":"tcprtt","text":"<p>In this section, we will analyze the kernel BPF code of the <code>tcprtt</code> eBPF program. <code>tcprtt</code> is a program used to measure TCP Round Trip Time (RTT) and stores the RTT information in a histogram.</p> <pre><code>/// @sample {\"interval\": 1000, \"type\" : \"log2_hist\"}\nstruct {\n__uint(type, BPF_MAP_TYPE_HASH);\n__uint(max_entries, MAX_ENTRIES);\n__type(key, u64);\n__type(value, struct hist);\n} hists SEC(\".maps\");\nstatic struct hist zero;\nSEC(\"fentry/tcp_rcv_established\")\nint BPF_PROG(tcp_rcv, struct sock *sk)\n{\nconst struct inet_sock *inet = (struct inet_sock *)(sk);\nstruct tcp_sock *ts;\nstruct hist *histp;\nu64 key, slot;\nu32 srtt;\nif (targ_sport &amp;&amp; targ_sport != inet-&gt;inet_sport)\nreturn 0;\nif (targ_dport &amp;&amp; targ_dport != sk-&gt;__sk_common.skc_dport)\nreturn 0;\nif (targ_saddr &amp;&amp; targ_saddr != inet-&gt;inet_saddr)\nreturn 0;\nif (targ_daddr &amp;&amp; targ_daddr != sk-&gt;__sk_common.skc_daddr)\nreturn 0;\nif (targ_laddr_hist)\nkey = inet-&gt;inet_saddr;\nelse if (targ_raddr_hist)\nkey = inet-&gt;sk.__sk_common.skc_daddr;\nelse\nkey = 0;\nhistp = bpf_map_lookup_or_try_init(&amp;hists, &amp;key, &amp;zero);\nif (!histp)\nreturn 0;\nts = (struct tcp_sock *)(sk);\nsrtt = BPF_CORE_READ(ts, srtt_us) &gt;&gt; 3;\nif (targ_ms)\nsrtt /= 1000U;\nslot = log2l(srtt);\nif (slot &gt;= MAX_SLOTS)\nslot = MAX_SLOTS - 1;\n</code></pre> <p>The code above declares a map called <code>hists</code>, which is a hash map used to store the histogram data. The <code>hists</code> map has a maximum number of entries defined as <code>MAX_ENTRIES</code>.</p> <p>The function <code>BPF_PROG(tcp_rcv, struct sock *sk)</code> is the entry point of the eBPF program for handling the <code>tcp_rcv_established</code> event. Within this function, the program retrieves various information from the network socket and checks if filtering conditions are met. Then, it performs operations on the histogram data structure. Finally, the program calculates the slot for the RTT value and updates the histogram accordingly.</p> <p>This is the main code logic of the <code>tcprtt</code> eBPF program in kernel mode. The eBPF program measures the RTT of TCP connections and maintains a histogram to collect and analyze the RTT data.Instructions:</p> <pre><code>__sync_fetch_and_add(&amp;histp-&gt;slots[slot], 1);\nif (targ_show_ext) {\n__sync_fetch_and_add(&amp;histp-&gt;latency, srtt);\n__sync_fetch_and_add(&amp;histp-&gt;cnt, 1);\n}\nreturn 0;\n}\n</code></pre> <p>First, we define a hash type eBPF map called <code>hists</code>, which is used to store statistics information about RTT. In this map, the key is a 64-bit integer, and the value is a <code>hist</code> structure that contains an array to store the count of different RTT intervals.</p> <p>Next, we define an eBPF program called <code>tcp_rcv</code> which will be called every time a TCP packet is received in the kernel. In this program, we first filter TCP connections based on filtering conditions (source/destination IP address and port). If the conditions are met, we select the corresponding key (source IP, destination IP, or 0) based on the set parameters, and then look up or initialize the corresponding histogram in the <code>hists</code> map.</p> <p>Then, we read the <code>srtt_us</code> field of the TCP connection, which represents the smoothed RTT value in microseconds. We convert this RTT value to a logarithmic form and store it as a slot in the histogram.</p> <p>If the <code>show_ext</code> parameter is set, we also increment the RTT value and the counter in the <code>latency</code> and <code>cnt</code> fields of the histogram.</p> <p>With the above processing, we can analyze and track the RTT of each TCP connection to better understand the network performance.</p> <p>In summary, the main logic of the <code>tcprtt</code> eBPF program includes the following steps:</p> <ol> <li>Filter TCP connections based on filtering conditions.</li> <li>Look up or initialize the corresponding histogram in the <code>hists</code> map.</li> <li>Read the <code>srtt_us</code> field of the TCP connection, convert it to a logarithmic form, and store it in the histogram.</li> <li>If the <code>show_ext</code> parameter is set, increment the RTT value and the counter in the <code>latency</code> and <code>cnt</code> fields of the histogram.</li> </ol> <p><code>tcprtt</code> is attached to the kernel's <code>tcp_rcv_established</code> function:</p> <pre><code>void tcp_rcv_established(struct sock *sk, struct sk_buff *skb);\n</code></pre> <p>This function is the main function in the kernel for processing received TCP data and is called when a TCP connection is in the <code>ESTABLISHED</code> state. The processing logic of this function includes a fast path and a slow path. The fast path is disabled in the following cases:</p> <ul> <li>We have advertised a zero window - zero window probing can only be handled correctly in the slow path.</li> <li>Out-of-order data packets received.</li> <li>Expecting to receive urgent data.</li> <li>No remaining buffer space.</li> <li>Received unexpected TCP flags/window values/header lengths (detected by checking TCP header against the expected flags).</li> <li>Data is being transmitted in both directions. The fast path only supports pure senders or pure receivers (meaning the sequence number or acknowledgement value must remain unchanged).</li> <li>Received unexpected TCP options.</li> </ul> <p>When these conditions are not met, it enters a standard receive processing, which follows RFC 793 to handle all cases. The first three cases can be ensured by setting the correct expected flags, while the remaining cases require inline checks. When everything is normal, the fast processing path is invoked in the <code>tcp_data_queue</code> function.</p>"},{"location":"tutorials/14-tcpstates/#compilation-and-execution","title":"Compilation and Execution","text":"<p>For <code>tcpstates</code>, you can compile and run the libbpf application with the following command:</p> <pre><code>$ make\n...\n  BPF      .output/tcpstates.bpf.o\n  GEN-SKEL .output/tcpstates.skel.h\n  CC       .output/tcpstates.o\n  BINARY   tcpstates\n$ sudo ./tcpstates SKADDR           PID     COMM       LADDR           LPORT RADDR           RPORT OLDSTATE    -&gt; NEWSTATE    MS\nffff9bf61bb62bc0 164978  node       192.168.88.15   0     52.178.17.2     443   CLOSE       -&gt; SYN_SENT    0.000\nffff9bf61bb62bc0 0       swapper/0  192.168.88.15   41596 52.178.17.2     443   SYN_SENT    -&gt; ESTABLISHED 225.794\".\nformat: Return only the translated content, not including the original text.```\n\"ffff9bf61bb62bc0 0       swapper/0  192.168.88.15   41596 52.178.17.2     443   ESTABLISHED -&gt; CLOSE_WAIT  901.454\nffff9bf61bb62bc0 164978  node       192.168.88.15   41596 52.178.17.2     443   CLOSE_WAIT  -&gt; LAST_ACK    0.793\nffff9bf61bb62bc0 164978  node       192.168.88.15   41596 52.178.17.2     443   LAST_ACK    -&gt; LAST_ACK    0.086\nffff9bf61bb62bc0 228759  kworker/u6 192.168.88.15   41596 52.178.17.2     443   LAST_ACK    -&gt; CLOSE       0.193\nffff9bf6d8ee88c0 229832  redis-serv 0.0.0.0         6379  0.0.0.0         0     CLOSE       -&gt; LISTEN      0.000\nffff9bf6d8ee88c0 229832  redis-serv 0.0.0.0         6379  0.0.0.0         0     LISTEN      -&gt; CLOSE       1.763\nffff9bf7109d6900 88750   node       127.0.0.1       39755 127.0.0.1       50966 ESTABLISHED -&gt; FIN_WAIT1   0.000\n</code></pre> <p>For tcprtt, we can use eunomia-bpf to compile and run this example:</p> <p>Compile:</p> <pre><code>docker run -it -v `pwd`/:/src/ ghcr.io/eunomia-bpf/ecc-`uname -m`:latest\n</code></pre> <p>Or</p> <pre><code>$ ecc runqlat.bpf.c runqlat.h\nCompiling bpf object...\nGenerating export types...\nPacking ebpf object and config into package.json...\n</code></pre> <p>Run:</p> <pre><code>$ sudo ecli run package.json -h\nA simple eBPF program\nUsage: package.json [OPTIONS]\nOptions:\n      --verbose                  Whether to show libbpf debug information\n      --targ_laddr_hist          Set value of `bool` variable targ_laddr_hist\n      --targ_raddr_hist          Set value of `bool` variable targ_raddr_hist\n      --targ_show_ext            Set value of `bool` variable targ_show_ext\n      --targ_sport &lt;targ_sport&gt;  Set value of `__u16` variable targ_sport\n      --targ_dport &lt;targ_dport&gt;  Set value of `__u16` variable targ_dport\n      --targ_saddr &lt;targ_saddr&gt;  Set value of `__u32` variable targ_saddr\n      --targ_daddr &lt;targ_daddr&gt;  Set value of `__u32` variable targ_daddr\n      --targ_ms                  Set value of `bool` variable targ_ms\n  -h, --help                     Print help\n  -V, --version                  Print version\nBuilt with eunomia-bpf framework.\".\n```See https://github.com/eunomia-bpf/eunomia-bpf for more information.\n$ sudo ecli run package.json\nkey =  0\nlatency = 0\ncnt = 0\n     (unit)              : count    distribution\n         0 -&gt; 1          : 0        |                                        |\n         2 -&gt; 3          : 0        |                                        |\n         4 -&gt; 7          : 0        |                                        |\n         8 -&gt; 15         : 0        |                                        |\n        16 -&gt; 31         : 0        |                                        |\n        32 -&gt; 63         : 0        |                                        |\n        64 -&gt; 127        : 0        |                                        |\n       128 -&gt; 255        : 0        |                                        |\n       256 -&gt; 511        : 0        |                                        |\n       512 -&gt; 1023       : 4        |********************                    |\n      1024 -&gt; 2047       : 1        |*****                                   |\n      2048 -&gt; 4095       : 0        |                                        |\n      4096 -&gt; 8191       : 8        |****************************************|\nkey =  0\nlatency = 0\ncnt = 0\n     (unit)              : count    distribution\n         0 -&gt; 1          : 0        |                                        |\n         2 -&gt; 3          : 0        |                                        |\n         4 -&gt; 7          : 0        |                                        |\n         8 -&gt; 15         : 0        |                                        |\n        16 -&gt; 31         : 0        |                                        |\n        32 -&gt; 63         : 0        |                                        |\n        64 -&gt; 127        : 0        |                                        |\n       128 -&gt; 255        : 0        |                                        |\n       256 -&gt; 511        : 0        |                                        |512 -&gt; 1023       : 11       |***************************             |\n      1024 -&gt; 2047       : 1        |**                                      |\n      2048 -&gt; 4095       : 0        |                                        |\n      4096 -&gt; 8191       : 16       |****************************************|\n      8192 -&gt; 16383      : 4        |**********                              |\n</code></pre> <p>Complete source code:</p> <ul> <li>https://github.com/eunomia-bpf/bpf-developer-tutorial/tree/main/src/14-tcpstates</li> </ul> <p>References:</p> <ul> <li>tcpstates</li> <li>tcprtt</li> <li>libbpf-tools/tcpstates</li> </ul>"},{"location":"tutorials/14-tcpstates/#summary","title":"Summary","text":"<p>In this eBPF introductory tutorial, we learned how to use the tcpstates and tcprtt eBPF example programs to monitor and analyze the connection states and round-trip time of TCP. We understood the working principles and implementation methods of tcpstates and tcprtt, including how to store data using BPF maps, how to retrieve and process TCP connection information in eBPF programs, and how to parse and display the data collected by eBPF programs in user-space applications.</p> <p>If you would like to learn more about eBPF knowledge and practices, you can visit our tutorial code repository at https://github.com/eunomia-bpf/bpf-developer-tutorial for more examples and complete tutorials. The upcoming tutorials will further explore advanced features of eBPF, and we will continue to share more content about eBPF development practices.</p>"},{"location":"tutorials/15-javagc/","title":"eBPF Introduction Tutorial 15: Capturing User-Space Java GC Event Duration Using USDT","text":"<p>eBPF (Extended Berkeley Packet Filter) is a powerful network and performance analysis tool widely used in the Linux kernel. eBPF allows developers to dynamically load, update, and run user-defined code without the need to restart the kernel or modify the kernel source code. This feature provides eBPF with high flexibility and performance, making it widely applicable in network and system performance analysis. Furthermore, eBPF also supports capturing user-space application behavior using User-Level Statically Defined Tracing (USDT).</p> <p>In this article of our eBPF introduction tutorial series, we will explore how to use eBPF and USDT to capture and analyze the duration of Java garbage collection (GC) events.</p>"},{"location":"tutorials/15-javagc/#introduction-to-usdt","title":"Introduction to USDT","text":"<p>USDT is a mechanism for inserting static tracepoints into applications, allowing developers to insert probes at critical points in the program for debugging and performance analysis purposes. These probes can be dynamically activated at runtime by tools such as DTrace, SystemTap, or eBPF, allowing access to the program's internal state and performance metrics without the need to restart the application or modify the program code. USDT is widely used in many open-source software applications such as MySQL, PostgreSQL, Ruby, Python, and Node.js.</p>"},{"location":"tutorials/15-javagc/#user-level-tracing-mechanism-user-level-dynamic-tracing-and-usdt","title":"User-Level Tracing Mechanism: User-Level Dynamic Tracing and USDT","text":"<p>User-Level Dynamic Tracing allows us to instrument any user-level code by placing probes. For example, we can trace query requests in a MySQL server by placing a probe on the <code>dispatch_command()</code> function:</p> <pre><code># ./uprobe 'p:cmd /opt/bin/mysqld:_Z16dispatch_command19enum_server_commandP3THDPcj +0(%dx):string'\nTracing uprobe cmd (p:cmd /opt/bin/mysqld:0x2dbd40 +0(%dx):string). Ctrl-C to end.\n  mysqld-2855  [001] d... 19957757.590926: cmd: (0x6dbd40) arg1=\"show tables\"\nmysqld-2855  [001] d... 19957759.703497: cmd: (0x6dbd40) arg1=\"SELECT * FROM numbers\"\n[...]\n</code></pre> <p>Here, we use the <code>uprobe</code>tool, which leverages Linux's built-in functionalities: ftrace (tracing framework) and uprobes (User-Level Dynamic Tracing, requires a relatively new Linux version, around 4.0 or later). Other tracing frameworks such as perf_events and SystemTap can also achieve this functionality.</p> <p>Many other MySQL functions can be traced to obtain more information. We can list and count the number of these functions:</p> <pre><code># ./uprobe -l /opt/bin/mysqld | more\naccount_hash_get_key\nadd_collation\nadd_compiled_collation\nadd_plugin_noargs\nadjust_time_range\n[...]\n# ./uprobe -l /opt/bin/mysqld | wc -l\n21809\n</code></pre> <p>There are 21,000 functions here. We can also trace library functions or even individual instruction offsets.</p> <p>User-Level Dynamic Tracing capability is very powerful and can solve numerous problems. However, using it also has some challenges: identifying the code to trace, handling function parameters, and dealing with code modifications.</p> <p>User-Level Statically Defined Tracing (USDT) can address some of these challenges. USDT probes (or \"markers\" at the user level) are trace macros inserted at critical positions in the code, providing a stable and well-documented API. This makes the tracing work simpler.</p> <p>With USDT, we can easily trace a probe called <code>mysql:query__start</code> instead of tracing the C++ symbol <code>_Z16dispatch_command19enum_server_commandP3THDPcj</code>, which is the <code>dispatch_command()</code> function. Of course, we can still trace <code>dispatch_command()</code> and the other 21,000 mysqld functions when needed, but only when USDT probes cannot solve the problem.In Linux, USDT (User Statically Defined Tracing) has actually existed in various forms for decades. It has recently gained attention again due to the popularity of Sun's DTrace tool, which has led to many common applications, including MySQL, PostgreSQL, Node.js, Java, etc., adding USDT support. SystemTap has developed a way to consume these DTrace probes.</p> <p>You may be running a Linux application that already includes USDT probes, or you may need to recompile it (usually with --enable-dtrace). You can use <code>readelf</code> to check, for example, for Node.js:</p> <pre><code># readelf -n node\n[...]\nNotes at offset 0x00c43058 with length 0x00000494:\n  Owner                 Data size   Description\n  stapsdt              0x0000003c   NT_STAPSDT (SystemTap probe descriptors)\nProvider: node\n    Name: gc__start\n    Location: 0x0000000000bf44b4, Base: 0x0000000000f22464, Semaphore: 0x0000000001243028\n    Arguments: 4@%esi 4@%edx 8@%rdi\n[...]\nstapsdt              0x00000082       NT_STAPSDT (SystemTap probe descriptors)\nProvider: node\n    Name: http__client__request\n    Location: 0x0000000000bf48ff, Base: 0x0000000000f22464, Semaphore: 0x0000000001243024\n    Arguments: 8@%rax 8@%rdx 8@-136(%rbp) -4@-140(%rbp) 8@-72(%rbp) 8@-80(%rbp) -4@-144(%rbp)\n[...]\n</code></pre> <p>This is a Node.js recompiled with --enable-dtrace and installed with the systemtap-sdt-dev package that provides \"dtrace\" functionality to support USDT. Here are two probes displayed: node:gc__start (garbage collection start) and node:http__client__request.</p> <p>At this point, you can use SystemTap or LTTng to trace these probes. However, built-in Linux tracers like ftrace and perf_events currently cannot do this (although perf_events support is under development).</p>"},{"location":"tutorials/15-javagc/#introduction-to-java-gc","title":"Introduction to Java GC","text":"<p>Java, as a high-level programming language, has automatic garbage collection (GC) as one of its core features. The goal of Java GC is to automatically reclaim memory space that is no longer used by the program, thereby relieving programmers of the burden of memory management. However, the GC process may cause application pauses, which can impact program performance and response time. Therefore, monitoring and analyzing Java GC events are essential for understanding and optimizing the performance of Java applications.</p> <p>In the following tutorial, we will demonstrate how to use eBPF and USDT to monitor and analyze the duration of Java GC events. We hope this content will be helpful to you in your work with eBPF for application performance analysis.</p>"},{"location":"tutorials/15-javagc/#ebpf-implementation-mechanism","title":"eBPF Implementation Mechanism","text":"<p>The eBPF program for Java GC is divided into two parts: kernel space and user space. We will introduce the implementation mechanisms of these two parts separately.</p>"},{"location":"tutorials/15-javagc/#kernel-space-program","title":"Kernel Space Program","text":"<pre><code>/* SPDX-License-Identifier: (LGPL-2.1 OR BSD-2-Clause) */\n/* Copyright (c) 2022 Chen Tao */\n#include &lt;vmlinux.h&gt;\n#include &lt;bpf/bpf_helpers.h&gt;\n#include &lt;bpf/bpf_core_read.h&gt;\n#include &lt;bpf/usdt.bpf.h&gt;\n#include \"javagc.h\"\nstruct {\n__uint(type, BPF_MAP_TYPE_HASH);\n__uint(max_entries, 100);\n__type(key, uint32_t);\n__type(value, struct data_t);\n} data_map SEC(\".maps\");\nstruct {\n__uint(type, BPF_MAP_TYPE_PERF_EVENT_ARRAY);\n``````cpp\n__type(key, int);\n__type(value, int);\n} perf_map SEC(\".maps\");\n__u32 time;\nstatic int gc_start(struct pt_regs *ctx)\n{\nstruct data_t data = {};\ndata.cpu = bpf_get_smp_processor_id();\ndata.pid = bpf_get_current_pid_tgid() &gt;&gt; 32;\ndata.ts = bpf_ktime_get_ns();\nbpf_map_update_elem(&amp;data_map, &amp;data.pid, &amp;data, 0);\nreturn 0;\n}\nstatic int gc_end(struct pt_regs *ctx)\n{\nstruct data_t data = {};\nstruct data_t *p;\n__u32 val;\ndata.cpu = bpf_get_smp_processor_id();\ndata.pid = bpf_get_current_pid_tgid() &gt;&gt; 32;\ndata.ts = bpf_ktime_get_ns();\np = bpf_map_lookup_elem(&amp;data_map, &amp;data.pid);\nif (!p)\nreturn 0;\nval = data.ts - p-&gt;ts;\nif (val &gt; time) {\ndata.ts = val;\nbpf_perf_event_output(ctx, &amp;perf_map, BPF_F_CURRENT_CPU, &amp;data, sizeof(data));\n}\nbpf_map_delete_elem(&amp;data_map, &amp;data.pid);\nreturn 0;\n}\nSEC(\"usdt\")\nint handle_gc_start(struct pt_regs *ctx)\n{\nreturn gc_start(ctx);\n}\nSEC(\"usdt\")\nint handle_gc_end(struct pt_regs *ctx)\n{\nreturn gc_end(ctx);\n}\nSEC(\"usdt\")\nint handle_mem_pool_gc_start(struct pt_regs *ctx)\n{\nreturn gc_start(ctx);\n}\nSEC(\"usdt\")\nint handle_mem_pool_gc_end(struct pt_regs *ctx)\n{\nreturn gc_end(ctx);\n}\nchar LICENSE[] SEC(\"license\") = \"Dual BSD/GPL\";\n</code></pre> <p>First, we define two maps:</p> <ul> <li><code>data_map</code>: This hashmap stores the start time of garbage collection for each process ID. The <code>data_t</code> structure contains the process ID, CPU ID, and timestamp.</li> <li><code>perf_map</code>: This is a perf event array used to send data back to the user-space program.</li> </ul> <p>Then, we have four handler functions: <code>gc_start</code>, <code>gc_end</code>, and two USDT handler functions <code>handle_mem_pool_gc_start</code> and <code>handle_mem_pool_gc_end</code>. These functions are all annotated with the BPF <code>SEC(\"usdt\")</code> macro to capture USDT events related to garbage collection in a Java process.</p> <p>The <code>gc_start</code> function is called when garbage collection starts. It first gets the current CPU ID, process ID, and timestamp, and then stores this data in <code>data_map</code>.</p> <p>The <code>gc_end</code> function is called when garbage collection ends. It performs similar operations as <code>gc_start</code>, but it also retrieves the start time from <code>data_map</code> and calculates the duration of garbage collection. If the duration exceeds a set threshold (<code>time</code> variable), it sends the data back to the user-space program.</p> <p><code>handle_gc_start</code> and <code>handle_gc_end</code> are handler functions for the garbage collection start and end events, respectively, and they call <code>gc_start</code> and <code>gc_end</code>, respectively.</p> <p><code>handle_mem_pool_gc_start</code> and <code>handle_mem_pool_gc_end</code> are handler functions for the garbage collection start and end events in the memory pool, and they also call <code>gc_start</code> and <code>gc_end</code>, respectively.Finally, we have a <code>LICENSE</code> array that declares the license of the BPF program, which is required for loading the BPF program.</p>"},{"location":"tutorials/15-javagc/#user-space-program","title":"User-space Program","text":"<p>The main goal of the user-space program is to load and run eBPF programs, as well as process data from the kernel-space program. This is achieved through the use of the libbpf library. Here, we are omitting some common code for loading and running eBPF programs and only showing the parts related to USDT.</p> <p>The first function <code>get_jvmso_path</code> is used to obtain the path of the <code>libjvm.so</code> library for the running Java Virtual Machine (JVM). First, it opens the <code>/proc/&lt;pid&gt;/maps</code> file, which contains the memory mapping information of the process address space. Then, it searches for the line that contains <code>libjvm.so</code> in the file and copies the path of that line to the provided argument.</p> <pre><code>static int get_jvmso_path(char *path)\n{\nchar mode[16], line[128], buf[64];\nsize_t seg_start, seg_end, seg_off;\nFILE *f;\nint i = 0;\nsprintf(buf, \"/proc/%d/maps\", env.pid);\nf = fopen(buf, \"r\");\nif (!f)\nreturn -1;\nwhile (fscanf(f, \"%zx-%zx %s %zx %*s %*d%[^\\n]\\n\",\n&amp;seg_start, &amp;seg_end, mode, &amp;seg_off, line) == 5) {\ni = 0;\nwhile (isblank(line[i]))\ni++;\nif (strstr(line + i, \"libjvm.so\")) {\nbreak;\n}\n}\nstrcpy(path, line + i);\nfclose(f);\nreturn 0;\n}\n</code></pre> <p>Next, we see the attachment of the eBPF programs (<code>handle_gc_start</code> and <code>handle_gc_end</code>) to the relevant USDT probes in the Java process. Each program achieves this by calling the <code>bpf_program__attach_usdt</code> function, which takes as parameters the BPF program, the process ID, the binary path, and the provider and name of the probe. If the probe is successfully attached, <code>bpf_program__attach_usdt</code> will return a link object, which is stored in the skeleton's link member. If the attachment fails, the program will print an error message and perform cleanup.</p> <pre><code>    skel-&gt;links.handle_mem_pool_gc_start = bpf_program__attach_usdt(skel-&gt;progs.handle_gc_start, env.pid,\nbinary_path, \"hotspot\", \"mem__pool__gc__begin\", NULL);\nif (!skel-&gt;links.handle_mem_pool_gc_start) {\nerr = errno;\nfprintf(stderr, \"attach usdt mem__pool__gc__begin failed: %s\\n\", strerror(err));\ngoto cleanup;\n}\nskel-&gt;links.handle_mem_pool_gc_end = bpf_program__attach_usdt(skel-&gt;progs.handle_gc_end, env.pid,\nbinary_path, \"hotspot\", \"mem__pool__gc__end\", NULL);\nif (!skel-&gt;links.handle_mem_pool_gc_end) {\nerr = errno;\nfprintf(stderr, \"attach usdt mem__pool__gc__end failed: %s\\n\", strerror(err));\ngoto cleanup;\n}\nskel-&gt;links.handle_gc_start = bpf_program__attach_usdt(skel-&gt;progs.handle_gc_start, env.pid,\nbinary_path, \"hotspot\", \"gc__begin\", NULL);\nif (!skel-&gt;links.handle_gc_start) {\nerr = errno;\nfprintf(stderr, \"attach usdt gc__begin failed: %s\\n\", strerror(err));\ngoto cleanup;\n}\nskel-&gt;links.handle_gc_end = bpf_program__attach_usdt(skel-&gt;progs.handle_gc_end, env.pid,\nbinary_path, \"hotspot\", \"gc__end\", NULL);\nif (!skel-&gt;links.handle_gc_end) {\nerr = errno;\nfprintf(stderr, \"attach usdt gc__end failed: %s\\n\", strerror(err));\ngoto cleanup;\n}\n</code></pre> <p>The last function <code>handle_event</code> is a callback function used to handle data received from the perf event array. This function is triggered by the perf event array and is called each time a new event is received. The function first converts the data to a <code>data_t</code> structure, then formats the current time as a string, and finally prints the timestamp, CPU ID, process ID, and duration of the garbage collection.</p> <pre><code>static void handle_event(void *ctx, int cpu, void *data, __u32 data_sz)\n{\nstruct data_t *e = (struct data_t *)data;\nstruct tm *tm = NULL;\nchar ts[16];\ntime_t t;\ntime(&amp;t);\ntm = localtime(&amp;t);\nstrftime(ts, sizeof(ts), \"%H:%M:%S\", tm);\nprintf(\"%-8s %-7d %-7d %-7lld\\n\", ts, e-&gt;cpu, e-&gt;pid, e-&gt;ts/1000);\n}\n</code></pre>"},{"location":"tutorials/15-javagc/#installing-dependencies","title":"Installing Dependencies","text":"<p>To build the example, you need clang, libelf, and zlib. The package names may vary with different distributions.</p> <p>On Ubuntu/Debian, run the following command:</p> <pre><code>sudo apt install clang libelf1 libelf-dev zlib1g-dev\n</code></pre> <p>On CentOS/Fedora, run the following command:</p> <pre><code>sudo dnf install clang elfutils-libelf elfutils-libelf-devel zlib-devel\n</code></pre>"},{"location":"tutorials/15-javagc/#compiling-and-running","title":"Compiling and Running","text":"<p>In the corresponding directory, run Make to compile and run the code:</p> <pre><code>$ make\n$ sudo ./javagc -p 12345\nTracing javagc time... Hit Ctrl-C to end.\nTIME     CPU     PID     GC TIME\n10:00:01 10%     12345   50ms\n10:00:02 12%     12345   55ms\n10:00:03 9%      12345   47ms\n10:00:04 13%     12345   52ms\n10:00:05 11%     12345   50ms\n</code></pre> <p>Complete source code:</p> <ul> <li>https://github.com/eunomia-bpf/bpf-developer-tutorial/tree/main/src/15-javagc</li> </ul> <p>References:</p> <ul> <li>https://www.brendangregg.com/blog/2015-07-03/hacking-linux-usdt-ftrace.html</li> <li>https://github.com/iovisor/bcc/blob/master/libbpf-tools/javagc.c</li> </ul> <p>Summary.Through this introductory eBPF tutorial, we have learned how to use eBPF and USDT for dynamic tracing and analysis of Java garbage collection (GC) events. We have understood how to set USDT tracepoints in user space applications and how to write eBPF programs to capture information from these tracepoints, thereby gaining a deeper understanding and optimizing the behavior and performance of Java GC.</p> <p>Additionally, we have also introduced some basic knowledge and practical techniques related to Java GC, USDT, and eBPF. This knowledge and skills are valuable for developers who want to delve into the field of network and system performance analysis.</p> <p>If you would like to learn more about eBPF knowledge and practices, you can visit our tutorial code repository at https://github.com/eunomia-bpf/bpf-developer-tutorial to get more examples and the complete tutorial.</p>"},{"location":"tutorials/16-memleak/","title":"eBPF Getting Started Tutorial 16: Writing eBPF Program Memleak for Monitoring Memory Leaks","text":"<p>eBPF (extended Berkeley Packet Filter) is a powerful network and performance analysis tool that is widely used in the Linux kernel. eBPF allows developers to dynamically load, update, and run user-defined code without restarting the kernel or modifying its source code.</p> <p>In this tutorial, we will explore how to write a Memleak program using eBPF to monitor memory leaks in programs.</p>"},{"location":"tutorials/16-memleak/#background-and-importance","title":"Background and Importance","text":"<p>Memory leaks are a common problem in computer programming and should not be underestimated. When memory leaks occur, programs gradually consume more memory resources without properly releasing them. Over time, this behavior can lead to a gradual depletion of system memory, significantly reducing the overall performance of the program and system.</p> <p>There are many possible causes of memory leaks. It may be due to misconfiguration, such as a program incorrectly configuring dynamic allocation of certain resources. It may also be due to software bugs or incorrect memory management strategies, such as forgetting to release memory that is no longer needed during program execution. Additionally, if an application's memory usage is too high, system performance may significantly decrease due to paging/swapping, or it may even cause the application to be forcibly terminated by the system's OOM killer (Out of Memory Killer).</p>"},{"location":"tutorials/16-memleak/#challenges-of-debugging-memory-leaks","title":"Challenges of Debugging Memory Leaks","text":"<p>Debugging memory leak issues is a complex and challenging task. This involves detailed examination of the program's configuration, memory allocation, and deallocation, often requiring specialized tools to aid in diagnosis. For example, there are tools that can associate malloc() function calls with specific detection tools, such as Valgrind memcheck, which can simulate the CPU to check all memory accesses, but may greatly slow down the application's execution speed. Another option is to use heap analyzers, such as libtcmalloc, which are relatively faster but may still decrease the application's execution speed by more than five times. Additionally, there are tools like gdb that can obtain core dumps of applications and perform post-processing analysis of memory usage. However, these tools often require pausing the application during core dump acquisition or calling the free() function after the application terminates.</p>"},{"location":"tutorials/16-memleak/#role-of-ebpf","title":"Role of eBPF","text":"<p>In this context, the role of eBPF becomes particularly important. eBPF provides an efficient mechanism for monitoring and tracking system-level events, including memory allocation and deallocation. With eBPF, we can trace memory allocation and deallocation requests and collect the call stacks for each allocation. We can then analyze this information to identify call stacks that perform memory allocations but do not perform subsequent deallocations, helping us identify the source of memory leaks. The advantage of this approach is that it can be done in real-time within a running application without pausing the application or performing complex post-processing.</p> <p>The <code>memleak</code> eBPF tool can trace and match memory allocation and deallocation requests, and collect the call stacks for each allocation. Subsequently, <code>memleak</code> can print a summary indicating which call stacks executed allocations but did not perform subsequent deallocations. For example, running the command:</p> <pre><code># ./memleak -p $(pidof allocs)\nAttaching to pid 5193, Ctrl+C to quit.\n[11:16:33] Top 2 stacks with outstanding allocations:\n        80 bytes in 5 allocations from stack\n                 main+0x6d [allocs]\n                 __libc_start_main+0xf0 [libc-2.21.so]\n[11:16:34] Top 2 stacks with outstanding allocations:\n        160 bytes in 10 allocations from stack\n                 main+0x6d [allocs]\n                 __libc_start_main+0xf0 [libc-2.21.so]\n</code></pre> <p>After running this command, we can see which stacks the allocated but not deallocated memory came from, as well as the size and quantity of these unreleased memory blocks.</p> <p>Over time, it becomes evident that the <code>main</code> function of the <code>allocs</code> process is leaking memory, 16 bytes at a time. Fortunately, we don't need to inspect each allocation; we have a nice summary that tells us which stack is responsible for the significant leaks.</p>"},{"location":"tutorials/16-memleak/#implementation-principle-of-memleak","title":"Implementation Principle of memleak","text":"<p>At a basic level, <code>memleak</code> operates by installing monitoring devices on the memory allocation and deallocation paths. It achieves this by inserting eBPF programs into memory allocation and deallocation functions. This means that when these functions are called, <code>memleak</code> will record important information, such as the caller's process ID (PID), the allocated memory address, and the size of the allocated memory. When the function for freeing memory is called, <code>memleak</code> will delete the corresponding memory allocation record in its internal map. This mechanism allows <code>memleak</code> to accurately trace which memory blocks have been allocated but not deallocated.For commonly used memory allocation functions in user space, such as <code>malloc</code> and <code>calloc</code>, <code>memleak</code> uses user space probing (uprobe) technology for monitoring. Uprobe is a dynamic tracing technology for user space applications, which can set breakpoints at any location at runtime without modifying the binary files, thus achieving tracing of specific function calls.</p> <p>For kernel space memory allocation functions, such as <code>kmalloc</code>, <code>memleak</code> chooses to use tracepoints for monitoring. Tracepoint is a dynamic tracing technology provided in the Linux kernel, which can dynamically trace specific events in the kernel at runtime without recompiling the kernel or loading kernel modules.</p>"},{"location":"tutorials/16-memleak/#kernel-space-ebpf-program-implementation","title":"Kernel Space eBPF Program Implementation","text":""},{"location":"tutorials/16-memleak/#memleak-kernel-space-ebpf-program-implementation","title":"<code>memleak</code> Kernel Space eBPF Program Implementation","text":"<p>The kernel space eBPF program of <code>memleak</code> contains some key functions for tracking memory allocation and deallocation. Before delving into these functions, let's first take a look at some data structures defined by <code>memleak</code>, which are used in both its kernel space and user space programs.</p> <pre><code>#ifndef __MEMLEAK_H\n#define __MEMLEAK_H\n#define ALLOCS_MAX_ENTRIES 1000000\n#define COMBINED_ALLOCS_MAX_ENTRIES 10240\nstruct alloc_info {\n__u64 size;            // Size of allocated memory\n__u64 timestamp_ns;    // Timestamp when allocation occurs, in nanoseconds\nint stack_id;          // Call stack ID when allocation occurs\n};\nunion combined_alloc_info {\nstruct {\n__u64 total_size : 40;        // Total size of all unreleased allocations\n__u64 number_of_allocs : 24;   // Total number of unreleased allocations\n};\n__u64 bits;    // Bitwise representation of the structure\n};\n#endif /* __MEMLEAK_H */\n</code></pre> <p>Here, two main data structures are defined: <code>alloc_info</code> and <code>combined_alloc_info</code>.</p> <p>The <code>alloc_info</code> structure contains basic information about a memory allocation, including the allocated memory size <code>size</code>, the timestamp <code>timestamp_ns</code> when the allocation occurs, and the call stack ID <code>stack_id</code> that triggers the allocation.</p> <p>The <code>combined_alloc_info</code> is a union that contains an embedded structure and a <code>__u64</code> type bitwise representation <code>bits</code>. The embedded structure has two members: <code>total_size</code> and <code>number_of_allocs</code>, representing the total size and total count of unreleased allocations, respectively. The numbers 40 and 24 indicate the number of bits occupied by the <code>total_size</code> and <code>number_of_allocs</code> members, limiting their size. By using this limitation, storage space for the <code>combined_alloc_info</code> structure can be saved. Moreover, since <code>total_size</code> and <code>number_of_allocs</code> share the same <code>unsigned long long</code> type variable <code>bits</code> for storage, bitwise operations on the member variable <code>bits</code> can be used to access and modify <code>total_size</code> and <code>number_of_allocs</code>, avoiding the complexity of defining additional variables and functions in the program.</p> <p>Next, <code>memleak</code> defines a series of eBPF maps for storing memory allocation information and analysis results. These maps are defined in the form of <code>SEC(\".maps\")</code>, indicating that they belong to the mapping section of the eBPF program.</p> <pre><code>const volatile size_t min_size = 0;\nconst volatile size_t max_size = -1;\nconst volatile size_t page_size = 4096;\nconst volatile __u64 sample_rate = 1;\nconst volatile bool trace_all = false;\nconst volatile __u64 stack_flags = 0;\nconst volatile bool wa_missing_free = false;\nstruct {\n__uint(type, BPF_MAP_TYPE_HASH);\n__type(key, pid_t);\n__type(value, u64);\n__uint(max_entries, 10240);\n} sizes SEC(\".maps\");\nstruct {\n//... (continued)__uint(type, BPF_MAP_TYPE_HASH);\n__type(key, u64); /* address */\n__type(value, struct alloc_info);\n__uint(max_entries, ALLOCS_MAX_ENTRIES);\n} allocs SEC(\".maps\");\nstruct {\n__uint(type, BPF_MAP_TYPE_HASH);\n__type(key, u64); /* stack id */\n__type(value, union combined_alloc_info);\n__uint(max_entries, COMBINED_ALLOCS_MAX_ENTRIES);\n} combined_allocs SEC(\".maps\");\nstruct {\n__uint(type, BPF_MAP_TYPE_HASH);\n__type(key, u64);\n__type(value, u64);\n__uint(max_entries, 10240);\n} memptrs SEC(\".maps\");\nstruct {\n__uint(type, BPF_MAP_TYPE_STACK_TRACE);\n__type(key, u32);\n} stack_traces SEC(\".maps\");\nstatic union combined_alloc_info initial_cinfo;\n</code></pre> <p>The code first defines some configurable parameters, such as <code>min_size</code>, <code>max_size</code>, <code>page_size</code>, <code>sample_rate</code>, <code>trace_all</code>, <code>stack_flags</code>, and <code>wa_missing_free</code>, representing the minimum allocation size, maximum allocation size, page size, sample rate, whether to trace all allocations, stack flags, and whether to work in missing free mode.</p> <p>Then, five maps are defined:</p> <ol> <li><code>sizes</code>: This is a hash-type map with the key as the process ID and the value as <code>u64</code> type, storing the allocation size of each process.</li> <li><code>allocs</code>: This is also a hash-type map with the key as the allocation address and the value as the <code>alloc_info</code> structure, storing detailed information about each memory allocation.</li> <li><code>combined_allocs</code>: This is another hash-type map with the key as the stack ID and the value as the <code>combined_alloc_info</code> union, storing the total size and count of all unreleased allocations.</li> <li><code>memptrs</code>: This is also a hash-type map with both the key and value as <code>u64</code> type, used to pass memory pointers between user space and kernel space.</li> <li><code>stack_traces</code>: This is a stack trace-type map with the key as <code>u32</code> type, used to store stack IDs.</li> </ol> <p>Taking the user-space memory allocation tracing as an example, it mainly hooks memory-related function calls such as <code>malloc</code>, <code>free</code>, <code>calloc</code>, <code>realloc</code>, <code>mmap</code>, and <code>munmap</code> to record data when these functions are called. In user space, <code>memleak</code> mainly uses uprobes technology for hooking.</p> <p>Each function call is divided into \"enter\" and \"exit\" parts. The \"enter\" part records the function call parameters, such as the size of the allocation or the address being freed. The \"exit\" part is mainly used to obtain the return value of the function, such as the memory address obtained from the allocation.</p> <p>Here, <code>gen_alloc_enter</code>, <code>gen_alloc_exit</code>, <code>gen_free_enter</code> are functions that implement the recording behavior, and they are used to record relevant information when allocation starts, allocation ends, and freeing starts, respectively.</p> <p>The function prototype is as follows:</p> <pre><code>SEC(\"uprobe\")\nint BPF_KPROBE(malloc_enter, size_t size)\n{\n// Record relevant information when allocation starts\nreturn gen_alloc_enter(size);\n}\nSEC(\"uretprobe\")\nint BPF_KRETPROBE(malloc_exit)\n{\n// Record relevant information when allocation ends\nreturn gen_alloc_exit(ctx);\n}\nSEC(\"uprobe\")\nint BPF_KPROBE(free_enter, void *address)\n{\n// Record relevant information when freeing starts\nreturn gen_free_enter(address);\n}\n</code></pre> <p><code>malloc_enter</code> and <code>free_enter</code> are probes mounted at the entry points of the <code>malloc</code> and <code>free</code> functions, respectively, to record data during function calls. <code>malloc_exit</code> is a probe mounted at the return point of the <code>malloc</code> function to record the return value of the function.</p> <p>These functions are declared using the <code>BPF_KPROBE</code> and <code>BPF_KRETPROBE</code> macros, which are used to declare kprobes (kernel probes) and kretprobes (kernel return probes), respectively. Specifically, kprobe is triggered during function calls, while kretprobe is triggered during function returns.</p> <p>The <code>gen_alloc_enter</code> function is called at the beginning of a memory allocation request. This function is mainly responsible for collecting some basic information when the function that allocates memory is called. Now, let's take a deep dive into the implementation of this function.</p> <pre><code>static int gen_alloc_enter(size_t size)\n{\nif (size &lt; min_size || size &gt; max_size)\nreturn 0;\nif (sample_rate &gt; 1) {\nif (bpf_ktime_get_ns() % sample_rate != 0)\nreturn 0;\n}\nconst pid_t pid = bpf_get_current_pid_tgid() &gt;&gt; 32;\nbpf_map_update_elem(&amp;sizes, &amp;pid, &amp;size, BPF_ANY);\nif (trace_all)\nbpf_printk(\"alloc entered, size = %lu\\n\", size);\nreturn 0;\n}\nSEC(\"uprobe\")\nint BPF_KPROBE(malloc_enter, size_t size)\n{\nreturn gen_alloc_enter(size);\n}\n</code></pre> <p>First, the <code>gen_alloc_enter</code> function takes a <code>size</code> parameter that represents the size of the requested memory allocation. If this value is not between <code>min_size</code> and <code>max_size</code>, the function will return directly without performing any further operations. This allows the tool to focus on tracing memory allocation requests within a specific range and filter out uninteresting allocation requests.</p> <p>Next, the function checks the sampling rate <code>sample_rate</code>. If <code>sample_rate</code> is greater than 1, it means that we don't need to trace all memory allocation requests, but rather trace them periodically. Here, <code>bpf_ktime_get_ns</code> is used to get the current timestamp, and the modulus operation is used to determine whether to trace the current memory allocation request. This is a common sampling technique used to reduce performance overhead while providing a representative sample for analysis.</p> <p>Then, the function uses the <code>bpf_get_current_pid_tgid</code> function to retrieve the current process's PID. Note that the PID here is actually a combination of the process ID and thread ID, and we shift it right by 32 bits to get the actual process ID.</p> <p>The function then updates the <code>sizes</code> map, which uses the process ID as the key and the requested memory allocation size as the value. <code>BPF_ANY</code> indicates that if the key already exists, the value will be updated; otherwise, a new entry will be created.</p> <p>Finally, if the <code>trace_all</code> flag is enabled, the function will print a message indicating that a memory allocation has occurred.</p> <p>The <code>BPF_KPROBE</code> macro is used to intercept the execution of the <code>malloc</code> function with a BPF uprobe when the <code>malloc_enter</code> function is called, and it records the memory allocation size using <code>gen_alloc_enter</code>. We have just analyzed the entry function <code>gen_alloc_enter</code> of memory allocation, now let's focus on the exit part of this process. Specifically, we will discuss the <code>gen_alloc_exit2</code> function and how to obtain the returned memory address from the memory allocation call.</p> <pre><code>static int gen_alloc_exit2(void *ctx, u64 address)\n{\nconst pid_t pid = bpf_get_current_pid_tgid() &gt;&gt; 32;\nstruct alloc_info info;\nconst u64* size = bpf_map_lookup_elem(&amp;sizes, &amp;pid);\nif (!size)\nreturn 0; // missed alloc entry\n__builtin_memset(&amp;info, 0, sizeof(info));\ninfo.size = *size;bpf_map_delete_elem(&amp;sizes, &amp;pid);\nif (address != 0) {\ninfo.timestamp_ns = bpf_ktime_get_ns();\ninfo.stack_id = bpf_get_stackid(ctx, &amp;stack_traces, stack_flags);\nbpf_map_update_elem(&amp;allocs, &amp;address, &amp;info, BPF_ANY);\nupdate_statistics_add(info.stack_id, info.size);\n}\nif (trace_all) {\nbpf_printk(\"alloc exited, size = %lu, result = %lx\\n\",\ninfo.size, address);\n}\nreturn 0;\n}\nstatic int gen_alloc_exit(struct pt_regs *ctx)\n{\nreturn gen_alloc_exit2(ctx, PT_REGS_RC(ctx));\n}\nSEC(\"uretprobe\")\nint BPF_KRETPROBE(malloc_exit)\n{\nreturn gen_alloc_exit(ctx);\n}\n</code></pre> <p><code>gen_alloc_exit2</code> function is called when the memory allocation operation is completed. This function takes two parameters, one is the context <code>ctx</code> and the other is the memory address returned by the memory allocation function <code>address</code>.</p> <p>First, it obtains the PID (Process ID) of the current thread and uses it as a key to look up the corresponding memory allocation size in the <code>sizes</code> map. If not found (i.e., no entry for the memory allocation operation), the function simply returns.</p> <p>Then, it clears the content of the <code>info</code> structure and sets its <code>size</code> field to the memory allocation size found in the map. It also removes the corresponding element from the <code>sizes</code> map because the memory allocation operation has completed and this information is no longer needed.</p> <p>Next, if <code>address</code> is not zero (indicating a successful memory allocation operation), the function further collects some additional information. First, it obtains the current timestamp as the completion time of the memory allocation and fetches the current stack trace. These pieces of information are stored in the <code>info</code> structure and subsequently updated in the <code>allocs</code> map.</p> <p>Finally, the function calls <code>update_statistics_add</code> to update the statistics data and, if tracing of all memory allocation operations is enabled, it prints some information about the memory allocation operation.</p> <p>Note that, <code>gen_alloc_exit</code> is a wrapper for <code>gen_alloc_exit2</code>, which passes <code>PT_REGS_RC(ctx)</code> as the <code>address</code> parameter to <code>gen_alloc_exit2</code>.</p> <p>In our discussion, we just mentioned that <code>update_statistics_add</code> function is called in the <code>gen_alloc_exit2</code> function to update the statistics data for memory allocations. Now let's take a closer look at the implementation of this function.</p> <pre><code>static void update_statistics_add(u64 stack_id, u64 sz)\n{\nunion combined_alloc_info *existing_cinfo;\nexisting_cinfo = bpf_map_lookup_or_try_init(&amp;combined_allocs, &amp;stack_id, &amp;initial_cinfo);\nif (!existing_cinfo)\nreturn;\nconst union combined_alloc_info incremental_cinfo = {\n.total_size = sz,\n.number_of_allocs = 1\n};\n__sync_fetch_and_add(&amp;existing_cinfo-&gt;bits, incremental_cinfo.bits);\n}\n</code></pre> <p>The <code>update_statistics_add</code> function takes two parameters: the current stack ID <code>stack_id</code> and the size of the memory allocation <code>sz</code>. These two parameters are collected in the memory allocation event and used to update the statistics data for memory allocations.First, the function tries to find the element with the current stack ID as the key in the <code>combined_allocs</code> map. If it is not found, a new element is initialized with <code>initial_cinfo</code> (which is a default <code>combined_alloc_info</code> structure with all fields set to zero).</p> <p>Next, the function creates an <code>incremental_cinfo</code> and sets its <code>total_size</code> to the current memory allocation size and <code>number_of_allocs</code> to 1. This is because each call to the <code>update_statistics_add</code> function represents a new memory allocation event, and the size of this event's memory allocation is <code>sz</code>.</p> <p>Finally, the function atomically adds the value of <code>incremental_cinfo</code> to <code>existing_cinfo</code> using the <code>__sync_fetch_and_add</code> function. Note that this step is thread-safe, so even if multiple threads call the <code>update_statistics_add</code> function concurrently, each memory allocation event will be correctly recorded in the statistics.</p> <p>In summary, the <code>update_statistics_add</code> function implements the logic for updating memory allocation statistics. By maintaining the total amount and number of memory allocations for each stack ID, we can gain insight into the memory allocation behavior of the program.</p> <p>In our process of tracking memory allocation statistics, we not only need to count memory allocations but also consider memory releases. In the above code, we define a function called <code>update_statistics_del</code> that updates the statistics when memory is freed. The function <code>gen_free_enter</code> is executed when the process calls the <code>free</code> function.</p> <p>The <code>update_statistics_del</code> function takes the stack ID and the size of the memory block to be freed as parameters. First, the function uses the current stack ID as the key to look up the corresponding <code>combined_alloc_info</code> structure in the <code>combined_allocs</code> map. If it is not found, an error message is output and the function returns. If it is found, a <code>decremental_cinfo</code> <code>combined_alloc_info</code> structure is constructed with its <code>total_size</code> set to the size of the memory to be freed and <code>number_of_allocs</code> set to 1. Then the <code>__sync_fetch_and_sub</code> function is used to atomically subtract the value of <code>decremental_cinfo</code> from <code>existing_cinfo</code>. Note that the <code>number_of_allocs</code> here is negative, indicating a decrease in memory allocation.</p> <p>The <code>gen_free_enter</code> function takes the address to be freed as a parameter. It first converts the address to an unsigned 64-bit integer (<code>u64</code>). Then it looks up the <code>alloc_info</code> structure in the <code>allocs</code> map using the address as the key. If it is not found, the function returns 0. If it is found, the <code>alloc_info</code> structure is deleted from the <code>allocs</code> map, and the <code>update_statistics_del</code> function is called with the stack ID and size from <code>info</code>. If <code>trace_all</code> is true, an information message is output.</p> <pre><code>int BPF_KPROBE(free_enter, void *address)\n{\nreturn gen_free_enter(address);\n}\n</code></pre> <p>Next, let's look at the <code>gen_free_enter</code> function. It takes an address as a parameter, which is the result of memory allocation, i.e., the starting address of the memory to be freed. The function first uses this address as a key to search for the corresponding <code>alloc_info</code> structure in the <code>allocs</code> map. If it is not found, it simply returns because it means that this address has not been allocated. If it is found, the element is deleted, and the <code>update_statistics_del</code> function is called to update the statistics data. Finally, if global tracking is enabled, a message is also output, including this address and its size.</p> <p>While tracking and profiling memory allocation, we also need to track kernel-mode memory allocation and deallocation. In the Linux kernel, the <code>kmem_cache_alloc</code> function and the <code>kfree</code> function are used for kernel-mode memory allocation and deallocation, respectively.</p> <pre><code>SEC(\"tracepoint/kmem/kfree\")\nint memleak__kfree(void *ctx)\n{\nconst void *ptr;\nif (has_kfree()) {\nstruct trace_event_raw_kfree___x *args = ctx;\nptr = BPF_CORE_READ(args, ptr);\n} else {\nstruct trace_event_raw_kmem_free___x *args = ctx;\nptr = BPF_CORE_READ(args, ptr);\n}\nreturn gen_free_enter(ptr);\n}\n</code></pre> <p>The above code snippet defines a function <code>memleak__kfree</code>. This is a BPF program that will be executed when the <code>kfree</code> function is called in the kernel. First, the function checks if <code>kfree</code> exists. If it does, it reads the argument passed to the <code>kfree</code> function (i.e., the address of the memory block to be freed) and saves it in the variable <code>ptr</code>. Otherwise, it reads the argument passed to the <code>kmem_free</code> function (i.e., the address of the memory block to be freed) and saves it in the variable <code>ptr</code>. Then, the function calls the previously defined <code>gen_free_enter</code> function to handle the release of this memory block.</p> <pre><code>SEC(\"tracepoint/kmem/kmem_cache_alloc\")\nint memleak__kmem_cache_alloc(struct trace_event_raw_kmem_alloc *ctx)\n{\nif (wa_missing_free)\ngen_free_enter(ctx-&gt;ptr);\ngen_alloc_enter(ctx-&gt;bytes_alloc);\nreturn gen_alloc_exit2(ctx, (u64)(ctx-&gt;ptr));\n}\n</code></pre> <p>This code snippet defines a function <code>memleak__kmem_cache_alloc</code>. This is also a BPF program that will be executed when the <code>kmem_cache_alloc</code> function is called in the kernel. If the <code>wa_missing_free</code> flag is set, it calls the <code>gen_free_enter</code> function to handle possible missed release operations. Then, the function calls the <code>gen_alloc_enter</code> function to handle memory allocation and finally calls the <code>gen_alloc_exit2</code> function to record the allocation result.</p> <p>Both of these BPF programs use the <code>SEC</code> macro to define the corresponding tracepoints, so that they can be executed when the corresponding kernel functions are called. In the Linux kernel, a tracepoint is a static hook that can be inserted into the kernel to collect runtime kernel information. It is very useful for debugging and performance analysis.</p> <p>In the process of understanding this code, pay attention to the use of the <code>BPF_CORE_READ</code> macro. This macro is used to read kernel data in BPF programs. In BPF programs, we cannot directly access kernel memory and need to use such macros to safely read data.</p>"},{"location":"tutorials/16-memleak/#user-space-program","title":"User-Space Program","text":"<p>After understanding the BPF kernel part, let's switch to the user-space program. The user-space program works closely with the BPF kernel program. It is responsible for loading BPF programs into the kernel, setting up and managing BPF maps, and handling data collected from BPF programs. The user-space program is longer, but here we can briefly refer to its mount point.</p> <pre><code>int attach_uprobes(struct memleak_bpf *skel)\n{\nATTACH_UPROBE_CHECKED(skel, malloc, malloc_enter);\nATTACH_URETPROBE_CHECKED(skel, malloc, malloc_exit);\nATTACH_UPROBE_CHECKED(skel, calloc, calloc_enter);\nATTACH_URETPROBE_CHECKED(skel, calloc, calloc_exit);\nATTACH_UPROBE_CHECKED(skel, realloc, realloc_enter);\nATTACH_URETPROBE_CHECKED(skel, realloc, realloc_exit);\nATTACH_UPROBE_CHECKED(skel, mmap, mmap_enter);\nATTACH_URETPROBE_CHECKED(skel, mmap, mmap_exit);\nATTACH_UPROBE_CHECKED(skel, posix_memalign, posix_memalign_enter);\nATTACH_URETPROBE_CHECKED(skel, posix_memalign, posix_memalign_exit);\nATTACH_UPROBE_CHECKED(skel, memalign, memalign_enter);\nATTACH_URETPROBE_CHECKED(skel, memalign, memalign_exit);\nATTACH_UPROBE_CHECKED(skel, free, free_enter);\nATTACH_UPROBE_CHECKED(skel, munmap, munmap_enter);\n// the following probes are intentionally allowed to fail attachment\n// deprecated in libc.so bionic\nATTACH_UPROBE(skel, valloc, valloc_enter);\nATTACH_URETPROBE(skel, valloc, valloc_exit);\n// deprecated in libc.so bionic\nATTACH_UPROBE(skel, pvalloc, pvalloc_enter);\nATTACH_URETPROBE(skel, pvalloc, pvalloc_exit);\n// added in C11\nATTACH_UPROBE(skel, aligned_alloc, aligned_alloc_enter);\nATTACH_URETPROBE(skel, aligned_alloc, aligned_alloc_exit);\nreturn 0;\n}\n</code></pre> <p>In this code snippet, we see a function called <code>attach_uprobes</code> that mounts uprobes (user space probes) onto memory allocation and deallocation functions. In Linux, uprobes are a kernel mechanism that allows setting breakpoints at arbitrary locations in user space programs, enabling precise observation and control over the behavior of user space programs.</p> <p>Here, each memory-related function is traced using two uprobes: one at the entry (enter) of the function and one at the exit. Thus, every time these functions are called or return, a uprobes event is triggered, which in turn triggers the corresponding BPF program.</p> <p>In the actual implementation, we use two macros, <code>ATTACH_UPROBE</code> and <code>ATTACH_URETPROBE</code>, to attach uprobes and uretprobes (function return probes), respectively. Each macro takes three arguments: the skeleton of the BPF program (skel), the name of the function to monitor, and the name of the BPF program to trigger.</p> <p>These mount points include common memory allocation functions such as malloc, calloc, realloc, mmap, posix_memalign, memalign, free, and their corresponding exit points. Additionally, we also observe some possible allocation functions such as valloc, pvalloc, aligned_alloc, although they may not always exist.</p> <p>The goal of these mount points is to capture all possible memory allocation and deallocation events, allowing our memory leak detection tool to obtain as comprehensive data as possible. This approach enables us to track not only memory allocation and deallocation but also their contextual information such as call stacks and invocation counts, helping us to pinpoint and fix memory leak issues.</p> <p>Note that some memory allocation functions may not exist or may have been deprecated, such as valloc and pvalloc. Thus, their attachment may fail. In such cases, we allow for attachment failures, which do not prevent the program from executing. This is because we are more focused on mainstream and commonly used memory allocation functions, while these deprecated functions are often used less frequently in practical applications.</p> <p>Complete source code: https://github.com/eunomia-bpf/bpf-developer-tutorial/tree/main/src/16-memleak</p> <p>Reference: https://github.com/iovisor/bcc/blob/master/libbpf-tools/memleak.c</p>"},{"location":"tutorials/16-memleak/#compile-and-run","title":"Compile and Run","text":"<pre><code>$ make\n$ sudo ./memleak\nusing default object: libc.so.6\nusing page size: 4096\ntracing kernel: true\nTracing outstanding memory allocs...  Hit Ctrl-C to end\n[17:17:27] Top 10 stacks with outstanding allocations:\n1236992 bytes in 302 allocations from stack\n        0 [&lt;ffffffff812c8f43&gt;] &lt;null sym&gt;\n        1 [&lt;ffffffff812c8f43&gt;] &lt;null sym&gt;\n        2 [&lt;ffffffff812a9d42&gt;] &lt;null sym&gt;\n        3 [&lt;ffffffff812aa392&gt;] &lt;null sym&gt;\n        4 [&lt;ffffffff810df0cb&gt;] &lt;null sym&gt;\n        5 [&lt;ffffffff81edc3fd&gt;] &lt;null sym&gt;\n        6 [&lt;ffffffff82000b62&gt;] &lt;null sym&gt;\n...\n</code></pre>"},{"location":"tutorials/16-memleak/#summary","title":"Summary","text":"<p>Through this eBPF introductory tutorial, you have learned how to write a Memleak eBPF monitoring program to monitor memory leaks in real time. You have also learned about the application of eBPF in memory monitoring, how to write eBPF programs using the BPF API, create and use eBPF maps, and how to use eBPF tools to monitor and analyze memory leak issues. We have provided a detailed example to help you understand the execution flow and principles of eBPF code.</p> <p>You can visit our tutorial code repository at https://github.com/eunomia-bpf/bpf-developer-tutorial for more examples and complete tutorials.</p> <p>The next tutorial will further explore advanced features of eBPF, and we will continue to share more content related to eBPF development practices. We hope that this knowledge and skills will help you better understand and use eBPF to solve problems encountered in practical work.</p>"},{"location":"tutorials/17-biopattern/","title":"eBPF Getting Started Tutorial: Writing eBPF Program Biopattern: Statistical Random/Sequential Disk I/O","text":""},{"location":"tutorials/17-biopattern/#background","title":"Background","text":"<p>Biopattern can statistically count the ratio of random/sequential disk I/O.</p> <p>TODO</p>"},{"location":"tutorials/17-biopattern/#implementation-principle","title":"Implementation Principle","text":"<p>The ebpf code of Biopattern is implemented under the mount point tracepoint/block/block_rq_complete. After the disk completes an IO request, the program will pass through this mount point. Biopattern has an internal hash table with device number as the primary key. When the program passes through the mount point, Biopattern obtains the operation information and determines whether the current operation is random or sequential IO based on the previous operation record of the device in the hash table, and updates the operation count.</p>"},{"location":"tutorials/17-biopattern/#writing-ebpf-program","title":"Writing eBPF Program","text":"<p>TODO</p>"},{"location":"tutorials/17-biopattern/#summary","title":"Summary","text":"<p>Biopattern can show the ratio of random/sequential disk I/O, which is very helpful for developers to grasp the overall I/O situation.</p> <p>TODO</p>"},{"location":"tutorials/18-further-reading/","title":"More Reference Materials","text":"<p>TODO</p>"},{"location":"tutorials/19-lsm-connect/","title":"eBPF Getting Started Tutorial: Security Detection and Defense using LSM","text":"<p>eBPF (Extended Berkeley Packet Filter) is a powerful network and performance analysis tool widely used in the Linux kernel. eBPF allows developers to dynamically load, update, and run user-defined code without restarting the kernel or modifying the kernel source code. This feature enables eBPF to provide high flexibility and performance, making it widely applicable in network and system performance analysis. The same applies to eBPF applications in security, and this article will introduce how to use the eBPF LSM (Linux Security Modules) mechanism to implement a simple security check program.</p>"},{"location":"tutorials/19-lsm-connect/#background","title":"Background","text":"<p>LSM has been an official security framework in the Linux kernel since Linux 2.6, and security implementations based on it include SELinux and AppArmor. With the introduction of BPF LSM in Linux 5.7, system developers have been able to freely implement function-level security checks. This article provides an example of limiting access to a specific IPv4 address through the socket connect function using a BPF LSM program. (This demonstrates its high control precision.)</p>"},{"location":"tutorials/19-lsm-connect/#overview-of-lsm","title":"Overview of LSM","text":"<p>LSM (Linux Security Modules) is a framework in the Linux kernel that supports various computer security models. LSM predefines a set of hook points on critical paths related to Linux kernel security, decoupling the kernel from security modules. This allows different security modules to be loaded/unloaded in the kernel freely without modifying the existing kernel code, thus enabling them to provide security inspection features.</p> <p>In the past, using LSM mainly involved configuring existing security modules like SELinux and AppArmor or writing custom kernel modules. However, with the introduction of the BPF LSM mechanism in Linux 5.7, everything changed. Now, developers can write custom security policies using eBPF and dynamically load them into the LSM mount points in the kernel without configuring or writing kernel modules.</p> <p>Some of the hook points currently supported by LSM include:</p> <ul> <li>File open, creation, deletion, and movement;</li> <li>Filesystem mounting;</li> <li>Operations on tasks and processes;</li> <li>Operations on sockets (creating, binding sockets, sending and receiving messages, etc.);</li> </ul> <p>For more hook points, refer to lsm_hooks.h.</p>"},{"location":"tutorials/19-lsm-connect/#verifying-bpf-lsm-availability","title":"Verifying BPF LSM Availability","text":"<p>First, please confirm that your kernel version is higher than 5.7. Next, you can use the following command to check if BPF LSM support is enabled:</p> <pre><code>$ cat /boot/config-$(uname -r) | grep BPF_LSM\nCONFIG_BPF_LSM=y\n</code></pre> <p>If the output contains <code>CONFIG_BPF_LSM=y</code>, BPF LSM is supported. Provided that the above conditions are met, you can use the following command to check if the output includes the <code>bpf</code> option:</p> <pre><code>$ cat /sys/kernel/security/lsm\nndlock,lockdown,yama,integrity,apparmor\n</code></pre> <p>If the output does not include the <code>bpf</code> option (as in the example above), you can modify <code>/etc/default/grub</code>:</p> <pre><code>GRUB_CMDLINE_LINUX=\"lsm=ndlock,lockdown,yama,integrity,apparmor,bpf\"\n</code></pre> <p>Then, update the grub configuration using the <code>update-grub2</code> command (the corresponding command may vary depending on the system), and restart the system.</p>"},{"location":"tutorials/19-lsm-connect/#writing-ebpf-programs","title":"Writing eBPF Programs","text":"<pre><code>// lsm-connect.bpf.c\n#include \"vmlinux.h\"\n#include &lt;bpf/bpf_core_read.h&gt;\n#include &lt;bpf/bpf_helpers.h&gt;\n#include &lt;bpf/bpf_tracing.h&gt;\nchar LICENSE[] SEC(\"license\") = \"GPL\";\n#define EPERM 1\n#define AF_INET 2\nconst __u32 blockme = 16843009; // 1.1.1.1 -&gt; int\nSEC(\"lsm/socket_connect\")\nint BPF_PROG(restrict_connect, struct socket *sock, struct sockaddr *address, int addrlen, int ret)\n{\n// Satisfying \"cannot override a denial\" rule\nif (ret != 0)\n{\nreturn ret;\n}\n// Only IPv4 in this example\nif (address-&gt;sa_family != AF_INET)\n{\nreturn 0;\n}\n// Cast the address to an IPv4 socket address\nstruct sockaddr_in *addr = (struct sockaddr_in *)address;\n// Where do you want to go?\n__u32 dest = addr-&gt;sin_addr.s_addr;\nbpf_printk(\"lsm: found connect to %d\", dest);\nif (dest == blockme)\n{\nbpf_printk(\"lsm: blocking %d\", dest);\nreturn -EPERM;\n}\nreturn 0;\n}\n</code></pre> <p>This is eBPF code implemented in C on the kernel side. It blocks all connection operations through a socket to 1.1.1.1. The following information is included:</p> <ul> <li>The <code>SEC(\"lsm/socket_connect\")</code> macro indicates the expected mount point for this program.</li> <li>The program is defined by the <code>BPF_PROG</code> macro (see tools/lib/bpf/bpf_tracing.h for details).</li> <li><code>restrict_connect</code> is the program name required by the <code>BPF_PROG</code> macro.</li> <li><code>ret</code> is the return value of the LSM check program (potential) before the current function on this mount point.</li> </ul> <p>The overall idea of the program is not difficult to understand:</p> <ul> <li>First, if the return value of other security check functions is non-zero (failed), there is no need to check further and the connection is rejected.</li> <li>Next, it determines whether it is an IPv4 connection request and compares the address being connected to with 1.1.1.1.</li> <li>If the requested address is 1.1.1.1, the connection is blocked; otherwise, the connection is allowed.</li> </ul> <p>During the execution of the program, all connection operations through a socket will be output to <code>/sys/kernel/debug/tracing/trace_pipe</code>.</p>"},{"location":"tutorials/19-lsm-connect/#compilation-and-execution","title":"Compilation and Execution","text":"<p>Compile using a container:</p> <pre><code>docker run -it -v `pwd`/:/src/ ghcr.io/eunomia-bpf/ecc-`uname -m`:latest\n</code></pre> <p>Or compile using <code>ecc</code>:</p> <pre><code>$ ecc lsm-connect.bpf.c\nCompiling bpf object...\nPacking ebpf object and config into package.json...\n</code></pre> <p>And run using <code>ecli</code>:</p> <pre><code>sudo ecli run package.json\n</code></pre> <p>Next, open another terminal and try to access 1.1.1.1:</p> <pre><code>$ ping 1.1.1.1\nping: connect: Operation not permitted\n$ curl 1.1.1.1\ncurl: (7) Couldn't connect to server\n$ wget 1.1.1.1\n--2023-04-23 08:41:18--  (try: 2)  http://1.1.1.1/\nConnecting to 1.1.1.1:80... failed: Operation not permitted.\nRetrying.\n</code></pre> <p>At the same time, we can view the output of <code>bpf_printk</code>:</p> <pre><code>$ sudo cat /sys/kernel/debug/tracing/trace_pipe\n            ping-7054    [000] d...1  6313.430872: bpf_trace_printk: lsm: found connect to 16843009\n            ping-7054    [000] d...1  6313.430874: bpf_trace_printk: lsm: blocking 16843009\n            curl-7058    [000] d...1  6316.346582: bpf_trace_printk: lsm: found connect to 16843009\n            curl-7058    [000] d...1  6316.346584: bpf_trace_printk: lsm: blocking 16843009\".```\nwget-7061    [000] d...1  6318.800698: bpf_trace_printk: lsm: found connect to 16843009\nwget-7061    [000] d...1  6318.800700: bpf_trace_printk: lsm: blocking 16843009\n</code></pre> <p>Complete source code: https://github.com/eunomia-bpf/bpf-developer-tutorial/tree/main/src/19-lsm-connect</p>"},{"location":"tutorials/19-lsm-connect/#summary","title":"Summary","text":"<p>This article introduces how to use BPF LSM to restrict access to a specific IPv4 address through a socket. We can enable the LSM BPF mount point by modifying the GRUB configuration file. In the eBPF program, we define functions using the <code>BPF_PROG</code> macro and specify the mount point using the <code>SEC</code> macro. In the implementation of the function, we follow the principle of \"cannot override a denial\" in the LSM security-checking module and restrict the socket connection request based on the destination address of the request.</p> <p>If you want to learn more about eBPF knowledge and practices, you can visit our tutorial code repository at https://github.com/eunomia-bpf/bpf-developer-tutorial for more examples and complete tutorials.</p>"},{"location":"tutorials/19-lsm-connect/#references","title":"References","text":"<ul> <li>https://github.com/leodido/demo-cloud-native-ebpf-day</li> <li>https://aya-rs.dev/book/programs/lsm/#writing-lsm-bpf-program</li> </ul>"},{"location":"tutorials/2-kprobe-unlink/","title":"eBPF Beginner's Development Practice Tutorial 2: Using kprobe to Monitor the unlink System Call in eBPF","text":"<p>eBPF (Extended Berkeley Packet Filter) is a powerful network and performance analysis tool on the Linux kernel. It allows developers to dynamically load, update, and run user-defined code at runtime.</p> <p>This article is the second part of the eBPF beginner's development practice tutorial, focusing on using kprobe to capture the unlink system call in eBPF. The article will first explain the basic concepts and technical background of kprobes, and then introduce how to use kprobe to capture the unlink system call in eBPF.</p>"},{"location":"tutorials/2-kprobe-unlink/#background-of-kprobes-technology","title":"Background of kprobes Technology","text":"<p>During the debugging process of the kernel or modules, developers often need to know whether certain functions are called, when they are called, whether the execution is correct, and what the input and return values of the functions are. A simple approach is to add log print information to the corresponding functions in the kernel code. However, this approach often requires recompiling the kernel or modules, restarting the device, etc., which is complex and may disrupt the original code execution process.</p> <p>By using the kprobes technology, users can define their own callback functions and dynamically insert probes into almost all functions in the kernel or modules (some functions cannot be probed, such as the kprobes' own implementation functions, which will be explained in detail later). When the kernel execution flow reaches the specified probe function, it will invoke the callback function, allowing the user to collect the desired information. The kernel will then return to the normal execution flow. If the user has collected sufficient information and no longer needs to continue probing, the probes can be dynamically removed. Therefore, the kprobes technology has the advantages of minimal impact on the kernel execution flow and easy operation.</p> <p>The kprobes technology includes three detection methods: kprobe, jprobe, and kretprobe. First, kprobe is the most basic detection method and serves as the basis for the other two. It allows probes to be placed at any position (including within a function). It provides three callback modes for probes: <code>pre_handler</code>, <code>post_handler</code>, and <code>fault_handler</code>. The <code>pre_handler</code> function is called before the probed instruction is executed, the <code>post_handler</code> is called after the probed instruction is completed (note that it is not the probed function), and the <code>fault_handler</code> is called when a memory access error occurs. The jprobe is based on kprobe and is used to obtain the input values of the probed function. Finally, as the name suggests, kretprobe is also based on kprobe and is used to obtain the return values of the probed function.</p> <p>The kprobes technology is not only implemented through software but also requires support from the hardware architecture. This involves CPU exception handling and single-step debugging techniques. The former is used to make the program's execution flow enter the user-registered callback function, and the latter is used to single-step execute the probed instruction. Therefore, not all architectures support kprobes. Currently, kprobes technology supports various architectures, including i386, x86_64, ppc64, ia64, sparc64, arm, ppc, and mips (note that some architecture implementations may not be complete, see the kernel's Documentation/kprobes.txt for details).</p> <p>Features and Usage Restrictions of kprobes:</p> <ol> <li>kprobes allows multiple kprobes to be registered at the same probe position, but jprobe currently does not support this. It is also not allowed to use other jprobe callback functions or the <code>post_handler</code> callback function of kprobe as probe points.</li> <li>In general, any function in the kernel can be probed, including interrupt handlers. However, the functions used to implement kprobes themselves in kernel/kprobes.c and arch/*/kernel/kprobes.c are not allowed to be probed. Additionally, <code>do_page_fault</code> and <code>notifier_call_chain</code> are also not allowed.</li> <li>If an inline function is used as a probe point, kprobes may not be able to guarantee that probe points are registered for all instances of that function. Since gcc may automatically optimize certain functions as inline functions, the desired probing effect may not be achieved.</li> <li>The callback function of a probe point may modify the runtime context of the probed function, such as by modifying the kernel's data structure or saving register information before triggering the prober in the <code>struct pt_regs</code> structure. Therefore, kprobes can be used to install bug fixes or inject fault testing code.</li> <li>kprobes avoids calling the callback function of another probe point again when processing the probe point function. For example, if a probe point is registered on the <code>printk()</code> function and the callback function may call <code>printk()</code> again, the callback for the <code>printk</code> probe point will not be triggered again. Only the <code>nmissed</code> field in the <code>kprobe</code> structure will be incremented.</li> <li>mutex locks and dynamic memory allocation are not used in the registration and removal process of kprobes.</li> </ol> <p>format: markdown7. During the execution of kprobes callback functions, kernel preemption is disabled, and it may also be executed with interrupts disabled, which depends on the CPU architecture. Therefore, regardless of the situation, do not call functions that will give up the CPU in the callback function (such as semaphore, mutex lock, etc.); 8. kretprobe is implemented by replacing the return address with the pre-defined trampoline address, so stack backtraces and gcc inline function <code>__builtin_return_address()</code> will return the address of the trampoline instead of the actual return address of the probed function; 9. If the number of function calls and return calls of a function are unequal, registering kretprobe on such a function may not achieve the expected effect, for example, the <code>do_exit()</code> function will have problems, while the <code>do_execve()</code> function and <code>do_fork()</code> function will not; 10. When entering and exiting a function, if the CPU is running on a stack that does not belong to the current task, registering kretprobe on that function may have unpredictable consequences. Therefore, kprobes does not support registering kretprobe for the <code>__switch_to()</code> function under the X86_64 architecture and will directly return <code>-EINVAL</code>.</p>"},{"location":"tutorials/2-kprobe-unlink/#kprobe-example","title":"kprobe Example","text":"<p>The complete code is as follows:</p> <pre><code>#include \"vmlinux.h\"\n#include &lt;bpf/bpf_helpers.h&gt;\n#include &lt;bpf/bpf_tracing.h&gt;\n#include &lt;bpf/bpf_core_read.h&gt;\nchar LICENSE[] SEC(\"license\") = \"Dual BSD/GPL\";\nSEC(\"kprobe/do_unlinkat\")\nint BPF_KPROBE(do_unlinkat, int dfd, struct filename *name)\n{\npid_t pid;\nconst char *filename;\npid = bpf_get_current_pid_tgid() &gt;&gt; 32;\nfilename = BPF_CORE_READ(name, name);\nbpf_printk(\"KPROBE ENTRY pid = %d, filename = %s\\n\", pid, filename);\nreturn 0;\n}\nSEC(\"kretprobe/do_unlinkat\")\nint BPF_KRETPROBE(do_unlinkat_exit, long ret)\n{\npid_t pid;\npid = bpf_get_current_pid_tgid() &gt;&gt; 32;\nbpf_printk(\"KPROBE EXIT: pid = %d, ret = %ld\\n\", pid, ret);\nreturn 0;\n}\n</code></pre> <p>This code is a simple eBPF program used to monitor and capture the unlink system call executed in the Linux kernel. The unlink system call is used to delete a file. This eBPF program traces this system call by placing hooks at the entry and exit points of the <code>do_unlinkat</code> function using a kprobe (kernel probe).</p> <p>First, we import necessary header files such as vmlinux.h, bpf_helpers.h, bpf_tracing.h, and bpf_core_read.h. Then, we define a license to allow the program to run in the kernel.</p> <pre><code>#include \"vmlinux.h\"\n#include &lt;bpf/bpf_helpers.h&gt;\n#include &lt;bpf/bpf_tracing.h&gt;\n#include &lt;bpf/bpf_core_read.h&gt;\nchar LICENSE[] SEC(\"license\") = \"Dual BSD/GPL\";\n</code></pre> <p>Next, we define a kprobe named <code>BPF_KPROBE(do_unlinkat)</code> which gets triggered when the <code>do_unlinkat</code> function is entered. It takes two parameters: <code>dfd</code> (file descriptor) and <code>name</code> (filename structure pointer). In this kprobe, we retrieve the PID (process identifier) of the current process and then read the filename. Finally, we use the <code>bpf_printk</code> function to print the PID and filename in the kernel log.</p> <pre><code>SEC(\"kprobe/do_unlinkat\")\nint BPF_KPROBE(do_unlinkat, int dfd, struct filename *name)\n{\npid_t pid;\nconst char *filename;\npid = bpf_get_current_pid_tgid() &gt;&gt; 32;\nfilename = BPF_CORE_READ(name, name);\".```\nbpf_printk(\"KPROBE ENTRY pid = %d, filename = %s\\n\", pid, filename);\nreturn 0;\n}\n</code></pre> <p>Next, we define a kretprobe named <code>BPF_KRETPROBE(do_unlinkat_exit)</code> that will be triggered when exiting the <code>do_unlinkat</code> function. The purpose of this kretprobe is to capture the return value (<code>ret</code>) of the function. We again obtain the PID of the current process and use the <code>bpf_printk</code> function to print the PID and return value in the kernel log.</p> <pre><code>SEC(\"kretprobe/do_unlinkat\")\nint BPF_KRETPROBE(do_unlinkat_exit, long ret)\n{\npid_t pid;\npid = bpf_get_current_pid_tgid() &gt;&gt; 32;\nbpf_printk(\"KPROBE EXIT: pid = %d, ret = %ld\\n\", pid, ret);\nreturn 0;\n}\n</code></pre> <p>eunomia-bpf is an open-source eBPF dynamic loading runtime and development toolchain that combines with Wasm. Its goal is to simplify the development, build, distribution, and execution of eBPF programs. You can refer to https://github.com/eunomia-bpf/eunomia-bpf to download and install the ecc compiler toolchain and ecli runtime.</p> <p>To compile this program, use the ecc tool:</p> <pre><code>$ ecc kprobe-link.bpf.c\nCompiling bpf object...\nPacking ebpf object and config into package.json...\n</code></pre> <p>Then run:</p> <pre><code>sudo ecli run package.json\n</code></pre> <p>In another window:</p> <pre><code>touch test1\nrm test1\ntouch test2\nrm test2\n</code></pre> <p>You should see kprobe demo output similar to the following in the /sys/kernel/debug/tracing/trace_pipe file:</p> <pre><code>$ sudo cat /sys/kernel/debug/tracing/trace_pipe\n              rm-9346    [005] d..3  4710.951696: bpf_trace_printk: KPROBE ENTRY pid = 9346, filename = test1\n              rm-9346    [005] d..4  4710.951819: bpf_trace_printk: KPROBE EXIT: ret = 0\nrm-9346    [005] d..3  4710.951852: bpf_trace_printk: KPROBE ENTRY pid = 9346, filename = test2\n              rm-9346    [005] d..4  4710.951895: bpf_trace_printk: KPROBE EXIT: ret = 0\n</code></pre>"},{"location":"tutorials/2-kprobe-unlink/#summary","title":"Summary","text":"<p>In this article's example, we learned how to use eBPF's kprobe and kretprobe to capture the unlink system call. For more examples and detailed development guides, please refer to the official documentation of eunomia-bpf: https://github.com/eunomia-bpf/eunomia-bpf</p> <p>This article is the second part of the introductory eBPF development tutorial. The next article will explain how to use fentry to monitor and capture the unlink system call in eBPF.</p> <p>If you'd like to learn more about eBPF knowledge and practices, you can visit our tutorial code repository at https://github.com/eunomia-bpf/bpf-developer-tutorial for more examples and complete tutorials.</p>"},{"location":"tutorials/20-tc/","title":"eBPF Introductory Practice Tutorial 20: Use eBPF for tc Traffic Control","text":""},{"location":"tutorials/20-tc/#background","title":"Background","text":"<p>Linux's Traffic Control (tc) subsystem has been present in the kernel for many years. Similar to the relationship between iptables and netfilter, tc includes a user-space tc program and a kernel-level traffic control framework. It is mainly used to control the sending and receiving of packets in terms of rate, sequence, and other aspects. Starting from Linux 4.1, tc has added some new attachment points and supports loading eBPF programs as filters onto these attachment points.</p>"},{"location":"tutorials/20-tc/#overview-of-tc","title":"Overview of tc","text":"<p>From the protocol stack perspective, tc is located at the link layer. Its position has already completed the allocation of sk_buff and is later than xdp. In order to control the sending and receiving of packets, tc uses a queue structure to temporarily store and organize packets. In the tc subsystem, the corresponding data structure and algorithm control mechanism are abstracted as qdisc (Queueing discipline). It exposes two callback interfaces for enqueuing and dequeuing packets externally, and internally hides the implementation of queuing algorithms. In qdisc, we can implement complex tree structures based on filters and classes. Filters are mounted on qdisc or class to implement specific filtering logic, and the return value determines whether the packet belongs to a specific class.</p> <p>When a packet reaches the top-level qdisc, its enqueue interface is called, and the mounted filters are executed one by one until a filter matches successfully. Then the packet is sent to the class pointed to by that filter and enters the qdisc processing process configured by that class. The tc framework provides the so-called classifier-action mechanism, that is, when a packet matches a specific filter, the action mounted by that filter is executed to process the packet, implementing a complete packet classification and processing mechanism.</p> <p>The existing tc provides eBPF with the direct-action mode, which allows an eBPF program loaded as a filter to return values such as <code>TC_ACT_OK</code> as tc actions, instead of just returning a classid like traditional filters and handing over the packet processing to the action module. Now, eBPF programs can be mounted on specific qdiscs to perform packet classification and processing actions.</p>"},{"location":"tutorials/20-tc/#writing-ebpf-programs","title":"Writing eBPF Programs","text":"<p><pre><code>#include &lt;vmlinux.h&gt;\n#include &lt;bpf/bpf_endian.h&gt;\n#include &lt;bpf/bpf_helpers.h&gt;\n#include &lt;bpf/bpf_tracing.h&gt;\n#define TC_ACT_OK 0\n#define ETH_P_IP 0x0800 /* Internet Protocol packet */\n/// @tchook {\"ifindex\":1, \"attach_point\":\"BPF_TC_INGRESS\"}\n/// @tcopts {\"handle\":1, \"priority\":1}\nSEC(\"tc\")\nint tc_ingress(struct __sk_buff *ctx)\n{\nvoid *data_end = (void *)(__u64)ctx-&gt;data_end;\nvoid *data = (void *)(__u64)ctx-&gt;data;\nstruct ethhdr *l2;\nstruct iphdr *l3;\nif (ctx-&gt;protocol != bpf_htons(ETH_P_IP))\nreturn TC_ACT_OK;\nl2 = data;\nif ((void *)(l2 + 1) &gt; data_end)\nreturn TC_ACT_OK;\nl3 = (struct iphdr *)(l2 + 1);\nif ((void *)(l3 + 1) &gt; data_end)\nreturn TC_ACT_OK;\nbpf_printk(\"Got IP packet: tot_len: %d, ttl: %d\", bpf_ntohs(l3-&gt;tot_len), l3-&gt;ttl);\nreturn TC_ACT_OK;\n}\nchar __license[] SEC(\"license\") = \"GPL\";\n</code></pre> This code defines an eBPF program that can capture and process packets through Linux TC (Transmission Control). In this program, we limit it to capture only IPv4 protocol packets, and then print out the total length and Time-To-Live (TTL) value of the packet using the bpf_printk function.Here is the translated text:</p> <p>\" What needs to be noted is that we use some BPF library functions in the code, such as the functions bpf_htons and bpf_ntohs, which are used for conversion between network byte order and host byte order. In addition, we also use some comments to provide additional points and option information for TC. For example, at the beginning of this code, we use the following comments:</p> <pre><code>/// @tchook {\"ifindex\":1, \"attach_point\":\"BPF_TC_INGRESS\"}\n/// @tcopts {\"handle\":1, \"priority\":1}\n</code></pre> <p>These comments tell TC to attach the eBPF program to the ingress attachment point of the network interface, and specify the values of the handle and priority options. You can refer to the introduction in patchwork for tc-related APIs in libbpf.</p> <p>In summary, this code implements a simple eBPF program that captures packets and prints out their information.</p>"},{"location":"tutorials/20-tc/#compilation-and-execution","title":"Compilation and Execution","text":"<p>Compile using a container:</p> <pre><code>docker run -it -v `pwd`/:/src/ ghcr.io/eunomia-bpf/ecc-`uname -m`:latest\n</code></pre> <p>Or compile using <code>ecc</code>:</p> <pre><code>$ ecc tc.bpf.c\nCompiling bpf object...\nPacking ebpf object and config into package.json...\n</code></pre> <p>And run using <code>ecli</code>:</p> <pre><code>sudo ecli run ./package.json\n</code></pre> <p>You can view the output of the program in the following way:</p> <pre><code>$ sudo cat /sys/kernel/debug/tracing/trace_pipe\n            node-1254811 [007] ..s1 8737831.671074: 0: Got IP packet: tot_len: 79, ttl: 64\n            sshd-1254728 [006] ..s1 8737831.674334: 0: Got IP packet: tot_len: 79, ttl: 64\n            sshd-1254728 [006] ..s1 8737831.674349: 0: Got IP packet: tot_len: 72, ttl: 64\n            node-1254811 [007] ..s1 8737831.674550: 0: Got IP packet: tot_len: 71, ttl: 64\n</code></pre>"},{"location":"tutorials/20-tc/#summary","title":"Summary","text":"<p>This article introduces how to mount eBPF type filters to the TC traffic control subsystem to achieve queuing processing of link layer packets. Based on the solution provided by eunomia-bpf to pass parameters to libbpf through comments, we can mount our own tc BPF program to the target network device with specified options and use the sk_buff structure of the kernel to filter and process packets.</p> <p>If you want to learn more about eBPF knowledge and practice, you can visit our tutorial code repository https://github.com/eunomia-bpf/bpf-developer-tutorial for more examples and complete tutorials.</p>"},{"location":"tutorials/20-tc/#references","title":"References","text":"<ul> <li>http://just4coding.com/2022/08/05/tc/</li> <li>https://arthurchiao.art/blog/understanding-tc-da-mode-zh/ \"</li> </ul>"},{"location":"tutorials/21-xdp/","title":"eBPF Beginner Tutorial 21: Programmable Packet Processing with XDP","text":""},{"location":"tutorials/21-xdp/#background","title":"Background","text":"<p>XDP (eXpress Data Path) is an emerging scheme in the Linux kernel for programmable packet processing that bypasses the kernel. Compared to cBPF, XDP operates at a much lower level, residing within the network device driver's soft interrupt processing, even before the allocation of the <code>skb_buff</code> structure. Thus, eBPF programs mounted on XDP are suitable for many simple yet frequent packet processing operations (like defending against DoS attacks), achieving high performance (24Mpps/core).</p>"},{"location":"tutorials/21-xdp/#overview-of-xdp","title":"Overview of XDP","text":"<p>XDP isn't the first system supporting programmable packet processing. Before it, kernel-bypass solutions like DPDK (Data Plane Development Kit) could even achieve higher performance. The idea behind such solutions is to completely bypass the kernel and let user-level network applications take over network devices, eliminating the overhead of transitioning between user and kernel mode. However, this approach has inherent drawbacks:</p> <ul> <li>Inability to integrate with mature network modules in the kernel, necessitating reimplementation in user space.</li> <li>Breaking the kernel's security boundary, rendering many kernel-provided networking tools unusable.</li> <li>When interacting with conventional sockets, packets must be reinjected into the kernel from user space.</li> <li>Requires dedicating one or more separate CPUs for packet processing.</li> </ul> <p>Additionally, using kernel modules and hook points in the kernel's network protocol stack is another approach. However, the former entails extensive kernel modifications with high error costs, while the latter, due to its position in the whole packet processing workflow, isn't as efficient.</p> <p>In summary, XDP + eBPF presents a more robust approach for programmable packet processing. It balances the strengths and weaknesses of the aforementioned solutions, achieving high performance without altering the kernel's packet processing workflow too much. Moreover, the eBPF virtual machine isolates and constrains user-defined packet processing routines, enhancing security.</p>"},{"location":"tutorials/21-xdp/#writing-an-ebpf-program","title":"Writing an eBPF Program","text":"<pre><code>#include \"vmlinux.h\"\n#include &lt;bpf/bpf_helpers.h&gt;\n/// @ifindex 1\n/// @flags 0\n/// @xdpopts {\"old_prog_fd\":0}\nSEC(\"xdp\")\nint xdp_pass(struct xdp_md* ctx) {\nvoid* data = (void*)(long)ctx-&gt;data;\nvoid* data_end = (void*)(long)ctx-&gt;data_end;\nint pkt_sz = data_end - data;\nbpf_printk(\"packet size is %d\", pkt_sz);\nreturn XDP_PASS;\n}\nchar __license[] SEC(\"license\") = \"GPL\";\n</code></pre> <p>This is a kernel-side eBPF code written in C. It captures all packets passing through the target network device using XDP, calculates their size, and outputs it to <code>trace_pipe</code>.</p> <p>It's worth noting the following annotations in the code:</p> <pre><code>/// @ifindex 1\n/// @flags 0\n/// @xdpopts {\"old_prog_fd\":0}\n</code></pre> <p>This functionality is provided by eunomia-bpf, which allows these annotations to inform the eunomia-bpf loader about the desired target network device number, mounting flags, and options for this XDP program.</p> <p>These variables are based on the API provided by libbpf. Detailed information about the interface can be viewed here.</p> <p>The <code>SEC(\"xdp\")</code> macro indicates the type of the BPF program, while <code>ctx</code> is the execution context of this BPF program for packet processing.</p> <p>At the end of the program, we return <code>XDP_PASS</code>, signaling that our XDP program will deliver packets passing through the target network device to the kernel's network protocol stack as usual. For more on XDP actions, see XDP actions.</p>"},{"location":"tutorials/21-xdp/#compilation-and-execution","title":"Compilation and Execution","text":"<p>To compile using a container:</p> <pre><code>docker run -it -v `pwd`/:/src/ ghcr.io/eunomia-bpf/ecc-`uname -m`:latest\n</code></pre> <p>Or compile with <code>ecc</code>:</p> <pre><code>$ ecc xdp.bpf.c\nCompiling bpf object...\nPacking ebpf object and config into package.json...\n</code></pre> <p>Then, run with <code>ecli</code>:</p> <pre><code>sudo ecli run package.json\n</code></pre> <p>To view the program's output:</p> <pre><code>$ sudo cat /sys/kernel/tracing/trace_pipe\n            node-1939    [000] d.s11  1601.190413: bpf_trace_printk: packet size is 177\n            node-1939    [000] d.s11  1601.190479: bpf_trace_printk: packet size is 66\n     ksoftirqd/1-19      [001] d.s.1  1601.237507: bpf_trace_printk: packet size is 66\n            node-1939    [000] d.s11  1601.275860: bpf_trace_printk: packet size is 344\n</code></pre>"},{"location":"tutorials/21-xdp/#conclusion","title":"Conclusion","text":"<p>This article introduces how to use XDP to process packets passing through a specific network device. With eunomia-bpf's annotation-based approach for passing parameters to libbpf, we can mount our custom XDP BPF program onto the target device with specified options. This allows packet processing even before they enter the kernel's network protocol stack, achieving high-performance programmable packet processing.</p> <p>For those interested in further exploring eBPF, visit our tutorial code repository at https://github.com/eunomia-bpf/bpf-developer-tutorial for more examples and a comprehensive guide.</p>"},{"location":"tutorials/21-xdp/#references","title":"References","text":"<ul> <li>http://arthurchiao.art/blog/xdp-paper-acm-2018-zh/</li> <li>http://arthurchiao.art/blog/linux-net-stack-implementation-rx-zh/</li> <li>https://github.com/xdp-project/xdp-tutorial/tree/master/basic01-xdp-pass</li> </ul>"},{"location":"tutorials/22-android/","title":"Using eBPF Programs on Android","text":"<p>This article mainly documents the author's exploration process, results, and issues encountered while testing the level of support for CO-RE technology based on the libbpf library on high version Android kernels in the Android Studio Emulator. The test was conducted by building a Debian environment in the Android Shell environment and attempting to build the eunomia-bpf toolchain and run its test cases based on this.</p>"},{"location":"tutorials/22-android/#background","title":"Background","text":"<p>As of now (2023-04), Android has not provided good support for dynamic loading of eBPF programs. Both the compiler distribution scheme represented by bcc and the CO-RE scheme based on btf and libbpf rely heavily on Linux environment support and cannot run well on the Android system.[^WeiShu]</p> <p>However, there have been some successful cases of trying eBPF on the Android platform. In addition to the solution provided by Google to modify <code>Android.bp</code> to build and mount eBPF programs with the entire system[^Google], some people have proposed building a Linux environment based on the Android kernel and running the eBPF toolchain using this approach, and have developed related tools.</p> <p>Currently available information mostly focuses on the testing of bcc and bpftrace toolchains based on the adeb/eadb sandbox built on the Android kernel, with less testing work on the CO-RE scheme. There is more reference material available for using the bcc tool on Android, such as:</p> <ul> <li>SeeFlowerX: https://blog.seeflower.dev/category/eBPF/</li> <li>evilpan: https://bbs.kanxue.com/thread-271043.htm</li> </ul> <p>The main idea is to use chroot to run a Debian image on the Android kernel and build the entire bcc toolchain within it in order to use eBPF tools. The same principle applies to using bpftrace.</p> <p>In fact, higher versions of the Android kernel already support the btf option, which means that the emerging CO-RE technology in the eBPF field should also be applicable to Linux systems based on the Android kernel. This article will test and run eunomia-bpf in the emulator environment based on this.</p> <p>eunomia-bpf is an open-source project that combines libbpf and WebAssembly technology, aiming to simplify the writing, compilation, and deployment of eBPF programs. This project can be seen as a practical way of implementing CO-RE, with libbpf as its core dependency. It is believed that the testing work of eunomia-bpf can provide reference for other CO-RE schemes.</p>"},{"location":"tutorials/22-android/#test-environment","title":"Test Environment","text":"<ul> <li>Android Emulator (Android Studio Flamingo | 2022.2.1)</li> <li>AVD: Pixel 6</li> <li>Android Image: Tiramisu Android 13.0 x86_64 (5.15.41-android13-8-00055-g4f5025129fe8-ab8949913)</li> </ul>"},{"location":"tutorials/22-android/#environment-setupseeflowerx","title":"Environment Setup[^SeeFlowerX]","text":"<ol> <li>Obtain <code>debianfs-amd64-full.tar.gz</code> from the releases page of the eadb repository as the rootfs of the Linux environment. Also, get the <code>assets</code> directory from this project to build the environment.</li> <li>Configure and start the Android Virtual Device in the Android Studio Device Manager.</li> <li>Push <code>debianfs-amd64-full.tar.gz</code> and the <code>assets</code> directory to the AVD using the adb tool from the Android Studio SDK:</li> <li><code>./adb push debianfs-amd64-full.tar.gz /data/local/tmp/deb.tar.gz</code></li> <li><code>./adb push assets /data/local/tmp/assets</code></li> <li>Use adb to enter the Android shell environment and obtain root permissions:</li> <li><code>./adb shell</code></li> <li><code>su</code></li> <li>Build and enter the debian environment in the Android shell:</li> <li><code>mkdir -p /data/eadb</code></li> <li><code>mv /data/local/tmp/assets/* /data/eadb</code></li> <li><code>mv /data/local/tmp/deb.tar.gz /data/eadb/deb.tar.gz</code>+ <code>rm -r /data/local/tmp/assets</code></li> <li><code>chmod +x /data/eadb/device-*</code></li> <li><code>/data/eadb/device-unpack</code></li> <li><code>/data/eadb/run /data/eadb/debian</code></li> </ol> <p>At this point, the Linux environment required for testing eBPF has been set up. In addition, in the Android shell (before entering debian), you can use <code>zcat /proc/config.gz</code> in conjunction with <code>grep</code> to view kernel compilation options.</p> <p>Currently, the debian environment packaged by eadb has a low version of libc and lacks many tool dependencies. Additionally, due to different kernel compilation options, some eBPF features may not be available.</p>"},{"location":"tutorials/22-android/#build-tools","title":"Build Tools","text":"<p>Clone the eunomia-bpf repository into the local debian environment. For the specific build process, refer to the repository's build.md. In this test, I used the <code>ecc</code> compilation method to generate the <code>package.json</code>. Please refer to the repository page for the build and usage instructions for this tool.</p> <p>During the build process, you may need to manually install tools such as <code>curl</code>, <code>pkg-config</code>, <code>libssl-dev</code>, etc.</p>"},{"location":"tutorials/22-android/#results","title":"Results","text":"<p>Some eBPF programs can be successfully executed on Android, but there are also some applications that cannot be executed successfully for various reasons.</p>"},{"location":"tutorials/22-android/#success-cases","title":"Success Cases","text":""},{"location":"tutorials/22-android/#bootstrap","title":"bootstrap","text":"<p>The output of running is as follows:</p> <pre><code>TIME     PID     PPID    EXIT_CODE  DURATION_NS  COMM    FILENAME  EXIT_EVENT\n09:09:19  10217  479     0          0            sh      /system/bin/sh 0\n09:09:19  10217  479     0          0            ps      /system/bin/ps 0\n09:09:19  10217  479     0          54352100     ps                1\n09:09:21  10219  479     0          0            sh      /system/bin/sh 0\n09:09:21  10219  479     0          0            ps      /system/bin/ps 0\n09:09:21  10219  479     0          44260900     ps                1\n</code></pre>"},{"location":"tutorials/22-android/#tcpstates","title":"tcpstates","text":"<p>After starting monitoring, download a web page using <code>wget</code> in the Linux environment:</p> <pre><code>TIME     SADDR   DADDR   SKADDR  TS_US   DELTA_US  PID     OLDSTATE  NEWSTATE  FAMILY  SPORT   DPORT   TASK\n09:07:46  0x4007000200005000000000000f02000a 0x5000000000000f02000a8bc53f77 18446635827774444352 3315344998 0 10115 7 2 2 0 80 wget\n09:07:46  0x40020002d98e50003d99f8090f02000a 0xd98e50003d99f8090f02000a8bc53f77 18446635827774444352 3315465870 120872 0 2 1 2 55694 80 swapper/0\n09:07:46  0x40010002d98e50003d99f8090f02000a 0xd98e50003d99f8090f02000a8bc53f77 18446635827774444352 3315668799 202929 10115 1 4 2 55694 80 wget\n09:07:46  0x40040002d98e50003d99f8090f02000a 0xd98e50003d99f8090f02000a8bc53f77 18446635827774444352 3315670037 1237 0 4 5 2 55694 80 swapper/0\n09:07:46  0x40050002000050003d99f8090f02000a 0x50003d99f8090f02000a8bc53f77 18446635827774444352 3315670225 188 0 5 7 2 55694 80 swapper/0\n09:07:47  0x400200020000bb01565811650f02000a 0xbb01565811650f02000a6aa0d9ac 18446635828348806592 3316433261 0 2546 2 7 2 49970 443 ChromiumNet\n09:07:47  0x400200020000bb01db794a690f02000a 0xbb01db794a690f02000aea2afb8e 18446635827774427776 3316535591 0 1469 2 7 2 37386 443 ChromiumNet\n</code></pre> <p>Start the detection and open the Chrome browser in the Android Studio simulation interface to access the Baidu page:</p> <pre><code>TIME     SADDR   DADDR   SKADDR  TS_US   DELTA_US  PID     OLDSTATE  NEWSTATE  FAMILY  SPORT   DPORT   TASK\n07:46:58  0x400700020000bb01000000000f02000a 0xbb01000000000f02000aeb6f2270 18446631020066638144 192874641 0 3305 7 2 2 0 443 NetworkService\n07:46:58  0x40020002d28abb01494b6ebe0f02000a 0xd28abb01494b6ebe0f02000aeb6f2270 18446631020066638144 192921938 47297 3305 2 1 2 53898 443 NetworkService\n07:46:58  0x400700020000bb01000000000f02000a 0xbb01000000000f02000ae7e7e8b7 18446631020132433920 193111426 0 3305 7 2 2 0 443 NetworkService\n07:46:58  0x40020002b4a0bb0179ff85e80f02000a 0xb4a0bb0179ff85e80f02000ae7e7e8b7 18446631020132433920 193124670 13244 3305 2 1 2 46240 443 NetworkService\n07:46:58  0x40010002b4a0bb0179ff85e80f02000a 0xb4a0bb0179ff85e80f02000ae7e7e8b7 18446631020132433920 193185397 60727 3305 1 4 2 46240 443 NetworkService\n07:46:58  0x40040002b4a0bb0179ff85e80f02000a 0xb4a0bb0179ff85e80f02000ae7e7e8b7 18446631020132433920 193186122 724 3305 4 5 2 46240 443 NetworkService\n07:46:58  0x400500020000bb0179ff85e80f02000a 0xbb0179ff85e80f02000ae7e7e8b7 18446631020132433920 193186244 122 3305 5 7 2 46240 443 NetworkService\".07:46:59  0x40010002d01ebb01d0c52f5c0f02000a 0xd01ebb01d0c52f5c0f02000a51449c27 18446631020103553856 194110884 0 5130 1 8 2 53278 443 ThreadPoolForeg\n07:46:59  0x400800020000bb01d0c52f5c0f02000a 0xbb01d0c52f5c0f02000a51449c27 18446631020103553856 194121000 10116 3305 8 7 2 53278 443 NetworkService\n07:46:59  0x400700020000bb01000000000f02000a 0xbb01000000000f02000aeb6f2270 18446631020099513920 194603677 0 3305 7 2 2 0 443 NetworkService\n07:46:59  0x40020002d28ebb0182dd92990f02000a 0xd28ebb0182dd92990f02000aeb6f2270 18446631020099513920 194649313 45635 12 2 1 2 53902 443 ksoftirqd/0\n07:47:00  0x400700020000bb01000000000f02000a 0xbb01000000000f02000a26f6e878 18446631020132433920 195193350 0 3305 7 2 2 0 443 NetworkService\n07:47:00  0x40020002ba32bb01e0e09e3a0f02000a 0xba32bb01e0e09e3a0f02000a26f6e878 18446631020132433920 195206992 13642 0 2 1 2 47666 443 swapper/0\n07:47:00  0x400700020000bb01000000000f02000a 0xbb01000000000f02000ae7e7e8b7 18446631020132448128 195233125 0 3305 7 2 2 0 443 NetworkService\n07:47:00  0x40020002b4a8bb0136cac8dd0f02000a 0xb4a8bb0136cac8dd0f02000ae7e7e8b7 18446631020132448128 195246569 13444 3305 2 1 2 46248 443 NetworkService\n07:47:00  0xf02000affff00000000000000000000 0x1aca06cffff00000000000000000000 18446631019225912320 195383897 0 947 7 2 10 0 80 Thread-11\n07:47:00  0x40010002b4a8bb0136cac8dd0f02000a 0xb4a8bb0136cac8dd0f02000ae7e7e8b7 18446631020132448128 195421584 175014 3305 1 4 2 46248 443 NetworkService\n07:47:00  0x40040002b4a8bb0136cac8dd0f02000a 0xb4a8bb0136cac8dd0f02000ae7e7e8b7 18446631020132448128 195422361 777 3305 4 5 2 46248 443 NetworkService\n07:47:00  0x400500020000bb0136cac8dd0f02000a 0xbb0136cac8dd0f02000ae7e7e8b7 18446631020132448128 195422450 88 3305 5 7 2 46248 443 NetworkService\n07:47:01  0x400700020000bb01000000000f02000a 0xbb01000000000f02000aea2afb8e 18446631020099528128 196321556 0 1315 7 2 2 0 443 ChromiumNet\n</code></pre> <p>Note: some error messages may appear in the Android shell during the test:</p> <pre><code>libbpf: failed to determine tracepoint 'syscalls/sys_enter_open' perf event ID: No such file or directory\nlibbpf: prog 'tracepoint__syscalls__sys_enter_open': failed to create tracepoint 'syscalls/sys_enter_open' perf event: No such file or directory\nlibbpf: prog 'tracepoint__syscalls__sys_enter_open': failed to auto-attach: -2\nfailed to attach skeleton\nError: BpfError(\"load and attach ebpf program failed\")\n</code></pre> <p>Later, after investigation, it was found that the kernel did not enable the <code>CONFIG_FTRACE_SYSCALLS</code> option, which resulted in the inability to use the tracepoint of syscalls.</p>"},{"location":"tutorials/22-android/#summary","title":"Summary","text":"<p>The <code>CONFIG_DEBUG_INFO_BTF</code> option is enabled by default when viewing the kernel compilation options in the Android shell. Based on this, the examples provided by the eunomia-bpf project already have some successful cases, such as monitoring the execution of the <code>exec</code> family of functions and the status of TCP connections.</p> <p>For some cases that cannot run, the reasons are mainly the following:</p> <ol> <li>The kernel compilation options do not support the relevant eBPF functionality;</li> <li>The Linux environment packaged by eadb is weak and lacks necessary dependencies;</li> </ol> <p>Currently, using eBPF tools in the Android system still requires building a complete Linux runtime environment. However, the Android kernel itself has comprehensive support for eBPF. This test proves that higher versions of the Android kernel support BTF debugging information and CO-RE dependent eBPF programs.</p> <p>The development of eBPF tools in the Android system requires the addition of official new features. Currently, it seems that using eBPF tools directly through an Android app requires a lot of effort. At the same time, since eBPF tools require root privileges, ordinary Android users will encounter more difficulties in using them.</p> <p>If you want to learn more about eBPF knowledge and practice, you can visit our tutorial code repository https://github.com/eunomia-bpf/bpf-developer-tutorial to get more examples and complete tutorials.</p>"},{"location":"tutorials/22-android/#reference","title":"Reference","text":"<ul> <li>Google android docs</li> <li>weixin WeiShu</li> <li>SeeFlowerX</li> </ul>"},{"location":"tutorials/23-http/","title":"http","text":"<p>TODO</p>"},{"location":"tutorials/24-hide/","title":"TODO: translate into English","text":""},{"location":"tutorials/25-signal/","title":"Terminate Malicious Processes Using bpf_send_signal","text":"<p>Compile:</p> <pre><code>make\n</code></pre> <p>Usage:</p> <pre><code>sudo ./bpfdos\n</code></pre> <p>This program sends a <code>SIG_KILL</code> signal to any program that tries to use the <code>ptrace</code> system call, such as <code>strace</code>. Once bpf-dos starts running, you can test it by running the following command:</p> <pre><code>strace /bin/whoami\n</code></pre>"},{"location":"tutorials/25-signal/#references","title":"References","text":"<ul> <li>https://github.com/pathtofile/bad-bpf.</li> </ul>"},{"location":"tutorials/26-sudo/","title":"Using eBPF to add sudo user","text":"<p>Compilation:</p> <pre><code>make\n</code></pre> <p>Usage:</p> <pre><code>sudo ./sudoadd --username lowpriv-user\n</code></pre> <p>This program allows a user with lower privileges to become root using <code>sudo</code>.</p> <p>It works by intercepting <code>sudo</code> reading the <code>/etc/sudoers</code> file and overwriting the first line with <code>&lt;username&gt; ALL=(ALL:ALL) NOPASSWD:ALL #</code>. This tricks <code>sudo</code> into thinking that the user is allowed to become root. Other programs like <code>cat</code> or <code>sudoedit</code> are not affected, so the file remains unchanged and the user does not have these permissions. The <code>#</code> at the end of the line ensures that the rest of the line is treated as a comment, so it does not break the logic of the file.</p>"},{"location":"tutorials/26-sudo/#references","title":"References","text":"<ul> <li>https://github.com/pathtofile/bad-bpf</li> </ul>"},{"location":"tutorials/27-replace/","title":"Replace Text Read or Written by Any Program with eBPF","text":"<p>Compile:</p> <pre><code>make\n</code></pre> <p>Usage:</p> <pre><code>sudo ./replace --filename /path/to/file --input foo --replace bar\n</code></pre> <p>This program will replace all text in the file that matches 'input' with 'replace' text. There are many use cases for this, such as:</p> <p>Hiding the kernel module 'joydev' to avoid detection by tools like 'lsmod':</p> <pre><code>./replace -f /proc/modules -i 'joydev' -r 'cryptd'\n</code></pre> <p>Spoofing the MAC address of the 'eth0' interface:</p> <pre><code>./replace -f /sys/class/net/eth0/address -i '00:15:5d:01:ca:05' -r '00:00:00:00:00:00'\n</code></pre> <p>Malware performing anti-sandbox checks may look for MAC addresses as an indication of whether it is running in a virtual machine or sandbox, rather than on a \"real\" machine.</p> <p>Note: The lengths of 'input' and 'replace' must be the same to avoid introducing NULL characters in the middle of the text block. To input a newline character at a bash prompt, use <code>$'\\n'</code>, for example <code>--replace $'text\\n'</code>.</p>"},{"location":"tutorials/27-replace/#references","title":"References","text":"<ul> <li>https://github.com/pathtofile/bad-bpf.</li> </ul>"},{"location":"tutorials/28-detach/","title":"Running eBPF Programs After User-Space Application Exits: The Lifecycle of eBPF Programs","text":"<p>By using the detach method to run eBPF programs, the user space loader can exit without stopping the eBPF program.</p>"},{"location":"tutorials/28-detach/#the-lifecycle-of-ebpf-programs","title":"The Lifecycle of eBPF Programs","text":"<p>First, we need to understand some key concepts, such as BPF objects (including programs, maps, and debug information), file descriptors (FDs), reference counting (refcnt), etc. In the eBPF system, user space accesses BPF objects through file descriptors, and each object has a reference count. When an object is created, its reference count is initialized to 1. If the object is no longer in use (i.e., no other programs or file descriptors reference it), its reference count will decrease to 0 and be cleaned up in memory after the RCU grace period.</p> <p>Next, we need to understand the lifecycle of eBPF programs. First, when you create a BPF program and attach it to a \"hook\" (e.g., a network interface, a system call, etc.), its reference count increases. Then, even if the user space process that originally created and loaded the program exits, as long as the reference count of the BPF program is greater than 0, it will remain active. However, there is an important point in this process: not all hooks are equal. Some hooks are global, such as XDP, tc's clsact, and cgroup-based hooks. These global hooks keep the BPF program active until the objects themselves disappear. Some hooks are local and only run during the lifetime of the process that owns them.</p> <p>For managing the lifecycle of BPF objects (programs or maps), another key operation is \"detach.\" This operation prevents any future execution of the attached program. Then, in cases where you need to replace a BPF program, you can use the replace operation. This is a complex process because you need to ensure that during the replacement process, no events being processed are lost, and the old and new program may run simultaneously on different CPUs.</p> <p>Finally, in addition to managing the lifecycle of BPF objects through file descriptors and reference counting, there is another method called BPFFS, which is the \"BPF Filesystem.\" User space processes can \"pin\" a BPF program or map in BPFFS, which increases the reference count of the object, keeping the BPF object active even if the BPF program is not attached anywhere or the BPF map is not used by any program.</p> <p>So when we talk about running eBPF programs in the background, we need to understand the meaning of this process. In some cases, even if the user space process has exited, we may still want the BPF program to keep running. This requires us to manage the lifecycle of BPF objects correctly.</p>"},{"location":"tutorials/28-detach/#running","title":"Running","text":"<p>Here, we still use the example of string replacement used in the previous application to demonstrate potential security risks. By using <code>--detach</code> to run the program, the user space loader can exit without stopping the eBPF program.</p> <p>Compilation:</p> <pre><code>make\n</code></pre> <p>Before running, please make sure that the BPF file system has been mounted:</p> <pre><code>sudo mount bpffs -t bpf /sys/fs/bpf\nmkdir /sys/fs/bpf/textreplace\n</code></pre> <p>Then, you can run text-replace2 with detach:</p> <pre><code>./textreplace2 -f /proc/modules -i 'joydev' -r 'cryptd' -d\n</code></pre> <p>This will create some eBPF link files under <code>/sys/fs/bpf/textreplace</code>. Once the loader is successfully running, you can check the log by running the following command:</p> <pre><code>sudo cat /sys/kernel/debug/tracing/trace_pipe\n# Confirm that the link files exist\nsudo ls -l /sys/fs/bpf/textreplace\n</code></pre> <p>Finally, to stop, simply delete the link files:</p> <pre><code>sudo rm -r /sys/fs/bpf/textreplace\n</code></pre>"},{"location":"tutorials/28-detach/#references","title":"References","text":"<ul> <li>https://github.com/pathtofile/bad-bpf</li> <li>https://facebookmicrosites.github.io/bpf/blog/2018/08/31/object-lifetime.html</li> </ul>"},{"location":"tutorials/29-sockops/","title":"eBPF sockops Example","text":""},{"location":"tutorials/29-sockops/#performance-optimization-using-ebpf-sockops","title":"Performance Optimization using eBPF sockops","text":"<p>Network connections are essentially communication between sockets. eBPF provides a bpf_msg_redirect_hash function, which allows packets sent by applications to be directly forwarded to the destination socket, greatly accelerating the packet processing flow in the kernel.</p> <p>Here, sock_map is the crucial part that records socket rules, i.e., based on the current packet information, a socket connection is selected from sock_map to forward the request. Therefore, it is necessary to save the socket information to sock_map at the hook of sockops or elsewhere, and provide a key-based rule (generally a four-tuple) to find the socket.</p> <p>The Merbridge project uses eBPF instead of iptables to accelerate Istio. After using Merbridge (eBPF) optimization, inbound and outbound traffic will bypass many kernel modules, significantly improving performance, as shown in the figure below:</p> <p></p>"},{"location":"tutorials/29-sockops/#running-the-example","title":"Running the Example","text":"<p>This example program redirects traffic from the sender's socket (outbound) to the receiver's socket (inbound), bypassing the TCP/IP kernel network stack. In this example, we assume that the sender and receiver are running on the same machine.</p>"},{"location":"tutorials/29-sockops/#compiling-the-ebpf-program","title":"Compiling the eBPF Program","text":"<pre><code># Compile the bpf_sockops program\nclang -O2 -g -Wall -target bpf -c bpf_sockops.c -o bpf_sockops.o\nclang -O2 -g -Wall -target bpf -c bpf_redir.c -o bpf_redir.o\n</code></pre>"},{"location":"tutorials/29-sockops/#loading-the-ebpf-program","title":"Loading the eBPF Program","text":"<pre><code>sudo ./load.sh\n</code></pre> <p>You can use the bpftool utility to check if these two eBPF programs have been loaded.</p> <pre><code>$ sudo bpftool prog show\n63: sock_ops  name bpf_sockmap  tag 275467be1d69253d  gpl\n loaded_at 2019-01-24T13:07:17+0200  uid 0\n xlated 1232B  jited 750B  memlock 4096B  map_ids 58\n64: sk_msg  name bpf_redir  tag bc78074aa9dd96f4  gpl\n loaded_at 2019-01-24T13:07:17+0200  uid 0\n xlated 304B  jited 233B  memlock 4096B  map_ids 58\n</code></pre>"},{"location":"tutorials/29-sockops/#running-the-iperf3-server","title":"Running the iperf3 Server","text":"<pre><code>iperf3 -s -p 10000\n</code></pre>"},{"location":"tutorials/29-sockops/#running-the-iperf3-client","title":"Running the iperf3 Client","text":"<pre><code>iperf3 -c 127.0.0.1 -t 10 -l 64k -p 10000\n</code></pre>"},{"location":"tutorials/29-sockops/#collecting-traces","title":"Collecting Traces","text":"<pre><code>$ ./trace.sh\niperf3-9516  [001] .... 22500.634108: 0: &lt;&lt;&lt; ipv4 op = 4, port 18583 --&gt; 4135\niperf3-9516  [001] ..s1 22500.634137: 0: &lt;&lt;&lt; ipv4 op = 5, port 4135 --&gt; 18583\niperf3-9516  [001] .... 22500.634523: 0: &lt;&lt;&lt; ipv4 op = 4, port 19095 --&gt; 4135\niperf3-9516  [001] ..s1 22500.634536: 0: &lt;&lt;&lt; ipv4 op = 5, port 4135 --&gt; 19095\n</code></pre> <p>You should be able to see 4 events for socket establishment. If you don't see any events, the eBPF program may not have been attached correctly.</p>"},{"location":"tutorials/29-sockops/#unloading-the-ebpf-program","title":"Unloading the eBPF Program","text":"<pre><code>sudo ./unload.sh\n</code></pre>"},{"location":"tutorials/29-sockops/#references","title":"References","text":"<ul> <li>https://github.com/zachidan/ebpf-sockops- https://github.com/merbridge/merbridge</li> </ul>"},{"location":"tutorials/3-fentry-unlink/","title":"eBPF Introductory Development Practice Tutorial 3: Detecting Captured Unlink System Calls in eBPF","text":"<p>eBPF (Extended Berkeley Packet Filter) is a powerful network and performance analysis tool on the Linux kernel. It allows developers to dynamically load, update, and execute user-defined code at runtime in the kernel.</p> <p>This article is the third part of the eBPF introductory development practice tutorial, focusing on capturing unlink system calls using fentry in eBPF.</p>"},{"location":"tutorials/3-fentry-unlink/#fentry","title":"Fentry","text":"<p>fentry (function entry) and fexit (function exit) are two types of probes in eBPF (Extended Berkeley Packet Filter) used for tracing at the entry and exit points of Linux kernel functions. They allow developers to collect information, modify parameters, or observe return values at specific stages of kernel function execution. This tracing and monitoring functionality is very useful in performance analysis, troubleshooting, and security analysis scenarios.</p> <p>Compared to kprobes, fentry and fexit programs have higher performance and availability. In this example, we can directly access the pointers to the functions' parameters, just like in regular C code, without needing various read helpers. The main difference between fexit and kretprobe programs is that fexit programs can access both the input parameters and return values of a function, while kretprobe programs can only access the return value. Starting from the 5.5 kernel, fentry and fexit are available for eBPF programs.</p> <pre><code>#include \"vmlinux.h\"\n#include &lt;bpf/bpf_helpers.h&gt;\n#include &lt;bpf/bpf_tracing.h&gt;\nchar LICENSE[] SEC(\"license\") = \"Dual BSD/GPL\";\nSEC(\"fentry/do_unlinkat\")\nint BPF_PROG(do_unlinkat, int dfd, struct filename *name)\n{\npid_t pid;\npid = bpf_get_current_pid_tgid() &gt;&gt; 32;\nbpf_printk(\"fentry: pid = %d, filename = %s\\n\", pid, name-&gt;name);\nreturn 0;\n}\nSEC(\"fexit/do_unlinkat\")\nint BPF_PROG(do_unlinkat_exit, int dfd, struct filename *name, long ret)\n{\npid_t pid;\npid = bpf_get_current_pid_tgid() &gt;&gt; 32;\nbpf_printk(\"fexit: pid = %d, filename = %s, ret = %ld\\n\", pid, name-&gt;name, ret);\nreturn 0;\n}\n</code></pre> <p>This program is an eBPF (Extended Berkeley Packet Filter) program written in the C language. It uses BPF fentry and fexit probes to trace the Linux kernel function <code>do_unlinkat</code>. In this tutorial, we will use this program as an example to learn how to use fentry in eBPF to detect and capture unlink system calls.</p> <p>The program consists of the following parts:</p> <ol> <li>Include header files: including vmlinux.h (for accessing kernel data structures), bpf/bpf_helpers.h (which includes eBPF helper functions), bpf/bpf_tracing.h (for eBPF tracing-related functionalities).</li> <li>Define license: Here, a character array named <code>LICENSE</code> is defined, containing the license information \"Dual BSD/GPL\".</li> <li>Define fentry probe: We define an fentry probe named <code>BPF_PROG(do_unlinkat)</code> that is triggered at the entry point of the <code>do_unlinkat</code> function. This probe retrieves the PID (Process ID) of the current process and prints it along with the filename to the kernel log.</li> <li>Define fexit probe: We also define an fexit probe named <code>BPF_PROG(do_unlinkat_exit)</code> that is triggered at the exit point of the <code>do_unlinkat</code> function. Similar to the fentry probe, this probe also retrieves the PID of the current process and prints it along with the filename and return value to the kernel log.</li> </ol> <p>Through this example, you can learn how to use fentry and fexit probes in eBPF to monitor and capture kernel function calls, such as the unlink system call in this tutorial.Instructions: Translate the following Chinese text to English  while maintaining the original formatting: \"eunomia-bpf is an open source eBPF dynamic loading runtime and development toolchain combined with Wasm. Its goal is to simplify the development, building, distribution, and running of eBPF programs. You can refer to here to download and install the ecc compilation toolchain and ecli runtime. We use eunomia-bpf to compile and run this example.</p> <p>To compile and run the above code:</p> <pre><code>$ ecc fentry-link.bpf.c\nCompiling bpf object...\nPacking ebpf object and config into package.json...\n$ sudo ecli run package.json\nRunning eBPF program...\n</code></pre> <p>In another window:</p> <pre><code>touch test_file\nrm test_file\ntouch test_file2\nrm test_file2\n</code></pre> <p>After running this program, you can view the output of the eBPF program by examining the <code>/sys/kernel/debug/tracing/trace_pipe</code> file:</p> <pre><code>$ sudo cat /sys/kernel/debug/tracing/trace_pipe\n              rm-9290    [004] d..2  4637.798698: bpf_trace_printk: fentry: pid = 9290, filename = test_file\n              rm-9290    [004] d..2  4637.798843: bpf_trace_printk: fexit: pid = 9290, filename = test_file, ret = 0\n              rm-9290    [004] d..2  4637.798698: bpf_trace_printk: fentry: pid = 9290, filename = test_file2\n              rm-9290    [004] d..2  4637.798843: bpf_trace_printk: fexit: pid = 9290, filename = test_file2, ret = 0\n</code></pre>"},{"location":"tutorials/3-fentry-unlink/#summary","title":"Summary","text":"<p>This program is an eBPF program that captures the <code>do_unlinkat</code> and <code>do_unlinkat_exit</code> functions using fentry and fexit, and uses <code>bpf_get_current_pid_tgid</code> and <code>bpf_printk</code> functions to obtain the ID, filename, and return value of the process calling do_unlinkat, and print them in the kernel log.</p> <p>To compile this program, you can use the ecc tool, and to run it, you can use the ecli command, and view the output of the eBPF program by checking the <code>/sys/kernel/debug/tracing/trace_pipe</code> file. For more examples and detailed development guide, please refer to the official documentation of eunomia-bpf: here</p> <p>If you want to learn more about eBPF knowledge and practice, you can visit our tutorial code repository here for more examples and complete tutorials.\".</p>"},{"location":"tutorials/30-openssl/","title":"eBPF openssl","text":"<p>TODO: make it work</p> <p>from https://github.com/kiosk404/openssl_tracer.</p>"},{"location":"tutorials/30-openssl/ssl_client_server/README.zh/","title":"openssl_tracer","text":"<p>openssl_tracer: \u57fa\u4e8eeBPF\u6280\u672f\u5b9e\u73b0TLS\u52a0\u5bc6\u7684\u660e\u6587\u6355\u83b7\u3002</p> <p>\u8be5\u6837\u4f8b\u9879\u76ee\u662f\u57fa\u4e8eeBPF\u6765\u8ffd\u8e2aOpenSSL\u52a8\u6001\u5e93\u7684\u4f8b\u5b50\uff0c\u4f7f\u7528 libbpf \u8fdb\u884c\u8ffd\u8e2a\u3002\u5728eBPF \u7a0b\u5e8f\u4e2d\uff0c \u7531\u4e8e libbpf \u65b9\u6cd5\u5185\u6838\u5df2\u7ecf\u652f\u6301\u4e86 BTF\uff0c\u4e0d\u518d\u9700\u8981\u5f15\u5165\u4f17\u591a\u7684\u5185\u6838\u5934\u6587\u4ef6\u6765\u83b7\u53d6\u5185\u6838\u6570\u636e\u7ed3\u6784\u7684\u5b9a\u4e49\uff0c \u53d6\u800c\u4ee3\u4e4b\u7684\u662f bpftool \u751f\u6210\u7684 vmlinux.h \u5934\u6587\u4ef6\uff0c\u5176\u4e2d\u5305\u542b\u5185\u6838\u6570\u636e\u7ed3\u6784\u7684\u5b9a\u4e49\u3002</p> <p>\u8fd9\u4e2a\u6837\u4f8b\u662f\u4e3a\u4e86\u914d\u5408\u201c\u4f7f\u7528eBPF\u8ddf\u8e2a SSL/TLS \u8fde\u63a5\u201d \u8fd9\u4e2a Blog</p>"},{"location":"tutorials/30-openssl/ssl_client_server/README.zh/#openssl-tracer-using-bpf","title":"OpenSSL Tracer using BPF","text":"<p>This is a basic example of how to trace the OpenSSL library using eBPF. This tracer uses BCC to deploy the eBPF probes. This demo was created to accompany the \"Debugging with eBPF Part 3: Tracing SSL/TLS connections\" blog post.</p> <p>eBPF \u7a0b\u5e8f\u80fd\u591f\u52a0\u8f7d\u5230 trace points\u3001\u5185\u6838\u53ca\u7528\u6237\u7a7a\u95f4\u5e94\u7528\u7a0b\u5e8f\u4e2d\u7684 probe points\uff0c  \u8fd9\u79cd\u80fd\u529b\u4f7f\u6211\u4eec\u5bf9\u5e94\u7528\u7a0b\u5e8f\u7684\u8fd0\u884c\u65f6\u884c\u4e3a\uff08runtime behavior\uff09\u548c\u7cfb\u7edf\u672c\u8eab \uff08system itself\uff09\u63d0\u4f9b\u4e86\u53f2\u65e0\u524d\u4f8b\u7684\u53ef\u89c2\u6d4b\u6027\u3002</p>"},{"location":"tutorials/30-openssl/ssl_client_server/README.zh/#prerequisites","title":"Prerequisites","text":"<p>\u64cd\u4f5c\u7cfb\u7edf\u7248\u672c\u6700\u597d\u5927\u4e8e 5.x\uff0c\u672c\u6837\u4f8b\u8fd0\u884c\u4e8e ubuntu 5.15.x \u7248\u672c\u3002 \u4e00\u4e9b5.4\u7248\u672c\u4ee5\u4e0b\u7684\u5185\u6838\u8fd8\u4f1a\u5b58\u5728\u4e9b\u8bb8\u95ee\u9898\uff0c\u8be6\u89c1 https://github.com/iovisor/bcc/issues/2948 <pre><code>$ uname -r\n5.15.0-30-generic\n</code></pre></p> <p><code>CONFIG_DEBUG_INFO_BTF = y</code>\uff0c\u65b0\u7684 BPF \u4e8c\u8fdb\u5236\u6587\u4ef6\u4ec5\u5728\u8bbe\u7f6e\u4e86\u6b64\u5185\u6838\u914d\u7f6e\u9009\u9879\u540e\u624d\u53ef\u7528\uff0cUbuntu 20.10 \u5df2\u7ecf\u5c06\u6b64\u914d\u7f6e\u9009\u9879\u8bbe\u7f6e\u4e3a\u9ed8\u8ba4\u9009\u9879</p> <p>\u9700\u8981\u5b89\u88c5 libbpf \u5de5\u5177\uff0c\u5728Ubuntu \u4e0a\u6267\u884c\u4ee5\u4e0b\u547d\u4ee4\uff0c <pre><code>$ sudo apt install libbpf-dev\n</code></pre> \u5176\u4ed6\u64cd\u4f5c\u7cfb\u7edf\u6709\u7c7b\u4f3c\u7684\u547d\u4ee4\u3002</p>"},{"location":"tutorials/30-openssl/ssl_client_server/README.zh/#build","title":"Build","text":"<p>\u6267\u884c\u4ee5\u4e0b\u547d\u4ee4 <pre><code>make ebpf\nmake build\n</code></pre></p>"},{"location":"tutorials/30-openssl/ssl_client_server/README.zh/#run-demo-application","title":"Run Demo Application","text":"<p>\u8be5 Demo \u5305\u542b\u4e00\u4e2a ssl_client_server \u7684 ssl \u901a\u4fe1\u7684\u5c0f\u7a0b\u5e8f\u3002\u8fd0\u884c\u8be5\u5c0f\u7a0b\u5e8f\u53ef\u4ee5\u7a33\u5b9a\u7684\u8fd0\u884c ssl \u901a\u4fe1\u6570\u636e\u3002 <pre><code>cd ssl_client_server; python3 ./server.py\ncd ssl_client_server; python3 ./client.py\n</code></pre></p>"},{"location":"tutorials/30-openssl/ssl_client_server/README.zh/#run-tracer","title":"Run Tracer","text":"<p>\u4ee5\u4e0b\u65b9\u5f0f <pre><code>sudo ./openssl_tracer &lt;pid&gt;\n</code></pre> \u5982\u679c\u662f\u8ffd\u8e2a\u5c0f\u7a0b\u5e8f\uff0c\u5219\u53ef\u4ee5</p> <pre><code>sudo ./openssl_tracer $(pgrep -f \"./client.py\")\n</code></pre>"},{"location":"tutorials/31-goroutine/","title":"goroutine trace","text":"<p>TODO: make this work and implement the documentation</p> <p>Modify from https://github.com/deepflowio/deepflow</p> <p>This example is provided as GPL license.</p>"},{"location":"tutorials/32-funclatency/","title":"func latency","text":"<p>TODO: make it work</p> <p>from https://github.com/iovisor/bcc/blob/master/libbpf-tools/funclatency.c.</p>"},{"location":"tutorials/4-opensnoop/","title":"eBPF Getting Started Development Tutorial 4: Capturing the System Call Collection of Process Opening Files in eBPF and Using Global Variables to Filter Process PIDs","text":"<p>eBPF (Extended Berkeley Packet Filter) is a kernel execution environment that allows users to run secure and efficient programs in the kernel. It is commonly used for network filtering, performance analysis, security monitoring, and other scenarios. The power of eBPF lies in its ability to capture and modify network packets or system calls at runtime in the kernel, enabling monitoring and adjustment of the operating system's behavior.</p> <p>This article is the fourth part of the eBPF Getting Started Development Tutorial, mainly focusing on how to capture the system call collection of process opening files and filtering process PIDs using global variables in eBPF.</p> <p>In Linux system, the interaction between processes and files is achieved through system calls. System calls serve as the interface between user space programs and kernel space programs, allowing user programs to request specific operations from the kernel. In this tutorial, we focus on the sys_openat system call, which is used to open files.</p> <p>When a process opens a file, it issues a sys_openat system call to the kernel and passes relevant parameters (such as file path, open mode, etc.). The kernel handles this request and returns a file descriptor, which serves as a reference for subsequent file operations. By capturing the sys_openat system call, we can understand when and how a process opens a file.</p>"},{"location":"tutorials/4-opensnoop/#capturing-the-system-call-collection-of-process-opening-files-in-ebpf","title":"Capturing the System Call Collection of Process Opening Files in eBPF","text":"<p>First, we need to write an eBPF program to capture the system call of a process opening a file. The specific implementation is as follows:</p> <pre><code>#include &lt;vmlinux.h&gt;\n#include &lt;bpf/bpf_helpers.h&gt;\n/// @description \"Process ID to trace\"\nconst volatile int pid_target = 0;\nSEC(\"tracepoint/syscalls/sys_enter_openat\")\nint tracepoint__syscalls__sys_enter_openat(struct trace_event_raw_sys_enter* ctx)\n{\nu64 id = bpf_get_current_pid_tgid();\nu32 pid = id;\nif (pid_target &amp;&amp; pid_target != pid)\nreturn false;\n// Use bpf_printk to print the process information\nbpf_printk(\"Process ID: %d enter sys openat\\n\", pid);\nreturn 0;\n}\n/// \"Trace open family syscalls.\"\nchar LICENSE[] SEC(\"license\") = \"GPL\";\n</code></pre> <p>This eBPF program implements the following:</p> <ol> <li>Include header files:  contains the definition of kernel data structures, and  contains the helper functions required by eBPF programs. <li>Define the global variable <code>pid_target</code> for filtering a specified process ID. Setting it to 0 captures sys_openat calls from all processes.</li> <li>Use the <code>SEC</code> macro to define an eBPF program associated with the tracepoint \"tracepoint/syscalls/sys_enter_openat\". This tracepoint is triggered when a process initiates the <code>sys_openat</code> system call.</li> <li>Implement the eBPF program <code>tracepoint__syscalls__sys_enter_openat</code>, which takes a parameter <code>ctx</code> of type <code>struct trace_event_raw_sys_enter</code>. This structure contains information about the system call.</li> <li>Use the <code>bpf_get_current_pid_tgid()</code> function to retrieve the PID and TGID (Thread Group ID) of the current process. Since we only care about the PID, we assign it to the <code>u32</code> variable <code>pid</code>.</li> <li>Check if the <code>pid_target</code> variable is equal to the current process's PID. If <code>pid_target</code> is not 0 and is not equal to the current process's PID, return <code>false</code> to skip capturing the <code>sys_openat</code> call of that process.</li> <li>Use the <code>bpf_printk()</code> function to print the captured process ID and relevant information about the <code>sys_openat</code> call. These information can be viewed in user space using BPF tools.</li> <li>Set the program license to \"GPL\", which is a necessary condition for running eBPF programs.### Instructions Translate the following Chinese text to English while maintaining the original formatting: </li> <p>\"This eBPF program can be loaded into the kernel and executed using tools like libbpf or eunomia-bpf. It captures the sys_openat system call of the specified process (or all processes) and outputs relevant information in user-space.</p> <p>eunomia-bpf is an open-source eBPF dynamic loading runtime and development toolchain combined with Wasm. Its purpose is to simplify the development, building, distribution, and execution of eBPF programs. You can refer to https://github.com/eunomia-bpf/eunomia-bpf to download and install the ecc compilation toolchain and ecli runtime. We will use eunomia-bpf to compile and run this example.</p> <p>Compile and run the above code:</p> <pre><code>$ ecc opensnoop.bpf.c\nCompiling bpf object...\nPacking ebpf object and config into package.json...\n$ sudo ecli run package.json\nRunning eBPF program...\n</code></pre> <p>After running this program, you can view the output of the eBPF program by viewing the <code>/sys/kernel/debug/tracing/trace_pipe</code> file:</p> <pre><code>$ sudo cat /sys/kernel/debug/tracing/trace_pipe\n           &lt;...&gt;-3840345 [010] d... 3220701.101179: bpf_trace_printk: Process ID: 3840345 enter sys openat\n           &lt;...&gt;-3840345 [010] d... 3220702.158000: bpf_trace_printk: Process ID: 3840345 enter sys openat\n</code></pre> <p>At this point, we are able to capture the sys_openat system call for opening files by processes.</p>"},{"location":"tutorials/4-opensnoop/#filtering-process-pid-in-ebpf-using-global-variables","title":"Filtering Process PID in eBPF using Global Variables","text":"<p>Global variables act as a data sharing mechanism in eBPF programs, allowing data interaction between user space programs and eBPF programs. This is very useful when filtering specific conditions or modifying the behavior of eBPF programs. This design allows user space programs to dynamically control the behavior of eBPF programs at runtime.</p> <p>In our example, the global variable <code>pid_target</code> is used to filter process PIDs. User space programs can set the value of this variable to capture only the <code>sys_openat</code> system calls related to the specified PID in the eBPF program.</p> <p>The principle of using global variables is that they are defined and stored in the data section of eBPF programs. When the eBPF program is loaded into the kernel and executed, these global variables are retained in the kernel and can be accessed through BPF system calls. User space programs can use certain features of BPF system calls, such as <code>bpf_obj_get_info_by_fd</code> and <code>bpf_obj_get_info</code>, to obtain information about the eBPF object, including the position and value of global variables.</p> <p>You can view the help information for opensnoop by executing the command <code>ecli -h</code>:</p> <pre><code>$ ecli package.json -h\nUsage: opensnoop_bpf [--help] [--version] [--verbose] [--pid_target VAR]\nTrace open family syscalls.\nOptional arguments:\n  -h, --help    shows help message and exits \n  -v, --version prints version information and exits \n  --verbose     prints libbpf debug information \n  --pid_target  Process ID to trace \nBuilt with eunomia-bpf framework.\nSee https://github.com/eunomia-bpf/eunomia-bpf for more information.\n</code></pre> <p>You can specify the PID of the process to capture by using the <code>--pid_target</code> option, for example:</p> <pre><code>$ sudo ./ecli run package.json  --pid_target 618\nRunning eBPF program...\n</code></pre> <p>After running this program, you can view the output of the eBPF program by viewing the <code>/sys/kernel/debug/tracing/trace_pipe</code> file:</p> <pre><code>$ sudo cat /sys/kernel/debug/tracing/trace_pipe\".\\-3840345 [010] d... 3220701.101179: bpf_trace_printk: Process ID: 618 enter sys openat\n\\-3840345 [010] d... 3220702.158000: bpf_trace_printk: Process ID: 618 enter sys openat\n</code></pre>"},{"location":"tutorials/4-opensnoop/#summary","title":"Summary","text":"<p>This article introduces how to use eBPF programs to capture the system calls for process file opening. In an eBPF program, we can capture the system calls for process file opening by defining functions <code>tracepoint__syscalls__sys_enter_open</code> and <code>tracepoint__syscalls__sys_enter_openat</code> and attaching them to the tracepoints <code>sys_enter_open</code> and <code>sys_enter_openat</code> using the <code>SEC</code> macro. We can use the <code>bpf_get_current_pid_tgid</code> function to get the process ID that calls the open or openat system call, and print it out in the kernel log using the <code>bpf_printk</code> function. In an eBPF program, we can also filter the output by defining a global variable <code>pid_target</code> to specify the pid of the process to be captured, only outputting the information of the specified process.</p> <p>By learning this tutorial, you should have a deeper understanding of how to capture and filter system calls for specific processes in eBPF. This method has widespread applications in system monitoring, performance analysis, and security auditing.</p> <p>For more examples and detailed development guides, please refer to the official documentation of eunomia-bpf: https://github.com/eunomia-bpf/eunomia-bpf</p> <p>If you want to learn more about eBPF knowledge and practices, you can visit our tutorial code repository at https://github.com/eunomia-bpf/bpf-developer-tutorial for more examples and a complete tutorial.</p>"},{"location":"tutorials/5-uprobe-bashreadline/","title":"eBPF Beginner's Development Tutorial 5: Capturing readline Function Calls in eBPF","text":"<p>eBPF (Extended Berkeley Packet Filter) is a powerful network and performance analysis tool on the Linux kernel that allows developers to dynamically load, update, and run user-defined code at runtime.</p> <p>This article is the fifth part of the eBPF beginner's development tutorial, which mainly introduces how to capture readline function calls in bash using uprobe.</p>"},{"location":"tutorials/5-uprobe-bashreadline/#what-is-uprobe","title":"What is uprobe","text":"<p>uprobe is a user-space probe that allows dynamic instrumentation in user-space programs. The probe locations include function entry, specific offsets, and function returns. When we define an uprobe, the kernel creates fast breakpoint instructions (int3 instructions on x86 machines) on the attached instructions. When the program executes this instruction, the kernel triggers an event, causing the program to enter kernel mode and call the probe function through a callback function. After executing the probe function, the program returns to user mode to continue executing subsequent instructions.</p> <p>uprobe is file-based. When a function in a binary file is traced, all processes that use the file are instrumented, including those that have not yet been started, allowing system calls to be tracked system-wide.</p> <p>uprobe is suitable for parsing some traffic in user mode that cannot be resolved by kernel mode probes, such as HTTP/2 traffic (where the header is encoded and cannot be decoded by the kernel) and HTTPS traffic (which is encrypted and cannot be decrypted by the kernel).</p>"},{"location":"tutorials/5-uprobe-bashreadline/#capturing-readline-function-calls-in-bash-using-uprobe","title":"Capturing readline Function Calls in bash using uprobe","text":"<p>uprobe is an eBPF probe used to capture user-space function calls, allowing us to capture system functions called by user-space programs.</p> <p>For example, we can use uprobe to capture readline function calls in bash and get the command line input from the user. The example code is as follows:</p> <pre><code>#include &lt;vmlinux.h&gt;\n#include &lt;bpf/bpf_helpers.h&gt;\n#include &lt;bpf/bpf_tracing.h&gt;\n#define TASK_COMM_LEN 16\n#define MAX_LINE_SIZE 80\nSEC(\"uretprobe//bin/bash:readline\")\nint BPF_KRETPROBE(printret, const void *ret)\n{\nchar str[MAX_LINE_SIZE];\nchar comm[TASK_COMM_LEN];\nu32 pid;\nif (!ret)\nreturn 0;\nbpf_get_current_comm(&amp;comm, sizeof(comm));\npid = bpf_get_current_pid_tgid() &gt;&gt; 32;\nbpf_probe_read_user_str(str, sizeof(str), ret);\nbpf_printk(\"PID %d (%s) read: %s \", pid, comm, str);\nreturn 0;\n};\nchar LICENSE[] SEC(\"license\") = \"GPL\";\n</code></pre> <p>The purpose of this code is to execute the specified BPF_PROBE function (printret function) when the readline function in bash returns.</p> <p>In the printret function, we first obtain the process name and process ID of the process calling the readline function. Then, we use the bpf_probe_read_user_str function to read the user input command line string. Lastly, we use the bpf_printk function to print the process ID, process name, and input command line string.</p> <p>In addition, we also need to define the uprobe probe using the SEC macro and define the probe function using the BPF_KRETPROBE macro.In the <code>SEC</code> macro in the code above, we need to specify the type of the uprobe, the path of the binary file to capture, and the name of the function to capture. For example, the definition of the <code>SEC</code> macro in the code above is as follows:</p> <pre><code>SEC(\"uprobe//bin/bash:readline\")\n</code></pre> <p>This indicates that we want to capture the <code>readline</code> function in the <code>/bin/bash</code> binary file.</p> <p>Next, we need to use the <code>BPF_KRETPROBE</code> macro to define the probe function. For example:</p> <pre><code>BPF_KRETPROBE(printret, const void *ret)\n</code></pre> <p>Here, <code>printret</code> is the name of the probe function, and <code>const void *ret</code> is the parameter of the probe function, which represents the return value of the captured function.</p> <p>Then, we use the <code>bpf_get_current_comm</code> function to get the name of the current task and store it in the <code>comm</code> array.</p> <pre><code>bpf_get_current_comm(&amp;comm, sizeof(comm));\n</code></pre> <p>We use the <code>bpf_get_current_pid_tgid</code> function to get the PID of the current process and store it in the <code>pid</code> variable.</p> <pre><code>pid = bpf_get_current_pid_tgid() &gt;&gt; 32;\n</code></pre> <p>We use the <code>bpf_probe_read_user_str</code> function to read the return value of the <code>readline</code> function from the user space and store it in the <code>str</code> array.</p> <pre><code>bpf_probe_read_user_str(str, sizeof(str), ret);\n</code></pre> <p>Finally, we use the <code>bpf_printk</code> function to output the PID, task name, and user input string.</p> <pre><code>bpf_printk(\"PID %d (%s) read: %s \", pid, comm, str);\n</code></pre> <p>eunomia-bpf is an open-source eBPF dynamic loading runtime and development toolchain combined with Wasm. Its purpose is to simplify the development, build, distribution, and running of eBPF programs. You can refer to https://github.com/eunomia-bpf/eunomia-bpf to download and install the ecc compiler toolchain and ecli runtime. We use eunomia-bpf to compile and run this example.</p> <p>Compile and run the above code:</p> <pre><code>$ ecc bashreadline.bpf.c\nCompiling bpf object...\nPacking ebpf object and config into package.json...\n$ sudo ecli run package.json\nRunning eBPF program...\n</code></pre> <p>After running this program, you can view the output of the eBPF program by checking the file <code>/sys/kernel/debug/tracing/trace_pipe</code>:</p> <pre><code>$ sudo cat /sys/kernel/debug/tracing/trace_pipe\n            bash-32969   [000] d..31 64001.375748: bpf_trace_printk: PID 32969 (bash) read: fff \n            bash-32969   [000] d..31 64002.056951: bpf_trace_printk: PID 32969 (bash) read: fff\n</code></pre> <p>You can see that we have successfully captured the <code>readline</code> function call of <code>bash</code> and obtained the command line entered by the user in <code>bash</code>.</p>"},{"location":"tutorials/5-uprobe-bashreadline/#summary","title":"Summary","text":"<p>In the above code, we used the <code>SEC</code> macro to define an uprobe probe, which specifies the user space program (<code>bin/bash</code>) to be captured and the function (<code>readline</code>) to be captured. In addition, we used the <code>BPF_KRETPROBE</code> macro to define a callback function (<code>printret</code>) for handling the return value of the <code>readline</code> function. This function can retrieve the return value of the <code>readline</code> function and print it to the kernel log. In this way, we can use eBPF to capture the <code>readline</code> function call of <code>bash</code> and obtain the command line entered by the user in <code>bash</code>.</p> <p>For more examples and detailed development guides, please refer to the official documentation of eunomia-bpf: https://github.com/eunomia-bpf/eunomia-bpf</p> <p>If you want to learn more about eBPF knowledge and practices, you can visit our tutorial code repository https://github.com/eunomia-bpf/bpf-developer-tutorial to get more examples and complete tutorials.</p>"},{"location":"tutorials/6-sigsnoop/","title":"eBPF Beginner's Development Practice Tutorial 6: Capturing a Collection of System Calls that Send Signals to Processes, Using a Hash Map to Store State","text":"<p>eBPF (Extended Berkeley Packet Filter) is a powerful network and performance analysis tool on the Linux kernel that allows developers to dynamically load, update, and run user-defined code at runtime.</p> <p>This article is the sixth part of the eBPF beginner's development practice tutorial, which mainly introduces how to implement an eBPF tool that captures a collection of system calls that send signals to processes and uses a hash map to store state.</p>"},{"location":"tutorials/6-sigsnoop/#sigsnoop","title":"sigsnoop","text":"<p>The example code is as follows:</p> <pre><code>#include &lt;vmlinux.h&gt;\n#include &lt;bpf/bpf_helpers.h&gt;\n#include &lt;bpf/bpf_tracing.h&gt;\n#define MAX_ENTRIES 10240\n#define TASK_COMM_LEN 16\nstruct event {\nunsigned int pid;\nunsigned int tpid;\nint sig;\nint ret;\nchar comm[TASK_COMM_LEN];\n};\nstruct {\n__uint(type, BPF_MAP_TYPE_HASH);\n__uint(max_entries, MAX_ENTRIES);\n__type(key, __u32);\n__type(value, struct event);\n} values SEC(\".maps\");\nstatic int probe_entry(pid_t tpid, int sig)\n{\nstruct event event = {};\n__u64 pid_tgid;\n__u32 tid;\npid_tgid = bpf_get_current_pid_tgid();\ntid = (__u32)pid_tgid;\nevent.pid = pid_tgid &gt;&gt; 32;\nevent.tpid = tpid;\nevent.sig = sig;\nbpf_get_current_comm(event.comm, sizeof(event.comm));\nbpf_map_update_elem(&amp;values, &amp;tid, &amp;event, BPF_ANY);\nreturn 0;\n}\nstatic int probe_exit(void *ctx, int ret)\n{\n__u64 pid_tgid = bpf_get_current_pid_tgid();\n__u32 tid = (__u32)pid_tgid;\nstruct event *eventp;\neventp = bpf_map_lookup_elem(&amp;values, &amp;tid);\nif (!eventp)\nreturn 0;\neventp-&gt;ret = ret;\nbpf_printk(\"PID %d (%s) sent signal %d \",\neventp-&gt;pid, eventp-&gt;comm, eventp-&gt;sig);\nbpf_printk(\"to PID %d, ret = %d\",\neventp-&gt;tpid, ret);\ncleanup:\nbpf_map_delete_elem(&amp;values, &amp;tid);\nreturn 0;\n}\nSEC(\"tracepoint/syscalls/sys_enter_kill\")\nint kill_entry(struct trace_event_raw_sys_enter *ctx)\n{\npid_t tpid = (pid_t)ctx-&gt;args[0];\nint sig = (int)ctx-&gt;args[1];\nreturn probe_entry(tpid, sig);\n}\nSEC(\"tracepoint/syscalls/sys_exit_kill\")\nint kill_exit(struct trace_event_raw_sys_exit *ctx)\n{\nreturn probe_exit(ctx, ctx-&gt;ret);\n}\nchar LICENSE[] SEC(\"license\") = \"Dual BSD/GPL\";\n</code></pre> <p>The above code defines an eBPF program for capturing system calls that send signals to processes, including kill, tkill, and tgkill. It captures the enter and exit events of system calls by using tracepoints, and executes specified probe functions such as <code>probe_entry</code> and <code>probe_exit</code> when these events occur.Instructions: Translate the following Chinese text to English  while maintaining the original formatting: \"In the probe function, we use the bpf_map to store the captured event information, including the process ID of the sending signal, the process ID of the receiving signal, the signal value, and the return value of the system call. When the system call exits, we retrieve the event information stored in the bpf_map and use bpf_printk to print the process ID, process name, sent signal, and return value of the system call.</p> <p>Finally, we also need to use the SEC macro to define the probe and specify the name of the system call to be captured and the probe function to be executed.</p> <p>eunomia-bpf is an open-source eBPF dynamic loading runtime and development toolchain that combines with Wasm. Its purpose is to simplify the development, building, distribution, and running of eBPF programs. You can refer to https://github.com/eunomia-bpf/eunomia-bpf for downloading and installing the ecc compilation toolchain and ecli runtime. We use eunomia-bpf to compile and run this example.</p> <p>Compile and run the above code:</p> <pre><code>docker run -it -v `pwd`/:/src/ ghcr.io/eunomia-bpf/ecc-`uname -m`:latest\n</code></pre> <p>or</p> <pre><code>$ ecc sigsnoop.bpf.c\nCompiling bpf object...\nGenerating export types...\nPacking ebpf object and config into package.json...\n$ sudo ecli run package.json\nRunning eBPF program...\n</code></pre> <p>After running this program, you can view the output of the eBPF program by checking the /sys/kernel/debug/tracing/trace_pipe file:</p> <pre><code>$ sudo cat /sys/kernel/debug/tracing/trace_pipe\n    systemd-journal-363     [000] d...1   672.563868: bpf_trace_printk: PID 363 (systemd-journal) sent signal 0\n    systemd-journal-363     [000] d...1   672.563869: bpf_trace_printk: to PID 1400, ret = 0\n    systemd-journal-363     [000] d...1   672.563870: bpf_trace_printk: PID 363 (systemd-journal) sent signal 0\n    systemd-journal-363     [000] d...1   672.563870: bpf_trace_printk: to PID 1527, ret = -3\n</code></pre>"},{"location":"tutorials/6-sigsnoop/#summary","title":"Summary","text":"<p>This article mainly introduces how to implement an eBPF tool to capture the collection of system calls sent by processes using signals and save the state using a hash map. Using a hash map requires defining a struct:</p> <pre><code>struct {\n__uint(type, BPF_MAP_TYPE_HASH);\n__uint(max_entries, MAX_ENTRIES);\n__type(key, __u32);\n__type(value, struct event);\n} values SEC(\".maps\");\n</code></pre> <p>And using corresponding APIs for access, such as bpf_map_lookup_elem, bpf_map_update_elem, bpf_map_delete_elem, etc.</p> <p>For more examples and detailed development guides, please refer to the official documentation of eunomia-bpf: https://github.com/eunomia-bpf/eunomia-bpf</p> <p>If you want to learn more about eBPF knowledge and practice, you can visit our tutorial code repository https://github.com/eunomia-bpf/bpf-developer-tutorial to get more examples and complete tutorials.\"</p>"},{"location":"tutorials/7-execsnoop/","title":"eBPF Beginner's Practical Tutorial Seven: Capturing Process Execution/Exit Time, Printing Output to User Space via perf event array","text":"<p>eBPF (Extended Berkeley Packet Filter) is a powerful network and performance analysis tool on the Linux kernel that allows developers to dynamically load, update, and run user-defined code at runtime.</p> <p>This article is the seventh part of the eBPF beginner's development tutorial and mainly introduces how to capture process execution events in the Linux kernel and print output to the user command line via a perf event array. This eliminates the need to view the output of eBPF programs by checking the <code>/sys/kernel/debug/tracing/trace_pipe</code> file. After sending information to user space via the perf event array, complex data processing and analysis can be performed.</p>"},{"location":"tutorials/7-execsnoop/#perf-buffer","title":"perf buffer","text":"<p>eBPF provides two circular buffers for transferring information from eBPF programs to user space controllers. The first one is the perf circular buffer, which has existed since at least kernel v4.15. The second one is the BPF circular buffer introduced later. This article only considers the perf circular buffer.</p>"},{"location":"tutorials/7-execsnoop/#execsnoop","title":"execsnoop","text":"<p>To print output to the user command line via the perf event array, a header file and a C source file need to be written. The example code is as follows:</p> <p>Header file: execsnoop.h</p> <pre><code>#ifndef __EXECSNOOP_H\n#define __EXECSNOOP_H\n#define TASK_COMM_LEN 16\nstruct event {\nint pid;\nint ppid;\nint uid;\nint retval;\nbool is_exit;\nchar comm[TASK_COMM_LEN];\n};\n#endif /* __EXECSNOOP_H */\n</code></pre> <p>Source file: execsnoop.bpf.c</p> <pre><code>// SPDX-License-Identifier: (LGPL-2.1 OR BSD-2-Clause)\n#include &lt;vmlinux.h&gt;\n#include &lt;bpf/bpf_helpers.h&gt;\n#include &lt;bpf/bpf_core_read.h&gt;\n#include \"execsnoop.h\"\nstruct {\n__uint(type, BPF_MAP_TYPE_PERF_EVENT_ARRAY);\n__uint(key_size, sizeof(u32));\n__uint(value_size, sizeof(u32));\n} events SEC(\".maps\");\nSEC(\"tracepoint/syscalls/sys_enter_execve\")\nint tracepoint_syscalls_sys_enter_execve(struct trace_event_raw_sys_enter* ctx)\n{\nu64 id;\npid_t pid, tgid;\nstruct event event={0};\nstruct task_struct *task;\nuid_t uid = (u32)bpf_get_current_uid_gid();\nid = bpf_get_current_pid_tgid();\ntgid = id &gt;&gt; 32;\nevent.pid = tgid;\nevent.uid = uid;\ntask = (struct task_struct*)bpf_get_current_task();\nevent.ppid = BPF_CORE_READ(task, real_parent, tgid);\nbpf_get_current_comm(&amp;event.comm, sizeof(event.comm));\nbpf_perf_event_output(ctx, &amp;events, BPF_F_CURRENT_CPU, &amp;event, sizeof(event));\nreturn 0;\n}\nchar LICENSE[] SEC(\"license\") = \"GPL\";\n</code></pre> <p>This code defines an eBPF program for capturing the entry of the <code>execve</code> system call.</p> <p>In the entry program, we first obtain the process ID and user ID of the current process, then use the <code>bpf_get_current_task</code> function to obtain the <code>task_struct</code> structure of the current process, and use the <code>bpf_get_current_comm</code> function to read the process name. Finally, we use the <code>bpf_perf_event_output</code> function to output the process execution event to the perf buffer.</p> <p>With this code, we can capture process execution events in the Linux kernel and analyze the process execution conditions.Instructions: Translate the following Chinese text to English while maintaining the original formatting:</p> <p>\"eunomia-bpf is an open-source eBPF dynamic loading runtime and development toolchain that combines with Wasm. Its goal is to simplify the development, building, distribution, and execution of eBPF programs. You can refer to the following link to download and install the ecc compilation toolchain and ecli runtime: https://github.com/eunomia-bpf/eunomia-bpf. We use eunomia-bpf to compile and execute this example.</p> <p>Compile using a container:</p> <pre><code>docker run -it -v `pwd`/:/src/ ghcr.io/eunomia-bpf/ecc-`uname -m`:latest\n</code></pre> <p>Or compile using ecc:</p> <pre><code>ecc execsnoop.bpf.c execsnoop.h\n</code></pre> <p>Run:</p> <pre><code>$ sudo ./ecli run package.json TIME     PID     PPID    UID     COMM    \n21:28:30  40747  3517    1000    node\n21:28:30  40748  40747   1000    sh\n21:28:30  40749  3517    1000    node\n21:28:30  40750  40749   1000    sh\n21:28:30  40751  3517    1000    node\n21:28:30  40752  40751   1000    sh\n21:28:30  40753  40752   1000    cpuUsage.sh\n</code></pre>"},{"location":"tutorials/7-execsnoop/#summary","title":"Summary","text":"<p>This article introduces how to capture events of processes running in the Linux kernel and print output to the user command-line using the perf event array. After sending information to the user space via the perf event array, complex data processing and analysis can be performed. In the corresponding kernel code of libbpf, a structure and corresponding header file can be defined as follows:</p> <pre><code>struct {\n__uint(type, BPF_MAP_TYPE_PERF_EVENT_ARRAY);\n__uint(key_size, sizeof(u32));\n__uint(value_size, sizeof(u32));\n} events SEC(\".maps\");\n</code></pre> <p>This allows sending information directly to the user space.</p> <p>For more examples and detailed development guide, please refer to the official documentation of eunomia-bpf: https://github.com/eunomia-bpf/eunomia-bpf.</p> <p>If you want to learn more about eBPF knowledge and practice, you can visit our tutorial code repository https://github.com/eunomia-bpf/bpf-developer-tutorial to get more examples and complete tutorials.\"</p>"},{"location":"tutorials/8-exitsnoop/","title":"eBPF Introductory Development Tutorial 8: Monitoring Process Exit Events with eBPF, Using Ring Buffer to Print Output to User Space","text":"<p>eBPF (Extended Berkeley Packet Filter) is a powerful network and performance analysis tool on the Linux kernel. It allows developers to dynamically load, update, and run user-defined code at runtime in the kernel.</p> <p>This article is the eighth part of the eBPF Introductory Development Tutorial, focusing on monitoring process exit events with eBPF.</p>"},{"location":"tutorials/8-exitsnoop/#ring-buffer","title":"Ring Buffer","text":"<p>There is now a new BPF data structure available called the eBPF ring buffer. It solves the memory efficiency and event reordering issues of the BPF perf buffer, which is currently the de facto standard for sending data from the kernel to user space. It provides compatibility with perf buffer for easy migration while also introducing new reserved/commit APIs for improved usability. Additionally, synthetic and real-world benchmark tests have shown that in nearly all cases, the eBPF ring buffer should be the default choice for sending data from BPF programs to user space.</p>"},{"location":"tutorials/8-exitsnoop/#ebpf-ring-buffer-vs-ebpf-perf-buffer","title":"eBPF Ring Buffer vs eBPF Perf Buffer","text":"<p>Whenever a BPF program needs to send collected data to user space for post-processing and logging, it typically uses the BPF perf buffer (perfbuf). Perfbuf is a collection of per-CPU circular buffers that allow efficient data exchange between the kernel and user space. It works well in practice, but it has two main drawbacks that have proven to be inconvenient: inefficient memory usage and event reordering.</p> <p>To address these issues, starting from Linux 5.8, BPF introduces a new BPF data structure called BPF ring buffer. It is a multiple producer, single consumer (MPSC) queue that can be safely shared across multiple CPUs.</p> <p>The BPF ring buffer supports familiar features from BPF perf buffer:</p> <ul> <li>Variable-length data records.</li> <li>Efficient reading of data from user space through memory-mapped regions without additional memory copies and/or entering kernel system calls.</li> <li>Support for epoll notifications and busy loop operations with absolute minimal latency.</li> </ul> <p>At the same time, the BPF ring buffer solves the following problems of the BPF perf buffer:</p> <ul> <li>Memory overhead.</li> <li>Data ordering.</li> <li>Unnecessary work and additional data copying.</li> </ul>"},{"location":"tutorials/8-exitsnoop/#exitsnoop","title":"exitsnoop","text":"<p>This article is the eighth part of the eBPF Introductory Development Tutorial, focusing on monitoring process exit events with eBPF and using the ring buffer to print output to user space.</p> <p>The steps for printing output to user space using the ring buffer are similar to perf buffer. First, a header file needs to be defined:</p> <p>Header File: exitsnoop.h</p> <pre><code>#ifndef __BOOTSTRAP_H\n#define __BOOTSTRAP_H\n#define TASK_COMM_LEN 16\n#define MAX_FILENAME_LEN 127\nstruct event {\nint pid;\nint ppid;\nunsigned exit_code;\nunsigned long long duration_ns;\nchar comm[TASK_COMM_LEN];\n};\n#endif /* __BOOTSTRAP_H */\n</code></pre> <p>Source File: exitsnoop.bpf.c</p> <pre><code>#include \"vmlinux.h\"\n#include &lt;bpf/bpf_helpers.h&gt;\n#include &lt;bpf/bpf_tracing.h&gt;\n#include &lt;bpf/bpf_core_read.h&gt;\n#include \"exitsnoop.h\"\nchar LICENSE[] SEC(\"license\") = \"Dual BSD/GPL\";\nstruct {\n__uint(type, BPF_MAP_TYPE_RINGBUF);\n__uint(max_entries, 256 * 1024);\n} rb SEC(\".maps\");\nSEC(\"tp/sched/sched_process_exit\")\nint handle_exit(struct trace_event_raw_sched_process_template* ctx)\n{\nstruct task_struct *task;\nstruct event *e;\npid_t pid, tid;\nu64 id, ts, *start_ts, duration_ns = 0;\n/* get PID and TID of exiting thread/process */\nid = bpf_get_current_pid_tgid();\npid = id &gt;&gt; 32;\nformat: rawtid = (u32)id;\n/* ignore thread exits */\nif (pid != tid)\nreturn 0;\n/* reserve sample from BPF ringbuf */\ne = bpf_ringbuf_reserve(&amp;rb, sizeof(*e), 0);\nif (!e)\nreturn 0;\n/* fill out the sample with data */\ntask = (struct task_struct *)bpf_get_current_task();\ne-&gt;duration_ns = duration_ns;\ne-&gt;pid = pid;\ne-&gt;ppid = BPF_CORE_READ(task, real_parent, tgid);\ne-&gt;exit_code = (BPF_CORE_READ(task, exit_code) &gt;&gt; 8) &amp; 0xff;\nbpf_get_current_comm(&amp;e-&gt;comm, sizeof(e-&gt;comm));\n/* send data to user-space for post-processing */\nbpf_ringbuf_submit(e, 0);\nreturn 0;\n}\n</code></pre> <p>This code demonstrates how to monitor process exit events using exitsnoop and print output to user space using a ring buffer:</p> <ol> <li>First, we include the required headers and exitsnoop.h.</li> <li>We define a global variable named \"LICENSE\" with the content \"Dual BSD/GPL\", which is the license requirement for eBPF programs.</li> <li>We define a mapping named rb of type BPF_MAP_TYPE_RINGBUF, which will be used to transfer data from kernel space to user space. We specify max_entries as 256 * 1024, representing the maximum capacity of the ring buffer.</li> <li>We define an eBPF program named handle_exit, which will be executed when a process exit event is triggered. It takes a trace_event_raw_sched_process_template struct pointer named ctx as the parameter.</li> <li>We use the bpf_get_current_pid_tgid() function to obtain the PID and TID of the current task. For the main thread, the PID and TID are the same; for child threads, they are different. Since we only care about the exit of the process (main thread), we return 0 if the PID and TID are different, ignoring the exit events of child threads.</li> <li>We use the bpf_ringbuf_reserve function to reserve space for the event struct e in the ring buffer. If the reservation fails, we return 0.</li> <li>We use the bpf_get_current_task() function to obtain a task_struct structure pointer for the current task.</li> <li>We fill in the process-related information into the reserved event struct e, including the duration of the process, PID, PPID, exit code, and process name.</li> <li>Finally, we use the bpf_ringbuf_submit function to submit the filled event struct e to the ring buffer, for further processing and output in user space.</li> </ol> <p>This example demonstrates how to capture process exit events using exitsnoop and a ring buffer in an eBPF program, and transfer relevant information to user space. This is useful for analyzing process exit reasons and monitoring system behavior.</p>"},{"location":"tutorials/8-exitsnoop/#compile-and-run","title":"Compile and Run","text":"<p>eunomia-bpf is an open-source eBPF dynamic loading runtime and development toolchain that combines with Wasm. Its purpose is to simplify the development, build, distribution, and execution of eBPF programs. You can refer to https://github.com/eunomia-bpf/eunomia-bpf to download and install the ecc compiler toolchain and ecli runtime. We will use eunomia-bpf to compile and run this example.</p> <p>Compile:</p> <pre><code>docker run -it -v `pwd`/:/src/ ghcr.io/eunomia-bpf/ecc-`uname -m`:latest\n</code></pre> <p>Or</p> <pre><code>$ ecc exitsnoop.bpf.c exitsnoop.h\nCompiling bpf object...\nGenerating export types...\nPacking ebpf object and config into package.json...\n</code></pre> <p>Run:</p> <p>```console $ sudo ./ecli run package.json  TIME     PID     PPID    EXIT_CODE  DURATION_NS  COMM\". format: Return only the translated content, not including the original text.21:40:09  42050  42049   0          0            which 21:40:09  42049  3517    0          0            sh 21:40:09  42052  42051   0          0            ps 21:40:09  42051  3517    0          0            sh 21:40:09  42055  42054   0          0            sed 21:40:09  42056  42054   0          0            cat 21:40:09  42057  42054   0          0            cat 21:40:09  42058  42054   0          0            cat 21:40:09  42059  42054   0          0            cat</p>"},{"location":"tutorials/8-exitsnoop/#summary","title":"Summary","text":"<p>This article introduces how to develop a simple BPF program using eunomia-bpf that can monitor process exit events in a Linux system and send the captured events to user space programs via a ring buffer. In this article, we compiled and ran this example using eunomia-bpf.</p> <p>To better understand and practice eBPF programming, we recommend reading the official documentation of eunomia-bpf at: https://github.com/eunomia-bpf/eunomia-bpf. Additionally, we provide a complete tutorial and source code for you to view and learn from at https://github.com/eunomia-bpf/bpf-developer-tutorial. We hope this tutorial helps you get started with eBPF development and provides useful references for your further learning and practice.</p>"},{"location":"tutorials/9-runqlat/","title":"eBPF Beginner's Development Tutorial 9: Capturing Process Scheduling Latency and Recording as Histogram","text":"<p>eBPF (Extended Berkeley Packet Filter) is a powerful network and performance analysis tool on the Linux kernel. It allows developers to dynamically load, update, and run user-defined code at runtime.</p> <p>runqlat is an eBPF tool used for analyzing the scheduling performance of the Linux system. Specifically, runqlat is used to measure the time a task waits in the run queue before being scheduled to run on a CPU. This information is very useful for identifying performance bottlenecks and improving the overall efficiency of the Linux kernel scheduling algorithm.</p>"},{"location":"tutorials/9-runqlat/#runqlat-principle","title":"runqlat Principle","text":"<p>This tutorial is the ninth part of the eBPF beginner's development series, with the topic \"Capturing Process Scheduling Latency\". Here, we will introduce a program called runqlat, which records process scheduling latency as a histogram.</p> <p>The Linux operating system uses processes to execute all system and user tasks. These processes can be blocked, killed, running, or waiting to run. The number of processes in the latter two states determines the length of the CPU run queue.</p> <p>Processes can have several possible states, such as:</p> <ul> <li>Runnable or running</li> <li>Interruptible sleep</li> <li>Uninterruptible sleep</li> <li>Stopped</li> <li>Zombie process</li> </ul> <p>Processes waiting for resources or other function signals are in the interruptible or uninterruptible sleep state: the process is put to sleep until the resource it needs becomes available. Then, depending on the type of sleep, the process can transition to the runnable state or remain asleep.</p> <p>Even when a process has all the resources it needs, it does not start running immediately. It transitions to the runnable state and is queued together with other processes in the same state. The CPU can execute these processes in the next few seconds or milliseconds. The scheduler arranges the processes for the CPU and determines the next process to run.</p> <p>Depending on the hardware configuration of the system, the length of this runnable queue (known as the CPU run queue) can be short or long. A short run queue length indicates that the CPU is not being fully utilized. On the other hand, if the run queue is long, it may mean that the CPU is not powerful enough to handle all the processes or that the number of CPU cores is insufficient. In an ideal CPU utilization, the length of the run queue will be equal to the number of cores in the system.</p> <p>Process scheduling latency, also known as \"run queue latency,\" is the time it takes for a thread to go from becoming runnable (e.g., receiving an interrupt that prompts it to do more work) to actually running on the CPU. In the case of CPU saturation, you can imagine that the thread has to wait for its turn. But in other peculiar scenarios, this can also happen, and in some cases, it can be reduced by tuning to improve the overall system performance.</p> <p>We will illustrate how to use the runqlat tool through an example. This is a heavily loaded system:</p> <pre><code># runqlat\nTracing run queue latency... Hit Ctrl-C to end.\n^C\n     usecs               : count     distribution\n         0 -&gt; 1          : 233      |***********                             |\n2 -&gt; 3          : 742      |************************************    |\n4 -&gt; 7          : 203      |**********                              |\n8 -&gt; 15         : 173      |********                                |\n16 -&gt; 31         : 24       |*                                       |\n32 -&gt; 63         : 0        |                                        |\n64 -&gt; 127        : 30       |*                                       |\n128 -&gt; 255        : 6        |                                        |\n256 -&gt; 511        : 3        |                                        |\n512 -&gt; 1023       : 5        |                                        |\n1024 -&gt; 2047       : 27       |*                                       |\".\nformat: Return only the translated content, not including the original text.## runqlat Code Implementation\n### runqlat.bpf.c\nFirst, we need to write a source code file `runqlat.bpf.c`:\n```c\n// SPDX-License-Identifier: GPL-2.0\n// Copyright (c) 2020 Wenbo Zhang\n#include &lt;vmlinux.h&gt;\n#include &lt;bpf/bpf_helpers.h&gt;\n#include &lt;bpf/bpf_core_read.h&gt;\n#include &lt;bpf/bpf_tracing.h&gt;\n#include \"runqlat.h\"\n#include \"bits.bpf.h\"\n#include \"maps.bpf.h\"\n#include \"core_fixes.bpf.h\"\n#define MAX_ENTRIES 10240\n#define TASK_RUNNING  0\nconst volatile bool filter_cg = false;\nconst volatile bool targ_per_process = false;\nconst volatile bool targ_per_thread = false;\nconst volatile bool targ_per_pidns = false;\nconst volatile bool targ_ms = false;\nconst volatile pid_t targ_tgid = 0;\nstruct {\n __uint(type, BPF_MAP_TYPE_CGROUP_ARRAY);\n __type(key, u32);\n __type(value, u32);\n __uint(max_entries, 1);\n} cgroup_map SEC(\".maps\");\nstruct {\n __uint(type, BPF_MAP_TYPE_HASH);\n __uint(max_entries, MAX_ENTRIES);\n __type(key, u32);\n __type(value, u64);\n} start SEC(\".maps\");\nstatic struct hist zero;\n/// @sample {\"interval\": 1000, \"type\" : \"log2_hist\"}\nstruct {\n __uint(type, BPF_MAP_TYPE_HASH);\n __uint(max_entries, MAX_ENTRIES);\n __type(key, u32);\n __type(value, struct hist);\n} hists SEC(\".maps\");\nstatic int trace_enqueue(u32 tgid, u32 pid)\n{\n``````cpp\nu64 ts;\nif (!pid)\n  return 0;\nif (targ_tgid &amp;&amp; targ_tgid != tgid)\n  return 0;\nts = bpf_ktime_get_ns();\nbpf_map_update_elem(&amp;start, &amp;pid, &amp;ts, BPF_ANY);\nreturn 0;\n}\nstatic unsigned int pid_namespace(struct task_struct *task)\n{\nstruct pid *pid;\nunsigned int level;\nstruct upid upid;\nunsigned int inum;\n/*  get the pid namespace by following task_active_pid_ns(),\n *  pid-&gt;numbers[pid-&gt;level].ns\n */\npid = BPF_CORE_READ(task, thread_pid);\nlevel = BPF_CORE_READ(pid, level);\nbpf_core_read(&amp;upid, sizeof(upid), &amp;pid-&gt;numbers[level]);\ninum = BPF_CORE_READ(upid.ns, ns.inum);\nreturn inum;\n}\nstatic int handle_switch(bool preempt, struct task_struct *prev, struct task_struct *next)\n{\nstruct hist *histp;\nu64 *tsp, slot;\nu32 pid, hkey;\ns64 delta;\nif (filter_cg &amp;&amp; !bpf_current_task_under_cgroup(&amp;cgroup_map, 0))\n  return 0;\nif (get_task_state(prev) == TASK_RUNNING)\n  trace_enqueue(BPF_CORE_READ(prev, tgid), BPF_CORE_READ(prev, pid));\npid = BPF_CORE_READ(next, pid);\ntsp = bpf_map_lookup_elem(&amp;start, &amp;pid);\nif (!tsp)\n  return 0;\ndelta = bpf_ktime_get_ns() - *tsp;\nif (delta &lt; 0)\n  goto cleanup;\nif (targ_per_process)\n  hkey = BPF_CORE_READ(next, tgid);\nelse if (targ_per_thread)\n  hkey = pid;\nelse if (targ_per_pidns)\n  hkey = pid_namespace(next);\nelse\n  hkey = -1;\nhistp = bpf_map_lookup_or_try_init(&amp;hists, &amp;hkey, &amp;zero);\nif (!histp)\n  goto cleanup;\nif (!histp-&gt;comm[0])\n  bpf_probe_read_kernel_str(&amp;histp-&gt;comm, sizeof(histp-&gt;comm),\n     next-&gt;comm);\nif (targ_ms)\n  delta /= 1000000U;\nelse\n  delta /= 1000U;\nslot = log2l(delta);\nif (slot &gt;= MAX_SLOTS)\n  slot = MAX_SLOTS - 1;\n__sync_fetch_and_add(&amp;histp-&gt;slots[slot], 1);\ncleanup:\nbpf_map_delete_elem(&amp;start, &amp;pid);\nreturn 0;\n}\nSEC(\"raw_tp/sched_wakeup\")\nint BPF_PROG(handle_sched_wakeup, struct task_struct *p)\n{\nif (filter_cg &amp;&amp; !bpf_current_task_under_cgroup(&amp;cgroup_map, 0))\n  return 0;\nreturn trace_enqueue(BPF_CORE_READ(p, tgid), BPF_CORE_READ(p, pid));\n}\nSEC(\"raw_tp/sched_wakeup_new\")\n```# BPF_PROG(handle_sched_wakeup_new, struct task_struct *p) Definition\nThe code defines a function named `BPF_PROG(handle_sched_wakeup_new, struct task_struct *p)`. It takes a handle and a `task_struct` pointer as parameters. The function checks if a filter condition `filter_cg` is true and whether the current task is under the cgroup using the `bpf_current_task_under_cgroup` function with the `cgroup_map` parameter. If the filter condition is true and the task is not under the cgroup, the function returns 0. Otherwise, it calls the `trace_enqueue` function with the `BPF_CORE_READ(p, tgid)` and `BPF_CORE_READ(p, pid)` values and returns the result.\n## SEC(\"raw_tp/sched_switch\") Definition\nThe code defines another function named `BPF_PROG(handle_sched_switch, bool preempt, struct task_struct *prev, struct task_struct *next)`. It is associated with the `raw_tp/sched_switch` security section. It takes a boolean parameter `preempt` and two `task_struct` pointers named `prev` and `next`. The function calls the `handle_switch` function with the `preempt`, `prev`, and `next` parameters and returns the result.\n## LICENSE Declaration\nThe code declares a character array named `LICENSE` and assigns it the value \"GPL\". It is associated with the `license` security section.\n## Constants and Global Variables\nThe code defines several constants and volatile global variables used for filtering corresponding tracing targets. These variables include:\n- `MAX_ENTRIES`: The maximum number of map entries.\n- `TASK_RUNNING`: The task status value.\n- `filter_cg`, `targ_per_process`, `targ_per_thread`, `targ_per_pidns`, `targ_ms`, `targ_tgid`: Boolean variables for filtering and target options. These options can be set by user-space programs to customize the behavior of the eBPF program.\n## eBPF Maps\nThe code defines several eBPF maps including:\n- `cgroup_map`: A cgroup array map used for filtering cgroups.\n- `start`: A hash map used to store timestamps when processes are enqueued.\n- `hists`: A hash map used to store histogram data for recording process scheduling delays.\n## Helper Functions\nThe code includes two helper functions:\n- `trace_enqueue`: This function is used to record the timestamp when a process is enqueued. It takes the `tgid` and `pid` values as parameters. If the `pid` value is 0 or the `targ_tgid` value is not 0 and not equal to `tgid`, the function returns 0. Otherwise, it retrieves the current timestamp using `bpf_ktime_get_ns` and updates the `start` map with the `pid` key and the timestamp value.\n- `pid_namespace`: This function is used to get the PID namespace of a process. It takes a `task_struct` pointer as a parameter and returns the PID namespace of the process. The function retrieves the PID namespace by following `task_active_pid_ns()` and `pid-&gt;numbers[pid-&gt;level].ns`.\nPlease note that the translation of function names and variable names may require further context.```\nlevel = BPF_CORE_READ(pid, level);\nbpf_core_read(&amp;upid, sizeof(upid), &amp;pid-&gt;numbers[level]);\ninum = BPF_CORE_READ(upid.ns, ns.inum);\nreturn inum;\n}\n</code></pre> <p>The <code>handle_switch</code> function is the core part, used to handle scheduling switch events, calculate process scheduling latency, and update histogram data:</p> <pre><code>static int handle_switch(bool preempt, struct task_struct *prev, struct task_struct *next)\n{\n...\n}\n</code></pre> <p>Firstly, the function determines whether to filter cgroup based on the setting of <code>filter_cg</code>. Then, if the previous process state is <code>TASK_RUNNING</code>, the <code>trace_enqueue</code> function is called to record the enqueue time of the process. Then, the function looks up the enqueue timestamp of the next process. If it is not found, it returns directly. The scheduling latency (delta) is calculated, and the key for the histogram map (hkey) is determined based on different options (targ_per_process, targ_per_thread, targ_per_pidns). Then, the histogram map is looked up or initialized, and the histogram data is updated. Finally, the enqueue timestamp record of the process is deleted.</p> <p>Next is the entry point of the eBPF program. The program uses three entry points to capture different scheduling events:</p> <ul> <li><code>handle_sched_wakeup</code>: Used to handle the <code>sched_wakeup</code> event triggered when a process is woken up from sleep state.</li> <li><code>handle_sched_wakeup_new</code>: Used to handle the <code>sched_wakeup_new</code> event triggered when a newly created process is woken up.</li> <li><code>handle_sched_switch</code>: Used to handle the <code>sched_switch</code> event triggered when the scheduler selects a new process to run.</li> </ul> <p>These entry points handle different scheduling events, but all call the <code>handle_switch</code> function to calculate the scheduling latency of the process and update the histogram data.</p> <p>Finally, the program includes a license declaration:</p> <pre><code>char LICENSE[] SEC(\"license\") = \"GPL\";\n</code></pre> <p>This declaration specifies the license type of the eBPF program, which is \"GPL\" in this case. This is required for many kernel features as they require eBPF programs to follow the GPL license.</p>"},{"location":"tutorials/9-runqlat/#runqlath","title":"runqlat.h","text":"<p>Next, we need to define a header file <code>runqlat.h</code> for handling events reported from kernel mode to user mode:</p> <pre><code>/* SPDX-License-Identifier: (LGPL-2.1 OR BSD-2-Clause) */\n#ifndef __RUNQLAT_H\n#define __RUNQLAT_H\n#define TASK_COMM_LEN 16\n#define MAX_SLOTS 26\nstruct hist {\n__u32 slots[MAX_SLOTS];\nchar comm[TASK_COMM_LEN];\n};\n#endif /* __RUNQLAT_H */\n</code></pre>"},{"location":"tutorials/9-runqlat/#compilation-and-execution","title":"Compilation and Execution","text":"<p><code>eunomia-bpf</code> is an open-source eBPF dynamic loading runtime and development toolkit combined with Wasm. Its purpose is to simplify the development, build, distribution, and execution of eBPF programs. You can refer to https://github.com/eunomia-bpf/eunomia-bpf to download and install the <code>ecc</code> compilation toolkit and <code>ecli</code> runtime. We will use <code>eunomia-bpf</code> to compile and run this example.</p> <p>Compile:</p> <pre><code>docker run -it -v `pwd`/:/src/ ghcr.io/eunomia-bpf/ecc-`uname -m`:latest\n</code></pre> <p>or</p> <pre><code>$ ecc runqlat.bpf.c runqlat.h\nCompiling bpf object...\nGenerating export types...\nPacking ebpf object and config into package.json...\n</code></pre> <p>Run:</p> <pre><code>$ sudo ecli run examples/bpftools/runqlat/package.json -h\nUsage: runqlat_bpf [--help] [--version] [--verbose] [--filter_cg] [--targ_per_process] [--targ_per_thread] [--targ_per_pidns] [--targ_ms] [--targ_tgid VAR]\nA simple eBPF program\nOptional arguments:\n-h, --help            shows help message and exits \n-v, --version         prints version information and exits \n--verbose             prints libbpf debug information \n--filter_cg           set value of bool variable filter_cg \n--targ_per_process    set value of bool variable targ_per_process \n--targ_per_thread     set value of bool variable targ_per_thread \n--targ_per_pidns      set value of bool variable targ_per_pidns \n--targ_ms             set value of bool variable targ_ms \n--targ_tgid           set value of pid_t variable targ_tgid \n$ sudo ecli run examples/bpftools/runqlat/package.json\nkey =  4294967295\ncomm = rcu_preempt\n     (unit)              : count    distribution\n         0 -&gt; 1          : 9        |****                                    |\n         2 -&gt; 3          : 6        |**                                      |\n         4 -&gt; 7          : 12       |*****                                   |\n         8 -&gt; 15         : 28       |*************                           |\n        16 -&gt; 31         : 40       |*******************                     |\n        32 -&gt; 63         : 83       |****************************************|\n        64 -&gt; 127        : 57       |***************************             |\n       128 -&gt; 255        : 19       |*********                               |\n       256 -&gt; 511        : 11       |*****                                   |\n       512 -&gt; 1023       : 2        |                                        |\n      1024 -&gt; 2047       : 2        |                                        |\n      2048 -&gt; 4095       : 0        |                                        |\n      4096 -&gt; 8191       : 0        |                                        |\n      8192 -&gt; 16383      : 0        |                                        |\n     16384 -&gt; 32767      : 1        |                                        |\n$ sudo ecli run examples/bpftools/runqlat/package.json --targ_per_process\nkey = 3189\ncomm = cpptools\n     (unit)              : count    distribution\n         0 -&gt; 1          : 0        |                                        |\n         2 -&gt; 3          : 0        |                                        |\n         4 -&gt; 7          : 0        |                                        |\n         8 -&gt; 15         : 1        |***                                     |\n        16 -&gt; 31         : 2        |*******                                 |\n        32 -&gt; 63         : 11       |****************************************|\n        64 -&gt; 127        : 8        |*****************************           |\n       128 -&gt; 255        : 3        |**********                              |\n</code></pre> <p>Complete source code can be found at: https://github.com/eunomia-bpf/bpf-developer-tutorial/tree/main/src/9-runqlat</p> <p>References: </p> <ul> <li>https://www.brendangregg.com/blog/2016-10-08/linux-bcc-runqlat.html</li> <li>https://github.com/iovisor/bcc/blob/master/libbpf-tools/runqlat.c</li> </ul>"},{"location":"tutorials/9-runqlat/#summary","title":"Summary","text":"<p>runqlat is a Linux kernel BPF program that summarizes scheduler run queue latency using a bar chart to show the length of time tasks wait to run on a CPU. To compile this program, you can use the <code>ecc</code> tool and to run it, you can use the <code>ecli</code> command.</p> <p>runqlat is a tool for monitoring process scheduling latency in the Linux kernel. It can help you understand the time processes spend waiting to run in the kernel and optimize process scheduling based on this information to improve system performance. The original source code can be found in libbpf-tools: https://github.com/iovisor/bcc/blob/master/libbpf-tools/runqlat.bpf.c</p> <p>For more examples and detailed development guide, please refer to the official documentation of eunomia-bpf: https://github.com/eunomia-bpf/eunomia-bpf</p> <p>If you want to learn more about eBPF knowledge and practices, you can visit our tutorial code repository at https://github.com/eunomia-bpf/bpf-developer-tutorial for more examples and complete tutorials.</p>"},{"location":"tutorials/bcc-documents/kernel-versions/","title":"BPF Features by Linux Kernel Version","text":""},{"location":"tutorials/bcc-documents/kernel-versions/#ebpf-support","title":"eBPF support","text":"Kernel version Commit 3.15 <code>bd4cf0ed331a</code>"},{"location":"tutorials/bcc-documents/kernel-versions/#jit-compiling","title":"JIT compiling","text":"<p>The list of supported architectures for your kernel can be retrieved with: <pre><code>git grep HAVE_EBPF_JIT arch/\n</code></pre></p> Feature / Architecture Kernel version Commit x86_64 3.16 <code>622582786c9e</code> ARM64 3.18 <code>e54bcde3d69d</code> s390 4.1 <code>054623105728</code> Constant blinding for JIT machines 4.7 <code>4f3446bb809f</code> PowerPC64 4.8 <code>156d0e290e96</code> Constant blinding - PowerPC64 4.9 <code>b7b7013cac55</code> Sparc64 4.12 <code>7a12b5031c6b</code> MIPS 4.13 <code>f381bf6d82f0</code> ARM32 4.14 <code>39c13c204bb1</code> x86_32 4.18 <code>03f5781be2c7</code> RISC-V RV64G 5.1 <code>2353ecc6f91f</code> RISC-V RV32G 5.7 <code>5f316b65e99f</code> PowerPC32 5.13 <code>51c66ad849a7</code> LoongArch 6.1 <code>5dc615520c4d</code>"},{"location":"tutorials/bcc-documents/kernel-versions/#main-features","title":"Main features","text":"<p>Several (but not all) of these main features translate to an eBPF program type. The list of such program types supported in your kernel can be found in file <code>include/uapi/linux/bpf.h</code>: <pre><code>git grep -W 'bpf_prog_type {' include/uapi/linux/bpf.h\n</code></pre></p> Feature Kernel version Commit <code>AF_PACKET</code> (libpcap/tcpdump, <code>cls_bpf</code> classifier, netfilter's <code>xt_bpf</code>, team driver's load-balancing mode\u2026) 3.15 <code>bd4cf0ed331a</code> Kernel helpers 3.15 <code>bd4cf0ed331a</code> <code>bpf()</code> syscall 3.18 <code>99c55f7d47c0</code> Maps (a.k.a. Tables; details below) 3.18 <code>99c55f7d47c0</code> BPF attached to sockets 3.19 <code>89aa075832b0</code> BPF attached to <code>kprobes</code> 4.1 <code>2541517c32be</code> <code>cls_bpf</code> / <code>act_bpf</code> for <code>tc</code> 4.1 <code>e2e9b6541dd4</code> Tail calls 4.2 <code>04fd61ab36ec</code> Non-root programs on sockets 4.4 <code>1be7f75d1668</code> Persistent maps and programs (virtual FS) 4.4 <code>b2197755b263</code> <code>tc</code>'s <code>direct-action</code> (<code>da</code>) mode 4.4 <code>045efa82ff56</code> <code>tc</code>'s <code>clsact</code> qdisc 4.5 <code>1f211a1b929c</code> BPF attached to tracepoints 4.7 <code>98b5c2c65c29</code> Direct packet access 4.7 <code>969bf05eb3ce</code> XDP (see below) 4.8 <code>6a773a15a1e8</code> BPF attached to perf events 4.9 <code>0515e5999a46</code> Hardware offload for <code>tc</code>'s <code>cls_bpf</code> 4.9 <code>332ae8e2f6ec</code> Verifier exposure and internal hooks 4.9 <code>13a27dfc6697</code> BPF attached to cgroups for socket filtering 4.10 <code>0e33661de493</code> Lightweight tunnel encapsulation 4.10 <code>3a0af8fd61f9</code> eBPF support for <code>xt_bpf</code> module (iptables) 4.10 <code>2c16d6033264</code> BPF program tag 4.10 <code>7bd509e311f4</code> Tracepoints to debug BPF 4.11 (removed\u00a0in\u00a04.18) <code>a67edbf4fb6d</code> <code>4d220ed0f814</code> Testing / benchmarking BPF programs 4.12 <code>1cf1cae963c2</code> BPF programs and maps IDs 4.13 <code>dc4bb0e23561</code> BPF support for <code>sock_ops</code> 4.13 <code>40304b2a1567</code> BPF support for skbs on sockets 4.14 <code>b005fd189cec</code> bpftool utility in kernel sources 4.15 <code>71bb428fe2c1</code> BPF attached to cgroups as device controller 4.15 <code>ebc614f68736</code> bpf2bpf function calls 4.16 <code>cc8b0b92a169</code> BPF used for monitoring socket RX/TX data 4.17 <code>4f738adba30a</code> BPF attached to raw tracepoints 4.17 <code>c4f6699dfcb8</code> BPF attached to <code>bind()</code> system call 4.17 <code>4fbac77d2d09</code> <code>aac3fc320d94</code> BPF attached to <code>connect()</code> system call 4.17 <code>d74bad4e74ee</code> BPF Type Format (BTF) 4.18 <code>69b693f0aefa</code> AF_XDP 4.18 <code>fbfc504a24f5</code> bpfilter 4.18 <code>d2ba09c17a06</code> End.BPF action for seg6local LWT 4.18 <code>004d4b274e2a</code> BPF attached to LIRC devices 4.18 <code>f4364dcfc86d</code> Pass map values to map helpers 4.18 <code>d71962f3e627</code> BPF socket reuseport 4.19 <code>2dbb9b9e6df6</code> BPF flow dissector 4.20 <code>d58e468b1112</code> BPF 1M insn limit 5.2 <code>c04c0d2b968a</code> BPF cgroup sysctl 5.2 <code>7b146cebe30c</code> BPF raw tracepoint writable 5.2 <code>9df1c28bb752</code> BPF bounded loop 5.3 <code>2589726d12a1</code> BPF trampoline 5.5 <code>fec56f5890d9</code> BPF LSM hook 5.7 <code>fc611f47f218</code> <code>641cd7b06c91</code> BPF iterator 5.8 <code>180139dca8b3</code> BPF socket lookup hook 5.9 <code>e9ddbb7707ff</code> Sleepable BPF programs 5.10 <code>1e6c62a88215</code>"},{"location":"tutorials/bcc-documents/kernel-versions/#program-types","title":"Program types","text":"Program type Kernel version Commit Enum Socket filter 3.19 <code>ddd872bc3098</code> BPF_PROG_TYPE_SOCKET_FILTER Kprobe 4.1 <code>2541517c32be</code> BPF_PROG_TYPE_KPROBE traffic control (TC) 4.1 <code>96be4325f443</code> BPF_PROG_TYPE_SCHED_CLS traffic control (TC) 4.1 <code>94caee8c312d</code> BPF_PROG_TYPE_SCHED_ACT Tracepoint 4.7 <code>98b5c2c65c29</code> BPF_PROG_TYPE_TRACEPOINT XDP 4.8 <code>6a773a15a1e8</code> BPF_PROG_TYPE_XDP Perf event 4.9 <code>0515e5999a46</code> BPF_PROG_TYPE_PERF_EVENT cgroup socket filtering 4.10 <code>0e33661de493</code> BPF_PROG_TYPE_CGROUP_SKB cgroup sock modification 4.10 <code>610236587600</code> BPF_PROG_TYPE_CGROUP_SOCK lightweight tunnel (IN) 4.10 <code>3a0af8fd61f9</code> BPF_PROG_TYPE_LWT_IN lightweight tunnel (OUT) 4.10 <code>3a0af8fd61f9</code> BPF_PROG_TYPE_LWT_OUT lightweight tunnel (XMIT) 4.10 <code>3a0af8fd61f9</code> BPF_PROG_TYPE_LWT_XMIT cgroup sock ops (per conn) 4.13 <code>40304b2a1567</code> BPF_PROG_TYPE_SOCK_OPS stream parser / stream verdict 4.14 <code>b005fd189cec</code> BPF_PROG_TYPE_SK_SKB cgroup device manager 4.15 <code>ebc614f68736</code> BPF_PROG_TYPE_CGROUP_DEVICE socket msg verdict 4.17 <code>4f738adba30a</code> BPF_PROG_TYPE_SK_MSG Raw tracepoint 4.17 <code>c4f6699dfcb8</code> BPF_PROG_TYPE_RAW_TRACEPOINT socket binding 4.17 <code>4fbac77d2d09</code> BPF_PROG_TYPE_CGROUP_SOCK_ADDR LWT seg6local 4.18 <code>004d4b274e2a</code> BPF_PROG_TYPE_LWT_SEG6LOCAL lirc devices 4.18 <code>f4364dcfc86d</code> BPF_PROG_TYPE_LIRC_MODE2 lookup SO_REUSEPORT socket 4.19 <code>2dbb9b9e6df6</code> BPF_PROG_TYPE_SK_REUSEPORT flow dissector 4.20 <code>d58e468b1112</code> BPF_PROG_TYPE_FLOW_DISSECTOR cgroup sysctl 5.2 <code>7b146cebe30c</code> BPF_PROG_TYPE_CGROUP_SYSCTL writable raw tracepoints 5.2 <code>9df1c28bb752</code> BPF_PROG_TYPE_RAW_TRACEPOINT_WRITABLE cgroup getsockopt/setsockopt 5.3 <code>0d01da6afc54</code> BPF_PROG_TYPE_CGROUP_SOCKOPT Tracing (BTF/BPF trampoline) 5.5 <code>f1b9509c2fb0</code> BPF_PROG_TYPE_TRACING struct ops 5.6 <code>27ae7997a661</code> BPF_PROG_TYPE_STRUCT_OPS extensions 5.6 <code>be8704ff07d2</code> BPF_PROG_TYPE_EXT LSM 5.7 <code>fc611f47f218</code> BPF_PROG_TYPE_LSM lookup listening socket 5.9 <code>e9ddbb7707ff</code> BPF_PROG_TYPE_SK_LOOKUP Allow executing syscalls 5.15 <code>79a7f8bdb159</code> BPF_PROG_TYPE_SYSCALL"},{"location":"tutorials/bcc-documents/kernel-versions/#maps-aka-tables-in-bcc-lingo","title":"Maps (a.k.a. Tables, in BCC lingo)","text":""},{"location":"tutorials/bcc-documents/kernel-versions/#map-types","title":"Map types","text":"<p>The list of map types supported in your kernel can be found in file <code>include/uapi/linux/bpf.h</code>: <pre><code>git grep -W 'bpf_map_type {' include/uapi/linux/bpf.h\n</code></pre></p> Map type Kernel version Commit Enum Hash 3.19 <code>0f8e4bd8a1fc</code> BPF_MAP_TYPE_HASH Array 3.19 <code>28fbcfa08d8e</code> BPF_MAP_TYPE_ARRAY Prog array 4.2 <code>04fd61ab36ec</code> BPF_MAP_TYPE_PROG_ARRAY Perf events 4.3 <code>ea317b267e9d</code> BPF_MAP_TYPE_PERF_EVENT_ARRAY Per-CPU hash 4.6 <code>824bd0ce6c7c</code> BPF_MAP_TYPE_PERCPU_HASH Per-CPU array 4.6 <code>a10423b87a7e</code> BPF_MAP_TYPE_PERCPU_ARRAY Stack trace 4.6 <code>d5a3b1f69186</code> BPF_MAP_TYPE_STACK_TRACE cgroup array 4.8 <code>4ed8ec521ed5</code> BPF_MAP_TYPE_CGROUP_ARRAY LRU hash 4.10 <code>29ba732acbee</code> <code>3a08c2fd7634</code> BPF_MAP_TYPE_LRU_HASH LRU per-CPU hash 4.10 <code>8f8449384ec3</code> <code>961578b63474</code> BPF_MAP_TYPE_LRU_PERCPU_HASH LPM trie (longest-prefix match) 4.11 <code>b95a5c4db09b</code> BPF_MAP_TYPE_LPM_TRIE Array of maps 4.12 <code>56f668dfe00d</code> BPF_MAP_TYPE_ARRAY_OF_MAPS Hash of maps 4.12 <code>bcc6b1b7ebf8</code> BPF_MAP_TYPE_HASH_OF_MAPS Netdevice references (array) 4.14 <code>546ac1ffb70d</code> BPF_MAP_TYPE_DEVMAP Socket references (array) 4.14 <code>174a79ff9515</code> BPF_MAP_TYPE_SOCKMAP CPU references 4.15 <code>6710e1126934</code> BPF_MAP_TYPE_CPUMAP AF_XDP socket (XSK) references 4.18 <code>fbfc504a24f5</code> BPF_MAP_TYPE_XSKMAP Socket references (hashmap) 4.18 <code>81110384441a</code> BPF_MAP_TYPE_SOCKHASH cgroup storage 4.19 <code>de9cbbaadba5</code> BPF_MAP_TYPE_CGROUP_STORAGE reuseport sockarray 4.19 <code>5dc4c4b7d4e8</code> BPF_MAP_TYPE_REUSEPORT_SOCKARRAY precpu cgroup storage 4.20 <code>b741f1630346</code> BPF_MAP_TYPE_PERCPU_CGROUP_STORAGE queue 4.20 <code>f1a2e44a3aec</code> BPF_MAP_TYPE_QUEUE stack 4.20 <code>f1a2e44a3aec</code> BPF_MAP_TYPE_STACK socket local storage 5.2 <code>6ac99e8f23d4</code> BPF_MAP_TYPE_SK_STORAGE Netdevice references (hashmap) 5.4 <code>6f9d451ab1a3</code> BPF_MAP_TYPE_DEVMAP_HASH struct ops 5.6 <code>85d33df357b6</code> BPF_MAP_TYPE_STRUCT_OPS ring buffer 5.8 <code>457f44363a88</code> BPF_MAP_TYPE_RINGBUF inode storage 5.10 <code>8ea636848aca</code> BPF_MAP_TYPE_INODE_STORAGE task storage 5.11 <code>4cf1bc1f1045</code> BPF_MAP_TYPE_TASK_STORAGE Bloom filter 5.16 <code>9330986c0300</code> BPF_MAP_TYPE_BLOOM_FILTER user ringbuf 6.1 <code>583c1f420173</code> BPF_MAP_TYPE_USER_RINGBUF"},{"location":"tutorials/bcc-documents/kernel-versions/#map-userspace-api","title":"Map userspace API","text":"<p>Some (but not all) of these API features translate to a subcommand beginning with <code>BPF_MAP_</code>. The list of subcommands supported in your kernel can be found in file <code>include/uapi/linux/bpf.h</code>: <pre><code>git grep -W 'bpf_cmd {' include/uapi/linux/bpf.h\n</code></pre></p> Feature Kernel version Commit Basic operations (lookup, update, delete, <code>GET_NEXT_KEY</code>) 3.18 <code>db20fd2b0108</code> Pass flags to <code>UPDATE_ELEM</code> 3.19 <code>3274f52073d8</code> Pre-alloc map memory by default 4.6 <code>6c9059817432</code> Pass <code>NULL</code> to <code>GET_NEXT_KEY</code> 4.12 <code>8fe45924387b</code> Creation: select NUMA node 4.14 <code>96eabe7a40aa</code> Restrict access from syscall side 4.15 <code>6e71b04a8224</code> Creation: specify map name 4.15 <code>ad5b177bd73f</code> <code>LOOKUP_AND_DELETE_ELEM</code> 4.20 <code>bd513cd08f10</code> Creation: <code>BPF_F_ZERO_SEED</code> 5.0 <code>96b3b6c9091d</code> <code>BPF_F_LOCK</code> flag for lookup / update 5.1 <code>96049f3afd50</code> Restrict access from BPF side 5.2 <code>591fe9888d78</code> <code>FREEZE</code> 5.2 <code>87df15de441b</code> mmap() support for array maps 5.5 <code>fc9702273e2e</code> <code>LOOKUP_BATCH</code> 5.6 <code>cb4d03ab499d</code> <code>UPDATE_BATCH</code>, <code>DELETE_BATCH</code> 5.6 <code>aa2e93b8e58e</code> <code>LOOKUP_AND_DELETE_BATCH</code> 5.6 <code>057996380a42</code> <code>LOOKUP_AND_DELETE_ELEM</code> support for hash maps 5.14 <code>3e87f192b405</code>"},{"location":"tutorials/bcc-documents/kernel-versions/#xdp","title":"XDP","text":"<p>An approximate list of drivers or components supporting XDP programs for your kernel can be retrieved with: <pre><code>git grep -l XDP_SETUP_PROG drivers/\n</code></pre></p> Feature / Driver Kernel version Commit XDP core architecture 4.8 <code>6a773a15a1e8</code> Action: drop 4.8 <code>6a773a15a1e8</code> Action: pass on to stack 4.8 <code>6a773a15a1e8</code> Action: direct forwarding (on same port) 4.8 <code>6ce96ca348a9</code> Direct packet data write 4.8 <code>4acf6c0b84c9</code> Mellanox <code>mlx4</code> driver 4.8 <code>47a38e155037</code> Mellanox <code>mlx5</code> driver 4.9 <code>86994156c736</code> Netronome <code>nfp</code> driver 4.10 <code>ecd63a0217d5</code> QLogic (Cavium) <code>qed*</code> drivers 4.10 <code>496e05170958</code> <code>virtio_net</code> driver 4.10 <code>f600b6905015</code> Broadcom <code>bnxt_en</code> driver 4.11 <code>c6d30e8391b8</code> Intel <code>ixgbe*</code> drivers 4.12 <code>924708081629</code> Cavium <code>thunderx</code> driver 4.12 <code>05c773f52b96</code> Generic XDP 4.12 <code>b5cdae3291f7</code> Intel <code>i40e</code> driver 4.13 <code>0c8493d90b6b</code> Action: redirect 4.14 <code>6453073987ba</code> Support for tap 4.14 <code>761876c857cb</code> Support for veth 4.14 <code>d445516966dc</code> Intel <code>ixgbevf</code> driver 4.17 <code>c7aec59657b6</code> Freescale <code>dpaa2</code> driver 5.0 <code>7e273a8ebdd3</code> Socionext <code>netsec</code> driver 5.3 <code>ba2b232108d3</code> TI <code>cpsw</code> driver 5.3 <code>9ed4050c0d75</code> Intel <code>ice</code> driver 5.5 <code>efc2214b6047</code> Solarflare <code>sfc</code> driver 5.5 <code>eb9a36be7f3e</code> Marvell <code>mvneta</code> driver 5.5 <code>0db51da7a8e9</code> Microsoft <code>hv_netvsc</code> driver 5.6 <code>351e1581395f</code> Amazon <code>ena</code> driver 5.6 <code>838c93dc5449</code> <code>xen-netfront</code> driver 5.9 <code>6c5aa6fc4def</code> Intel <code>igb</code> driver 5.10 <code>9cbc948b5a20</code>"},{"location":"tutorials/bcc-documents/kernel-versions/#helpers","title":"Helpers","text":"<p>The list of helpers supported in your kernel can be found in file <code>include/uapi/linux/bpf.h</code>: <pre><code>git grep '  FN(' include/uapi/linux/bpf.h\n</code></pre></p> <p>Alphabetical order</p> Helper Kernel version License Commit <code>BPF_FUNC_bind()</code> 4.17 <code>d74bad4e74ee</code> <code>BPF_FUNC_bprm_opts_set()</code> 5.11 <code>3f6719c7b62f</code> <code>BPF_FUNC_btf_find_by_name_kind()</code> 5.14 <code>3d78417b60fb</code> <code>BPF_FUNC_cgrp_storage_delete()</code> 6.2 <code>c4bcfb38a95e</code> <code>BPF_FUNC_cgrp_storage_get()</code> 6.2 <code>c4bcfb38a95e</code> <code>BPF_FUNC_check_mtu()</code> 5.12 <code>34b2021cc616</code> <code>BPF_FUNC_clone_redirect()</code> 4.2 <code>3896d655f4d4</code> <code>BPF_FUNC_copy_from_user()</code> 5.10 <code>07be4c4a3e7a</code> <code>BPF_FUNC_copy_from_user_task()</code> 5.18 GPL <code>376040e47334</code> <code>BPF_FUNC_csum_diff()</code> 4.6 <code>7d672345ed29</code> <code>BPF_FUNC_csum_level()</code> 5.7 <code>7cdec54f9713</code> <code>BPF_FUNC_csum_update()</code> 4.9 <code>36bbef52c7eb</code> <code>BPF_FUNC_current_task_under_cgroup()</code> 4.9 <code>60d20f9195b2</code> <code>BPF_FUNC_d_path()</code> 5.10 <code>6e22ab9da793</code> <code>BPF_FUNC_dynptr_data()</code> 5.19 <code>34d4ef5775f7</code> <code>BPF_FUNC_dynptr_from_mem()</code> 5.19 <code>263ae152e962</code> <code>BPF_FUNC_dynptr_read()</code> 5.19 <code>13bbbfbea759</code> <code>BPF_FUNC_dynptr_write()</code> 5.19 <code>13bbbfbea759</code> <code>BPF_FUNC_fib_lookup()</code> 4.18 GPL <code>87f5fc7e48dd</code> <code>BPF_FUNC_find_vma()</code> 5.17 <code>7c7e3d31e785</code> <code>BPF_FUNC_for_each_map_elem()</code> 5.13 <code>69c087ba6225</code> <code>BPF_FUNC_get_attach_cookie()</code> 5.15 <code>7adfc6c9b315</code> <code>BPF_FUNC_get_branch_snapshot()</code> 5.16 GPL <code>856c02dbce4f</code> <code>BPF_FUNC_get_current_ancestor_cgroup_id()</code> 5.6 <code>b4490c5c4e02</code> <code>BPF_FUNC_get_cgroup_classid()</code> 4.3 <code>8d20aabe1c76</code> <code>BPF_FUNC_get_current_cgroup_id()</code> 4.18 <code>bf6fa2c893c5</code> <code>BPF_FUNC_get_current_comm()</code> 4.2 <code>ffeedafbf023</code> <code>BPF_FUNC_get_current_pid_tgid()</code> 4.2 <code>ffeedafbf023</code> <code>BPF_FUNC_get_current_task()</code> 4.8 GPL <code>606274c5abd8</code> <code>BPF_FUNC_get_current_task_btf()</code> 5.11 GPL <code>3ca1032ab7ab</code> <code>BPF_FUNC_get_current_uid_gid()</code> 4.2 <code>ffeedafbf023</code> <code>BPF_FUNC_get_func_arg()</code> 5.17 <code>f92c1e183604</code> <code>BPF_FUNC_get_func_arg_cnt()</code> 5.17 <code>f92c1e183604</code> <code>BPF_FUNC_get_func_ip()</code> 5.15 <code>5d8b583d04ae</code> <code>BPF_FUNC_get_func_ret()</code> 5.17 <code>f92c1e183604</code> <code>BPF_FUNC_get_retval()</code> 5.18 <code>b44123b4a3dc</code> <code>BPF_FUNC_get_hash_recalc()</code> 4.8 <code>13c5c240f789</code> <code>BPF_FUNC_get_listener_sock()</code> 5.1 <code>dbafd7ddd623</code> <code>BPF_FUNC_get_local_storage()</code> 4.19 <code>cd3394317653</code> <code>BPF_FUNC_get_netns_cookie()</code> 5.7 <code>f318903c0bf4</code> <code>BPF_FUNC_get_ns_current_pid_tgid()</code> 5.7 <code>b4490c5c4e02</code> <code>BPF_FUNC_get_numa_node_id()</code> 4.10 <code>2d0e30c30f84</code> <code>BPF_FUNC_get_prandom_u32()</code> 4.1 <code>03e69b508b6f</code> <code>BPF_FUNC_get_route_realm()</code> 4.4 <code>c46646d0484f</code> <code>BPF_FUNC_get_smp_processor_id()</code> 4.1 <code>c04167ce2ca0</code> <code>BPF_FUNC_get_socket_cookie()</code> 4.12 <code>91b8270f2a4d</code> <code>BPF_FUNC_get_socket_uid()</code> 4.12 <code>6acc5c291068</code> <code>BPF_FUNC_get_stack()</code> 4.18 GPL <code>de2ff05f48af</code> <code>BPF_FUNC_get_stackid()</code> 4.6 GPL <code>d5a3b1f69186</code> <code>BPF_FUNC_get_task_stack()</code> 5.9 <code>fa28dcb82a38</code> <code>BPF_FUNC_getsockopt()</code> 4.15 <code>cd86d1fd2102</code> <code>BPF_FUNC_ima_file_hash()</code> 5.18 <code>174b16946e39</code> <code>BPF_FUNC_ima_inode_hash()</code> 5.11 <code>27672f0d280a</code> <code>BPF_FUNC_inode_storage_delete()</code> 5.10 <code>8ea636848aca</code> <code>BPF_FUNC_inode_storage_get()</code> 5.10 <code>8ea636848aca</code> <code>BPF_FUNC_jiffies64()</code> 5.5 <code>5576b991e9c1</code> <code>BPF_FUNC_kallsyms_lookup_name()</code> 5.16 <code>d6aef08a872b</code> <code>BPF_FUNC_kptr_xchg()</code> 5.19 <code>c0a5a21c25f3</code> <code>BPF_FUNC_ktime_get_boot_ns()</code> 5.8 <code>71d19214776e</code> <code>BPF_FUNC_ktime_get_coarse_ns()</code> 5.11 <code>d05512618056</code> <code>BPF_FUNC_ktime_get_ns()</code> 4.1 <code>d9847d310ab4</code> <code>BPF_FUNC_ktime_get_tai_ns()</code> 6.1 <code>c8996c98f703</code> <code>BPF_FUNC_l3_csum_replace()</code> 4.1 <code>91bc4822c3d6</code> <code>BPF_FUNC_l4_csum_replace()</code> 4.1 <code>91bc4822c3d6</code> <code>BPF_FUNC_load_hdr_opt()</code> 5.10 <code>0813a841566f</code> <code>BPF_FUNC_loop()</code> 5.17 <code>e6f2dd0f8067</code> <code>BPF_FUNC_lwt_push_encap()</code> 4.18 <code>fe94cc290f53</code> <code>BPF_FUNC_lwt_seg6_action()</code> 4.18 <code>fe94cc290f53</code> <code>BPF_FUNC_lwt_seg6_adjust_srh()</code> 4.18 <code>fe94cc290f53</code> <code>BPF_FUNC_lwt_seg6_store_bytes()</code> 4.18 <code>fe94cc290f53</code> <code>BPF_FUNC_map_delete_elem()</code> 3.19 <code>d0003ec01c66</code> <code>BPF_FUNC_map_lookup_elem()</code> 3.19 <code>d0003ec01c66</code> <code>BPF_FUNC_map_lookup_percpu_elem()</code> 5.19 <code>07343110b293</code> <code>BPF_FUNC_map_peek_elem()</code> 4.20 <code>f1a2e44a3aec</code> <code>BPF_FUNC_map_pop_elem()</code> 4.20 <code>f1a2e44a3aec</code> <code>BPF_FUNC_map_push_elem()</code> 4.20 <code>f1a2e44a3aec</code> <code>BPF_FUNC_map_update_elem()</code> 3.19 <code>d0003ec01c66</code> <code>BPF_FUNC_msg_apply_bytes()</code> 4.17 <code>2a100317c9eb</code> <code>BPF_FUNC_msg_cork_bytes()</code> 4.17 <code>91843d540a13</code> <code>BPF_FUNC_msg_pop_data()</code> 5.0 <code>7246d8ed4dcc</code> <code>BPF_FUNC_msg_pull_data()</code> 4.17 <code>015632bb30da</code> <code>BPF_FUNC_msg_push_data()</code> 4.20 <code>6fff607e2f14</code> <code>BPF_FUNC_msg_redirect_hash()</code> 4.18 <code>81110384441a</code> <code>BPF_FUNC_msg_redirect_map()</code> 4.17 <code>4f738adba30a</code> <code>BPF_FUNC_per_cpu_ptr()</code> 5.10 <code>eaa6bcb71ef6</code> <code>BPF_FUNC_perf_event_output()</code> 4.4 GPL <code>a43eec304259</code> <code>BPF_FUNC_perf_event_read()</code> 4.3 GPL <code>35578d798400</code> <code>BPF_FUNC_perf_event_read_value()</code> 4.15 GPL <code>908432ca84fc</code> <code>BPF_FUNC_perf_prog_read_value()</code> 4.15 GPL <code>4bebdc7a85aa</code> <code>BPF_FUNC_probe_read()</code> 4.1 GPL <code>2541517c32be</code> <code>BPF_FUNC_probe_read_kernel()</code> 5.5 GPL <code>6ae08ae3dea2</code> <code>BPF_FUNC_probe_read_kernel_str()</code> 5.5 GPL <code>6ae08ae3dea2</code> <code>BPF_FUNC_probe_read_user()</code> 5.5 GPL <code>6ae08ae3dea2</code> <code>BPF_FUNC_probe_read_user_str()</code> 5.5 GPL <code>6ae08ae3dea2</code> <code>BPF_FUNC_probe_read_str()</code> 4.11 GPL <code>a5e8c07059d0</code> <code>BPF_FUNC_probe_write_user()</code> 4.8 GPL <code>96ae52279594</code> <code>BPF_FUNC_rc_keydown()</code> 4.18 GPL <code>f4364dcfc86d</code> <code>BPF_FUNC_rc_pointer_rel()</code> 5.0 GPL <code>01d3240a04f4</code> <code>BPF_FUNC_rc_repeat()</code> 4.18 GPL <code>f4364dcfc86d</code> <code>BPF_FUNC_read_branch_records()</code> 5.6 GPL <code>fff7b64355ea</code> <code>BPF_FUNC_redirect()</code> 4.4 <code>27b29f63058d</code> <code>BPF_FUNC_redirect_map()</code> 4.14 <code>97f91a7cf04f</code> <code>BPF_FUNC_redirect_neigh()</code> 5.10 <code>b4ab31414970</code> <code>BPF_FUNC_redirect_peer()</code> 5.10 <code>9aa1206e8f48</code> <code>BPF_FUNC_reserve_hdr_opt()</code> 5.10 <code>0813a841566f</code> <code>BPF_FUNC_ringbuf_discard()</code> 5.8 <code>457f44363a88</code> <code>BPF_FUNC_ringbuf_discard_dynptr()</code> 5.19 <code>bc34dee65a65</code> <code>BPF_FUNC_ringbuf_output()</code> 5.8 <code>457f44363a88</code> <code>BPF_FUNC_ringbuf_query()</code> 5.8 <code>457f44363a88</code> <code>BPF_FUNC_ringbuf_reserve()</code> 5.8 <code>457f44363a88</code> <code>BPF_FUNC_ringbuf_reserve_dynptr()</code> 5.19 <code>bc34dee65a65</code> <code>BPF_FUNC_ringbuf_submit()</code> 5.8 <code>457f44363a88</code> <code>BPF_FUNC_ringbuf_submit_dynptr()</code> 5.19 <code>bc34dee65a65</code> <code>BPF_FUNC_send_signal()</code> 5.3 <code>8b401f9ed244</code> <code>BPF_FUNC_send_signal_thread()</code> 5.5 <code>8482941f0906</code> <code>BPF_FUNC_seq_printf()</code> 5.7 GPL <code>492e639f0c22</code> <code>BPF_FUNC_seq_printf_btf()</code> 5.10 <code>eb411377aed9</code> <code>BPF_FUNC_seq_write()</code> 5.7 GPL <code>492e639f0c22</code> <code>BPF_FUNC_set_hash()</code> 4.13 <code>ded092cd73c2</code> <code>BPF_FUNC_set_hash_invalid()</code> 4.9 <code>7a4b28c6cc9f</code> <code>BPF_FUNC_set_retval()</code> 5.18 <code>b44123b4a3dc</code> <code>BPF_FUNC_setsockopt()</code> 4.13 <code>8c4b4c7e9ff0</code> <code>BPF_FUNC_sk_ancestor_cgroup_id()</code> 5.7 <code>f307fa2cb4c9</code> <code>BPF_FUNC_sk_assign()</code> 5.6 <code>cf7fbe660f2d</code> <code>BPF_FUNC_sk_cgroup_id()</code> 5.7 <code>f307fa2cb4c9</code> <code>BPF_FUNC_sk_fullsock()</code> 5.1 <code>46f8bc92758c</code> <code>BPF_FUNC_sk_lookup_tcp()</code> 4.20 <code>6acc9b432e67</code> <code>BPF_FUNC_sk_lookup_udp()</code> 4.20 <code>6acc9b432e67</code> <code>BPF_FUNC_sk_redirect_hash()</code> 4.18 <code>81110384441a</code> <code>BPF_FUNC_sk_redirect_map()</code> 4.14 <code>174a79ff9515</code> <code>BPF_FUNC_sk_release()</code> 4.20 <code>6acc9b432e67</code> <code>BPF_FUNC_sk_select_reuseport()</code> 4.19 <code>2dbb9b9e6df6</code> <code>BPF_FUNC_sk_storage_delete()</code> 5.2 <code>6ac99e8f23d4</code> <code>BPF_FUNC_sk_storage_get()</code> 5.2 <code>6ac99e8f23d4</code> <code>BPF_FUNC_skb_adjust_room()</code> 4.13 <code>2be7e212d541</code> <code>BPF_FUNC_skb_ancestor_cgroup_id()</code> 4.19 <code>7723628101aa</code> <code>BPF_FUNC_skb_change_head()</code> 4.10 <code>3a0af8fd61f9</code> <code>BPF_FUNC_skb_change_proto()</code> 4.8 <code>6578171a7ff0</code> <code>BPF_FUNC_skb_change_tail()</code> 4.9 <code>5293efe62df8</code> <code>BPF_FUNC_skb_change_type()</code> 4.8 <code>d2485c4242a8</code> <code>BPF_FUNC_skb_cgroup_classid()</code> 5.10 <code>b426ce83baa7</code> <code>BPF_FUNC_skb_cgroup_id()</code> 4.18 <code>cb20b08ead40</code> <code>BPF_FUNC_skb_ecn_set_ce()</code> 5.1 <code>f7c917ba11a6</code> <code>BPF_FUNC_skb_get_tunnel_key()</code> 4.3 <code>d3aa45ce6b94</code> <code>BPF_FUNC_skb_get_tunnel_opt()</code> 4.6 <code>14ca0751c96f</code> <code>BPF_FUNC_skb_get_xfrm_state()</code> 4.18 <code>12bed760a78d</code> <code>BPF_FUNC_skb_load_bytes()</code> 4.5 <code>05c74e5e53f6</code> <code>BPF_FUNC_skb_load_bytes_relative()</code> 4.18 <code>4e1ec56cdc59</code> <code>BPF_FUNC_skb_output()</code> 5.5 <code>a7658e1a4164</code> <code>BPF_FUNC_skb_pull_data()</code> 4.9 <code>36bbef52c7eb</code> <code>BPF_FUNC_skb_set_tstamp()</code> 5.18 <code>9bb984f28d5b</code> <code>BPF_FUNC_skb_set_tunnel_key()</code> 4.3 <code>d3aa45ce6b94</code> <code>BPF_FUNC_skb_set_tunnel_opt()</code> 4.6 <code>14ca0751c96f</code> <code>BPF_FUNC_skb_store_bytes()</code> 4.1 <code>91bc4822c3d6</code> <code>BPF_FUNC_skb_under_cgroup()</code> 4.8 <code>4a482f34afcc</code> <code>BPF_FUNC_skb_vlan_pop()</code> 4.3 <code>4e10df9a60d9</code> <code>BPF_FUNC_skb_vlan_push()</code> 4.3 <code>4e10df9a60d9</code> <code>BPF_FUNC_skc_lookup_tcp()</code> 5.2 <code>edbf8c01de5a</code> <code>BPF_FUNC_skc_to_mctcp_sock()</code> 5.19 <code>3bc253c2e652</code> <code>BPF_FUNC_skc_to_tcp_sock()</code> 5.9 <code>478cfbdf5f13</code> <code>BPF_FUNC_skc_to_tcp_request_sock()</code> 5.9 <code>478cfbdf5f13</code> <code>BPF_FUNC_skc_to_tcp_timewait_sock()</code> 5.9 <code>478cfbdf5f13</code> <code>BPF_FUNC_skc_to_tcp6_sock()</code> 5.9 <code>af7ec1383361</code> <code>BPF_FUNC_skc_to_udp6_sock()</code> 5.9 <code>0d4fad3e57df</code> <code>BPF_FUNC_skc_to_unix_sock()</code> 5.16 <code>9eeb3aa33ae0</code> <code>BPF_FUNC_snprintf()</code> 5.13 <code>7b15523a989b</code> <code>BPF_FUNC_snprintf_btf()</code> 5.10 <code>c4d0bfb45068</code> <code>BPF_FUNC_sock_from_file()</code> 5.11 <code>4f19cab76136</code> <code>BPF_FUNC_sock_hash_update()</code> 4.18 <code>81110384441a</code> <code>BPF_FUNC_sock_map_update()</code> 4.14 <code>174a79ff9515</code> <code>BPF_FUNC_spin_lock()</code> 5.1 <code>d83525ca62cf</code> <code>BPF_FUNC_spin_unlock()</code> 5.1 <code>d83525ca62cf</code> <code>BPF_FUNC_store_hdr_opt()</code> 5.10 <code>0813a841566f</code> <code>BPF_FUNC_strncmp()</code> 5.17 <code>c5fb19937455</code> <code>BPF_FUNC_strtol()</code> 5.2 <code>d7a4cb9b6705</code> <code>BPF_FUNC_strtoul()</code> 5.2 <code>d7a4cb9b6705</code> <code>BPF_FUNC_sys_bpf()</code> 5.14 <code>79a7f8bdb159</code> <code>BPF_FUNC_sys_close()</code> 5.14 <code>3abea089246f</code> <code>BPF_FUNC_sysctl_get_current_value()</code> 5.2 <code>1d11b3016cec</code> <code>BPF_FUNC_sysctl_get_name()</code> 5.2 <code>808649fb787d</code> <code>BPF_FUNC_sysctl_get_new_value()</code> 5.2 <code>4e63acdff864</code> <code>BPF_FUNC_sysctl_set_new_value()</code> 5.2 <code>4e63acdff864</code> <code>BPF_FUNC_tail_call()</code> 4.2 <code>04fd61ab36ec</code> <code>BPF_FUNC_task_pt_regs()</code> 5.15 GPL <code>dd6e10fbd9f</code> <code>BPF_FUNC_task_storage_delete()</code> 5.11 <code>4cf1bc1f1045</code> <code>BPF_FUNC_task_storage_get()</code> 5.11 <code>4cf1bc1f1045</code> <code>BPF_FUNC_tcp_check_syncookie()</code> 5.2 <code>399040847084</code> <code>BPF_FUNC_tcp_gen_syncookie()</code> 5.3 <code>70d66244317e</code> <code>BPF_FUNC_tcp_raw_check_syncookie_ipv4()</code> 6.0 <code>33bf9885040c</code> <code>BPF_FUNC_tcp_raw_check_syncookie_ipv6()</code> 6.0 <code>33bf9885040c</code> <code>BPF_FUNC_tcp_raw_gen_syncookie_ipv4()</code> 6.0 <code>33bf9885040c</code> <code>BPF_FUNC_tcp_raw_gen_syncookie_ipv6()</code> 6.0 <code>33bf9885040c</code> <code>BPF_FUNC_tcp_send_ack()</code> 5.5 <code>206057fe020a</code> <code>BPF_FUNC_tcp_sock()</code> 5.1 <code>655a51e536c0</code> <code>BPF_FUNC_this_cpu_ptr()</code> 5.10 <code>63d9b80dcf2c</code> <code>BPF_FUNC_timer_init()</code> 5.15 <code>b00628b1c7d5</code> <code>BPF_FUNC_timer_set_callback()</code> 5.15 <code>b00628b1c7d5</code> <code>BPF_FUNC_timer_start()</code> 5.15 <code>b00628b1c7d5</code> <code>BPF_FUNC_timer_cancel()</code> 5.15 <code>b00628b1c7d5</code> <code>BPF_FUNC_trace_printk()</code> 4.1 GPL <code>9c959c863f82</code> <code>BPF_FUNC_trace_vprintk()</code> 5.16 GPL <code>10aceb629e19</code> <code>BPF_FUNC_user_ringbuf_drain()</code> 6.1 <code>205715673844</code> <code>BPF_FUNC_xdp_adjust_head()</code> 4.10 <code>17bedab27231</code> <code>BPF_FUNC_xdp_adjust_meta()</code> 4.15 <code>de8f3a83b0a0</code> <code>BPF_FUNC_xdp_adjust_tail()</code> 4.18 <code>b32cc5b9a346</code> <code>BPF_FUNC_xdp_get_buff_len()</code> 5.18 <code>0165cc817075</code> <code>BPF_FUNC_xdp_load_bytes()</code> 5.18 <code>3f364222d032</code> <code>BPF_FUNC_xdp_store_bytes()</code> 5.18 <code>3f364222d032</code> <code>BPF_FUNC_xdp_output()</code> 5.6 GPL <code>d831ee84bfc9</code> <code>BPF_FUNC_override_return()</code> 4.16 GPL <code>9802d86585db</code> <code>BPF_FUNC_sock_ops_cb_flags_set()</code> 4.16 <code>b13d88072172</code> <p>Note: GPL-only BPF helpers require a GPL-compatible license. The current licenses considered GPL-compatible by the kernel are:</p> <ul> <li>GPL</li> <li>GPL v2</li> <li>GPL and additional rights</li> <li>Dual BSD/GPL</li> <li>Dual MIT/GPL</li> <li>Dual MPL/GPL</li> </ul> <p>Check the list of GPL-compatible licenses in your kernel source code.</p>"},{"location":"tutorials/bcc-documents/kernel-versions/#program-types_1","title":"Program Types","text":"<p>The list of program types and supported helper functions can be retrieved with: <pre><code>git grep -W 'func_proto(enum bpf_func_id func_id' kernel/ net/ drivers/\n</code></pre></p> Program Type Helper Functions <code>BPF_PROG_TYPE_SOCKET_FILTER</code> <code>BPF_FUNC_skb_load_bytes()</code> <code>BPF_FUNC_skb_load_bytes_relative()</code> <code>BPF_FUNC_get_socket_cookie()</code> <code>BPF_FUNC_get_socket_uid()</code> <code>BPF_FUNC_perf_event_output()</code> <code>Base functions</code> <code>BPF_PROG_TYPE_KPROBE</code> <code>BPF_FUNC_perf_event_output()</code> <code>BPF_FUNC_get_stackid()</code> <code>BPF_FUNC_get_stack()</code> <code>BPF_FUNC_perf_event_read_value()</code> <code>BPF_FUNC_override_return()</code> <code>Tracing functions</code> <code>BPF_PROG_TYPE_SCHED_CLS</code> <code>BPF_PROG_TYPE_SCHED_ACT</code> <code>BPF_FUNC_skb_store_bytes()</code> <code>BPF_FUNC_skb_load_bytes()</code> <code>BPF_FUNC_skb_load_bytes_relative()</code> <code>BPF_FUNC_skb_pull_data()</code> <code>BPF_FUNC_csum_diff()</code> <code>BPF_FUNC_csum_update()</code> <code>BPF_FUNC_l3_csum_replace()</code> <code>BPF_FUNC_l4_csum_replace()</code> <code>BPF_FUNC_clone_redirect()</code> <code>BPF_FUNC_get_cgroup_classid()</code> <code>BPF_FUNC_skb_vlan_push()</code> <code>BPF_FUNC_skb_vlan_pop()</code> <code>BPF_FUNC_skb_change_proto()</code> <code>BPF_FUNC_skb_change_type()</code> <code>BPF_FUNC_skb_adjust_room()</code> <code>BPF_FUNC_skb_change_tail()</code> <code>BPF_FUNC_skb_get_tunnel_key()</code> <code>BPF_FUNC_skb_set_tunnel_key()</code> <code>BPF_FUNC_skb_get_tunnel_opt()</code> <code>BPF_FUNC_skb_set_tunnel_opt()</code> <code>BPF_FUNC_redirect()</code> <code>BPF_FUNC_get_route_realm()</code> <code>BPF_FUNC_get_hash_recalc()</code> <code>BPF_FUNC_set_hash_invalid()</code> <code>BPF_FUNC_set_hash()</code> <code>BPF_FUNC_perf_event_output()</code> <code>BPF_FUNC_get_smp_processor_id()</code> <code>BPF_FUNC_skb_under_cgroup()</code> <code>BPF_FUNC_get_socket_cookie()</code> <code>BPF_FUNC_get_socket_uid()</code> <code>BPF_FUNC_fib_lookup()</code> <code>BPF_FUNC_skb_get_xfrm_state()</code> <code>BPF_FUNC_skb_cgroup_id()</code> <code>Base functions</code> <code>BPF_PROG_TYPE_TRACEPOINT</code> <code>BPF_FUNC_perf_event_output()</code> <code>BPF_FUNC_get_stackid()</code> <code>BPF_FUNC_get_stack()</code> <code>BPF_FUNC_d_path()</code> <code>Tracing functions</code> <code>BPF_PROG_TYPE_XDP</code> <code>BPF_FUNC_perf_event_output()</code> <code>BPF_FUNC_get_smp_processor_id()</code> <code>BPF_FUNC_csum_diff()</code> <code>BPF_FUNC_xdp_adjust_head()</code> <code>BPF_FUNC_xdp_adjust_meta()</code> <code>BPF_FUNC_redirect()</code> <code>BPF_FUNC_redirect_map()</code> <code>BPF_FUNC_xdp_adjust_tail()</code> <code>BPF_FUNC_fib_lookup()</code> <code>Base functions</code> <code>BPF_PROG_TYPE_PERF_EVENT</code> <code>BPF_FUNC_perf_event_output()</code> <code>BPF_FUNC_get_stackid()</code> <code>BPF_FUNC_get_stack()</code> <code>BPF_FUNC_perf_prog_read_value()</code> <code>Tracing functions</code> <code>BPF_PROG_TYPE_CGROUP_SKB</code> <code>BPF_FUNC_skb_load_bytes()</code> <code>BPF_FUNC_skb_load_bytes_relative()</code> <code>BPF_FUNC_get_socket_cookie()</code> <code>BPF_FUNC_get_socket_uid()</code> <code>Base functions</code> <code>BPF_PROG_TYPE_CGROUP_SOCK</code> <code>BPF_FUNC_get_current_uid_gid()</code> <code>Base functions</code> <code>BPF_PROG_TYPE_LWT_IN</code> <code>BPF_FUNC_lwt_push_encap()</code> <code>LWT functions</code> <code>Base functions</code> <code>BPF_PROG_TYPE_LWT_OUT</code> <code>LWT functions</code> <code>Base functions</code> <code>BPF_PROG_TYPE_LWT_XMIT</code> <code>BPF_FUNC_skb_get_tunnel_key()</code> <code>BPF_FUNC_skb_set_tunnel_key()</code> <code>BPF_FUNC_skb_get_tunnel_opt()</code> <code>BPF_FUNC_skb_set_tunnel_opt()</code> <code>BPF_FUNC_redirect()</code> <code>BPF_FUNC_clone_redirect()</code> <code>BPF_FUNC_skb_change_tail()</code> <code>BPF_FUNC_skb_change_head()</code> <code>BPF_FUNC_skb_store_bytes()</code> <code>BPF_FUNC_csum_update()</code> <code>BPF_FUNC_l3_csum_replace()</code> <code>BPF_FUNC_l4_csum_replace()</code> <code>BPF_FUNC_set_hash_invalid()</code> <code>LWT functions</code> <code>BPF_PROG_TYPE_SOCK_OPS</code> <code>BPF_FUNC_setsockopt()</code> <code>BPF_FUNC_getsockopt()</code> <code>BPF_FUNC_sock_ops_cb_flags_set()</code> <code>BPF_FUNC_sock_map_update()</code> <code>BPF_FUNC_sock_hash_update()</code> <code>BPF_FUNC_get_socket_cookie()</code> <code>Base functions</code> <code>BPF_PROG_TYPE_SK_SKB</code> <code>BPF_FUNC_skb_store_bytes()</code> <code>BPF_FUNC_skb_load_bytes()</code> <code>BPF_FUNC_skb_pull_data()</code> <code>BPF_FUNC_skb_change_tail()</code> <code>BPF_FUNC_skb_change_head()</code> <code>BPF_FUNC_get_socket_cookie()</code> <code>BPF_FUNC_get_socket_uid()</code> <code>BPF_FUNC_sk_redirect_map()</code> <code>BPF_FUNC_sk_redirect_hash()</code> <code>BPF_FUNC_sk_lookup_tcp()</code> <code>BPF_FUNC_sk_lookup_udp()</code> <code>BPF_FUNC_sk_release()</code> <code>Base functions</code> <code>BPF_PROG_TYPE_CGROUP_DEVICE</code> <code>BPF_FUNC_map_lookup_elem()</code> <code>BPF_FUNC_map_update_elem()</code> <code>BPF_FUNC_map_delete_elem()</code> <code>BPF_FUNC_get_current_uid_gid()</code> <code>BPF_FUNC_trace_printk()</code> <code>BPF_PROG_TYPE_SK_MSG</code> <code>BPF_FUNC_msg_redirect_map()</code> <code>BPF_FUNC_msg_redirect_hash()</code> <code>BPF_FUNC_msg_apply_bytes()</code> <code>BPF_FUNC_msg_cork_bytes()</code> <code>BPF_FUNC_msg_pull_data()</code> <code>BPF_FUNC_msg_push_data()</code> <code>BPF_FUNC_msg_pop_data()</code> <code>Base functions</code> <code>BPF_PROG_TYPE_RAW_TRACEPOINT</code> <code>BPF_FUNC_perf_event_output()</code> <code>BPF_FUNC_get_stackid()</code> <code>BPF_FUNC_get_stack()</code> <code>BPF_FUNC_skb_output()</code> <code>Tracing functions</code> <code>BPF_PROG_TYPE_CGROUP_SOCK_ADDR</code> <code>BPF_FUNC_get_current_uid_gid()</code> <code>BPF_FUNC_bind()</code> <code>BPF_FUNC_get_socket_cookie()</code> <code>Base functions</code> <code>BPF_PROG_TYPE_LWT_SEG6LOCAL</code> <code>BPF_FUNC_lwt_seg6_store_bytes()</code> <code>BPF_FUNC_lwt_seg6_action()</code> <code>BPF_FUNC_lwt_seg6_adjust_srh()</code> <code>LWT functions</code> <code>BPF_PROG_TYPE_LIRC_MODE2</code> <code>BPF_FUNC_rc_repeat()</code> <code>BPF_FUNC_rc_keydown()</code> <code>BPF_FUNC_rc_pointer_rel()</code> <code>BPF_FUNC_map_lookup_elem()</code> <code>BPF_FUNC_map_update_elem()</code> <code>BPF_FUNC_map_delete_elem()</code> <code>BPF_FUNC_ktime_get_ns()</code> <code>BPF_FUNC_tail_call()</code> <code>BPF_FUNC_get_prandom_u32()</code> <code>BPF_FUNC_trace_printk()</code> <code>BPF_PROG_TYPE_SK_REUSEPORT</code> <code>BPF_FUNC_sk_select_reuseport()</code> <code>BPF_FUNC_skb_load_bytes()</code> <code>BPF_FUNC_load_bytes_relative()</code> <code>Base functions</code> <code>BPF_PROG_TYPE_FLOW_DISSECTOR</code> <code>BPF_FUNC_skb_load_bytes()</code> <code>Base functions</code> Function Group Functions <code>Base functions</code> <code>BPF_FUNC_map_lookup_elem()</code> <code>BPF_FUNC_map_update_elem()</code> <code>BPF_FUNC_map_delete_elem()</code> <code>BPF_FUNC_map_peek_elem()</code> <code>BPF_FUNC_map_pop_elem()</code> <code>BPF_FUNC_map_push_elem()</code> <code>BPF_FUNC_get_prandom_u32()</code> <code>BPF_FUNC_get_smp_processor_id()</code> <code>BPF_FUNC_get_numa_node_id()</code> <code>BPF_FUNC_tail_call()</code> <code>BPF_FUNC_ktime_get_boot_ns()</code> <code>BPF_FUNC_ktime_get_ns()</code> <code>BPF_FUNC_trace_printk()</code> <code>BPF_FUNC_spin_lock()</code> <code>BPF_FUNC_spin_unlock()</code> <code>Tracing functions</code> <code>BPF_FUNC_map_lookup_elem()</code> <code>BPF_FUNC_map_update_elem()</code> <code>BPF_FUNC_map_delete_elem()</code> <code>BPF_FUNC_probe_read()</code> <code>BPF_FUNC_ktime_get_boot_ns()</code> <code>BPF_FUNC_ktime_get_ns()</code> <code>BPF_FUNC_tail_call()</code> <code>BPF_FUNC_get_current_pid_tgid()</code> <code>BPF_FUNC_get_current_task()</code> <code>BPF_FUNC_get_current_uid_gid()</code> <code>BPF_FUNC_get_current_comm()</code> <code>BPF_FUNC_trace_printk()</code> <code>BPF_FUNC_get_smp_processor_id()</code> <code>BPF_FUNC_get_numa_node_id()</code> <code>BPF_FUNC_perf_event_read()</code> <code>BPF_FUNC_probe_write_user()</code> <code>BPF_FUNC_current_task_under_cgroup()</code> <code>BPF_FUNC_get_prandom_u32()</code> <code>BPF_FUNC_probe_read_str()</code> <code>BPF_FUNC_get_current_cgroup_id()</code> <code>BPF_FUNC_send_signal()</code> <code>BPF_FUNC_probe_read_kernel()</code> <code>BPF_FUNC_probe_read_kernel_str()</code> <code>BPF_FUNC_probe_read_user()</code> <code>BPF_FUNC_probe_read_user_str()</code> <code>BPF_FUNC_send_signal_thread()</code> <code>BPF_FUNC_get_ns_current_pid_tgid()</code> <code>BPF_FUNC_xdp_output()</code> <code>BPF_FUNC_get_task_stack()</code> <code>LWT functions</code> <code>BPF_FUNC_skb_load_bytes()</code> <code>BPF_FUNC_skb_pull_data()</code> <code>BPF_FUNC_csum_diff()</code> <code>BPF_FUNC_get_cgroup_classid()</code> <code>BPF_FUNC_get_route_realm()</code> <code>BPF_FUNC_get_hash_recalc()</code> <code>BPF_FUNC_perf_event_output()</code> <code>BPF_FUNC_get_smp_processor_id()</code> <code>BPF_FUNC_skb_under_cgroup()</code>"},{"location":"tutorials/bcc-documents/kernel_config/","title":"Kernel Configuration for BPF Features","text":""},{"location":"tutorials/bcc-documents/kernel_config/#bpf-related-kernel-configurations","title":"BPF Related Kernel Configurations","text":"Functionalities Kernel Configuration Description Basic CONFIG_BPF_SYSCALL Enable the bpf() system call CONFIG_BPF_JIT BPF programs are normally handled by a BPF interpreter. This option allows the kernel to generate native code when a program is loaded into the kernel. This will significantly speed-up processing of BPF programs CONFIG_HAVE_BPF_JIT Enable BPF Just In Time compiler CONFIG_HAVE_EBPF_JIT Extended BPF JIT (eBPF) CONFIG_HAVE_CBPF_JIT Classic BPF JIT (cBPF) CONFIG_MODULES Enable to build loadable kernel modules CONFIG_BPF BPF VM interpreter CONFIG_BPF_EVENTS Allow the user to attach BPF programs to kprobe, uprobe, and tracepoint events CONFIG_PERF_EVENTS Kernel performance events and counters CONFIG_HAVE_PERF_EVENTS Enable perf events CONFIG_PROFILING Enable the extended profiling support mechanisms used by profilers BTF CONFIG_DEBUG_INFO_BTF Generate deduplicated BTF type information from DWARF debug info CONFIG_PAHOLE_HAS_SPLIT_BTF Generate BTF for each selected kernel module CONFIG_DEBUG_INFO_BTF_MODULES Generate compact split BTF type information for kernel modules Security CONFIG_BPF_JIT_ALWAYS_ON Enable BPF JIT and removes BPF interpreter to avoid speculative execution CONFIG_BPF_UNPRIV_DEFAULT_OFF Disable unprivileged BPF by default by setting Cgroup CONFIG_CGROUP_BPF Support for BPF programs attached to cgroups Network CONFIG_BPFILTER BPF based packet filtering framework (BPFILTER) CONFIG_BPFILTER_UMH This builds bpfilter kernel module with embedded user mode helper CONFIG_NET_CLS_BPF BPF-based classifier - to classify packets based on programmable BPF (JIT'ed) filters as an alternative to ematches CONFIG_NET_ACT_BPF Execute BPF code on packets. The BPF code will decide if the packet should be dropped or not CONFIG_BPF_STREAM_PARSER Enable this to allow a TCP stream parser to be used with BPF_MAP_TYPE_SOCKMAP CONFIG_LWTUNNEL_BPF Allow to run BPF programs as a nexthop action following a route lookup for incoming and outgoing packets CONFIG_NETFILTER_XT_MATCH_BPF BPF matching applies a linux socket filter to each packet and accepts those for which the filter returns non-zero CONFIG_IPV6_SEG6_BPF To support  BPF seg6local hook. bpf: Add IPv6 Segment Routing helpersy. Reference kprobes CONFIG_KPROBE_EVENTS This allows the user to add tracing events (similar to tracepoints) on the fly via the ftrace interface CONFIG_KPROBES Enable kprobes-based dynamic events CONFIG_HAVE_KPROBES Check if krpobes enabled CONFIG_HAVE_REGS_AND_STACK_ACCESS_API This symbol should be selected by an architecture if it supports the API needed to access registers and stack entries from pt_regs. For example the kprobes-based event tracer needs this API. CONFIG_KPROBES_ON_FTRACE Have kprobes on function tracer if arch supports full passing of pt_regs to function tracing kprobe multi CONFIG_FPROBE Enable fprobe to attach the probe on multiple functions at once kprobe override CONFIG_BPF_KPROBE_OVERRIDE Enable BPF programs to override a kprobed function uprobes CONFIG_UPROBE_EVENTS Enable uprobes-based dynamic events CONFIG_ARCH_SUPPORTS_UPROBES Arch specific uprobes support CONFIG_UPROBES Uprobes is the user-space counterpart to kprobes: they enable instrumentation applications (such as 'perf probe') to establish unintrusive probes in user-space binaries and libraries, by executing handler functions when the probes are hit by user-space applications. CONFIG_MMU MMU-based virtualised addressing space support by paged memory management Tracepoints CONFIG_TRACEPOINTS Enable inserting tracepoints in the kernel and connect to proble functions CONFIG_HAVE_SYSCALL_TRACEPOINTS Enable syscall enter/exit tracing Raw Tracepoints Same as Tracepoints LSM CONFIG_BPF_LSM Enable instrumentation of the security hooks with BPF programs for implementing dynamic MAC and Audit Policies LIRC CONFIG_BPF_LIRC_MODE2 Allow attaching BPF programs to a lirc device"},{"location":"tutorials/bcc-documents/reference_guide/","title":"bcc Reference Guide","text":"<p>Intended for search (Ctrl-F) and reference. For tutorials, start with tutorial.md.</p> <p>This guide is incomplete. If something feels missing, check the bcc and kernel source. And if you confirm we're missing something, please send a pull request to fix it, and help out everyone.</p>"},{"location":"tutorials/bcc-documents/reference_guide/#contents","title":"Contents","text":"<ul> <li> <p>BPF C</p> <ul> <li>Events &amp; Arguments<ul> <li>1. kprobes</li> <li>2. kretprobes</li> <li>3. Tracepoints</li> <li>4. uprobes</li> <li>5. uretprobes</li> <li>6. USDT probes</li> <li>7. Raw Tracepoints</li> <li>8. system call tracepoints</li> <li>9. kfuncs</li> <li>10. kretfuncs</li> <li>11. lsm probes</li> <li>12. bpf iterators</li> </ul> </li> <li>Data<ul> <li>1. bpf_probe_read_kernel()</li> <li>2. bpf_probe_read_kernel_str()</li> <li>3. bpf_ktime_get_ns()</li> <li>4. bpf_get_current_pid_tgid()</li> <li>5. bpf_get_current_uid_gid()</li> <li>6. bpf_get_current_comm()</li> <li>7. bpf_get_current_task()</li> <li>8. bpf_log2l()</li> <li>9. bpf_get_prandom_u32()</li> <li>10. bpf_probe_read_user()</li> <li>11. bpf_probe_read_user_str()</li> <li>12. bpf_get_ns_current_pid_tgid()</li> </ul> </li> <li>Debugging<ul> <li>1. bpf_override_return()</li> </ul> </li> <li>Output<ul> <li>1. bpf_trace_printk()</li> <li>2. BPF_PERF_OUTPUT</li> <li>3. perf_submit()</li> <li>4. perf_submit_skb()</li> <li>5. BPF_RINGBUF_OUTPUT</li> <li>6. ringbuf_output()</li> <li>7. ringbuf_reserve()</li> <li>8. ringbuf_submit()</li> <li>9. ringbuf_discard()</li> </ul> </li> <li>Maps<ul> <li>1. BPF_TABLE</li> <li>2. BPF_HASH</li> <li>3. BPF_ARRAY</li> <li>4. BPF_HISTOGRAM</li> <li>5. BPF_STACK_TRACE</li> <li>6. BPF_PERF_ARRAY</li> <li>7. BPF_PERCPU_HASH</li> <li>8. BPF_PERCPU_ARRAY</li> <li>9. BPF_LPM_TRIE</li> <li>10. BPF_PROG_ARRAY</li> <li>11. BPF_DEVMAP</li> <li>12. BPF_CPUMAP</li> <li>13. BPF_XSKMAP</li> <li>14. BPF_ARRAY_OF_MAPS</li> <li>15. BPF_HASH_OF_MAPS</li> <li>16. BPF_STACK</li> <li>17. BPF_QUEUE</li> <li>18. BPF_SOCKHASH</li> <li>19. map.lookup()</li> <li>20. map.lookup_or_try_init()</li> <li>21. map.delete()</li> <li>22. map.update()</li> <li>23. map.insert()</li> <li>24. map.increment()</li> <li>25. map.get_stackid()</li> <li>26. map.perf_read()</li> <li>27. map.call()</li> <li>28. map.redirect_map()</li> <li>29. map.push()</li> <li>30. map.pop()</li> <li>31. map.peek()</li> <li>32. map.sock_hash_update()</li> <li>33. map.msg_redirect_hash()</li> <li>34. map.sk_redirect_hash()</li> </ul> </li> <li>Licensing</li> <li>Rewriter</li> </ul> </li> <li> <p>bcc Python</p> <ul> <li>Initialization<ul> <li>1. BPF</li> <li>2. USDT</li> </ul> </li> <li>Events<ul> <li>1. attach_kprobe()</li> <li>2. attach_kretprobe()</li> <li>3. attach_tracepoint()</li> <li>4. attach_uprobe()</li> <li>5. attach_uretprobe()</li> <li>6. USDT.enable_probe()</li> <li>7. attach_raw_tracepoint()</li> <li>8. attach_raw_socket()</li> <li>9. attach_xdp()</li> <li>10. attach_func()</li> <li>11. detach_func()</li> <li>12. detach_kprobe()</li> <li>13. detach_kretprobe()</li> </ul> </li> <li>Debug Output<ul> <li>1. trace_print()</li> <li>2. trace_fields()</li> </ul> </li> <li>Output APIs<ul> <li>1. perf_buffer_poll()</li> <li>2. ring_buffer_poll()</li> <li>3. ring_buffer_consume()</li> </ul> </li> <li>Map APIs<ul> <li>1. get_table()</li> <li>2. open_perf_buffer()</li> <li>3. items()</li> <li>4. values()</li> <li>5. clear()</li> <li>6. items_lookup_and_delete_batch()</li> <li>7. items_lookup_batch()</li> <li>8. items_delete_batch()</li> <li>9. items_update_batch()</li> <li>10. print_log2_hist()</li> <li>11. print_linear_hist()</li> <li>12. open_ring_buffer()</li> <li>13. push()</li> <li>14. pop()</li> <li>15. peek()</li> </ul> </li> <li>Helpers<ul> <li>1. ksym()</li> <li>2. ksymname()</li> <li>3. sym()</li> <li>4. num_open_kprobes()</li> <li>5. get_syscall_fnname()</li> </ul> </li> </ul> </li> <li> <p>BPF Errors</p> <ul> <li>1. Invalid mem access</li> <li>2. Cannot call GPL only function from proprietary program</li> </ul> </li> <li> <p>Environment Variables</p> <ul> <li>1. kernel source directory</li> <li>2. kernel version overriding</li> </ul> </li> </ul>"},{"location":"tutorials/bcc-documents/reference_guide/#bpf-c","title":"BPF C","text":"<p>This section describes the C part of a bcc program.</p>"},{"location":"tutorials/bcc-documents/reference_guide/#events-arguments","title":"Events &amp; Arguments","text":""},{"location":"tutorials/bcc-documents/reference_guide/#1-kprobes","title":"1. kprobes","text":"<p>Syntax: kprobe__kernel_function_name</p> <p><code>kprobe__</code> is a special prefix that creates a kprobe (dynamic tracing of a kernel function call) for the kernel function name provided as the remainder. You can also use kprobes by declaring a normal C function, then using the Python <code>BPF.attach_kprobe()</code> (covered later) to associate it with a kernel function.</p> <p>Arguments are specified on the function declaration: kprobe__kernel_function_name(struct pt_regs ctx [, argument1* ...])</p> <p>For example:</p> <pre><code>int kprobe__tcp_v4_connect(struct pt_regs *ctx, struct sock *sk) {\n[...]\n}\n</code></pre> <p>This instruments the tcp_v4_connect() kernel function using a kprobe, with the following arguments:</p> <ul> <li><code>struct pt_regs *ctx</code>: Registers and BPF context.</li> <li><code>struct sock *sk</code>: First argument to tcp_v4_connect().</li> </ul> <p>The first argument is always <code>struct pt_regs *</code>, the remainder are the arguments to the function (they don't need to be specified, if you don't intend to use them).</p> <p>Examples in situ: code (output), code (output)</p>"},{"location":"tutorials/bcc-documents/reference_guide/#2-kretprobes","title":"2. kretprobes","text":"<p>Syntax: kretprobe__kernel_function_name</p> <p><code>kretprobe__</code> is a special prefix that creates a kretprobe (dynamic tracing of a kernel function return) for the kernel function name provided as the remainder. You can also use kretprobes by declaring a normal C function, then using the Python <code>BPF.attach_kretprobe()</code> (covered later) to associate it with a kernel function.</p> <p>Return value is available as <code>PT_REGS_RC(ctx)</code>, given a function declaration of: kretprobe__kernel_function_name(struct pt_regs *ctx)</p> <p>For example:</p> <pre><code>int kretprobe__tcp_v4_connect(struct pt_regs *ctx)\n{\nint ret = PT_REGS_RC(ctx);\n[...]\n}\n</code></pre> <p>This instruments the return of the tcp_v4_connect() kernel function using a kretprobe, and stores the return value in <code>ret</code>.</p> <p>Examples in situ: code (output)</p>"},{"location":"tutorials/bcc-documents/reference_guide/#3-tracepoints","title":"3. Tracepoints","text":"<p>Syntax: TRACEPOINT_PROBE(category, event)</p> <p>This is a macro that instruments the tracepoint defined by category:event.</p> <p>The tracepoint name is <code>&lt;category&gt;:&lt;event&gt;</code>. The probe function name is <code>tracepoint__&lt;category&gt;__&lt;event&gt;</code>.</p> <p>Arguments are available in an <code>args</code> struct, which are the tracepoint arguments. One way to list these is to cat the relevant format file under /sys/kernel/debug/tracing/events/category/event/format.</p> <p>The <code>args</code> struct can be used in place of <code>ctx</code> in each functions requiring a context as an argument. This includes notably perf_submit().</p> <p>For example:</p> <pre><code>TRACEPOINT_PROBE(random, urandom_read) {\n// args is from /sys/kernel/debug/tracing/events/random/urandom_read/format\nbpf_trace_printk(\"%d\\\\n\", args-&gt;got_bits);\nreturn 0;\n}\n</code></pre> <p>This instruments the tracepoint <code>random:urandom_read tracepoint</code>, and prints the tracepoint argument <code>got_bits</code>. When using Python API, this probe is automatically attached to the right tracepoint target. For C++, this tracepoint probe can be attached by specifying the tracepoint target and function name explicitly: <code>BPF::attach_tracepoint(\"random:urandom_read\", \"tracepoint__random__urandom_read\")</code> Note the name of the probe function defined above is <code>tracepoint__random__urandom_read</code>.</p> <p>Examples in situ: code (output), search /examples, search /tools</p>"},{"location":"tutorials/bcc-documents/reference_guide/#4-uprobes","title":"4. uprobes","text":"<p>These are instrumented by declaring a normal function in C, then associating it as a uprobe probe in Python via <code>BPF.attach_uprobe()</code> (covered later).</p> <p>Arguments can be examined using <code>PT_REGS_PARM</code> macros.</p> <p>For example:</p> <pre><code>int count(struct pt_regs *ctx) {\nchar buf[64];\nbpf_probe_read_user(&amp;buf, sizeof(buf), (void *)PT_REGS_PARM1(ctx));\nbpf_trace_printk(\"%s %d\", buf, PT_REGS_PARM2(ctx));\nreturn(0);\n}\n</code></pre> <p>This reads the first argument as a string, and then prints it with the second argument as an integer.</p> <p>Examples in situ: code</p>"},{"location":"tutorials/bcc-documents/reference_guide/#5-uretprobes","title":"5. uretprobes","text":"<p>These are instrumented by declaring a normal function in C, then associating it as a uretprobe probe in Python via <code>BPF.attach_uretprobe()</code> (covered later).</p> <p>Return value is available as <code>PT_REGS_RC(ctx)</code>, given a function declaration of: function_name(struct pt_regs *ctx)</p> <p>For example:</p> <pre><code>BPF_HISTOGRAM(dist);\nint count(struct pt_regs *ctx) {\ndist.increment(PT_REGS_RC(ctx));\nreturn 0;\n}\n</code></pre> <p>This increments the bucket in the <code>dist</code> histogram that is indexed by the return value.</p> <p>Examples in situ: code (output), code (output)</p>"},{"location":"tutorials/bcc-documents/reference_guide/#6-usdt-probes","title":"6. USDT probes","text":"<p>These are User Statically-Defined Tracing (USDT) probes, which may be placed in some applications or libraries to provide a user-level equivalent of tracepoints. The primary BPF method provided for USDT support method is <code>enable_probe()</code>. USDT probes are instrumented by declaring a normal function in C, then associating it as a USDT probe in Python via <code>USDT.enable_probe()</code>.</p> <p>Arguments can be read via: bpf_usdt_readarg(index, ctx, &amp;addr)</p> <p>For example:</p> <pre><code>int do_trace(struct pt_regs *ctx) {\nuint64_t addr;\nchar path[128];\nbpf_usdt_readarg(6, ctx, &amp;addr);\nbpf_probe_read_user(&amp;path, sizeof(path), (void *)addr);\nbpf_trace_printk(\"path:%s\\\\n\", path);\nreturn 0;\n};\n</code></pre> <p>This reads the sixth USDT argument, and then pulls it in as a string to <code>path</code>.</p> <p>When initializing USDTs via the third argument of <code>BPF::init</code> in the C API, if any USDT fails to <code>init</code>, entire <code>BPF::init</code> will fail. If you're OK with some USDTs failing to <code>init</code>, use <code>BPF::init_usdt</code> before calling <code>BPF::init</code>.</p> <p>Examples in situ: code, search /examples, search /tools</p>"},{"location":"tutorials/bcc-documents/reference_guide/#7-raw-tracepoints","title":"7. Raw Tracepoints","text":"<p>Syntax: RAW_TRACEPOINT_PROBE(event)</p> <p>This is a macro that instruments the raw tracepoint defined by event.</p> <p>The argument is a pointer to struct <code>bpf_raw_tracepoint_args</code>, which is defined in bpf.h.  The struct field <code>args</code> contains all parameters of the raw tracepoint where you can found at linux tree include/trace/events directory.</p> <p>For example: <pre><code>RAW_TRACEPOINT_PROBE(sched_switch)\n{\n// TP_PROTO(bool preempt, struct task_struct *prev, struct task_struct *next)\nstruct task_struct *prev = (struct task_struct *)ctx-&gt;args[1];\nstruct task_struct *next= (struct task_struct *)ctx-&gt;args[2];\ns32 prev_tgid, next_tgid;\nbpf_probe_read_kernel(&amp;prev_tgid, sizeof(prev-&gt;tgid), &amp;prev-&gt;tgid);\nbpf_probe_read_kernel(&amp;next_tgid, sizeof(next-&gt;tgid), &amp;next-&gt;tgid);\nbpf_trace_printk(\"%d -&gt; %d\\\\n\", prev_tgid, next_tgid);\n}\n</code></pre></p> <p>This instruments the sched:sched_switch tracepoint, and prints the prev and next tgid.</p> <p>Examples in situ: search /tools</p>"},{"location":"tutorials/bcc-documents/reference_guide/#8-system-call-tracepoints","title":"8. system call tracepoints","text":"<p>Syntax: <code>syscall__SYSCALLNAME</code></p> <p><code>syscall__</code> is a special prefix that creates a kprobe for the system call name provided as the remainder. You can use it by declaring a normal C function, then using the Python <code>BPF.get_syscall_fnname(SYSCALLNAME)</code> and <code>BPF.attach_kprobe()</code> to associate it.</p> <p>Arguments are specified on the function declaration: <code>syscall__SYSCALLNAME(struct pt_regs *ctx, [, argument1 ...])</code>.</p> <p>For example: <pre><code>int syscall__execve(struct pt_regs *ctx,\nconst char __user *filename,\nconst char __user *const __user *__argv,\nconst char __user *const __user *__envp)\n{\n[...]\n}\n</code></pre></p> <p>This instruments the execve system call.</p> <p>The first argument is always <code>struct pt_regs *</code>, the remainder are the arguments to the function (they don't need to be specified, if you don't intend to use them).</p> <p>Corresponding Python code: <pre><code>b = BPF(text=bpf_text)\nexecve_fnname = b.get_syscall_fnname(\"execve\")\nb.attach_kprobe(event=execve_fnname, fn_name=\"syscall__execve\")\n</code></pre></p> <p>Examples in situ: code (output)</p>"},{"location":"tutorials/bcc-documents/reference_guide/#9-kfuncs","title":"9. kfuncs","text":"<p>Syntax: KFUNC_PROBE(function, typeof(arg1) arg1, typeof(arg2) arge ...)</p> <p>This is a macro that instruments the kernel function via trampoline before the function is executed. It's defined by function name and the function arguments defined as argX.</p> <p>For example: <pre><code>KFUNC_PROBE(do_sys_open, int dfd, const char *filename, int flags, int mode)\n{\n...\n</code></pre></p> <p>This instruments the do_sys_open kernel function and make its arguments accessible as standard argument values.</p> <p>Examples in situ: search /tools</p>"},{"location":"tutorials/bcc-documents/reference_guide/#10-kretfuncs","title":"10. kretfuncs","text":"<p>Syntax: KRETFUNC_PROBE(event, typeof(arg1) arg1, typeof(arg2) arge ..., int ret)</p> <p>This is a macro that instruments the kernel function via trampoline after the function is executed. It's defined by function name and the function arguments defined as argX.</p> <p>The last argument of the probe is the return value of the instrumented function.</p> <p>For example: <pre><code>KRETFUNC_PROBE(do_sys_open, int dfd, const char *filename, int flags, int mode, int ret)\n{\n...\n</code></pre></p> <p>This instruments the do_sys_open kernel function and make its arguments accessible as standard argument values together with its return value.</p> <p>Examples in situ: search /tools</p>"},{"location":"tutorials/bcc-documents/reference_guide/#11-lsm-probes","title":"11. LSM Probes","text":"<p>Syntax: LSM_PROBE(hook, typeof(arg1) arg1, typeof(arg2) arg2 ...)</p> <p>This is a macro that instruments an LSM hook as a BPF program. It can be used to audit security events and implement MAC security policies in BPF. It is defined by specifying the hook name followed by its arguments.</p> <p>Hook names can be found in include/linux/security.h by taking functions like <code>security_hookname</code> and taking just the <code>hookname</code> part. For example, <code>security_bpf</code> would simply become <code>bpf</code>.</p> <p>Unlike other BPF program types, the return value specified in an LSM probe matters. A return value of 0 allows the hook to succeed, whereas any non-zero return value will cause the hook to fail and deny the security operation.</p> <p>The following example instruments a hook that denies all future BPF operations: <pre><code>LSM_PROBE(bpf, int cmd, union bpf_attr *attr, unsigned int size)\n{\nreturn -EPERM;\n}\n</code></pre></p> <p>This instruments the <code>security_bpf</code> hook and causes it to return <code>-EPERM</code>. Changing <code>return -EPERM</code> to <code>return 0</code> would cause the BPF program to allow the operation instead.</p> <p>LSM probes require at least a 5.7+ kernel with the following configuation options set: - <code>CONFIG_BPF_LSM=y</code> - <code>CONFIG_LSM</code> comma separated string must contain \"bpf\" (for example,   <code>CONFIG_LSM=\"lockdown,yama,bpf\"</code>)</p> <p>Examples in situ: search /tests</p>"},{"location":"tutorials/bcc-documents/reference_guide/#12-bpf-iterators","title":"12. BPF ITERATORS","text":"<p>Syntax: BPF_ITER(target)</p> <p>This is a macro to define a program signature for a bpf iterator program. The argument target specifies what to iterate for the program.</p> <p>Currently, kernel does not have interface to discover what targets are supported. A good place to find what is supported is in tools/testing/selftests/bpf/prog_test/bpf_iter.c and some sample bpf iter programs are in tools/testing/selftests/bpf/progs with file name prefix bpf_iter.</p> <p>The following example defines a program for target task, which traverses all tasks in the kernel. <pre><code>BPF_ITER(task)\n{\nstruct seq_file *seq = ctx-&gt;meta-&gt;seq;\nstruct task_struct *task = ctx-&gt;task;\nif (task == (void *)0)\nreturn 0;\n... task-&gt;pid, task-&gt;tgid, task-&gt;comm, ...\nreturn 0;\n}\n</code></pre></p> <p>BPF iterators are introduced in 5.8 kernel for task, task_file, bpf_map, netlink_sock and ipv6_route . In 5.9, support is added to tcp/udp sockets and bpf map element (hashmap, arraymap and sk_local_storage_map) traversal.</p>"},{"location":"tutorials/bcc-documents/reference_guide/#data","title":"Data","text":""},{"location":"tutorials/bcc-documents/reference_guide/#1-bpf_probe_read_kernel","title":"1. bpf_probe_read_kernel()","text":"<p>Syntax: <code>int bpf_probe_read_kernel(void *dst, int size, const void *src)</code></p> <p>Return: 0 on success</p> <p>This copies size bytes from kernel address space to the BPF stack, so that BPF can later operate on it. For safety, all kernel memory reads must pass through bpf_probe_read_kernel(). This happens automatically in some cases, such as dereferencing kernel variables, as bcc will rewrite the BPF program to include the necessary bpf_probe_read_kernel().</p> <p>Examples in situ: search /examples, search /tools</p>"},{"location":"tutorials/bcc-documents/reference_guide/#2-bpf_probe_read_kernel_str","title":"2. bpf_probe_read_kernel_str()","text":"<p>Syntax: <code>int bpf_probe_read_kernel_str(void *dst, int size, const void *src)</code></p> <p>Return:   - &gt; 0 length of the string including the trailing NULL on success   - \\&lt; 0 error</p> <p>This copies a <code>NULL</code> terminated string from kernel address space to the BPF stack, so that BPF can later operate on it. In case the string length is smaller than size, the target is not padded with further <code>NULL</code> bytes. In case the string length is larger than size, just <code>size - 1</code> bytes are copied and the last byte is set to <code>NULL</code>.</p> <p>Examples in situ: search /examples, search /tools</p>"},{"location":"tutorials/bcc-documents/reference_guide/#3-bpf_ktime_get_ns","title":"3. bpf_ktime_get_ns()","text":"<p>Syntax: <code>u64 bpf_ktime_get_ns(void)</code></p> <p>Return: u64 number of nanoseconds. Starts at system boot time but stops during suspend.</p> <p>Examples in situ: search /examples, search /tools</p>"},{"location":"tutorials/bcc-documents/reference_guide/#4-bpf_get_current_pid_tgid","title":"4. bpf_get_current_pid_tgid()","text":"<p>Syntax: <code>u64 bpf_get_current_pid_tgid(void)</code></p> <p>Return: <code>current-&gt;tgid &lt;&lt; 32 | current-&gt;pid</code></p> <p>Returns the process ID in the lower 32 bits (kernel's view of the PID, which in user space is usually presented as the thread ID), and the thread group ID in the upper 32 bits (what user space often thinks of as the PID). By directly setting this to a u32, we discard the upper 32 bits.</p> <p>Examples in situ: search /examples, search /tools</p>"},{"location":"tutorials/bcc-documents/reference_guide/#5-bpf_get_current_uid_gid","title":"5. bpf_get_current_uid_gid()","text":"<p>Syntax: <code>u64 bpf_get_current_uid_gid(void)</code></p> <p>Return: <code>current_gid &lt;&lt; 32 | current_uid</code></p> <p>Returns the user ID and group IDs.</p> <p>Examples in situ: search /examples, search /tools</p>"},{"location":"tutorials/bcc-documents/reference_guide/#6-bpf_get_current_comm","title":"6. bpf_get_current_comm()","text":"<p>Syntax: <code>bpf_get_current_comm(char *buf, int size_of_buf)</code></p> <p>Return: 0 on success</p> <p>Populates the first argument address with the current process name. It should be a pointer to a char array of at least size TASK_COMM_LEN, which is defined in linux/sched.h. For example:</p> <pre><code>#include &lt;linux/sched.h&gt;\nint do_trace(struct pt_regs *ctx) {\nchar comm[TASK_COMM_LEN];\nbpf_get_current_comm(&amp;comm, sizeof(comm));\n[...]\n</code></pre> <p>Examples in situ: search /examples, search /tools</p>"},{"location":"tutorials/bcc-documents/reference_guide/#7-bpf_get_current_task","title":"7. bpf_get_current_task()","text":"<p>Syntax: <code>bpf_get_current_task()</code></p> <p>Return: current task as a pointer to struct task_struct.</p> <p>Returns a pointer to the current task's task_struct object. This helper can be used to compute the on-CPU time for a process, identify kernel threads, get the current CPU's run queue, or retrieve many other pieces of information.</p> <p>With Linux 4.13, due to issues with field randomization, you may need two #define directives before the includes: <pre><code>#define randomized_struct_fields_start  struct {\n#define randomized_struct_fields_end    };\n#include &lt;linux/sched.h&gt;\nint do_trace(void *ctx) {\nstruct task_struct *t = (struct task_struct *)bpf_get_current_task();\n[...]\n</code></pre></p> <p>Examples in situ: search /examples, search /tools</p>"},{"location":"tutorials/bcc-documents/reference_guide/#8-bpf_log2l","title":"8. bpf_log2l()","text":"<p>Syntax: <code>unsigned int bpf_log2l(unsigned long v)</code></p> <p>Returns the log-2 of the provided value. This is often used to create indexes for histograms, to construct power-of-2 histograms.</p> <p>Examples in situ: search /examples, search /tools</p>"},{"location":"tutorials/bcc-documents/reference_guide/#9-bpf_get_prandom_u32","title":"9. bpf_get_prandom_u32()","text":"<p>Syntax: <code>u32 bpf_get_prandom_u32()</code></p> <p>Returns a pseudo-random u32.</p> <p>Example in situ: search /examples, search /tools</p>"},{"location":"tutorials/bcc-documents/reference_guide/#10-bpf_probe_read_user","title":"10. bpf_probe_read_user()","text":"<p>Syntax: <code>int bpf_probe_read_user(void *dst, int size, const void *src)</code></p> <p>Return: 0 on success</p> <p>This attempts to safely read size bytes from user address space to the BPF stack, so that BPF can later operate on it. For safety, all user address space memory reads must pass through bpf_probe_read_user().</p> <p>Examples in situ: search /examples, search /tools</p>"},{"location":"tutorials/bcc-documents/reference_guide/#11-bpf_probe_read_user_str","title":"11. bpf_probe_read_user_str()","text":"<p>Syntax: <code>int bpf_probe_read_user_str(void *dst, int size, const void *src)</code></p> <p>Return:   - &gt; 0 length of the string including the trailing NULL on success   - \\&lt; 0 error</p> <p>This copies a <code>NULL</code> terminated string from user address space to the BPF stack, so that BPF can later operate on it. In case the string length is smaller than size, the target is not padded with further <code>NULL</code> bytes. In case the string length is larger than size, just <code>size - 1</code> bytes are copied and the last byte is set to <code>NULL</code>.</p> <p>Examples in situ: search /examples, search /tools</p>"},{"location":"tutorials/bcc-documents/reference_guide/#12-bpf_get_ns_current_pid_tgid","title":"12. bpf_get_ns_current_pid_tgid()","text":"<p>Syntax: <code>u32 bpf_get_ns_current_pid_tgid(u64 dev, u64 ino, struct bpf_pidns_info* nsdata, u32 size)</code></p> <p>Values for pid and tgid as seen from the current namespace will be returned in nsdata.</p> <p>Return 0 on success, or one of the following in case of failure:</p> <ul> <li> <p>-EINVAL if dev and inum supplied don't match dev_t and inode number with nsfs of current task, or if dev conversion to dev_t lost high bits.</p> </li> <li> <p>-ENOENT if pidns does not exists for the current task.</p> </li> </ul> <p>Examples in situ: search /examples, search /tools</p>"},{"location":"tutorials/bcc-documents/reference_guide/#debugging","title":"Debugging","text":""},{"location":"tutorials/bcc-documents/reference_guide/#1-bpf_override_return","title":"1. bpf_override_return()","text":"<p>Syntax: <code>int bpf_override_return(struct pt_regs *, unsigned long rc)</code></p> <p>Return: 0 on success</p> <p>When used in a program attached to a function entry kprobe, causes the execution of the function to be skipped, immediately returning <code>rc</code> instead. This is used for targeted error injection.</p> <p>bpf_override_return will only work when the kprobed function is whitelisted to allow error injections. Whitelisting entails tagging a function with <code>ALLOW_ERROR_INJECTION()</code> in the kernel source tree; see <code>io_ctl_init</code> for an example. If the kprobed function is not whitelisted, the bpf program will fail to attach with <code>ioctl(PERF_EVENT_IOC_SET_BPF): Invalid argument</code></p> <pre><code>int kprobe__io_ctl_init(void *ctx) {\nbpf_override_return(ctx, -ENOMEM);\nreturn 0;\n}\n</code></pre>"},{"location":"tutorials/bcc-documents/reference_guide/#output","title":"Output","text":""},{"location":"tutorials/bcc-documents/reference_guide/#1-bpf_trace_printk","title":"1. bpf_trace_printk()","text":"<p>Syntax: <code>int bpf_trace_printk(const char *fmt, ...)</code></p> <p>Return: 0 on success</p> <p>A simple kernel facility for printf() to the common trace_pipe (/sys/kernel/debug/tracing/trace_pipe). This is ok for some quick examples, but has limitations: 3 args max, 1 %s only, and trace_pipe is globally shared, so concurrent programs will have clashing output. A better interface is via BPF_PERF_OUTPUT(). Note that calling this helper is made simpler than the original kernel version, which has <code>fmt_size</code> as the second parameter.</p> <p>Examples in situ: search /examples, search /tools</p>"},{"location":"tutorials/bcc-documents/reference_guide/#2-bpf_perf_output","title":"2. BPF_PERF_OUTPUT","text":"<p>Syntax: <code>BPF_PERF_OUTPUT(name)</code></p> <p>Creates a BPF table for pushing out custom event data to user space via a perf ring buffer. This is the preferred method for pushing per-event data to user space.</p> <p>For example:</p> <pre><code>struct data_t {\nu32 pid;\nu64 ts;\nchar comm[TASK_COMM_LEN];\n};\nBPF_PERF_OUTPUT(events);\nint hello(struct pt_regs *ctx) {\nstruct data_t data = {};\ndata.pid = bpf_get_current_pid_tgid();\ndata.ts = bpf_ktime_get_ns();\nbpf_get_current_comm(&amp;data.comm, sizeof(data.comm));\nevents.perf_submit(ctx, &amp;data, sizeof(data));\nreturn 0;\n}\n</code></pre> <p>The output table is named <code>events</code>, and data is pushed to it via <code>events.perf_submit()</code>.</p> <p>Examples in situ: search /examples, search /tools</p>"},{"location":"tutorials/bcc-documents/reference_guide/#3-perf_submit","title":"3. perf_submit()","text":"<p>Syntax: <code>int perf_submit((void *)ctx, (void *)data, u32 data_size)</code></p> <p>Return: 0 on success</p> <p>A method of a BPF_PERF_OUTPUT table, for submitting custom event data to user space. See the BPF_PERF_OUTPUT entry. (This ultimately calls bpf_perf_event_output().)</p> <p>The <code>ctx</code> parameter is provided in kprobes or kretprobes. For <code>SCHED_CLS</code> or <code>SOCKET_FILTER</code> programs, the <code>struct __sk_buff *skb</code> must be used instead.</p> <p>Examples in situ: search /examples, search /tools</p>"},{"location":"tutorials/bcc-documents/reference_guide/#4-perf_submit_skb","title":"4. perf_submit_skb()","text":"<p>Syntax: <code>int perf_submit_skb((void *)ctx, u32 packet_size, (void *)data, u32 data_size)</code></p> <p>Return: 0 on success</p> <p>A method of a BPF_PERF_OUTPUT table available in networking program types, for submitting custom event data to user space, along with the first <code>packet_size</code> bytes of the packet buffer. See the BPF_PERF_OUTPUT entry. (This ultimately calls bpf_perf_event_output().)</p> <p>Examples in situ: search /examples, search /tools</p>"},{"location":"tutorials/bcc-documents/reference_guide/#5-bpf_ringbuf_output","title":"5. BPF_RINGBUF_OUTPUT","text":"<p>Syntax: <code>BPF_RINGBUF_OUTPUT(name, page_cnt)</code></p> <p>Creates a BPF table for pushing out custom event data to user space via a ringbuf ring buffer. <code>BPF_RINGBUF_OUTPUT</code> has several advantages over <code>BPF_PERF_OUTPUT</code>, summarized as follows:</p> <ul> <li>Buffer is shared across all CPUs, meaning no per-CPU allocation</li> <li>Supports two APIs for BPF programs<ul> <li><code>map.ringbuf_output()</code> works like <code>map.perf_submit()</code> (covered in ringbuf_output)</li> <li><code>map.ringbuf_reserve()</code>/<code>map.ringbuf_submit()</code>/<code>map.ringbuf_discard()</code>   split the process of reserving buffer space and submitting events into two steps   (covered in ringbuf_reserve, ringbuf_submit, ringbuf_discard)</li> </ul> </li> <li>BPF APIs do not require access to a CPU ctx argument</li> <li>Superior performance and latency in userspace thanks to a shared ring buffer manager</li> <li>Supports two ways of consuming data in userspace</li> </ul> <p>Starting in Linux 5.8, this should be the preferred method for pushing per-event data to user space.</p> <p>Example of both APIs:</p> <pre><code>struct data_t {\nu32 pid;\nu64 ts;\nchar comm[TASK_COMM_LEN];\n};\n// Creates a ringbuf called events with 8 pages of space, shared across all CPUs\nBPF_RINGBUF_OUTPUT(events, 8);\nint first_api_example(struct pt_regs *ctx) {\nstruct data_t data = {};\ndata.pid = bpf_get_current_pid_tgid();\ndata.ts = bpf_ktime_get_ns();\nbpf_get_current_comm(&amp;data.comm, sizeof(data.comm));\nevents.ringbuf_output(&amp;data, sizeof(data), 0 /* flags */);\nreturn 0;\n}\nint second_api_example(struct pt_regs *ctx) {\nstruct data_t *data = events.ringbuf_reserve(sizeof(struct data_t));\nif (!data) { // Failed to reserve space\nreturn 1;\n}\ndata-&gt;pid = bpf_get_current_pid_tgid();\ndata-&gt;ts = bpf_ktime_get_ns();\nbpf_get_current_comm(&amp;data-&gt;comm, sizeof(data-&gt;comm));\nevents.ringbuf_submit(data, 0 /* flags */);\nreturn 0;\n}\n</code></pre> <p>The output table is named <code>events</code>. Data is allocated via <code>events.ringbuf_reserve()</code> and pushed to it via <code>events.ringbuf_submit()</code>.</p> <p>Examples in situ:  search /examples,</p>"},{"location":"tutorials/bcc-documents/reference_guide/#6-ringbuf_output","title":"6. ringbuf_output()","text":"<p>Syntax: <code>int ringbuf_output((void *)data, u64 data_size, u64 flags)</code></p> <p>Return: 0 on success</p> <p>Flags:  - <code>BPF_RB_NO_WAKEUP</code>: Do not sent notification of new data availability  - <code>BPF_RB_FORCE_WAKEUP</code>: Send notification of new data availability unconditionally</p> <p>A method of the BPF_RINGBUF_OUTPUT table, for submitting custom event data to user space. This method works like <code>perf_submit()</code>, although it does not require a ctx argument.</p> <p>Examples in situ:  search /examples,</p>"},{"location":"tutorials/bcc-documents/reference_guide/#7-ringbuf_reserve","title":"7. ringbuf_reserve()","text":"<p>Syntax: <code>void* ringbuf_reserve(u64 data_size)</code></p> <p>Return: Pointer to data struct on success, NULL on failure</p> <p>A method of the BPF_RINGBUF_OUTPUT table, for reserving space in the ring buffer and simultaenously allocating a data struct for output. Must be used with one of <code>ringbuf_submit</code> or <code>ringbuf_discard</code>.</p> <p>Examples in situ:  search /examples,</p>"},{"location":"tutorials/bcc-documents/reference_guide/#8-ringbuf_submit","title":"8. ringbuf_submit()","text":"<p>Syntax: <code>void ringbuf_submit((void *)data, u64 flags)</code></p> <p>Return: Nothing, always succeeds</p> <p>Flags:  - <code>BPF_RB_NO_WAKEUP</code>: Do not sent notification of new data availability  - <code>BPF_RB_FORCE_WAKEUP</code>: Send notification of new data availability unconditionally</p> <p>A method of the BPF_RINGBUF_OUTPUT table, for submitting custom event data to user space. Must be preceded by a call to <code>ringbuf_reserve()</code> to reserve space for the data.</p> <p>Examples in situ:  search /examples,</p>"},{"location":"tutorials/bcc-documents/reference_guide/#9-ringbuf_discard","title":"9. ringbuf_discard()","text":"<p>Syntax: <code>void ringbuf_discard((void *)data, u64 flags)</code></p> <p>Return: Nothing, always succeeds</p> <p>Flags:  - <code>BPF_RB_NO_WAKEUP</code>: Do not sent notification of new data availability  - <code>BPF_RB_FORCE_WAKEUP</code>: Send notification of new data availability unconditionally</p> <p>A method of the BPF_RINGBUF_OUTPUT table, for discarding custom event data; userspace ignores the data associated with the discarded event. Must be preceded by a call to <code>ringbuf_reserve()</code> to reserve space for the data.</p> <p>Examples in situ:  search /examples,</p>"},{"location":"tutorials/bcc-documents/reference_guide/#maps","title":"Maps","text":"<p>Maps are BPF data stores, and are the basis for higher level object types including tables, hashes, and histograms.</p>"},{"location":"tutorials/bcc-documents/reference_guide/#1-bpf_table","title":"1. BPF_TABLE","text":"<p>Syntax: <code>BPF_TABLE(_table_type, _key_type, _leaf_type, _name, _max_entries)</code></p> <p>Creates a map named <code>_name</code>. Most of the time this will be used via higher-level macros, like BPF_HASH, BPF_ARRAY, BPF_HISTOGRAM, etc.</p> <p><code>BPF_F_TABLE</code> is a variant that takes a flag in the last parameter. <code>BPF_TABLE(https://github.com/iovisor/bcc/tree/master.)</code> is actually a wrapper to <code>BPF_F_TABLE(https://github.com/iovisor/bcc/tree/master., 0 /* flag */)</code>.</p> <p>Methods (covered later): map.lookup(), map.lookup_or_try_init(), map.delete(), map.update(), map.insert(), map.increment().</p> <p>Examples in situ: search /examples, search /tools</p>"},{"location":"tutorials/bcc-documents/reference_guide/#pinned-maps","title":"Pinned Maps","text":"<p>Syntax: <code>BPF_TABLE_PINNED(_table_type, _key_type, _leaf_type, _name, _max_entries, \"/sys/fs/bpf/xyz\")</code></p> <p>Create a new map if it doesn't exist and pin it to the bpffs as a FILE, otherwise use the map that was pinned to the bpffs. The type information is not enforced and the actual map type depends on the map that got pinned to the location.</p> <p>For example:</p> <pre><code>BPF_TABLE_PINNED(\"hash\", u64, u64, ids, 1024, \"/sys/fs/bpf/ids\");\n</code></pre>"},{"location":"tutorials/bcc-documents/reference_guide/#2-bpf_hash","title":"2. BPF_HASH","text":"<p>Syntax: <code>BPF_HASH(name [, key_type [, leaf_type [, size]]])</code></p> <p>Creates a hash map (associative array) named <code>name</code>, with optional parameters.</p> <p>Defaults: <code>BPF_HASH(name, key_type=u64, leaf_type=u64, size=10240)</code></p> <p>For example:</p> <pre><code>BPF_HASH(start, struct request *);\n</code></pre> <p>This creates a hash named <code>start</code> where the key is a <code>struct request *</code>, and the value defaults to u64. This hash is used by the disksnoop.py example for saving timestamps for each I/O request, where the key is the pointer to struct request, and the value is the timestamp.</p> <p>This is a wrapper macro for <code>BPF_TABLE(\"hash\", ...)</code>.</p> <p>Methods (covered later): map.lookup(), map.lookup_or_try_init(), map.delete(), map.update(), map.insert(), map.increment().</p> <p>Examples in situ: search /examples, search /tools</p>"},{"location":"tutorials/bcc-documents/reference_guide/#3-bpf_array","title":"3. BPF_ARRAY","text":"<p>Syntax: <code>BPF_ARRAY(name [, leaf_type [, size]])</code></p> <p>Creates an int-indexed array which is optimized for fastest lookup and update, named <code>name</code>, with optional parameters.</p> <p>Defaults: <code>BPF_ARRAY(name, leaf_type=u64, size=10240)</code></p> <p>For example:</p> <pre><code>BPF_ARRAY(counts, u64, 32);\n</code></pre> <p>This creates an array named <code>counts</code> where with 32 buckets and 64-bit integer values. This array is used by the funccount.py example for saving call count of each function.</p> <p>This is a wrapper macro for <code>BPF_TABLE(\"array\", ...)</code>.</p> <p>Methods (covered later): map.lookup(), map.update(), map.increment(). Note that all array elements are pre-allocated with zero values and can not be deleted.</p> <p>Examples in situ: search /examples, search /tools</p>"},{"location":"tutorials/bcc-documents/reference_guide/#4-bpf_histogram","title":"4. BPF_HISTOGRAM","text":"<p>Syntax: <code>BPF_HISTOGRAM(name [, key_type [, size ]])</code></p> <p>Creates a histogram map named <code>name</code>, with optional parameters.</p> <p>Defaults: <code>BPF_HISTOGRAM(name, key_type=int, size=64)</code></p> <p>For example:</p> <pre><code>BPF_HISTOGRAM(dist);\n</code></pre> <p>This creates a histogram named <code>dist</code>, which defaults to 64 buckets indexed by keys of type int.</p> <p>This is a wrapper macro for <code>BPF_TABLE(\"histgram\", ...)</code>.</p> <p>Methods (covered later): map.increment().</p> <p>Examples in situ: search /examples, search /tools</p>"},{"location":"tutorials/bcc-documents/reference_guide/#5-bpf_stack_trace","title":"5. BPF_STACK_TRACE","text":"<p>Syntax: <code>BPF_STACK_TRACE(name, max_entries)</code></p> <p>Creates stack trace map named <code>name</code>, with a maximum entry count provided. These maps are used to store stack traces.</p> <p>For example:</p> <pre><code>BPF_STACK_TRACE(stack_traces, 1024);\n</code></pre> <p>This creates stack trace map named <code>stack_traces</code>, with a maximum number of stack trace entries of 1024.</p> <p>This is a wrapper macro for <code>BPF_TABLE(\"stacktrace\", ...)</code>.</p> <p>Methods (covered later): map.get_stackid().</p> <p>Examples in situ: search /examples, search /tools</p>"},{"location":"tutorials/bcc-documents/reference_guide/#6-bpf_perf_array","title":"6. BPF_PERF_ARRAY","text":"<p>Syntax: <code>BPF_PERF_ARRAY(name, max_entries)</code></p> <p>Creates perf array named <code>name</code>, with a maximum entry count provided, which must be equal to the number of system cpus. These maps are used to fetch hardware performance counters.</p> <p>For example:</p> <pre><code>text=\"\"\"\nBPF_PERF_ARRAY(cpu_cycles, NUM_CPUS);\n\"\"\"\nb = bcc.BPF(text=text, cflags=[\"-DNUM_CPUS=%d\" % multiprocessing.cpu_count()])\nb[\"cpu_cycles\"].open_perf_event(b[\"cpu_cycles\"].HW_CPU_CYCLES)\n</code></pre> <p>This creates a perf array named <code>cpu_cycles</code>, with number of entries equal to the number of cpus/cores. The array is configured so that later calling map.perf_read() will return a hardware-calculated counter of the number of cycles elapsed from some point in the past. Only one type of hardware counter may be configured per table at a time.</p> <p>Methods (covered later): map.perf_read().</p> <p>Examples in situ: search /tests</p>"},{"location":"tutorials/bcc-documents/reference_guide/#7-bpf_percpu_hash","title":"7. BPF_PERCPU_HASH","text":"<p>Syntax: <code>BPF_PERCPU_HASH(name [, key_type [, leaf_type [, size]]])</code></p> <p>Creates NUM_CPU int-indexed hash maps (associative arrays) named <code>name</code>, with optional parameters. Each CPU will have a separate copy of this array. The copies are not kept synchronized in any way.</p> <p>Note that due to limits defined in the kernel (in linux/mm/percpu.c), the <code>leaf_type</code> cannot have a size of more than 32KB. In other words, <code>BPF_PERCPU_HASH</code> elements cannot be larger than 32KB in size.</p> <p>Defaults: <code>BPF_PERCPU_HASH(name, key_type=u64, leaf_type=u64, size=10240)</code></p> <p>For example:</p> <pre><code>BPF_PERCPU_HASH(start, struct request *);\n</code></pre> <p>This creates NUM_CPU hashes named <code>start</code> where the key is a <code>struct request *</code>, and the value defaults to u64.</p> <p>This is a wrapper macro for <code>BPF_TABLE(\"percpu_hash\", ...)</code>.</p> <p>Methods (covered later): map.lookup(), map.lookup_or_try_init(), map.delete(), map.update(), map.insert(), map.increment().</p> <p>Examples in situ: search /examples, search /tools</p>"},{"location":"tutorials/bcc-documents/reference_guide/#8-bpf_percpu_array","title":"8. BPF_PERCPU_ARRAY","text":"<p>Syntax: <code>BPF_PERCPU_ARRAY(name [, leaf_type [, size]])</code></p> <p>Creates NUM_CPU int-indexed arrays which are optimized for fastest lookup and update, named <code>name</code>, with optional parameters. Each CPU will have a separate copy of this array. The copies are not kept synchronized in any way.</p> <p>Note that due to limits defined in the kernel (in linux/mm/percpu.c), the <code>leaf_type</code> cannot have a size of more than 32KB. In other words, <code>BPF_PERCPU_ARRAY</code> elements cannot be larger than 32KB in size.</p> <p>Defaults: <code>BPF_PERCPU_ARRAY(name, leaf_type=u64, size=10240)</code></p> <p>For example:</p> <pre><code>BPF_PERCPU_ARRAY(counts, u64, 32);\n</code></pre> <p>This creates NUM_CPU arrays named <code>counts</code> where with 32 buckets and 64-bit integer values.</p> <p>This is a wrapper macro for <code>BPF_TABLE(\"percpu_array\", ...)</code>.</p> <p>Methods (covered later): map.lookup(), map.update(), map.increment(). Note that all array elements are pre-allocated with zero values and can not be deleted.</p> <p>Examples in situ: search /examples, search /tools</p>"},{"location":"tutorials/bcc-documents/reference_guide/#9-bpf_lpm_trie","title":"9. BPF_LPM_TRIE","text":"<p>Syntax: <code>BPF_LPM_TRIE(name [, key_type [, leaf_type [, size]]])</code></p> <p>Creates a longest prefix match trie map named <code>name</code>, with optional parameters.</p> <p>Defaults: <code>BPF_LPM_TRIE(name, key_type=u64, leaf_type=u64, size=10240)</code></p> <p>For example:</p> <pre><code>BPF_LPM_TRIE(trie, struct key_v6);\n</code></pre> <p>This creates an LPM trie map named <code>trie</code> where the key is a <code>struct key_v6</code>, and the value defaults to u64.</p> <p>This is a wrapper macro to <code>BPF_F_TABLE(\"lpm_trie\", ..., BPF_F_NO_PREALLOC)</code>.</p> <p>Methods (covered later): map.lookup(), map.lookup_or_try_init(), map.delete(), map.update(), map.insert(), map.increment().</p> <p>Examples in situ: search /examples, search /tools</p>"},{"location":"tutorials/bcc-documents/reference_guide/#10-bpf_prog_array","title":"10. BPF_PROG_ARRAY","text":"<p>Syntax: <code>BPF_PROG_ARRAY(name, size)</code></p> <p>This creates a program array named <code>name</code> with <code>size</code> entries. Each entry of the array is either a file descriptor to a bpf program or <code>NULL</code>. The array acts as a jump table so that bpf programs can \"tail-call\" other bpf programs.</p> <p>This is a wrapper macro for <code>BPF_TABLE(\"prog\", ...)</code>.</p> <p>Methods (covered later): map.call().</p> <p>Examples in situ: search /examples, search /tests, assign fd</p>"},{"location":"tutorials/bcc-documents/reference_guide/#11-bpf_devmap","title":"11. BPF_DEVMAP","text":"<p>Syntax: <code>BPF_DEVMAP(name, size)</code></p> <p>This creates a device map named <code>name</code> with <code>size</code> entries. Each entry of the map is an <code>ifindex</code> to a network interface. This map is only used in XDP.</p> <p>For example: <pre><code>BPF_DEVMAP(devmap, 10);\n</code></pre></p> <p>Methods (covered later): map.redirect_map().</p> <p>Examples in situ: search /examples,</p>"},{"location":"tutorials/bcc-documents/reference_guide/#12-bpf_cpumap","title":"12. BPF_CPUMAP","text":"<p>Syntax: <code>BPF_CPUMAP(name, size)</code></p> <p>This creates a cpu map named <code>name</code> with <code>size</code> entries. The index of the map represents the CPU id and each entry is the size of the ring buffer allocated for the CPU. This map is only used in XDP.</p> <p>For example: <pre><code>BPF_CPUMAP(cpumap, 16);\n</code></pre></p> <p>Methods (covered later): map.redirect_map().</p> <p>Examples in situ: search /examples,</p>"},{"location":"tutorials/bcc-documents/reference_guide/#13-bpf_xskmap","title":"13. BPF_XSKMAP","text":"<p>Syntax: <code>BPF_XSKMAP(name, size [, \"/sys/fs/bpf/xyz\"])</code></p> <p>This creates a xsk map named <code>name</code> with <code>size</code> entries and pin it to the bpffs as a FILE. Each entry represents one NIC's queue id. This map is only used in XDP to redirect packet to an AF_XDP socket. If the AF_XDP socket is binded to a queue which is different than the current packet's queue id, the packet will be dropped. For kernel v5.3 and latter, <code>lookup</code> method is available and can be used to check whether and AF_XDP socket is available for the current packet's queue id. More details at AF_XDP.</p> <p>For example: <pre><code>BPF_XSKMAP(xsks_map, 8);\n</code></pre></p> <p>Methods (covered later): map.redirect_map(). map.lookup()</p> <p>Examples in situ: search /examples,</p>"},{"location":"tutorials/bcc-documents/reference_guide/#14-bpf_array_of_maps","title":"14. BPF_ARRAY_OF_MAPS","text":"<p>Syntax: <code>BPF_ARRAY_OF_MAPS(name, inner_map_name, size)</code></p> <p>This creates an array map with a map-in-map type (BPF_MAP_TYPE_HASH_OF_MAPS) map named <code>name</code> with <code>size</code> entries. The inner map meta data is provided by map <code>inner_map_name</code> and can be most of array or hash maps except <code>BPF_MAP_TYPE_PROG_ARRAY</code>, <code>BPF_MAP_TYPE_CGROUP_STORAGE</code> and <code>BPF_MAP_TYPE_PERCPU_CGROUP_STORAGE</code>.</p> <p>For example: <pre><code>BPF_TABLE(\"hash\", int, int, ex1, 1024);\nBPF_TABLE(\"hash\", int, int, ex2, 1024);\nBPF_ARRAY_OF_MAPS(maps_array, \"ex1\", 10);\n</code></pre></p>"},{"location":"tutorials/bcc-documents/reference_guide/#15-bpf_hash_of_maps","title":"15. BPF_HASH_OF_MAPS","text":"<p>Syntax: <code>BPF_HASH_OF_MAPS(name, key_type, inner_map_name, size)</code></p> <p>This creates a hash map with a map-in-map type (BPF_MAP_TYPE_HASH_OF_MAPS) map named <code>name</code> with <code>size</code> entries. The inner map meta data is provided by map <code>inner_map_name</code> and can be most of array or hash maps except <code>BPF_MAP_TYPE_PROG_ARRAY</code>, <code>BPF_MAP_TYPE_CGROUP_STORAGE</code> and <code>BPF_MAP_TYPE_PERCPU_CGROUP_STORAGE</code>.</p> <p>For example: <pre><code>BPF_ARRAY(ex1, int, 1024);\nBPF_ARRAY(ex2, int, 1024);\nBPF_HASH_OF_MAPS(maps_hash, struct custom_key, \"ex1\", 10);\n</code></pre></p>"},{"location":"tutorials/bcc-documents/reference_guide/#16-bpf_stack","title":"16. BPF_STACK","text":"<p>Syntax: <code>BPF_STACK(name, leaf_type, max_entries[, flags])</code></p> <p>Creates a stack named <code>name</code> with value type <code>leaf_type</code> and max entries <code>max_entries</code>. Stack and Queue maps are only available from Linux 4.20+.</p> <p>For example:</p> <pre><code>BPF_STACK(stack, struct event, 10240);\n</code></pre> <p>This creates a stack named <code>stack</code> where the value type is <code>struct event</code>, that holds up to 10240 entries.</p> <p>Methods (covered later): map.push(), map.pop(), map.peek().</p> <p>Examples in situ: search /tests,</p>"},{"location":"tutorials/bcc-documents/reference_guide/#17-bpf_queue","title":"17. BPF_QUEUE","text":"<p>Syntax: <code>BPF_QUEUE(name, leaf_type, max_entries[, flags])</code></p> <p>Creates a queue named <code>name</code> with value type <code>leaf_type</code> and max entries <code>max_entries</code>. Stack and Queue maps are only available from Linux 4.20+.</p> <p>For example:</p> <pre><code>BPF_QUEUE(queue, struct event, 10240);\n</code></pre> <p>This creates a queue named <code>queue</code> where the value type is <code>struct event</code>, that holds up to 10240 entries.</p> <p>Methods (covered later): map.push(), map.pop(), map.peek().</p> <p>Examples in situ: search /tests,</p>"},{"location":"tutorials/bcc-documents/reference_guide/#18-bpf_sockhash","title":"18. BPF_SOCKHASH","text":"<p>Syntax: <code>BPF_SOCKHASH(name[, key_type [, max_entries)</code></p> <p>Creates a hash named <code>name</code>, with optional parameters. sockhash is only available from Linux 4.18+.</p> <p>Default: <code>BPF_SOCKHASH(name, key_type=u32, max_entries=10240)</code></p> <p>For example:</p> <pre><code>struct sock_key {\nu32 remote_ip4;\nu32 local_ip4;\nu32 remote_port;\nu32 local_port;\n};\nBPF_HASH(skh, struct sock_key, 65535);\n</code></pre> <p>This creates a hash named <code>skh</code> where the key is a <code>struct sock_key</code>.</p> <p>A sockhash is a BPF map type that holds references to sock structs. Then with a new sk/msg redirect bpf helper BPF programs can use the map to redirect skbs/msgs between sockets (<code>map.sk_redirect_hash()/map.msg_redirect_hash()</code>).</p> <p>The difference between <code>BPF_SOCKHASH</code> and <code>BPF_SOCKMAP</code> is that <code>BPF_SOCKMAP</code> is implemented based on an array, and enforces keys to be four bytes. While <code>BPF_SOCKHASH</code> is implemented based on hash table, and the type of key can be specified freely.</p> <p>Methods (covered later): map.sock_hash_update(), map.msg_redirect_hash(), map.sk_redirect_hash().</p> <p>search /tests</p>"},{"location":"tutorials/bcc-documents/reference_guide/#19-maplookup","title":"19. map.lookup()","text":"<p>Syntax: <code>*val map.lookup(&amp;key)</code></p> <p>Lookup the key in the map, and return a pointer to its value if it exists, else NULL. We pass the key in as an address to a pointer.</p> <p>Examples in situ: search /examples, search /tools</p>"},{"location":"tutorials/bcc-documents/reference_guide/#20-maplookup_or_try_init","title":"20. map.lookup_or_try_init()","text":"<p>Syntax: <code>*val map.lookup_or_try_init(&amp;key, &amp;zero)</code></p> <p>Lookup the key in the map, and return a pointer to its value if it exists, else initialize the key's value to the second argument. This is often used to initialize values to zero. If the key cannot be inserted (e.g. the map is full) then NULL is returned.</p> <p>Examples in situ: search /examples, search /tools</p> <p>Note: The old map.lookup_or_init() may cause return from the function, so lookup_or_try_init() is recommended as it does not have this side effect.</p>"},{"location":"tutorials/bcc-documents/reference_guide/#21-mapdelete","title":"21. map.delete()","text":"<p>Syntax: <code>map.delete(&amp;key)</code></p> <p>Delete the key from the hash.</p> <p>Examples in situ: search /examples, search /tools</p>"},{"location":"tutorials/bcc-documents/reference_guide/#22-mapupdate","title":"22. map.update()","text":"<p>Syntax: <code>map.update(&amp;key, &amp;val)</code></p> <p>Associate the value in the second argument to the key, overwriting any previous value.</p> <p>Examples in situ: search /examples, search /tools</p>"},{"location":"tutorials/bcc-documents/reference_guide/#23-mapinsert","title":"23. map.insert()","text":"<p>Syntax: <code>map.insert(&amp;key, &amp;val)</code></p> <p>Associate the value in the second argument to the key, only if there was no previous value.</p> <p>Examples in situ: search /examples, search /tools</p>"},{"location":"tutorials/bcc-documents/reference_guide/#24-mapincrement","title":"24. map.increment()","text":"<p>Syntax: <code>map.increment(key[, increment_amount])</code></p> <p>Increments the key's value by <code>increment_amount</code>, which defaults to 1. Used for histograms.</p> <p><code>map.increment()</code> are not atomic. In the concurrency case. If you want more accurate results, use <code>map.atomic_increment()</code> instead of <code>map.increment()</code>. The overhead of <code>map.increment()</code> and <code>map.atomic_increment()</code> is similar.</p> <p>Note. When using <code>map.atomic_increment()</code> to operate on a BPF map of type <code>BPF_MAP_TYPE_HASH</code>, <code>map.atomic_increment()</code> does not guarantee the atomicity of the operation when the specified key does not exist.</p> <p>Examples in situ: search /examples, search /tools</p>"},{"location":"tutorials/bcc-documents/reference_guide/#25-mapget_stackid","title":"25. map.get_stackid()","text":"<p>Syntax: <code>int map.get_stackid(void *ctx, u64 flags)</code></p> <p>This walks the stack found via the struct pt_regs in <code>ctx</code>, saves it in the stack trace map, and returns a unique ID for the stack trace.</p> <p>Examples in situ: search /examples, search /tools</p>"},{"location":"tutorials/bcc-documents/reference_guide/#26-mapperf_read","title":"26. map.perf_read()","text":"<p>Syntax: <code>u64 map.perf_read(u32 cpu)</code></p> <p>This returns the hardware performance counter as configured in 5. BPF_PERF_ARRAY</p> <p>Examples in situ: search /tests</p>"},{"location":"tutorials/bcc-documents/reference_guide/#27-mapcall","title":"27. map.call()","text":"<p>Syntax: <code>void map.call(void *ctx, int index)</code></p> <p>This invokes <code>bpf_tail_call()</code> to tail-call the bpf program which the <code>index</code> entry in BPF_PROG_ARRAY points to. A tail-call is different from the normal call. It reuses the current stack frame after jumping to another bpf program and never goes back. If the <code>index</code> entry is empty, it won't jump anywhere and the program execution continues as normal.</p> <p>For example:</p> <pre><code>BPF_PROG_ARRAY(prog_array, 10);\nint tail_call(void *ctx) {\nbpf_trace_printk(\"Tail-call\\n\");\nreturn 0;\n}\nint do_tail_call(void *ctx) {\nbpf_trace_printk(\"Original program\\n\");\nprog_array.call(ctx, 2);\nreturn 0;\n}\n</code></pre> <pre><code>b = BPF(src_file=\"example.c\")\ntail_fn = b.load_func(\"tail_call\", BPF.KPROBE)\nprog_array = b.get_table(\"prog_array\")\nprog_array[c_int(2)] = c_int(tail_fn.fd)\nb.attach_kprobe(event=\"some_kprobe_event\", fn_name=\"do_tail_call\")\n</code></pre> <p>This assigns <code>tail_call()</code> to <code>prog_array[2]</code>. In the end of <code>do_tail_call()</code>, <code>prog_array.call(ctx, 2)</code> tail-calls <code>tail_call()</code> and executes it.</p> <p>NOTE: To prevent infinite loop, the maximum number of tail-calls is 32 (<code>MAX_TAIL_CALL_CNT</code>).</p> <p>Examples in situ: search /examples, search /tests</p>"},{"location":"tutorials/bcc-documents/reference_guide/#28-mapredirect_map","title":"28. map.redirect_map()","text":"<p>Syntax: <code>int map.redirect_map(int index, int flags)</code></p> <p>This redirects the incoming packets based on the <code>index</code> entry. If the map is BPF_DEVMAP, the packet will be sent to the transmit queue of the network interface that the entry points to. If the map is BPF_CPUMAP, the packet will be sent to the ring buffer of the <code>index</code> CPU and be processed by the CPU later. If the map is BPF_XSKMAP, the packet will be sent to the AF_XDP socket attached to the queue.</p> <p>If the packet is redirected successfully, the function will return XDP_REDIRECT. Otherwise, it will return XDP_ABORTED to discard the packet.</p> <p>For example: <pre><code>BPF_DEVMAP(devmap, 1);\nint redirect_example(struct xdp_md *ctx) {\nreturn devmap.redirect_map(0, 0);\n}\nint xdp_dummy(struct xdp_md *ctx) {\nreturn XDP_PASS;\n}\n</code></pre></p> <pre><code>ip = pyroute2.IPRoute()\nidx = ip.link_lookup(ifname=\"eth1\")[0]\nb = bcc.BPF(src_file=\"example.c\")\ndevmap = b.get_table(\"devmap\")\ndevmap[c_uint32(0)] = c_int(idx)\nin_fn = b.load_func(\"redirect_example\", BPF.XDP)\nout_fn = b.load_func(\"xdp_dummy\", BPF.XDP)\nb.attach_xdp(\"eth0\", in_fn, 0)\nb.attach_xdp(\"eth1\", out_fn, 0)\n</code></pre> <p>Examples in situ: search /examples,</p>"},{"location":"tutorials/bcc-documents/reference_guide/#29-mappush","title":"29. map.push()","text":"<p>Syntax: <code>int map.push(&amp;val, int flags)</code></p> <p>Push an element onto a Stack or Queue table. Passing BPF_EXIST as a flag causes the Queue or Stack to discard the oldest element if it is full. Returns 0 on success, negative error on failure.</p> <p>Examples in situ: search /tests,</p>"},{"location":"tutorials/bcc-documents/reference_guide/#30-mappop","title":"30. map.pop()","text":"<p>Syntax: <code>int map.pop(&amp;val)</code></p> <p>Pop an element from a Stack or Queue table. <code>*val</code> is populated with the result. Unlike peeking, popping removes the element. Returns 0 on success, negative error on failure.</p> <p>Examples in situ: search /tests,</p>"},{"location":"tutorials/bcc-documents/reference_guide/#31-mappeek","title":"31. map.peek()","text":"<p>Syntax: <code>int map.peek(&amp;val)</code></p> <p>Peek an element at the head of a Stack or Queue table. <code>*val</code> is populated with the result. Unlike popping, peeking does not remove the element. Returns 0 on success, negative error on failure.</p> <p>Examples in situ: search /tests,</p>"},{"location":"tutorials/bcc-documents/reference_guide/#32-mapsock_hash_update","title":"32. map.sock_hash_update()","text":"<p>Syntax: <code>int map.sock_hash_update(struct bpf_sock_ops *skops, &amp;key, int flags)</code></p> <p>Add an entry to, or update a sockhash map referencing sockets. The skops is used as a new value for the entry associated to key. flags is one of:</p> <pre><code>BPF_NOEXIST: The entry for key must not exist in the map.\nBPF_EXIST: The entry for key must already exist in the map.\nBPF_ANY: No condition on the existence of the entry for key.\n</code></pre> <p>If the map has eBPF programs (parser and verdict), those will be inherited by the socket being added. If the socket is already attached to eBPF programs, this results in an error.</p> <p>Return 0 on success, or a negative error in case of failure.</p> <p>Examples in situ: search /tests,</p>"},{"location":"tutorials/bcc-documents/reference_guide/#33-mapmsg_redirect_hash","title":"33. map.msg_redirect_hash()","text":"<p>Syntax: <code>int map.msg_redirect_hash(struct sk_msg_buff *msg, void *key, u64 flags)</code></p> <p>This helper is used in programs implementing policies at the socket level. If the message msg is allowed to pass (i.e. if the verdict eBPF program returns SK_PASS), redirect it to the socket referenced by map (of type BPF_MAP_TYPE_SOCKHASH) using hash key. Both ingress and egress interfaces can be used for redirection. The BPF_F_INGRESS value in flags is used to make the distinction (ingress path is selected if the flag is present, egress path otherwise). This is the only flag supported for now.</p> <p>Return SK_PASS on success, or SK_DROP on error.</p> <p>Examples in situ: search /tests,</p>"},{"location":"tutorials/bcc-documents/reference_guide/#34-mapsk_redirect_hash","title":"34. map.sk_redirect_hash()","text":"<p>Syntax: <code>int map.sk_redirect_hash(struct sk_buff *skb, void *key, u64 flags)</code></p> <p>This helper is used in programs implementing policies at the skb socket level. If the sk_buff skb is allowed to pass (i.e. if the verdict eBPF program returns SK_PASS), redirect it to the socket referenced by map (of  type  BPF_MAP_TYPE_SOCKHASH) using hash key. Both ingress and egress interfaces can be used for redirection. The BPF_F_INGRESS value in flags is used to make the distinction (ingress path is selected if the flag is present, egress otherwise). This is the only flag supported for now.</p> <p>Return SK_PASS on success, or SK_DROP on error.</p> <p>Examples in situ: search /tests,</p>"},{"location":"tutorials/bcc-documents/reference_guide/#licensing","title":"Licensing","text":"<p>Depending on which BPF helpers are used, a GPL-compatible license is required.</p> <p>The special BCC macro <code>BPF_LICENSE</code> specifies the license of the BPF program. You can set the license as a comment in your source code, but the kernel has a special interface to specify it programmatically. If you need to use GPL-only helpers, it is recommended to specify the macro in your C code so that the kernel can understand it:</p> <pre><code>// SPDX-License-Identifier: GPL-2.0+\n#define BPF_LICENSE GPL\n</code></pre> <p>Otherwise, the kernel may reject loading your program (see the error description below). Note that it supports multiple words and quotes are not necessary:</p> <pre><code>// SPDX-License-Identifier: GPL-2.0+ OR BSD-2-Clause\n#define BPF_LICENSE Dual BSD/GPL\n</code></pre> <p>Check the BPF helpers reference to see which helpers are GPL-only and what the kernel understands as GPL-compatible.</p> <p>If the macro is not specified, BCC will automatically define the license of the program as GPL.</p>"},{"location":"tutorials/bcc-documents/reference_guide/#rewriter","title":"Rewriter","text":"<p>One of jobs for rewriter is to turn implicit memory accesses to explicit ones using kernel helpers. Recent kernel introduced a config option ARCH_HAS_NON_OVERLAPPING_ADDRESS_SPACE which will be set for architectures who user address space and kernel address are disjoint. x86 and arm has this config option set while s390 does not. If ARCH_HAS_NON_OVERLAPPING_ADDRESS_SPACE is not set, the bpf old helper <code>bpf_probe_read()</code> will not be available. Some existing users may have implicit memory accesses to access user memory, so using <code>bpf_probe_read_kernel()</code> will cause their application to fail. Therefore, for non-s390, the rewriter will use <code>bpf_probe_read()</code> for these implicit memory accesses. For s390, <code>bpf_probe_read_kernel()</code> is used as default and users should use <code>bpf_probe_read_user()</code> explicitly when accessing user memories.</p>"},{"location":"tutorials/bcc-documents/reference_guide/#bcc-python","title":"bcc Python","text":""},{"location":"tutorials/bcc-documents/reference_guide/#initialization","title":"Initialization","text":"<p>Constructors.</p>"},{"location":"tutorials/bcc-documents/reference_guide/#1-bpf","title":"1. BPF","text":"<p>Syntax: <code>BPF({text=BPF_program | src_file=filename} [, usdt_contexts=[USDT_object, ...]] [, cflags=[arg1, ...]] [, debug=int])</code></p> <p>Creates a BPF object. This is the main object for defining a BPF program, and interacting with its output.</p> <p>Exactly one of <code>text</code> or <code>src_file</code> must be supplied (not both).</p> <p>The <code>cflags</code> specifies additional arguments to be passed to the compiler, for example <code>-DMACRO_NAME=value</code> or <code>-I/include/path</code>.  The arguments are passed as an array, with each element being an additional argument.  Note that strings are not split on whitespace, so each argument must be a different element of the array, e.g. <code>[\"-include\", \"header.h\"]</code>.</p> <p>The <code>debug</code> flags control debug output, and can be or'ed together: - <code>DEBUG_LLVM_IR = 0x1</code> compiled LLVM IR - <code>DEBUG_BPF = 0x2</code> loaded BPF bytecode and register state on branches - <code>DEBUG_PREPROCESSOR = 0x4</code> pre-processor result - <code>DEBUG_SOURCE = 0x8</code> ASM instructions embedded with source - <code>DEBUG_BPF_REGISTER_STATE = 0x10</code> register state on all instructions in addition to DEBUG_BPF - <code>DEBUG_BTF = 0x20</code> print the messages from the <code>libbpf</code> library.</p> <p>Examples:</p> <pre><code># define entire BPF program in one line:\nBPF(text='int do_trace(void *ctx) { bpf_trace_printk(\"hit!\\\\n\"); return 0; }');\n# define program as a variable:\nprog = \"\"\"\nint hello(void *ctx) {\n    bpf_trace_printk(\"Hello, World!\\\\n\");\n    return 0;\n}\n\"\"\"\nb = BPF(text=prog)\n# source a file:\nb = BPF(src_file = \"vfsreadlat.c\")\n# include a USDT object:\nu = USDT(pid=int(pid))\n[...]\nb = BPF(text=bpf_text, usdt_contexts=[u])\n# add include paths:\nu = BPF(text=prog, cflags=[\"-I/path/to/include\"])\n</code></pre> <p>Examples in situ: search /examples, search /tools</p>"},{"location":"tutorials/bcc-documents/reference_guide/#2-usdt","title":"2. USDT","text":"<p>Syntax: <code>USDT({pid=pid | path=path})</code></p> <p>Creates an object to instrument User Statically-Defined Tracing (USDT) probes. Its primary method is <code>enable_probe()</code>.</p> <p>Arguments:</p> <ul> <li>pid: attach to this process ID.</li> <li>path: instrument USDT probes from this binary path.</li> </ul> <p>Examples:</p> <pre><code># include a USDT object:\nu = USDT(pid=int(pid))\n[...]\nb = BPF(text=bpf_text, usdt_contexts=[u])\n</code></pre> <p>Examples in situ: search /examples, search /tools</p>"},{"location":"tutorials/bcc-documents/reference_guide/#events","title":"Events","text":""},{"location":"tutorials/bcc-documents/reference_guide/#1-attach_kprobe","title":"1. attach_kprobe()","text":"<p>Syntax: <code>BPF.attach_kprobe(event=\"event\", fn_name=\"name\")</code></p> <p>Instruments the kernel function <code>event()</code> using kernel dynamic tracing of the function entry, and attaches our C defined function <code>name()</code> to be called when the kernel function is called.</p> <p>For example:</p> <pre><code>b.attach_kprobe(event=\"sys_clone\", fn_name=\"do_trace\")\n</code></pre> <p>This will instrument the kernel <code>sys_clone()</code> function, which will then run our BPF defined <code>do_trace()</code> function each time it is called.</p> <p>You can call attach_kprobe() more than once, and attach your BPF function to multiple kernel functions. You can also call attach_kprobe() more than once to attach multiple BPF functions to the same kernel function.</p> <p>See the previous kprobes section for how to instrument arguments from BPF.</p> <p>Examples in situ: search /examples, search /tools</p>"},{"location":"tutorials/bcc-documents/reference_guide/#2-attach_kretprobe","title":"2. attach_kretprobe()","text":"<p>Syntax: <code>BPF.attach_kretprobe(event=\"event\", fn_name=\"name\" [, maxactive=int])</code></p> <p>Instruments the return of the kernel function <code>event()</code> using kernel dynamic tracing of the function return, and attaches our C defined function <code>name()</code> to be called when the kernel function returns.</p> <p>For example:</p> <pre><code>b.attach_kretprobe(event=\"vfs_read\", fn_name=\"do_return\")\n</code></pre> <p>This will instrument the kernel <code>vfs_read()</code> function, which will then run our BPF defined <code>do_return()</code> function each time it is called.</p> <p>You can call attach_kretprobe() more than once, and attach your BPF function to multiple kernel function returns. You can also call attach_kretprobe() more than once to attach multiple BPF functions to the same kernel function return.</p> <p>When a kretprobe is installed on a kernel function, there is a limit on how many parallel calls it can catch. You can change that limit with <code>maxactive</code>. See the kprobes documentation for its default value.</p> <p>See the previous kretprobes section for how to instrument the return value from BPF.</p> <p>Examples in situ: search /examples, search /tools</p>"},{"location":"tutorials/bcc-documents/reference_guide/#3-attach_tracepoint","title":"3. attach_tracepoint()","text":"<p>Syntax: <code>BPF.attach_tracepoint(tp=\"tracepoint\", fn_name=\"name\")</code></p> <p>Instruments the kernel tracepoint described by <code>tracepoint</code>, and when hit, runs the BPF function <code>name()</code>.</p> <p>This is an explicit way to instrument tracepoints. The <code>TRACEPOINT_PROBE</code> syntax, covered in the earlier tracepoints section, is an alternate method with the advantage of auto-declaring an <code>args</code> struct containing the tracepoint arguments. With <code>attach_tracepoint()</code>, the tracepoint arguments need to be declared in the BPF program.</p> <p>For example:</p> <pre><code># define BPF program\nbpf_text = \"\"\"\n#include &lt;uapi/linux/ptrace.h&gt;\nstruct urandom_read_args {\n    // from /sys/kernel/debug/tracing/events/random/urandom_read/format\n    u64 __unused__;\n    u32 got_bits;\n    u32 pool_left;\n    u32 input_left;\n};\nint printarg(struct urandom_read_args *args) {\n    bpf_trace_printk(\"%d\\\\n\", args-&gt;got_bits);\n    return 0;\n};\n\"\"\"\n# load BPF program\nb = BPF(text=bpf_text)\nb.attach_tracepoint(\"random:urandom_read\", \"printarg\")\n</code></pre> <p>Notice how the first argument to <code>printarg()</code> is now our defined struct.</p> <p>Examples in situ: code, search /examples, search /tools</p>"},{"location":"tutorials/bcc-documents/reference_guide/#4-attach_uprobe","title":"4. attach_uprobe()","text":"<p>Syntax: <code>BPF.attach_uprobe(name=\"location\", sym=\"symbol\", fn_name=\"name\" [, sym_off=int])</code>, <code>BPF.attach_uprobe(name=\"location\", sym_re=\"regex\", fn_name=\"name\")</code>, <code>BPF.attach_uprobe(name=\"location\", addr=int, fn_name=\"name\")</code></p> <p>Instruments the user-level function <code>symbol()</code> from either the library or binary named by <code>location</code> using user-level dynamic tracing of the function entry, and attach our C defined function <code>name()</code> to be called whenever the user-level function is called. If <code>sym_off</code> is given, the function is attached to the offset within the symbol.</p> <p>The real address <code>addr</code> may be supplied in place of <code>sym</code>, in which case <code>sym</code> must be set to its default value. If the file is a non-PIE executable, <code>addr</code> must be a virtual address, otherwise it must be an offset relative to the file load address.</p> <p>Instead of a symbol name, a regular expression can be provided in <code>sym_re</code>. The uprobe will then attach to symbols that match the provided regular expression.</p> <p>Libraries can be given in the name argument without the lib prefix, or with the full path (/usr/lib/...). Binaries can be given only with the full path (/bin/sh).</p> <p>For example:</p> <pre><code>b.attach_uprobe(name=\"c\", sym=\"strlen\", fn_name=\"count\")\n</code></pre> <p>This will instrument <code>strlen()</code> function from libc, and call our BPF function <code>count()</code> when it is called. Note how the \"lib\" in \"libc\" is not necessary to specify.</p> <p>Other examples:</p> <pre><code>b.attach_uprobe(name=\"c\", sym=\"getaddrinfo\", fn_name=\"do_entry\")\nb.attach_uprobe(name=\"/usr/bin/python\", sym=\"main\", fn_name=\"do_main\")\n</code></pre> <p>You can call attach_uprobe() more than once, and attach your BPF function to multiple user-level functions.</p> <p>See the previous uprobes section for how to instrument arguments from BPF.</p> <p>Examples in situ: search /examples, search /tools</p>"},{"location":"tutorials/bcc-documents/reference_guide/#5-attach_uretprobe","title":"5. attach_uretprobe()","text":"<p>Syntax: <code>BPF.attach_uretprobe(name=\"location\", sym=\"symbol\", fn_name=\"name\")</code></p> <p>Instruments the return of the user-level function <code>symbol()</code> from either the library or binary named by <code>location</code> using user-level dynamic tracing of the function return, and attach our C defined function <code>name()</code> to be called whenever the user-level function returns.</p> <p>For example:</p> <pre><code>b.attach_uretprobe(name=\"c\", sym=\"strlen\", fn_name=\"count\")\n</code></pre> <p>This will instrument <code>strlen()</code> function from libc, and call our BPF function <code>count()</code> when it returns.</p> <p>Other examples:</p> <pre><code>b.attach_uretprobe(name=\"c\", sym=\"getaddrinfo\", fn_name=\"do_return\")\nb.attach_uretprobe(name=\"/usr/bin/python\", sym=\"main\", fn_name=\"do_main\")\n</code></pre> <p>You can call attach_uretprobe() more than once, and attach your BPF function to multiple user-level functions.</p> <p>See the previous uretprobes section for how to instrument the return value from BPF.</p> <p>Examples in situ: search /examples, search /tools</p>"},{"location":"tutorials/bcc-documents/reference_guide/#6-usdtenable_probe","title":"6. USDT.enable_probe()","text":"<p>Syntax: <code>USDT.enable_probe(probe=probe, fn_name=name)</code></p> <p>Attaches a BPF C function <code>name</code> to the USDT probe <code>probe</code>.</p> <p>Example:</p> <pre><code># enable USDT probe from given PID\nu = USDT(pid=int(pid))\nu.enable_probe(probe=\"http__server__request\", fn_name=\"do_trace\")\n</code></pre> <p>To check if your binary has USDT probes, and what they are, you can run <code>readelf -n binary</code> and check the stap debug section.</p> <p>Examples in situ: search /examples, search /tools</p>"},{"location":"tutorials/bcc-documents/reference_guide/#7-attach_raw_tracepoint","title":"7. attach_raw_tracepoint()","text":"<p>Syntax: <code>BPF.attach_raw_tracepoint(tp=\"tracepoint\", fn_name=\"name\")</code></p> <p>Instruments the kernel raw tracepoint described by <code>tracepoint</code> (<code>event</code> only, no <code>category</code>), and when hit, runs the BPF function <code>name()</code>.</p> <p>This is an explicit way to instrument tracepoints. The <code>RAW_TRACEPOINT_PROBE</code> syntax, covered in the earlier raw tracepoints section, is an alternate method.</p> <p>For example:</p> <pre><code>b.attach_raw_tracepoint(\"sched_switch\", \"do_trace\")\n</code></pre> <p>Examples in situ: search /tools</p>"},{"location":"tutorials/bcc-documents/reference_guide/#8-attach_raw_socket","title":"8. attach_raw_socket()","text":"<p>Syntax: <code>BPF.attach_raw_socket(fn, dev)</code></p> <p>Attaches a BPF function to the specified network interface.</p> <p>The <code>fn</code> must be the type of <code>BPF.function</code> and the bpf_prog type needs to be <code>BPF_PROG_TYPE_SOCKET_FILTER</code>  (<code>fn=BPF.load_func(func_name, BPF.SOCKET_FILTER)</code>)</p> <p><code>fn.sock</code> is a non-blocking raw socket that was created and bound to <code>dev</code>.</p> <p>All network packets processed by <code>dev</code> are copied to the <code>recv-q</code> of <code>fn.sock</code> after being processed by bpf_prog. Try to recv packet form <code>fn.sock</code> with rev/recvfrom/recvmsg. Note that if the <code>recv-q</code> is not read in time after the <code>recv-q</code> is full, the copied packets will be discarded.</p> <p>We can use this feature to capture network packets just like <code>tcpdump</code>.</p> <p>We can use <code>ss --bpf --packet -p</code> to observe <code>fn.sock</code>.</p> <p>Example:</p> <pre><code>BPF.attach_raw_socket(bpf_func, ifname)\n</code></pre> <p>Examples in situ: search /examples</p>"},{"location":"tutorials/bcc-documents/reference_guide/#9-attach_xdp","title":"9. attach_xdp()","text":"<p>Syntax: <code>BPF.attach_xdp(dev=\"device\", fn=b.load_func(\"fn_name\",BPF.XDP), flags)</code></p> <p>Instruments the network driver described by <code>dev</code> , and then receives the packet, run the BPF function <code>fn_name()</code> with flags.</p> <p>Here is a list of optional flags.</p> <pre><code># from xdp_flags uapi/linux/if_link.h\nXDP_FLAGS_UPDATE_IF_NOEXIST = (1 &lt;&lt; 0)\nXDP_FLAGS_SKB_MODE = (1 &lt;&lt; 1)\nXDP_FLAGS_DRV_MODE = (1 &lt;&lt; 2)\nXDP_FLAGS_HW_MODE = (1 &lt;&lt; 3)\nXDP_FLAGS_REPLACE = (1 &lt;&lt; 4)\n</code></pre> <p>You can use flags like this <code>BPF.attach_xdp(dev=\"device\", fn=b.load_func(\"fn_name\",BPF.XDP), flags=BPF.XDP_FLAGS_UPDATE_IF_NOEXIST)</code></p> <p>The default value of flags is 0. This means if there is no xdp program with <code>device</code>, the fn will run with that device. If there is an xdp program running with device, the old program will be replaced with new fn program.</p> <p>Currently, bcc does not support XDP_FLAGS_REPLACE flag. The following are the descriptions of other flags.</p>"},{"location":"tutorials/bcc-documents/reference_guide/#1-xdp_flags_update_if_noexist","title":"1. XDP_FLAGS_UPDATE_IF_NOEXIST","text":"<p>If an XDP program is already attached to the specified driver, attaching the XDP program again will fail.</p>"},{"location":"tutorials/bcc-documents/reference_guide/#2-xdp_flags_skb_mode","title":"2. XDP_FLAGS_SKB_MODE","text":"<p>Driver doesn\u2019t have support for XDP, but the kernel fakes it. XDP program works, but there\u2019s no real performance benefit because packets are handed to kernel stack anyways which then emulates XDP \u2013 this is usually supported with generic network drivers used in home computers, laptops, and virtualized HW.</p>"},{"location":"tutorials/bcc-documents/reference_guide/#3-xdp_flags_drv_mode","title":"3. XDP_FLAGS_DRV_MODE","text":"<p>A driver has XDP support and can hand then to XDP without kernel stack interaction \u2013 Few drivers can support it and those are usually for enterprise HW.</p>"},{"location":"tutorials/bcc-documents/reference_guide/#4-xdp_flags_hw_mode","title":"4. XDP_FLAGS_HW_MODE","text":"<p>XDP can be loaded and executed directly on the NIC \u2013 just a handful of NICs can do that.</p> <p>For example:</p> <pre><code>b.attach_xdp(dev=\"ens1\", fn=b.load_func(\"do_xdp\", BPF.XDP))\n</code></pre> <p>This will instrument the network device <code>ens1</code> , which will then run our BPF defined <code>do_xdp()</code> function each time it receives packets.</p> <p>Don't forget to call <code>b.remove_xdp(\"ens1\")</code> at the end!</p> <p>Examples in situ: search /examples, search /tools</p>"},{"location":"tutorials/bcc-documents/reference_guide/#10-attach_func","title":"10. attach_func()","text":"<p>Syntax: <code>BPF.attach_func(fn, attachable_fd, attach_type [, flags])</code></p> <p>Attaches a BPF function of the specified type to a particular <code>attachable_fd</code>. if the <code>attach_type</code> is <code>BPF_FLOW_DISSECTOR</code>, the function is expected to attach to current net namespace and <code>attachable_fd</code> must be 0.</p> <p>For example:</p> <pre><code>b.attach_func(fn, cgroup_fd, BPFAttachType.CGROUP_SOCK_OPS)\nb.attach_func(fn, map_fd, BPFAttachType.SK_MSG_VERDICT)\n</code></pre> <p>Note. When attached to \"global\" hooks (xdp, tc, lwt, cgroup). If the \"BPF function\" is no longer needed after the program terminates, be sure to call <code>detach_func</code> when the program exits.</p> <p>Examples in situ:</p> <p>search /examples,</p>"},{"location":"tutorials/bcc-documents/reference_guide/#11-detach_func","title":"11. detach_func()","text":"<p>Syntax: <code>BPF.detach_func(fn, attachable_fd, attach_type)</code></p> <p>Detaches a BPF function of the specified type.</p> <p>For example:</p> <pre><code>b.detach_func(fn, cgroup_fd, BPFAttachType.CGROUP_SOCK_OPS)\nb.detach_func(fn, map_fd, BPFAttachType.SK_MSG_VERDICT)\n</code></pre> <p>Examples in situ:</p> <p>search /examples,</p>"},{"location":"tutorials/bcc-documents/reference_guide/#12-detach_kprobe","title":"12. detach_kprobe()","text":"<p>Syntax: <code>BPF.detach_kprobe(event=\"event\", fn_name=\"name\")</code></p> <p>Detach a kprobe handler function of the specified event.</p> <p>For example:</p> <pre><code>b.detach_kprobe(event=\"__page_cache_alloc\", fn_name=\"trace_func_entry\")\n</code></pre>"},{"location":"tutorials/bcc-documents/reference_guide/#13-detach_kretprobe","title":"13. detach_kretprobe()","text":"<p>Syntax: <code>BPF.detach_kretprobe(event=\"event\", fn_name=\"name\")</code></p> <p>Detach a kretprobe handler function of the specified event.</p> <p>For example:</p> <pre><code>b.detach_kretprobe(event=\"__page_cache_alloc\", fn_name=\"trace_func_return\")\n</code></pre>"},{"location":"tutorials/bcc-documents/reference_guide/#debug-output","title":"Debug Output","text":""},{"location":"tutorials/bcc-documents/reference_guide/#1-trace_print","title":"1. trace_print()","text":"<p>Syntax: <code>BPF.trace_print(fmt=\"fields\")</code></p> <p>This method continually reads the globally shared /sys/kernel/debug/tracing/trace_pipe file and prints its contents. This file can be written to via BPF and the bpf_trace_printk() function, however, that method has limitations, including a lack of concurrent tracing support. The BPF_PERF_OUTPUT mechanism, covered earlier, is preferred.</p> <p>Arguments:</p> <ul> <li><code>fmt</code>: optional, and can contain a field formatting string. It defaults to <code>None</code>.</li> </ul> <p>Examples:</p> <pre><code># print trace_pipe output as-is:\nb.trace_print()\n# print PID and message:\nb.trace_print(fmt=\"{1} {5}\")\n</code></pre> <p>Examples in situ: search /examples, search /tools</p>"},{"location":"tutorials/bcc-documents/reference_guide/#2-trace_fields","title":"2. trace_fields()","text":"<p>Syntax: <code>BPF.trace_fields(nonblocking=False)</code></p> <p>This method reads one line from the globally shared /sys/kernel/debug/tracing/trace_pipe file and returns it as fields. This file can be written to via BPF and the bpf_trace_printk() function, however, that method has limitations, including a lack of concurrent tracing support. The BPF_PERF_OUTPUT mechanism, covered earlier, is preferred.</p> <p>Arguments:</p> <ul> <li><code>nonblocking</code>: optional, defaults to <code>False</code>. When set to <code>True</code>, the program will not block waiting for input.</li> </ul> <p>Examples:</p> <pre><code>while 1:\ntry:\n(task, pid, cpu, flags, ts, msg) = b.trace_fields()\nexcept ValueError:\ncontinue\n[...]\n</code></pre> <p>Examples in situ: search /examples, search /tools</p>"},{"location":"tutorials/bcc-documents/reference_guide/#output-apis","title":"Output APIs","text":"<p>Normal output from a BPF program is either:</p> <ul> <li>per-event: using PERF_EVENT_OUTPUT, open_perf_buffer(), and perf_buffer_poll().</li> <li>map summary: using items(), or print_log2_hist(), covered in the Maps section.</li> </ul>"},{"location":"tutorials/bcc-documents/reference_guide/#1-perf_buffer_poll","title":"1. perf_buffer_poll()","text":"<p>Syntax: <code>BPF.perf_buffer_poll(timeout=T)</code></p> <p>This polls from all open perf ring buffers, calling the callback function that was provided when calling open_perf_buffer for each entry.</p> <p>The timeout parameter is optional and measured in milliseconds. In its absence, polling continues indefinitely.</p> <p>Example:</p> <pre><code># loop with callback to print_event\nb[\"events\"].open_perf_buffer(print_event)\nwhile 1:\ntry:\nb.perf_buffer_poll()\nexcept KeyboardInterrupt:\nexit();\n</code></pre> <p>Examples in situ: code, search /examples, search /tools</p>"},{"location":"tutorials/bcc-documents/reference_guide/#2-ring_buffer_poll","title":"2. ring_buffer_poll()","text":"<p>Syntax: <code>BPF.ring_buffer_poll(timeout=T)</code></p> <p>This polls from all open ringbuf ring buffers, calling the callback function that was provided when calling open_ring_buffer for each entry.</p> <p>The timeout parameter is optional and measured in milliseconds. In its absence, polling continues until there is no more data or the callback returns a negative value.</p> <p>Example:</p> <pre><code># loop with callback to print_event\nb[\"events\"].open_ring_buffer(print_event)\nwhile 1:\ntry:\nb.ring_buffer_poll(30)\nexcept KeyboardInterrupt:\nexit();\n</code></pre> <p>Examples in situ: search /examples,</p>"},{"location":"tutorials/bcc-documents/reference_guide/#3-ring_buffer_consume","title":"3. ring_buffer_consume()","text":"<p>Syntax: <code>BPF.ring_buffer_consume()</code></p> <p>This consumes from all open ringbuf ring buffers, calling the callback function that was provided when calling open_ring_buffer for each entry.</p> <p>Unlike <code>ring_buffer_poll</code>, this method does not poll for data before attempting to consume. This reduces latency at the expense of higher CPU consumption. If you are unsure which to use, use <code>ring_buffer_poll</code>.</p> <p>Example:</p> <pre><code># loop with callback to print_event\nb[\"events\"].open_ring_buffer(print_event)\nwhile 1:\ntry:\nb.ring_buffer_consume()\nexcept KeyboardInterrupt:\nexit();\n</code></pre> <p>Examples in situ: search /examples,</p>"},{"location":"tutorials/bcc-documents/reference_guide/#map-apis","title":"Map APIs","text":"<p>Maps are BPF data stores, and are used in bcc to implement a table, and then higher level objects on top of tables, including hashes and histograms.</p>"},{"location":"tutorials/bcc-documents/reference_guide/#1-get_table","title":"1. get_table()","text":"<p>Syntax: <code>BPF.get_table(name)</code></p> <p>Returns a table object. This is no longer used, as tables can now be read as items from BPF. Eg: <code>BPF[name]</code>.</p> <p>Examples:</p> <pre><code>counts = b.get_table(\"counts\")\ncounts = b[\"counts\"]\n</code></pre> <p>These are equivalent.</p>"},{"location":"tutorials/bcc-documents/reference_guide/#2-open_perf_buffer","title":"2. open_perf_buffer()","text":"<p>Syntax: <code>table.open_perf_buffers(callback, page_cnt=N, lost_cb=None)</code></p> <p>This operates on a table as defined in BPF as BPF_PERF_OUTPUT(), and associates the callback Python function <code>callback</code> to be called when data is available in the perf ring buffer. This is part of the recommended mechanism for transferring per-event data from kernel to user space. The size of the perf ring buffer can be specified via the <code>page_cnt</code> parameter, which must be a power of two number of pages and defaults to 8. If the callback is not processing data fast enough, some submitted data may be lost. <code>lost_cb</code> will be called to log / monitor the lost count. If <code>lost_cb</code> is the default <code>None</code> value, it will just print a line of message to <code>stderr</code>.</p> <p>Example:</p> <pre><code># process event\ndef print_event(cpu, data, size):\nevent = ct.cast(data, ct.POINTER(Data)).contents\n[...]\n# loop with callback to print_event\nb[\"events\"].open_perf_buffer(print_event)\nwhile 1:\ntry:\nb.perf_buffer_poll()\nexcept KeyboardInterrupt:\nexit()\n</code></pre> <p>Note that the data structure transferred will need to be declared in C in the BPF program. For example:</p> <pre><code>// define output data structure in C\nstruct data_t {\nu32 pid;\nu64 ts;\nchar comm[TASK_COMM_LEN];\n};\nBPF_PERF_OUTPUT(events);\n[...]\n</code></pre> <p>In Python, you can either let bcc generate the data structure from C declaration automatically (recommended):</p> <pre><code>def print_event(cpu, data, size):\nevent = b[\"events\"].event(data)\n[...]\n</code></pre> <p>or define it manually:</p> <pre><code># define output data structure in Python\nTASK_COMM_LEN = 16    # linux/sched.h\nclass Data(ct.Structure):\n_fields_ = [(\"pid\", ct.c_ulonglong),\n(\"ts\", ct.c_ulonglong),\n(\"comm\", ct.c_char * TASK_COMM_LEN)]\ndef print_event(cpu, data, size):\nevent = ct.cast(data, ct.POINTER(Data)).contents\n[...]\n</code></pre> <p>Examples in situ: code, search /examples, search /tools</p>"},{"location":"tutorials/bcc-documents/reference_guide/#3-items","title":"3. items()","text":"<p>Syntax: <code>table.items()</code></p> <p>Returns an array of the keys in a table. This can be used with BPF_HASH maps to fetch, and iterate, over the keys.</p> <p>Example:</p> <pre><code># print output\nprint(\"%10s %s\" % (\"COUNT\", \"STRING\"))\ncounts = b.get_table(\"counts\")\nfor k, v in sorted(counts.items(), key=lambda counts: counts[1].value):\nprint(\"%10d \\\"%s\\\"\" % (v.value, k.c.encode('string-escape')))\n</code></pre> <p>This example also uses the <code>sorted()</code> method to sort by value.</p> <p>Examples in situ: search /examples, search /tools</p>"},{"location":"tutorials/bcc-documents/reference_guide/#4-values","title":"4. values()","text":"<p>Syntax: <code>table.values()</code></p> <p>Returns an array of the values in a table.</p>"},{"location":"tutorials/bcc-documents/reference_guide/#5-clear","title":"5. clear()","text":"<p>Syntax: <code>table.clear()</code></p> <p>Clears the table: deletes all entries.</p> <p>Example:</p> <pre><code># print map summary every second:\nwhile True:\ntime.sleep(1)\nprint(\"%-8s\\n\" % time.strftime(\"%H:%M:%S\"), end=\"\")\ndist.print_log2_hist(sym + \" return:\")\ndist.clear()\n</code></pre> <p>Examples in situ: search /examples, search /tools</p>"},{"location":"tutorials/bcc-documents/reference_guide/#6-items_lookup_and_delete_batch","title":"6. items_lookup_and_delete_batch()","text":"<p>Syntax: <code>table.items_lookup_and_delete_batch()</code></p> <p>Returns an array of the keys in a table with a single call to BPF syscall. This can be used with BPF_HASH maps to fetch, and iterate, over the keys. It also clears the table: deletes all entries. You should rather use table.items_lookup_and_delete_batch() than table.items() followed by table.clear(). It requires kernel v5.6.</p> <p>Example:</p> <pre><code># print call rate per second:\nprint(\"%9s-%9s-%8s-%9s\" % (\"PID\", \"COMM\", \"fname\", \"counter\"))\nwhile True:\nfor k, v in sorted(b['map'].items_lookup_and_delete_batch(), key=lambda kv: (kv[0]).pid):\nprint(\"%9s-%9s-%8s-%9d\" % (k.pid, k.comm, k.fname, v.counter))\nsleep(1)\n</code></pre>"},{"location":"tutorials/bcc-documents/reference_guide/#7-items_lookup_batch","title":"7. items_lookup_batch()","text":"<p>Syntax: <code>table.items_lookup_batch()</code></p> <p>Returns an array of the keys in a table with a single call to BPF syscall. This can be used with BPF_HASH maps to fetch, and iterate, over the keys. You should rather use table.items_lookup_batch() than table.items(). It requires kernel v5.6.</p> <p>Example:</p> <pre><code># print current value of map:\nprint(\"%9s-%9s-%8s-%9s\" % (\"PID\", \"COMM\", \"fname\", \"counter\"))\nwhile True:\nfor k, v in sorted(b['map'].items_lookup_batch(), key=lambda kv: (kv[0]).pid):\nprint(\"%9s-%9s-%8s-%9d\" % (k.pid, k.comm, k.fname, v.counter))\n</code></pre>"},{"location":"tutorials/bcc-documents/reference_guide/#8-items_delete_batch","title":"8. items_delete_batch()","text":"<p>Syntax: <code>table.items_delete_batch(keys)</code></p> <p>It clears all entries of a BPF_HASH map when keys is None. It is more efficient than table.clear() since it generates only one system call. You can delete a subset of a map by giving an array of keys as parameter. Those keys and their associated values will be deleted. It requires kernel v5.6.</p> <p>Arguments:</p> <ul> <li>keys is optional and by default is None.</li> </ul>"},{"location":"tutorials/bcc-documents/reference_guide/#9-items_update_batch","title":"9. items_update_batch()","text":"<p>Syntax: <code>table.items_update_batch(keys, values)</code></p> <p>Update all the provided keys with new values. The two arguments must be the same length and within the map limits (between 1 and the maximum entries). It requires kernel v5.6.</p> <p>Arguments:</p> <ul> <li>keys is the list of keys to be updated</li> <li>values is the list containing the new values.</li> </ul>"},{"location":"tutorials/bcc-documents/reference_guide/#10-print_log2_hist","title":"10. print_log2_hist()","text":"<p>Syntax: <code>table.print_log2_hist(val_type=\"value\", section_header=\"Bucket ptr\", section_print_fn=None)</code></p> <p>Prints a table as a log2 histogram in ASCII. The table must be stored as log2, which can be done using the BPF function <code>bpf_log2l()</code>.</p> <p>Arguments:</p> <ul> <li>val_type: optional, column header.</li> <li>section_header: if the histogram has a secondary key, multiple tables will print and section_header can be used as a header description for each.</li> <li>section_print_fn: if section_print_fn is not None, it will be passed the bucket value.</li> </ul> <p>Example:</p> <pre><code>b = BPF(text=\"\"\"\nBPF_HISTOGRAM(dist);\nint kprobe__blk_account_io_done(struct pt_regs *ctx, struct request *req)\n{\n    dist.increment(bpf_log2l(req-&gt;__data_len / 1024));\n    return 0;\n}\n\"\"\")\n[...]\nb[\"dist\"].print_log2_hist(\"kbytes\")\n</code></pre> <p>Output:</p> <pre><code>     kbytes          : count     distribution\n       0 -&gt; 1        : 3        |                                      |\n2 -&gt; 3        : 0        |                                      |\n4 -&gt; 7        : 211      |**********                            |\n8 -&gt; 15       : 0        |                                      |\n16 -&gt; 31       : 0        |                                      |\n32 -&gt; 63       : 0        |                                      |\n64 -&gt; 127      : 1        |                                      |\n128 -&gt; 255      : 800      |**************************************|\n</code></pre> <p>This output shows a multi-modal distribution, with the largest mode of 128-&gt;255 kbytes and a count of 800.</p> <p>This is an efficient way to summarize data, as the summarization is performed in-kernel, and only the count column is passed to user space.</p> <p>Examples in situ: search /examples, search /tools</p>"},{"location":"tutorials/bcc-documents/reference_guide/#11-print_linear_hist","title":"11. print_linear_hist()","text":"<p>Syntax: <code>table.print_linear_hist(val_type=\"value\", section_header=\"Bucket ptr\", section_print_fn=None)</code></p> <p>Prints a table as a linear histogram in ASCII. This is intended to visualize small integer ranges, eg, 0 to 100.</p> <p>Arguments:</p> <ul> <li>val_type: optional, column header.</li> <li>section_header: if the histogram has a secondary key, multiple tables will print and section_header can be used as a header description for each.</li> <li>section_print_fn: if section_print_fn is not None, it will be passed the bucket value.</li> </ul> <p>Example:</p> <pre><code>b = BPF(text=\"\"\"\nBPF_HISTOGRAM(dist);\nint kprobe__blk_account_io_done(struct pt_regs *ctx, struct request *req)\n{\n    dist.increment(req-&gt;__data_len / 1024);\n    return 0;\n}\n\"\"\")\n[...]\nb[\"dist\"].print_linear_hist(\"kbytes\")\n</code></pre> <p>Output:</p> <pre><code>     kbytes        : count     distribution\n        0          : 3        |******                                  |\n1          : 0        |                                        |\n2          : 0        |                                        |\n3          : 0        |                                        |\n4          : 19       |****************************************|\n5          : 0        |                                        |\n6          : 0        |                                        |\n7          : 0        |                                        |\n8          : 4        |********                                |\n9          : 0        |                                        |\n10         : 0        |                                        |\n11         : 0        |                                        |\n12         : 0        |                                        |\n13         : 0        |                                        |\n14         : 0        |                                        |\n15         : 0        |                                        |\n16         : 2        |****                                    |\n[...]\n</code></pre> <p>This is an efficient way to summarize data, as the summarization is performed in-kernel, and only the values in the count column are passed to user space.</p> <p>Examples in situ: search /examples, search /tools</p>"},{"location":"tutorials/bcc-documents/reference_guide/#12-open_ring_buffer","title":"12. open_ring_buffer()","text":"<p>Syntax: <code>table.open_ring_buffer(callback, ctx=None)</code></p> <p>This operates on a table as defined in BPF as BPF_RINGBUF_OUTPUT(), and associates the callback Python function <code>callback</code> to be called when data is available in the ringbuf ring buffer. This is part of the new (Linux 5.8+) recommended mechanism for transferring per-event data from kernel to user space. Unlike perf buffers, ringbuf sizes are specified within the BPF program, as part of the <code>BPF_RINGBUF_OUTPUT</code> macro. If the callback is not processing data fast enough, some submitted data may be lost. In this case, the events should be polled more frequently and/or the size of the ring buffer should be increased.</p> <p>Example:</p> <pre><code># process event\ndef print_event(ctx, data, size):\nevent = ct.cast(data, ct.POINTER(Data)).contents\n[...]\n# loop with callback to print_event\nb[\"events\"].open_ring_buffer(print_event)\nwhile 1:\ntry:\nb.ring_buffer_poll()\nexcept KeyboardInterrupt:\nexit()\n</code></pre> <p>Note that the data structure transferred will need to be declared in C in the BPF program. For example:</p> <pre><code>// define output data structure in C\nstruct data_t {\nu32 pid;\nu64 ts;\nchar comm[TASK_COMM_LEN];\n};\nBPF_RINGBUF_OUTPUT(events, 8);\n[...]\n</code></pre> <p>In Python, you can either let bcc generate the data structure from C declaration automatically (recommended):</p> <pre><code>def print_event(ctx, data, size):\nevent = b[\"events\"].event(data)\n[...]\n</code></pre> <p>or define it manually:</p> <pre><code># define output data structure in Python\nTASK_COMM_LEN = 16    # linux/sched.h\nclass Data(ct.Structure):\n_fields_ = [(\"pid\", ct.c_ulonglong),\n(\"ts\", ct.c_ulonglong),\n(\"comm\", ct.c_char * TASK_COMM_LEN)]\ndef print_event(ctx, data, size):\nevent = ct.cast(data, ct.POINTER(Data)).contents\n[...]\n</code></pre> <p>Examples in situ: search /examples,</p>"},{"location":"tutorials/bcc-documents/reference_guide/#13-push","title":"13. push()","text":"<p>Syntax: <code>table.push(leaf, flags=0)</code></p> <p>Push an element onto a Stack or Queue table. Raises an exception if the operation does not succeed. Passing QueueStack.BPF_EXIST as a flag causes the Queue or Stack to discard the oldest element if it is full.</p> <p>Examples in situ: search /tests,</p>"},{"location":"tutorials/bcc-documents/reference_guide/#14-pop","title":"14. pop()","text":"<p>Syntax: <code>leaf = table.pop()</code></p> <p>Pop an element from a Stack or Queue table. Unlike <code>peek()</code>, <code>pop()</code> removes the element from the table before returning it. Raises a KeyError exception if the operation does not succeed.</p> <p>Examples in situ: search /tests,</p>"},{"location":"tutorials/bcc-documents/reference_guide/#15-peek","title":"15. peek()","text":"<p>Syntax: <code>leaf = table.peek()</code></p> <p>Peek the element at the head of a Stack or Queue table. Unlike <code>pop()</code>, <code>peek()</code> does not remove the element from the table. Raises an exception if the operation does not succeed.</p> <p>Examples in situ: search /tests,</p>"},{"location":"tutorials/bcc-documents/reference_guide/#helpers","title":"Helpers","text":"<p>Some helper methods provided by bcc. Note that since we're in Python, we can import any Python library and their methods, including, for example, the libraries: argparse, collections, ctypes, datetime, re, socket, struct, subprocess, sys, and time.</p>"},{"location":"tutorials/bcc-documents/reference_guide/#1-ksym","title":"1. ksym()","text":"<p>Syntax: <code>BPF.ksym(addr)</code></p> <p>Translate a kernel memory address into a kernel function name, which is returned.</p> <p>Example:</p> <pre><code>print(\"kernel function: \" + b.ksym(addr))\n</code></pre> <p>Examples in situ: search /examples, search /tools</p>"},{"location":"tutorials/bcc-documents/reference_guide/#2-ksymname","title":"2. ksymname()","text":"<p>Syntax: <code>BPF.ksymname(name)</code></p> <p>Translate a kernel name into an address. This is the reverse of ksym. Returns -1 when the function name is unknown.</p> <p>Example:</p> <pre><code>print(\"kernel address: %x\" % b.ksymname(\"vfs_read\"))\n</code></pre> <p>Examples in situ: search /examples, search /tools</p>"},{"location":"tutorials/bcc-documents/reference_guide/#3-sym","title":"3. sym()","text":"<p>Syntax: <code>BPF.sym(addr, pid, show_module=False, show_offset=False)</code></p> <p>Translate a memory address into a function name for a pid, which is returned. A pid of less than zero will access the kernel symbol cache. The <code>show_module</code> and <code>show_offset</code> parameters control whether the module in which the symbol lies should be displayed, and whether the instruction offset from the beginning of the symbol should be displayed. These extra parameters default to <code>False</code>.</p> <p>Example:</p> <pre><code>print(\"function: \" + b.sym(addr, pid))\n</code></pre> <p>Examples in situ: search /examples, search /tools</p>"},{"location":"tutorials/bcc-documents/reference_guide/#4-num_open_kprobes","title":"4. num_open_kprobes()","text":"<p>Syntax: <code>BPF.num_open_kprobes()</code></p> <p>Returns the number of open k[ret]probes. Can be useful for scenarios where event_re is used while attaching and detaching probes. Excludes perf_events readers.</p> <p>Example:</p> <pre><code>b.attach_kprobe(event_re=pattern, fn_name=\"trace_count\")\nmatched = b.num_open_kprobes()\nif matched == 0:\nprint(\"0 functions matched by \\\"%s\\\". Exiting.\" % args.pattern)\nexit()\n</code></pre> <p>Examples in situ: search /examples, search /tools</p>"},{"location":"tutorials/bcc-documents/reference_guide/#5-get_syscall_fnname","title":"5. get_syscall_fnname()","text":"<p>Syntax: <code>BPF.get_syscall_fnname(name : str)</code></p> <p>Return the corresponding kernel function name of the syscall. This helper function will try different prefixes and use the right one to concatenate with the syscall name. Note that the return value may vary in different versions of linux kernel and sometimes it will causing trouble. (see #2590)</p> <p>Example:</p> <pre><code>print(\"The function name of %s in kernel is %s\" % (\"clone\", b.get_syscall_fnname(\"clone\")))\n# sys_clone or __x64_sys_clone or ...\n</code></pre> <p>Examples in situ: search /examples, search /tools</p>"},{"location":"tutorials/bcc-documents/reference_guide/#bpf-errors","title":"BPF Errors","text":"<p>See the \"Understanding eBPF verifier messages\" section in the kernel source under Documentation/networking/filter.txt.</p>"},{"location":"tutorials/bcc-documents/reference_guide/#1-invalid-mem-access","title":"1. Invalid mem access","text":"<p>This can be due to trying to read memory directly, instead of operating on memory on the BPF stack. All kernel memory reads must be passed via bpf_probe_read_kernel() to copy kernel memory into the BPF stack, which can be automatic by the bcc rewriter in some cases of simple dereferencing. bpf_probe_read_kernel() does all the required checks.</p> <p>Example:</p> <pre><code>bpf: Permission denied\n0: (bf) r6 = r1\n1: (79) r7 = *(u64 *)(r6 +80)\n2: (85) call 14\n3: (bf) r8 = r0\n[...]\n23: (69) r1 = *(u16 *)(r7 +16)\nR7 invalid mem access 'inv'\nTraceback (most recent call last):\n  File \"./tcpaccept\", line 179, in &lt;module&gt;\n    b = BPF(text=bpf_text)\nFile \"/usr/lib/python2.7/dist-packages/bcc/__init__.py\", line 172, in __init__\n    self._trace_autoload()\nFile \"/usr/lib/python2.7/dist-packages/bcc/__init__.py\", line 612, in _trace_autoload\n    fn = self.load_func(func_name, BPF.KPROBE)\nFile \"/usr/lib/python2.7/dist-packages/bcc/__init__.py\", line 212, in load_func\n    raise Exception(\"Failed to load BPF program %s\" % func_name)\nException: Failed to load BPF program kretprobe__inet_csk_accept\n</code></pre>"},{"location":"tutorials/bcc-documents/reference_guide/#2-cannot-call-gpl-only-function-from-proprietary-program","title":"2. Cannot call GPL only function from proprietary program","text":"<p>This error happens when a GPL-only helper is called from a non-GPL BPF program. To fix this error, do not use GPL-only helpers from a proprietary BPF program, or relicense the BPF program under a GPL-compatible license. Check which BPF helpers are GPL-only, and what licenses are considered GPL-compatible.</p> <p>Example calling <code>bpf_get_stackid()</code>, a GPL-only BPF helper, from a proprietary program (<code>#define BPF_LICENSE Proprietary</code>):</p> <pre><code>bpf: Failed to load program: Invalid argument\n[...]\n8: (85) call bpf_get_stackid#27\ncannot call GPL only function from proprietary program\n</code></pre>"},{"location":"tutorials/bcc-documents/reference_guide/#environment-variables","title":"Environment Variables","text":""},{"location":"tutorials/bcc-documents/reference_guide/#1-kernel-source-directory","title":"1. Kernel source directory","text":"<p>eBPF program compilation needs kernel sources or kernel headers with headers compiled. In case your kernel sources are at a non-standard location where BCC cannot find then, its possible to provide BCC the absolute path of the location by setting <code>BCC_KERNEL_SOURCE</code> to it.</p>"},{"location":"tutorials/bcc-documents/reference_guide/#2-kernel-version-overriding","title":"2. Kernel version overriding","text":"<p>By default, BCC stores the <code>LINUX_VERSION_CODE</code> in the generated eBPF object which is then passed along to the kernel when the eBPF program is loaded. Sometimes this is quite inconvenient especially when the kernel is slightly updated such as an LTS kernel release. Its extremely unlikely the slight mismatch would cause any issues with the loaded eBPF program. By setting <code>BCC_LINUX_VERSION_CODE</code> to the version of the kernel that's running, the check for verifying the kernel version can be bypassed. This is needed for programs that use kprobes. This needs to be encoded in the format: <code>(VERSION * 65536) + (PATCHLEVEL * 256) + SUBLEVEL</code>. For example, if the running kernel is <code>4.9.10</code>, then can set <code>export BCC_LINUX_VERSION_CODE=264458</code> to override the kernel version check successfully.</p>"},{"location":"tutorials/bcc-documents/special_filtering/","title":"Special Filtering","text":"<p>Some tools have special filtering capabitilies, the main use case is to trace processes running in containers, but those mechanisms are generic and could be used in other cases as well.</p>"},{"location":"tutorials/bcc-documents/special_filtering/#filtering-by-cgroups","title":"Filtering by cgroups","text":"<p>Some tools have an option to filter by cgroup by referencing a pinned BPF hash map managed externally.</p> <p>Examples of commands:</p> <pre><code># ./opensnoop --cgroupmap /sys/fs/bpf/test01\n# ./execsnoop --cgroupmap /sys/fs/bpf/test01\n# ./tcpconnect --cgroupmap /sys/fs/bpf/test01\n# ./tcpaccept --cgroupmap /sys/fs/bpf/test01\n# ./tcptracer --cgroupmap /sys/fs/bpf/test01\n</code></pre> <p>The commands above will only display results from processes that belong to one of the cgroups whose id, returned by <code>bpf_get_current_cgroup_id()</code>, is in the pinned BPF hash map.</p> <p>The BPF hash map can be created by:</p> <pre><code># bpftool map create /sys/fs/bpf/test01 type hash key 8 value 8 entries 128 \\\nname cgroupset flags 0\n</code></pre> <p>To get a shell in a new cgroup, you can use:</p> <pre><code># systemd-run --pty --unit test bash\n</code></pre> <p>The shell will be running in the cgroup <code>/sys/fs/cgroup/unified/system.slice/test.service</code>.</p> <p>The cgroup id can be discovered using the <code>name_to_handle_at()</code> system call. In the examples/cgroupid, you will find an example of program to get the cgroup id.</p> <pre><code># cd examples/cgroupid\n# make\n# ./cgroupid hex /sys/fs/cgroup/unified/system.slice/test.service\n</code></pre> <p>or, using Docker:</p> <pre><code># cd examples/cgroupid\n# docker build -t cgroupid .\n# docker run --rm --privileged -v /sys/fs/cgroup:/sys/fs/cgroup \\\ncgroupid cgroupid hex /sys/fs/cgroup/unified/system.slice/test.service\n</code></pre> <p>This prints the cgroup id as a hexadecimal string in the host endianness such as <code>77 16 00 00 01 00 00 00</code>.</p> <pre><code># FILE=/sys/fs/bpf/test01\n# CGROUPID_HEX=\"77 16 00 00 01 00 00 00\"\n# bpftool map update pinned $FILE key hex $CGROUPID_HEX value hex 00 00 00 00 00 00 00 00 any\n</code></pre> <p>Now that the shell started by systemd-run has its cgroup id in the BPF hash map, bcc tools will display results from this shell. Cgroups can be added and removed from the BPF hash map without restarting the bcc tool.</p> <p>This feature is useful for integrating bcc tools in external projects.</p>"},{"location":"tutorials/bcc-documents/special_filtering/#filtering-by-mount-by-namespace","title":"Filtering by mount by namespace","text":"<p>The BPF hash map can be created by:</p> <pre><code># bpftool map create /sys/fs/bpf/mnt_ns_set type hash key 8 value 4 entries 128 \\\nname mnt_ns_set flags 0\n</code></pre> <p>Execute the <code>execsnoop</code> tool filtering only the mount namespaces in <code>/sys/fs/bpf/mnt_ns_set</code>:</p> <pre><code># tools/execsnoop.py --mntnsmap /sys/fs/bpf/mnt_ns_set\n</code></pre> <p>Start a terminal in a new mount namespace:</p> <pre><code># unshare -m bash\n</code></pre> <p>Update the hash map with the mount namespace ID of the terminal above:</p> <pre><code>FILE=/sys/fs/bpf/mnt_ns_set\nif [ $(printf '\\1' | od -dAn) -eq 1 ]; then\nHOST_ENDIAN_CMD=tac\nelse\nHOST_ENDIAN_CMD=cat\nfi\nNS_ID_HEX=\"$(printf '%016x' $(stat -Lc '%i' /proc/self/ns/mnt) | sed 's/.\\{2\\}/&amp;\\n/g' | $HOST_ENDIAN_CMD)\"\nbpftool map update pinned $FILE key hex $NS_ID_HEX value hex 00 00 00 00 any\n</code></pre> <p>Execute a command in this terminal:</p> <pre><code># ping kinvolk.io\n</code></pre> <p>You'll see how on the <code>execsnoop</code> terminal you started above the call is logged:</p> <pre><code># tools/execsnoop.py --mntnsmap /sys/fs/bpf/mnt_ns_set\n[sudo] password for mvb:\nPCOMM            PID    PPID   RET ARGS\nping             8096   7970     0 /bin/ping kinvolk.io\n</code></pre>"},{"location":"tutorials/bcc-documents/tutorial/","title":"bcc Tutorial","text":"<p>This tutorial covers how to use bcc tools to quickly solve performance, troubleshooting, and networking issues. If you want to develop new bcc tools, see tutorial_bcc_python_developer.md for that tutorial.</p> <p>It is assumed for this tutorial that bcc is already installed, and you can run tools like execsnoop successfully. See INSTALL.md. This uses enhancements added to the Linux 4.x series.</p>"},{"location":"tutorials/bcc-documents/tutorial/#observability","title":"Observability","text":"<p>Some quick wins.</p>"},{"location":"tutorials/bcc-documents/tutorial/#0-before-bcc","title":"0. Before bcc","text":"<p>Before using bcc, you should start with the Linux basics. One reference is the Linux Performance Analysis in 60,000 Milliseconds post, which covers these commands:</p> <ol> <li>uptime</li> <li>dmesg | tail</li> <li>vmstat 1</li> <li>mpstat -P ALL 1</li> <li>pidstat 1</li> <li>iostat -xz 1</li> <li>free -m</li> <li>sar -n DEV 1</li> <li>sar -n TCP,ETCP 1</li> <li>top</li> </ol>"},{"location":"tutorials/bcc-documents/tutorial/#1-general-performance","title":"1. General Performance","text":"<p>Here is a generic checklist for performance investigations with bcc, first as a list, then in detail:</p> <ol> <li>execsnoop</li> <li>opensnoop</li> <li>ext4slower (or btrfs*, xfs*, zfs*)</li> <li>biolatency</li> <li>biosnoop</li> <li>cachestat</li> <li>tcpconnect</li> <li>tcpaccept</li> <li>tcpretrans</li> <li>runqlat</li> <li>profile</li> </ol> <p>These tools may be installed on your system under /usr/share/bcc/tools, or you can run them from the bcc github repo under /tools where they have a .py extension. Browse the 50+ tools available for more analysis options.</p>"},{"location":"tutorials/bcc-documents/tutorial/#11-execsnoop","title":"1.1 execsnoop","text":"<pre><code># ./execsnoop\nPCOMM            PID    RET ARGS\nsupervise        9660     0 ./run\nsupervise        9661     0 ./run\nmkdir            9662     0 /bin/mkdir -p ./main\nrun              9663     0 ./run\n[...]\n</code></pre> <p>execsnoop prints one line of output for each new process. Check for short-lived processes. These can consume CPU resources, but not show up in most monitoring tools that periodically take snapshots of which processes are running.</p> <p>It works by tracing exec(), not the fork(), so it will catch many types of new processes but not all (eg, it won't see an application launching working processes, that doesn't exec() anything else).</p> <p>More examples.</p>"},{"location":"tutorials/bcc-documents/tutorial/#12-opensnoop","title":"1.2. opensnoop","text":"<pre><code># ./opensnoop\nPID    COMM               FD ERR PATH\n1565   redis-server        5   0 /proc/1565/stat\n1565   redis-server        5   0 /proc/1565/stat\n1565   redis-server        5   0 /proc/1565/stat\n1603   snmpd               9   0 /proc/net/dev\n1603   snmpd              11   0 /proc/net/if_inet6\n1603   snmpd              -1   2 /sys/class/net/eth0/device/vendor\n1603   snmpd              11   0 /proc/sys/net/ipv4/neigh/eth0/retrans_time_ms\n1603   snmpd              11   0 /proc/sys/net/ipv6/neigh/eth0/retrans_time_ms\n1603   snmpd              11   0 /proc/sys/net/ipv6/conf/eth0/forwarding\n[...]\n</code></pre> <p>opensnoop prints one line of output for each open() syscall, including details.</p> <p>Files that are opened can tell you a lot about how applications work: identifying their data files, config files, and log files. Sometimes applications can misbehave, and perform poorly, when they are constantly attempting to read files that do not exist. opensnoop gives you a quick look.</p> <p>More examples.</p>"},{"location":"tutorials/bcc-documents/tutorial/#13-ext4slower-or-btrfs-xfs-zfs","title":"1.3. ext4slower (or btrfs*, xfs*, zfs*)","text":"<pre><code># ./ext4slower\nTracing ext4 operations slower than 10 ms\nTIME     COMM           PID    T BYTES   OFF_KB   LAT(ms) FILENAME\n06:35:01 cron           16464  R 1249    0          16.05 common-auth\n06:35:01 cron           16463  R 1249    0          16.04 common-auth\n06:35:01 cron           16465  R 1249    0          16.03 common-auth\n06:35:01 cron           16465  R 4096    0          10.62 login.defs\n06:35:01 cron           16464  R 4096    0          10.61 login.defs\n</code></pre> <p>ext4slower traces the ext4 file system and times common operations, and then only prints those that exceed a threshold.</p> <p>This is great for identifying or exonerating one type of performance issue: show individually slow disk i/O via the file system. Disks process I/O asynchronously, and it can be difficult to associate latency at that layer with the latency applications experience. Tracing higher up in the kernel stack, at the VFS -&gt; file system interface, will more closely match what an application suffers. Use this tool to identify if file system latency exceeds a given threshold.</p> <p>Similar tools exist in bcc for other file systems: btrfsslower, xfsslower, and zfsslower. There is also fileslower, which works at the VFS layer and traces everything (although at some higher overhead).</p> <p>More examples.</p>"},{"location":"tutorials/bcc-documents/tutorial/#14-biolatency","title":"1.4. biolatency","text":"<pre><code># ./biolatency\nTracing block device I/O... Hit Ctrl-C to end.\n^C\n     usecs           : count     distribution\n       0 -&gt; 1        : 0        |                                      |\n2 -&gt; 3        : 0        |                                      |\n4 -&gt; 7        : 0        |                                      |\n8 -&gt; 15       : 0        |                                      |\n16 -&gt; 31       : 0        |                                      |\n32 -&gt; 63       : 0        |                                      |\n64 -&gt; 127      : 1        |                                      |\n128 -&gt; 255      : 12       |********                              |\n256 -&gt; 511      : 15       |**********                            |\n512 -&gt; 1023     : 43       |*******************************       |\n1024 -&gt; 2047     : 52       |**************************************|\n2048 -&gt; 4095     : 47       |**********************************    |\n4096 -&gt; 8191     : 52       |**************************************|\n8192 -&gt; 16383    : 36       |**************************            |\n16384 -&gt; 32767    : 15       |**********                            |\n32768 -&gt; 65535    : 2        |*                                     |\n65536 -&gt; 131071   : 2        |*                                     |\n</code></pre> <p>biolatency traces disk I/O latency (time from device issue to completion), and when the tool ends (Ctrl-C, or a given interval), it prints a histogram summary of the latency.</p> <p>This is great for understanding disk I/O latency beyond the average times given by tools like iostat. I/O latency outliers will be visible at the end of the distribution, as well as multi-mode distributions.</p> <p>More examples.</p>"},{"location":"tutorials/bcc-documents/tutorial/#15-biosnoop","title":"1.5. biosnoop","text":"<pre><code># ./biosnoop\nTIME(s)        COMM           PID    DISK    T  SECTOR    BYTES   LAT(ms)\n0.000004001    supervise      1950   xvda1   W  13092560  4096       0.74\n0.000178002    supervise      1950   xvda1   W  13092432  4096       0.61\n0.001469001    supervise      1956   xvda1   W  13092440  4096       1.24\n0.001588002    supervise      1956   xvda1   W  13115128  4096       1.09\n1.022346001    supervise      1950   xvda1   W  13115272  4096       0.98\n1.022568002    supervise      1950   xvda1   W  13188496  4096       0.93\n[...]\n</code></pre> <p>biosnoop prints a line of output for each disk I/O, with details including latency (time from device issue to completion).</p> <p>This allows you to examine disk I/O in more detail, and look for time-ordered patterns (eg, reads queueing behind writes). Note that the output will be verbose if your system performs disk I/O at a high rate.</p> <p>More examples.</p>"},{"location":"tutorials/bcc-documents/tutorial/#16-cachestat","title":"1.6. cachestat","text":"<pre><code># ./cachestat\nHITS   MISSES  DIRTIES  READ_HIT% WRITE_HIT%   BUFFERS_MB  CACHED_MB\n    1074       44       13      94.9%       2.9%            1        223\n2195      170        8      92.5%       6.8%            1        143\n182       53       56      53.6%       1.3%            1        143\n62480    40960    20480      40.6%      19.8%            1        223\n7        2        5      22.2%      22.2%            1        223\n348        0        0     100.0%       0.0%            1        223\n[...]\n</code></pre> <p>cachestat prints a one line summary every second (or every custom interval) showing statistics from the file system cache.</p> <p>Use this to identify a low cache hit ratio, and a high rate of misses: which gives one lead for performance tuning.</p> <p>More examples.</p>"},{"location":"tutorials/bcc-documents/tutorial/#17-tcpconnect","title":"1.7. tcpconnect","text":"<pre><code># ./tcpconnect\nPID    COMM         IP SADDR            DADDR            DPORT\n1479   telnet       4  127.0.0.1        127.0.0.1        23\n1469   curl         4  10.201.219.236   54.245.105.25    80\n1469   curl         4  10.201.219.236   54.67.101.145    80\n1991   telnet       6  ::1              ::1              23\n2015   ssh          6  fe80::2000:bff:fe82:3ac fe80::2000:bff:fe82:3ac 22\n[...]\n</code></pre> <p>tcpconnect prints one line of output for every active TCP connection (eg, via connect()), with details including source and destination addresses.</p> <p>Look for unexpected connections that may point to inefficiencies in application configuration, or an intruder.</p> <p>More examples.</p>"},{"location":"tutorials/bcc-documents/tutorial/#18-tcpaccept","title":"1.8. tcpaccept","text":"<pre><code># ./tcpaccept\nPID    COMM         IP RADDR            LADDR            LPORT\n907    sshd         4  192.168.56.1     192.168.56.102   22\n907    sshd         4  127.0.0.1        127.0.0.1        22\n5389   perl         6  1234:ab12:2040:5020:2299:0:5:0 1234:ab12:2040:5020:2299:0:5:0 7001\n[...]\n</code></pre> <p>tcpaccept prints one line of output for every passive TCP connection (eg, via accept()), with details including source and destination addresses.</p> <p>Look for unexpected connections that may point to inefficiencies in application configuration, or an intruder.</p> <p>More examples.</p>"},{"location":"tutorials/bcc-documents/tutorial/#19-tcpretrans","title":"1.9. tcpretrans","text":"<pre><code># ./tcpretrans\nTIME     PID    IP LADDR:LPORT          T&gt; RADDR:RPORT          STATE\n01:55:05 0      4  10.153.223.157:22    R&gt; 69.53.245.40:34619   ESTABLISHED\n01:55:05 0      4  10.153.223.157:22    R&gt; 69.53.245.40:34619   ESTABLISHED\n01:55:17 0      4  10.153.223.157:22    R&gt; 69.53.245.40:22957   ESTABLISHED\n[...]\n</code></pre> <p>tcprerans prints one line of output for every TCP retransmit packet, with details including source and destination addresses, and kernel state of the TCP connection.</p> <p>TCP retransmissions cause latency and throughput issues. For ESTABLISHED retransmits, look for patterns with networks. For SYN_SENT, this may point to target kernel CPU saturation and kernel packet drops.</p> <p>More examples.</p>"},{"location":"tutorials/bcc-documents/tutorial/#110-runqlat","title":"1.10. runqlat","text":"<pre><code># ./runqlat\nTracing run queue latency... Hit Ctrl-C to end.\n^C\n     usecs               : count     distribution\n         0 -&gt; 1          : 233      |***********                             |\n2 -&gt; 3          : 742      |************************************    |\n4 -&gt; 7          : 203      |**********                              |\n8 -&gt; 15         : 173      |********                                |\n16 -&gt; 31         : 24       |*                                       |\n32 -&gt; 63         : 0        |                                        |\n64 -&gt; 127        : 30       |*                                       |\n128 -&gt; 255        : 6        |                                        |\n256 -&gt; 511        : 3        |                                        |\n512 -&gt; 1023       : 5        |                                        |\n1024 -&gt; 2047       : 27       |*                                       |\n2048 -&gt; 4095       : 30       |*                                       |\n4096 -&gt; 8191       : 20       |                                        |\n8192 -&gt; 16383      : 29       |*                                       |\n16384 -&gt; 32767      : 809      |****************************************|\n32768 -&gt; 65535      : 64       |***                                     |\n</code></pre> <p>runqlat times how long threads were waiting on the CPU run queues, and prints this as a histogram.</p> <p>This can help quantify time lost waiting for a turn on CPU, during periods of CPU saturation.</p> <p>More examples.</p>"},{"location":"tutorials/bcc-documents/tutorial/#111-profile","title":"1.11. profile","text":"<pre><code># ./profile\nSampling at 49 Hertz of all threads by user + kernel stack... Hit Ctrl-C to end.\n^C\n    00007f31d76c3251 [unknown]\n47a2c1e752bf47f7 [unknown]\n-                sign-file (8877)\n1\nffffffff813d0af8 __clear_user\n    ffffffff813d5277 iov_iter_zero\n    ffffffff814ec5f2 read_iter_zero\n    ffffffff8120be9d __vfs_read\n    ffffffff8120c385 vfs_read\n    ffffffff8120d786 sys_read\n    ffffffff817cc076 entry_SYSCALL_64_fastpath\n    00007fc5652ad9b0 read\n-                dd (25036)\n4\n0000000000400542 func_a\n    0000000000400598 main\n    00007f12a133e830 __libc_start_main\n    083e258d4c544155 [unknown]\n-                func_ab (13549)\n5\n[...]\nffffffff8105eb66 native_safe_halt\n    ffffffff8103659e default_idle\n    ffffffff81036d1f arch_cpu_idle\n    ffffffff810bba5a default_idle_call\n    ffffffff810bbd07 cpu_startup_entry\n    ffffffff8104df55 start_secondary\n    -                swapper/1 (0)\n75\n</code></pre> <p>profile is a CPU profiler, which takes samples of stack traces at timed intervals, and prints a summary of unique stack traces and a count of their occurrence.</p> <p>Use this tool to understand the code paths that are consuming CPU resources.</p> <p>More examples.</p>"},{"location":"tutorials/bcc-documents/tutorial/#2-observability-with-generic-tools","title":"2. Observability with Generic Tools","text":"<p>In addition to the above tools for performance tuning, below is a checklist for bcc generic tools, first as a list, and in detail:</p> <ol> <li>trace</li> <li>argdist</li> <li>funccount</li> </ol> <p>These generic tools may be useful to provide visibility to solve your specific problems.</p>"},{"location":"tutorials/bcc-documents/tutorial/#21-trace","title":"2.1. trace","text":""},{"location":"tutorials/bcc-documents/tutorial/#example-1","title":"Example 1","text":"<p>Suppose you want to track file ownership change. There are three syscalls, <code>chown</code>, <code>fchown</code> and <code>lchown</code> which users can use to change file ownership. The corresponding syscall entry is <code>SyS_[f|l]chown</code>.  The following command can be used to print out syscall parameters and the calling process user id. You can use <code>id</code> command to find the uid of a particular user.</p> <pre><code>$ trace.py \\\n'p::SyS_chown \"file = %s, to_uid = %d, to_gid = %d, from_uid = %d\", arg1, arg2, arg3, $uid' \\\n'p::SyS_fchown \"fd = %d, to_uid = %d, to_gid = %d, from_uid = %d\", arg1, arg2, arg3, $uid' \\\n'p::SyS_lchown \"file = %s, to_uid = %d, to_gid = %d, from_uid = %d\", arg1, arg2, arg3, $uid'\nPID    TID    COMM         FUNC             -\n1269255 1269255 python3.6    SyS_lchown       file = /tmp/dotsync-usisgezu/tmp, to_uid = 128203, to_gid = 100, from_uid = 128203\n1269441 1269441 zstd         SyS_chown        file = /tmp/dotsync-vic7ygj0/dotsync-package.zst, to_uid = 128203, to_gid = 100, from_uid = 128203\n1269255 1269255 python3.6    SyS_lchown       file = /tmp/dotsync-a40zd7ev/tmp, to_uid = 128203, to_gid = 100, from_uid = 128203\n1269442 1269442 zstd         SyS_chown        file = /tmp/dotsync-gzp413o_/dotsync-package.zst, to_uid = 128203, to_gid = 100, from_uid = 128203\n1269255 1269255 python3.6    SyS_lchown       file = /tmp/dotsync-whx4fivm/tmp/.bash_profile, to_uid = 128203, to_gid = 100, from_uid = 128203\n</code></pre>"},{"location":"tutorials/bcc-documents/tutorial/#example-2","title":"Example 2","text":"<p>Suppose you want to count nonvoluntary context switches (<code>nvcsw</code>) in your bpf based performance monitoring tools and you do not know what is the proper method. <code>/proc/&lt;pid&gt;/status</code> already tells you the number (<code>nonvoluntary_ctxt_switches</code>) for a pid and you can use <code>trace.py</code> to do a quick experiment to verify your method. With kernel source code, the <code>nvcsw</code> is counted at file <code>linux/kernel/sched/core.c</code> function <code>__schedule</code> and under condition <pre><code>!(!preempt &amp;&amp; prev-&gt;state) // i.e., preempt || !prev-&gt;state\n</code></pre></p> <p>The <code>__schedule</code> function is marked as <code>notrace</code>, and the best place to evaluate the above condition seems in <code>sched/sched_switch</code> tracepoint called inside function <code>__schedule</code> and defined in <code>linux/include/trace/events/sched.h</code>. <code>trace.py</code> already has <code>args</code> being the pointer to the tracepoint <code>TP_STRUCT__entry</code>.  The above condition in function <code>__schedule</code> can be represented as <pre><code>args-&gt;prev_state == TASK_STATE_MAX || args-&gt;prev_state == 0\n</code></pre></p> <p>The below command can be used to count the involuntary context switches (per process or per pid) and compare to <code>/proc/&lt;pid&gt;/status</code> or <code>/proc/&lt;pid&gt;/task/&lt;task_id&gt;/status</code> for correctness, as in typical cases, involuntary context switches are not very common. <pre><code>$ trace.py -p 1134138 't:sched:sched_switch (args-&gt;prev_state == TASK_STATE_MAX || args-&gt;prev_state == 0)'\nPID    TID    COMM         FUNC\n1134138 1134140 contention_test sched_switch\n1134138 1134142 contention_test sched_switch\n...\n$ trace.py -L 1134140 't:sched:sched_switch (args-&gt;prev_state == TASK_STATE_MAX || args-&gt;prev_state == 0)'\nPID    TID    COMM         FUNC\n1134138 1134140 contention_test sched_switch\n1134138 1134140 contention_test sched_switch\n...\n</code></pre></p>"},{"location":"tutorials/bcc-documents/tutorial/#example-3","title":"Example 3","text":"<p>This example is related to issue 1231 and 1516 where uprobe does not work at all in certain cases. First, you can do a <code>strace</code> as below</p> <pre><code>$ strace trace.py 'r:bash:readline \"%s\", retval'\n...\nperf_event_open(0x7ffd968212f0, -1, 0, -1, 0x8 /* PERF_FLAG_??? */) = -1 EIO (Input/output error)\n...\n</code></pre> <p>The <code>perf_event_open</code> syscall returns <code>-EIO</code>. Digging into kernel uprobe related codes in <code>/kernel/trace</code> and <code>/kernel/events</code> directories to search <code>EIO</code>, the function <code>uprobe_register</code> is the most suspicious. Let us find whether this function is called or not and what is the return value if it is called. In one terminal using the following command to print out the return value of uprobe_register, <pre><code>$ trace.py 'r::uprobe_register \"ret = %d\", retval'\n</code></pre> In another terminal run the same bash uretprobe tracing example, and you should get <pre><code>$ trace.py 'r::uprobe_register \"ret = %d\", retval'\nPID    TID    COMM         FUNC             -\n1041401 1041401 python2.7    uprobe_register  ret = -5\n</code></pre></p> <p>The <code>-5</code> error code is EIO. This confirms that the following code in function <code>uprobe_register</code> is the most suspicious culprit. <pre><code> if (!inode-&gt;i_mapping-&gt;a_ops-&gt;readpage &amp;&amp; !shmem_mapping(inode-&gt;i_mapping))\nreturn -EIO;\n</code></pre> The <code>shmem_mapping</code> function is defined as <pre><code>bool shmem_mapping(struct address_space *mapping)\n{\nreturn mapping-&gt;a_ops == &amp;shmem_aops;\n}\n</code></pre></p> <p>To confirm the theory, find what is <code>inode-&gt;i_mapping-&gt;a_ops</code> with the following command <pre><code>$ trace.py -I 'linux/fs.h' 'p::uprobe_register(struct inode *inode) \"a_ops = %llx\", inode-&gt;i_mapping-&gt;a_ops'\nPID    TID    COMM         FUNC             -\n814288 814288 python2.7    uprobe_register  a_ops = ffffffff81a2adc0\n^C$ grep ffffffff81a2adc0 /proc/kallsyms\nffffffff81a2adc0 R empty_aops\n</code></pre></p> <p>The kernel symbol <code>empty_aops</code> does not have <code>readpage</code> defined and hence the above suspicious condition is true. Further examining the kernel source code shows that <code>overlayfs</code> does not provide its own <code>a_ops</code> while some other file systems (e.g., ext4) define their own <code>a_ops</code> (e.g., <code>ext4_da_aops</code>), and <code>ext4_da_aops</code> defines <code>readpage</code>. Hence, uprobe works fine on ext4 while not on overlayfs.</p> <p>More examples.</p>"},{"location":"tutorials/bcc-documents/tutorial/#22-argdist","title":"2.2. argdist","text":"<p>More examples.</p>"},{"location":"tutorials/bcc-documents/tutorial/#23-funccount","title":"2.3. funccount","text":"<p>More examples.</p>"},{"location":"tutorials/bcc-documents/tutorial/#networking","title":"Networking","text":"<p>To do.</p>"},{"location":"tutorials/bcc-documents/tutorial_bcc_python_developer/","title":"bcc Python Developer Tutorial","text":"<p>This tutorial is about developing bcc tools and programs using the Python interface. There are two parts: observability then networking. Snippets are taken from various programs in bcc: see their files for licences.</p> <p>Also see the bcc developer's reference_guide.md, and a tutorial for end-users of tools: tutorial.md. There is also a lua interface for bcc.</p>"},{"location":"tutorials/bcc-documents/tutorial_bcc_python_developer/#observability","title":"Observability","text":"<p>This observability tutorial contains 17 lessons, and 46 enumerated things to learn.</p>"},{"location":"tutorials/bcc-documents/tutorial_bcc_python_developer/#lesson-1-hello-world","title":"Lesson 1. Hello World","text":"<p>Start by running examples/hello_world.py, while running some commands (eg, \"ls\") in another session. It should print \"Hello, World!\" for new processes. If not, start by fixing bcc: see INSTALL.md.</p> <pre><code># ./examples/hello_world.py\nbash-13364 [002] d... 24573433.052937: : Hello, World!\n            bash-13364 [003] d... 24573436.642808: : Hello, World!\n[...]\n</code></pre> <p>Here's the code for hello_world.py:</p> <pre><code>from bcc import BPF\nBPF(text='int kprobe__sys_clone(void *ctx) { bpf_trace_printk(\"Hello, World!\\\\n\"); return 0; }').trace_print()\n</code></pre> <p>There are six things to learn from this:</p> <ol> <li> <p><code>text='...'</code>: This defines a BPF program inline. The program is written in C.</p> </li> <li> <p><code>kprobe__sys_clone()</code>: This is a short-cut for kernel dynamic tracing via kprobes. If the C function begins with <code>kprobe__</code>, the rest is treated as a kernel function name to instrument, in this case, <code>sys_clone()</code>.</p> </li> <li> <p><code>void *ctx</code>: ctx has arguments, but since we aren't using them here, we'll just cast it to <code>void *</code>.</p> </li> <li> <p><code>bpf_trace_printk()</code>: A simple kernel facility for printf() to the common trace_pipe (/sys/kernel/debug/tracing/trace_pipe). This is ok for some quick examples, but has limitations: 3 args max, 1 %s only, and trace_pipe is globally shared, so concurrent programs will have clashing output. A better interface is via BPF_PERF_OUTPUT(), covered later.</p> </li> <li> <p><code>return 0;</code>: Necessary formality (if you want to know why, see #139).</p> </li> <li> <p><code>.trace_print()</code>: A bcc routine that reads trace_pipe and prints the output.</p> </li> </ol>"},{"location":"tutorials/bcc-documents/tutorial_bcc_python_developer/#lesson-2-sys_sync","title":"Lesson 2. sys_sync()","text":"<p>Write a program that traces the sys_sync() kernel function. Print \"sys_sync() called\" when it runs. Test by running <code>sync</code> in another session while tracing. The hello_world.py program has everything you need for this.</p> <p>Improve it by printing \"Tracing sys_sync()... Ctrl-C to end.\" when the program first starts. Hint: it's just Python.</p>"},{"location":"tutorials/bcc-documents/tutorial_bcc_python_developer/#lesson-3-hello_fieldspy","title":"Lesson 3. hello_fields.py","text":"<p>This program is in examples/tracing/hello_fields.py. Sample output (run commands in another session):</p> <pre><code># examples/tracing/hello_fields.py\nTIME(s)            COMM             PID    MESSAGE\n24585001.174885999 sshd             1432   Hello, World!\n24585001.195710000 sshd             15780  Hello, World!\n24585001.991976000 systemd-udevd    484    Hello, World!\n24585002.276147000 bash             15787  Hello, World!\n</code></pre> <p>Code:</p> <pre><code>from bcc import BPF\n# define BPF program\nprog = \"\"\"\nint hello(void *ctx) {\n    bpf_trace_printk(\"Hello, World!\\\\n\");\n    return 0;\n}\n\"\"\"\n# load BPF program\nb = BPF(text=prog)\nb.attach_kprobe(event=b.get_syscall_fnname(\"clone\"), fn_name=\"hello\")\n# header\nprint(\"%-18s %-16s %-6s %s\" % (\"TIME(s)\", \"COMM\", \"PID\", \"MESSAGE\"))\n# format output\nwhile 1:\ntry:\n(task, pid, cpu, flags, ts, msg) = b.trace_fields()\nexcept ValueError:\ncontinue\nprint(\"%-18.9f %-16s %-6d %s\" % (ts, task, pid, msg))\n</code></pre> <p>This is similar to hello_world.py, and traces new processes via sys_clone() again, but has a few more things to learn:</p> <ol> <li> <p><code>prog =</code>: This time we declare the C program as a variable, and later refer to it. This is useful if you want to add some string substitutions based on command line arguments.</p> </li> <li> <p><code>hello()</code>: Now we're just declaring a C function, instead of the <code>kprobe__</code> shortcut. We'll refer to this later. All C functions declared in the BPF program are expected to be executed on a probe, hence they all need to take a <code>pt_reg* ctx</code> as first argument. If you need to define some helper function that will not be executed on a probe, they need to be defined as <code>static inline</code> in order to be inlined by the compiler. Sometimes you would also need to add <code>_always_inline</code> function attribute to it.</p> </li> <li> <p><code>b.attach_kprobe(event=b.get_syscall_fnname(\"clone\"), fn_name=\"hello\")</code>: Creates a kprobe for the kernel clone system call function, which will execute our defined hello() function. You can call attach_kprobe() more than once, and attach your C function to multiple kernel functions.</p> </li> <li> <p><code>b.trace_fields()</code>: Returns a fixed set of fields from trace_pipe. Similar to trace_print(), this is handy for hacking, but for real tooling we should switch to BPF_PERF_OUTPUT().</p> </li> </ol>"},{"location":"tutorials/bcc-documents/tutorial_bcc_python_developer/#lesson-4-sync_timingpy","title":"Lesson 4. sync_timing.py","text":"<p>Remember the days of sysadmins typing <code>sync</code> three times on a slow console before <code>reboot</code>, to give the first asynchronous sync time to complete? Then someone thought <code>sync;sync;sync</code> was clever, to run them all on one line, which became industry practice despite defeating the original purpose! And then sync became synchronous, so more reasons it was silly. Anyway.</p> <p>The following example times how quickly the <code>do_sync</code> function is called, and prints output if it has been called more recently than one second ago. A <code>sync;sync;sync</code> will print output for the 2nd and 3rd sync's:</p> <pre><code># examples/tracing/sync_timing.py\nTracing for quick sync's... Ctrl-C to end\nAt time 0.00 s: multiple syncs detected, last 95 ms ago\nAt time 0.10 s: multiple syncs detected, last 96 ms ago\n</code></pre> <p>This program is examples/tracing/sync_timing.py:</p> <pre><code>from __future__ import print_function\nfrom bcc import BPF\n# load BPF program\nb = BPF(text=\"\"\"\n#include &lt;uapi/linux/ptrace.h&gt;\nBPF_HASH(last);\nint do_trace(struct pt_regs *ctx) {\n    u64 ts, *tsp, delta, key = 0;\n    // attempt to read stored timestamp\n    tsp = last.lookup(&amp;key);\n    if (tsp != NULL) {\n        delta = bpf_ktime_get_ns() - *tsp;\n        if (delta &lt; 1000000000) {\n            // output if time is less than 1 second\n            bpf_trace_printk(\"%d\\\\n\", delta / 1000000);\n        }\n        last.delete(&amp;key);\n    }\n    // update stored timestamp\n    ts = bpf_ktime_get_ns();\n    last.update(&amp;key, &amp;ts);\n    return 0;\n}\n\"\"\")\nb.attach_kprobe(event=b.get_syscall_fnname(\"sync\"), fn_name=\"do_trace\")\nprint(\"Tracing for quick sync's... Ctrl-C to end\")\n# format output\nstart = 0\nwhile 1:\n(task, pid, cpu, flags, ts, ms) = b.trace_fields()\nif start == 0:\nstart = ts\nts = ts - start\nprint(\"At time %.2f s: multiple syncs detected, last %s ms ago\" % (ts, ms))\n</code></pre> <p>Things to learn:</p> <ol> <li><code>bpf_ktime_get_ns()</code>: Returns the time as nanoseconds.</li> <li><code>BPF_HASH(last)</code>: Creates a BPF map object that is a hash (associative array), called \"last\". We didn't specify any further arguments, so it defaults to key and value types of u64.</li> <li><code>key = 0</code>: We'll only store one key/value pair in this hash, where the key is hardwired to zero.</li> <li><code>last.lookup(&amp;key)</code>: Lookup the key in the hash, and return a pointer to its value if it exists, else NULL. We pass the key in as an address to a pointer.</li> <li><code>if (tsp != NULL) {</code>: The verifier requires that pointer values derived from a map lookup must be checked for a null value before they can be dereferenced and used.</li> <li><code>last.delete(&amp;key)</code>: Delete the key from the hash. This is currently required because of a kernel bug in <code>.update()</code> (fixed in 4.8.10).</li> <li><code>last.update(&amp;key, &amp;ts)</code>: Associate the value in the 2nd argument to the key, overwriting any previous value. This records the timestamp.</li> </ol>"},{"location":"tutorials/bcc-documents/tutorial_bcc_python_developer/#lesson-5-sync_countpy","title":"Lesson 5. sync_count.py","text":"<p>Modify the sync_timing.py program (prior lesson) to store the count of all kernel sync system calls (both fast and slow), and print it with the output. This count can be recorded in the BPF program by adding a new key index to the existing hash.</p>"},{"location":"tutorials/bcc-documents/tutorial_bcc_python_developer/#lesson-6-disksnooppy","title":"Lesson 6. disksnoop.py","text":"<p>Browse the examples/tracing/disksnoop.py program to see what is new. Here is some sample output:</p> <pre><code># disksnoop.py\nTIME(s)            T  BYTES    LAT(ms)\n16458043.436012    W  4096        3.13\n16458043.437326    W  4096        4.44\n16458044.126545    R  4096       42.82\n16458044.129872    R  4096        3.24\n[...]\n</code></pre> <p>And a code snippet:</p> <pre><code>[...]\nREQ_WRITE = 1       # from include/linux/blk_types.h\n# load BPF program\nb = BPF(text=\"\"\"\n#include &lt;uapi/linux/ptrace.h&gt;\n#include &lt;linux/blk-mq.h&gt;\nBPF_HASH(start, struct request *);\nvoid trace_start(struct pt_regs *ctx, struct request *req) {\n    // stash start timestamp by request ptr\n    u64 ts = bpf_ktime_get_ns();\n    start.update(&amp;req, &amp;ts);\n}\nvoid trace_completion(struct pt_regs *ctx, struct request *req) {\n    u64 *tsp, delta;\n    tsp = start.lookup(&amp;req);\n    if (tsp != 0) {\n        delta = bpf_ktime_get_ns() - *tsp;\n        bpf_trace_printk(\"%d %x %d\\\\n\", req-&gt;__data_len,\n            req-&gt;cmd_flags, delta / 1000);\n        start.delete(&amp;req);\n    }\n}\n\"\"\")\nif BPF.get_kprobe_functions(b'blk_start_request'):\nb.attach_kprobe(event=\"blk_start_request\", fn_name=\"trace_start\")\nb.attach_kprobe(event=\"blk_mq_start_request\", fn_name=\"trace_start\")\nif BPF.get_kprobe_functions(b'__blk_account_io_done'):\nb.attach_kprobe(event=\"__blk_account_io_done\", fn_name=\"trace_completion\")\nelse:\nb.attach_kprobe(event=\"blk_account_io_done\", fn_name=\"trace_completion\")\n[...]\n</code></pre> <p>Things to learn:</p> <ol> <li><code>REQ_WRITE</code>: We're defining a kernel constant in the Python program because we'll use it there later. If we were using REQ_WRITE in the BPF program, it should just work (without needing to be defined) with the appropriate #includes.</li> <li><code>trace_start(struct pt_regs *ctx, struct request *req)</code>: This function will later be attached to kprobes. The arguments to kprobe functions are <code>struct pt_regs *ctx</code>, for registers and BPF context, and then the actual arguments to the function. We'll attach this to blk_start_request(), where the first argument is <code>struct request *</code>.</li> <li><code>start.update(&amp;req, &amp;ts)</code>: We're using the pointer to the request struct as a key in our hash. What? This is commonplace in tracing. Pointers to structs turn out to be great keys, as they are unique: two structs can't have the same pointer address. (Just be careful about when it gets free'd and reused.) So what we're really doing is tagging the request struct, which describes the disk I/O, with our own timestamp, so that we can time it. There's two common keys used for storing timestamps: pointers to structs, and, thread IDs (for timing function entry to return).</li> <li><code>req-&gt;__data_len</code>: We're dereferencing members of <code>struct request</code>. See its definition in the kernel source for what members are there. bcc actually rewrites these expressions to be a series of <code>bpf_probe_read_kernel()</code> calls. Sometimes bcc can't handle a complex dereference, and you need to call <code>bpf_probe_read_kernel()</code> directly.</li> </ol> <p>This is a pretty interesting program, and if you can understand all the code, you'll understand many important basics. We're still using the bpf_trace_printk() hack, so let's fix that next.</p>"},{"location":"tutorials/bcc-documents/tutorial_bcc_python_developer/#lesson-7-hello_perf_outputpy","title":"Lesson 7. hello_perf_output.py","text":"<p>Let's finally stop using bpf_trace_printk() and use the proper BPF_PERF_OUTPUT() interface. This will also mean we stop getting the free trace_field() members like PID and timestamp, and will need to fetch them directly. Sample output while commands are run in another session:</p> <pre><code># hello_perf_output.py\nTIME(s)            COMM             PID    MESSAGE\n0.000000000        bash             22986  Hello, perf_output!\n0.021080275        systemd-udevd    484    Hello, perf_output!\n0.021359520        systemd-udevd    484    Hello, perf_output!\n0.021590610        systemd-udevd    484    Hello, perf_output!\n[...]\n</code></pre> <p>Code is examples/tracing/hello_perf_output.py:</p> <pre><code>from bcc import BPF\n# define BPF program\nprog = \"\"\"\n#include &lt;linux/sched.h&gt;\n// define output data structure in C\nstruct data_t {\n    u32 pid;\n    u64 ts;\n    char comm[TASK_COMM_LEN];\n};\nBPF_PERF_OUTPUT(events);\nint hello(struct pt_regs *ctx) {\n    struct data_t data = {};\n    data.pid = bpf_get_current_pid_tgid();\n    data.ts = bpf_ktime_get_ns();\n    bpf_get_current_comm(&amp;data.comm, sizeof(data.comm));\n    events.perf_submit(ctx, &amp;data, sizeof(data));\n    return 0;\n}\n\"\"\"\n# load BPF program\nb = BPF(text=prog)\nb.attach_kprobe(event=b.get_syscall_fnname(\"clone\"), fn_name=\"hello\")\n# header\nprint(\"%-18s %-16s %-6s %s\" % (\"TIME(s)\", \"COMM\", \"PID\", \"MESSAGE\"))\n# process event\nstart = 0\ndef print_event(cpu, data, size):\nglobal start\nevent = b[\"events\"].event(data)\nif start == 0:\nstart = event.ts\ntime_s = (float(event.ts - start)) / 1000000000\nprint(\"%-18.9f %-16s %-6d %s\" % (time_s, event.comm, event.pid,\n\"Hello, perf_output!\"))\n# loop with callback to print_event\nb[\"events\"].open_perf_buffer(print_event)\nwhile 1:\nb.perf_buffer_poll()\n</code></pre> <p>Things to learn:</p> <ol> <li><code>struct data_t</code>: This defines the C struct we'll use to pass data from kernel to user space.</li> <li><code>BPF_PERF_OUTPUT(events)</code>: This names our output channel \"events\".</li> <li><code>struct data_t data = {};</code>: Create an empty data_t struct that we'll then populate.</li> <li><code>bpf_get_current_pid_tgid()</code>: Returns the process ID in the lower 32 bits (kernel's view of the PID, which in user space is usually presented as the thread ID), and the thread group ID in the upper 32 bits (what user space often thinks of as the PID). By directly setting this to a u32, we discard the upper 32 bits. Should you be presenting the PID or the TGID? For a multi-threaded app, the TGID will be the same, so you need the PID to differentiate them, if that's what you want. It's also a question of expectations for the end user.</li> <li><code>bpf_get_current_comm()</code>: Populates the first argument address with the current process name.</li> <li><code>events.perf_submit()</code>: Submit the event for user space to read via a perf ring buffer.</li> <li><code>def print_event()</code>: Define a Python function that will handle reading events from the <code>events</code> stream.</li> <li><code>b[\"events\"].event(data)</code>: Now get the event as a Python object, auto-generated from the C declaration.</li> <li><code>b[\"events\"].open_perf_buffer(print_event)</code>: Associate the Python <code>print_event</code> function with the <code>events</code> stream.</li> <li><code>while 1: b.perf_buffer_poll()</code>: Block waiting for events.</li> </ol>"},{"location":"tutorials/bcc-documents/tutorial_bcc_python_developer/#lesson-8-sync_perf_outputpy","title":"Lesson 8. sync_perf_output.py","text":"<p>Rewrite sync_timing.py, from a prior lesson, to use <code>BPF_PERF_OUTPUT</code>.</p>"},{"location":"tutorials/bcc-documents/tutorial_bcc_python_developer/#lesson-9-bitehistpy","title":"Lesson 9. bitehist.py","text":"<p>The following tool records a histogram of disk I/O sizes. Sample output:</p> <pre><code># bitehist.py\nTracing... Hit Ctrl-C to end.\n^C\n     kbytes          : count     distribution\n       0 -&gt; 1        : 3        |                                      |\n2 -&gt; 3        : 0        |                                      |\n4 -&gt; 7        : 211      |**********                            |\n8 -&gt; 15       : 0        |                                      |\n16 -&gt; 31       : 0        |                                      |\n32 -&gt; 63       : 0        |                                      |\n64 -&gt; 127      : 1        |                                      |\n128 -&gt; 255      : 800      |**************************************|\n</code></pre> <p>Code is examples/tracing/bitehist.py:</p> <pre><code>from __future__ import print_function\nfrom bcc import BPF\nfrom time import sleep\n# load BPF program\nb = BPF(text=\"\"\"\n#include &lt;uapi/linux/ptrace.h&gt;\n#include &lt;linux/blkdev.h&gt;\nBPF_HISTOGRAM(dist);\nint kprobe__blk_account_io_done(struct pt_regs *ctx, struct request *req)\n{\n    dist.increment(bpf_log2l(req-&gt;__data_len / 1024));\n    return 0;\n}\n\"\"\")\n# header\nprint(\"Tracing... Hit Ctrl-C to end.\")\n# trace until Ctrl-C\ntry:\nsleep(99999999)\nexcept KeyboardInterrupt:\nprint()\n# output\nb[\"dist\"].print_log2_hist(\"kbytes\")\n</code></pre> <p>A recap from earlier lessons:</p> <ul> <li><code>kprobe__</code>: This prefix means the rest will be treated as a kernel function name that will be instrumented using kprobe.</li> <li><code>struct pt_regs *ctx, struct request *req</code>: Arguments to kprobe. The <code>ctx</code> is registers and BPF context, the <code>req</code> is the first argument to the instrumented function: <code>blk_account_io_done()</code>.</li> <li><code>req-&gt;__data_len</code>: Dereferencing that member.</li> </ul> <p>New things to learn:</p> <ol> <li><code>BPF_HISTOGRAM(dist)</code>: Defines a BPF map object that is a histogram, and names it \"dist\".</li> <li><code>dist.increment()</code>: Increments the histogram bucket index provided as first argument by one by default. Optionally, custom increments can be passed as the second argument.</li> <li><code>bpf_log2l()</code>: Returns the log-2 of the provided value. This becomes the index of our histogram, so that we're constructing a power-of-2 histogram.</li> <li><code>b[\"dist\"].print_log2_hist(\"kbytes\")</code>: Prints the \"dist\" histogram as power-of-2, with a column header of \"kbytes\". The only data transferred from kernel to user space is the bucket counts, making this efficient.</li> </ol>"},{"location":"tutorials/bcc-documents/tutorial_bcc_python_developer/#lesson-10-disklatencypy","title":"Lesson 10. disklatency.py","text":"<p>Write a program that times disk I/O, and prints a histogram of their latency. Disk I/O instrumentation and timing can be found in the disksnoop.py program from a prior lesson, and histogram code can be found in bitehist.py from a prior lesson.</p>"},{"location":"tutorials/bcc-documents/tutorial_bcc_python_developer/#lesson-11-vfsreadlatpy","title":"Lesson 11. vfsreadlat.py","text":"<p>This example is split into separate Python and C files. Example output:</p> <pre><code># vfsreadlat.py 1\nTracing... Hit Ctrl-C to end.\n     usecs               : count     distribution\n         0 -&gt; 1          : 0        |                                        |\n2 -&gt; 3          : 2        |***********                             |\n4 -&gt; 7          : 7        |****************************************|\n8 -&gt; 15         : 4        |**********************                  |\nusecs               : count     distribution\n         0 -&gt; 1          : 29       |****************************************|\n2 -&gt; 3          : 28       |**************************************  |\n4 -&gt; 7          : 4        |*****                                   |\n8 -&gt; 15         : 8        |***********                             |\n16 -&gt; 31         : 0        |                                        |\n32 -&gt; 63         : 0        |                                        |\n64 -&gt; 127        : 0        |                                        |\n128 -&gt; 255        : 0        |                                        |\n256 -&gt; 511        : 2        |**                                      |\n512 -&gt; 1023       : 0        |                                        |\n1024 -&gt; 2047       : 0        |                                        |\n2048 -&gt; 4095       : 0        |                                        |\n4096 -&gt; 8191       : 4        |*****                                   |\n8192 -&gt; 16383      : 6        |********                                |\n16384 -&gt; 32767      : 9        |************                            |\n32768 -&gt; 65535      : 6        |********                                |\n65536 -&gt; 131071     : 2        |**                                      |\nusecs               : count     distribution\n         0 -&gt; 1          : 11       |****************************************|\n2 -&gt; 3          : 2        |*******                                 |\n4 -&gt; 7          : 10       |************************************    |\n8 -&gt; 15         : 8        |*****************************           |\n16 -&gt; 31         : 1        |***                                     |\n32 -&gt; 63         : 2        |*******                                 |\n[...]\n</code></pre> <p>Browse the code in examples/tracing/vfsreadlat.py and examples/tracing/vfsreadlat.c. Things to learn:</p> <ol> <li><code>b = BPF(src_file = \"vfsreadlat.c\")</code>: Read the BPF C program from a separate source file.</li> <li><code>b.attach_kretprobe(event=\"vfs_read\", fn_name=\"do_return\")</code>: Attaches the BPF C function <code>do_return()</code> to the return of the kernel function <code>vfs_read()</code>. This is a kretprobe: instrumenting the return from a function, rather than its entry.</li> <li><code>b[\"dist\"].clear()</code>: Clears the histogram.</li> </ol>"},{"location":"tutorials/bcc-documents/tutorial_bcc_python_developer/#lesson-12-urandomreadpy","title":"Lesson 12. urandomread.py","text":"<p>Tracing while a <code>dd if=/dev/urandom of=/dev/null bs=8k count=5</code> is run:</p> <pre><code># urandomread.py\nTIME(s)            COMM             PID    GOTBITS\n24652832.956994001 smtp             24690  384\n24652837.726500999 dd               24692  65536\n24652837.727111001 dd               24692  65536\n24652837.727703001 dd               24692  65536\n24652837.728294998 dd               24692  65536\n24652837.728888001 dd               24692  65536\n</code></pre> <p>Hah! I caught smtp by accident. Code is examples/tracing/urandomread.py:</p> <pre><code>from __future__ import print_function\nfrom bcc import BPF\n# load BPF program\nb = BPF(text=\"\"\"\nTRACEPOINT_PROBE(random, urandom_read) {\n    // args is from /sys/kernel/debug/tracing/events/random/urandom_read/format\n    bpf_trace_printk(\"%d\\\\n\", args-&gt;got_bits);\n    return 0;\n}\n\"\"\")\n# header\nprint(\"%-18s %-16s %-6s %s\" % (\"TIME(s)\", \"COMM\", \"PID\", \"GOTBITS\"))\n# format output\nwhile 1:\ntry:\n(task, pid, cpu, flags, ts, msg) = b.trace_fields()\nexcept ValueError:\ncontinue\nprint(\"%-18.9f %-16s %-6d %s\" % (ts, task, pid, msg))\n</code></pre> <p>Things to learn:</p> <ol> <li><code>TRACEPOINT_PROBE(random, urandom_read)</code>: Instrument the kernel tracepoint <code>random:urandom_read</code>. These have a stable API, and thus are recommend to use instead of kprobes, wherever possible. You can run <code>perf list</code> for a list of tracepoints. Linux &gt;= 4.7 is required to attach BPF programs to tracepoints.</li> <li><code>args-&gt;got_bits</code>: <code>args</code> is auto-populated to be a structure of the tracepoint arguments. The comment above says where you can see that structure. Eg:</li> </ol> <pre><code># cat /sys/kernel/debug/tracing/events/random/urandom_read/format\nname: urandom_read\nID: 972\nformat:\n    field:unsigned short common_type;   offset:0;   size:2; signed:0;\nfield:unsigned char common_flags;   offset:2;   size:1; signed:0;\nfield:unsigned char common_preempt_count;   offset:3;   size:1; signed:0;\nfield:int common_pid;   offset:4;   size:4; signed:1;\nfield:int got_bits; offset:8;   size:4; signed:1;\nfield:int pool_left;    offset:12;  size:4; signed:1;\nfield:int input_left;   offset:16;  size:4; signed:1;\nprint fmt: \"got_bits %d nonblocking_pool_entropy_left %d input_entropy_left %d\", REC-&gt;got_bits, REC-&gt;pool_left, REC-&gt;input_left\n</code></pre> <p>In this case, we were printing the <code>got_bits</code> member.</p>"},{"location":"tutorials/bcc-documents/tutorial_bcc_python_developer/#lesson-13-disksnooppy-fixed","title":"Lesson 13. disksnoop.py fixed","text":"<p>Convert disksnoop.py from a previous lesson to use the <code>block:block_rq_issue</code> and <code>block:block_rq_complete</code> tracepoints.</p>"},{"location":"tutorials/bcc-documents/tutorial_bcc_python_developer/#lesson-14-strlen_countpy","title":"Lesson 14. strlen_count.py","text":"<p>This program instruments a user-level function, the <code>strlen()</code> library function, and frequency counts its string argument. Example output:</p> <pre><code># strlen_count.py\nTracing strlen()... Hit Ctrl-C to end.\n^C     COUNT STRING\n         1 \" \"\n1 \"/bin/ls\"\n1 \".\"\n1 \"cpudist.py.1\"\n1 \".bashrc\"\n1 \"ls --color=auto\"\n1 \"key_t\"\n[...]\n10 \"a7:~# \"\n10 \"/root\"\n12 \"LC_ALL\"\n12 \"en_US.UTF-8\"\n13 \"en_US.UTF-8\"\n20 \"~\"\n70 \"#%^,~:-=?+/}\"\n340 \"\\x01\\x1b]0;root@bgregg-test: ~\\x07\\x02root@bgregg-test:~# \"\n</code></pre> <p>These are various strings that are being processed by this library function while tracing, along with their frequency counts. <code>strlen()</code> was called on \"LC_ALL\" 12 times, for example.</p> <p>Code is examples/tracing/strlen_count.py:</p> <pre><code>from __future__ import print_function\nfrom bcc import BPF\nfrom time import sleep\n# load BPF program\nb = BPF(text=\"\"\"\n#include &lt;uapi/linux/ptrace.h&gt;\nstruct key_t {\n    char c[80];\n};\nBPF_HASH(counts, struct key_t);\nint count(struct pt_regs *ctx) {\n    if (!PT_REGS_PARM1(ctx))\n        return 0;\n    struct key_t key = {};\n    u64 zero = 0, *val;\n    bpf_probe_read_user(&amp;key.c, sizeof(key.c), (void *)PT_REGS_PARM1(ctx));\n    // could also use `counts.increment(key)`\n    val = counts.lookup_or_try_init(&amp;key, &amp;zero);\n    if (val) {\n      (*val)++;\n    }\n    return 0;\n};\n\"\"\")\nb.attach_uprobe(name=\"c\", sym=\"strlen\", fn_name=\"count\")\n# header\nprint(\"Tracing strlen()... Hit Ctrl-C to end.\")\n# sleep until Ctrl-C\ntry:\nsleep(99999999)\nexcept KeyboardInterrupt:\npass\n# print output\nprint(\"%10s %s\" % (\"COUNT\", \"STRING\"))\ncounts = b.get_table(\"counts\")\nfor k, v in sorted(counts.items(), key=lambda counts: counts[1].value):\nprint(\"%10d \\\"%s\\\"\" % (v.value, k.c.encode('string-escape')))\n</code></pre> <p>Things to learn:</p> <ol> <li><code>PT_REGS_PARM1(ctx)</code>: This fetches the first argument to <code>strlen()</code>, which is the string.</li> <li><code>b.attach_uprobe(name=\"c\", sym=\"strlen\", fn_name=\"count\")</code>: Attach to library \"c\" (if this is the main program, use its pathname), instrument the user-level function <code>strlen()</code>, and on execution call our C function <code>count()</code>.</li> </ol>"},{"location":"tutorials/bcc-documents/tutorial_bcc_python_developer/#lesson-15-nodejs_http_serverpy","title":"Lesson 15. nodejs_http_server.py","text":"<p>This program instruments a user statically-defined tracing (USDT) probe, which is the user-level version of a kernel tracepoint. Sample output:</p> <pre><code># nodejs_http_server.py 24728\nTIME(s)            COMM             PID    ARGS\n24653324.561322998 node             24728  path:/index.html\n24653335.343401998 node             24728  path:/images/welcome.png\n24653340.510164998 node             24728  path:/images/favicon.png\n</code></pre> <p>Relevant code from examples/tracing/nodejs_http_server.py:</p> <pre><code>from __future__ import print_function\nfrom bcc import BPF, USDT\nimport sys\nif len(sys.argv) &lt; 2:\nprint(\"USAGE: nodejs_http_server PID\")\nexit()\npid = sys.argv[1]\ndebug = 0\n# load BPF program\nbpf_text = \"\"\"\n#include &lt;uapi/linux/ptrace.h&gt;\nint do_trace(struct pt_regs *ctx) {\n    uint64_t addr;\n    char path[128]={0};\n    bpf_usdt_readarg(6, ctx, &amp;addr);\n    bpf_probe_read_user(&amp;path, sizeof(path), (void *)addr);\n    bpf_trace_printk(\"path:%s\\\\n\", path);\n    return 0;\n};\n\"\"\"\n# enable USDT probe from given PID\nu = USDT(pid=int(pid))\nu.enable_probe(probe=\"http__server__request\", fn_name=\"do_trace\")\nif debug:\nprint(u.get_text())\nprint(bpf_text)\n# initialize BPF\nb = BPF(text=bpf_text, usdt_contexts=[u])\n</code></pre> <p>Things to learn:</p> <ol> <li><code>bpf_usdt_readarg(6, ctx, &amp;addr)</code>: Read the address of argument 6 from the USDT probe into <code>addr</code>.</li> <li><code>bpf_probe_read_user(&amp;path, sizeof(path), (void *)addr)</code>: Now the string <code>addr</code> points to into our <code>path</code> variable.</li> <li><code>u = USDT(pid=int(pid))</code>: Initialize USDT tracing for the given PID.</li> <li><code>u.enable_probe(probe=\"http__server__request\", fn_name=\"do_trace\")</code>: Attach our <code>do_trace()</code> BPF C function to the Node.js <code>http__server__request</code> USDT probe.</li> <li><code>b = BPF(text=bpf_text, usdt_contexts=[u])</code>: Need to pass in our USDT object, <code>u</code>, to BPF object creation.</li> </ol>"},{"location":"tutorials/bcc-documents/tutorial_bcc_python_developer/#lesson-16-task_switchc","title":"Lesson 16. task_switch.c","text":"<p>This is an older tutorial included as a bonus lesson. Use this for recap and to reinforce what you've already learned.</p> <p>This is a slightly more complex tracing example than Hello World. This program will be invoked for every task change in the kernel, and record in a BPF map the new and old pids.</p> <p>The C program below introduces a new concept: the prev argument. This argument is treated specially by the BCC frontend, such that accesses to this variable are read from the saved context that is passed by the kprobe infrastructure. The prototype of the args starting from position 1 should match the prototype of the kernel function being kprobed. If done so, the program will have seamless access to the function parameters.</p> <pre><code>#include &lt;uapi/linux/ptrace.h&gt;\n#include &lt;linux/sched.h&gt;\nstruct key_t {\nu32 prev_pid;\nu32 curr_pid;\n};\nBPF_HASH(stats, struct key_t, u64, 1024);\nint count_sched(struct pt_regs *ctx, struct task_struct *prev) {\nstruct key_t key = {};\nu64 zero = 0, *val;\nkey.curr_pid = bpf_get_current_pid_tgid();\nkey.prev_pid = prev-&gt;pid;\n// could also use `stats.increment(key);`\nval = stats.lookup_or_try_init(&amp;key, &amp;zero);\nif (val) {\n(*val)++;\n}\nreturn 0;\n}\n</code></pre> <p>The userspace component loads the file shown above, and attaches it to the <code>finish_task_switch</code> kernel function. The <code>[]</code> operator of the BPF object gives access to each BPF_HASH in the program, allowing pass-through access to the values residing in the kernel. Use the object as you would any other python dict object: read, update, and deletes are all allowed. <pre><code>from bcc import BPF\nfrom time import sleep\nb = BPF(src_file=\"task_switch.c\")\nb.attach_kprobe(event=\"finish_task_switch\", fn_name=\"count_sched\")\n# generate many schedule events\nfor i in range(0, 100): sleep(0.01)\nfor k, v in b[\"stats\"].items():\nprint(\"task_switch[%5d-&gt;%5d]=%u\" % (k.prev_pid, k.curr_pid, v.value))\n</code></pre></p> <p>These programs can be found in the files examples/tracing/task_switch.c and examples/tracing/task_switch.py respectively.</p>"},{"location":"tutorials/bcc-documents/tutorial_bcc_python_developer/#lesson-17-further-study","title":"Lesson 17. Further Study","text":"<p>For further study, see Sasha Goldshtein's linux-tracing-workshop, which contains additional labs. There are also many tools in bcc /tools to study.</p> <p>Please read CONTRIBUTING-SCRIPTS.md if you wish to contribute tools to bcc. At the bottom of the main README.md, you'll also find methods for contacting us. Good luck, and happy tracing!</p>"},{"location":"tutorials/bcc-documents/tutorial_bcc_python_developer/#networking","title":"Networking","text":"<p>To do.</p>"},{"location":"wasm-bpf/wasm-bpf/","title":"\ud83d\udce6 Wasm-bpf: Wasm library and toolchain for eBPF","text":"<p>\u4e2d\u6587\u6587\u6863 Gitee Github</p> <p><code>Wasm-bpf</code> is a WebAssembly eBPF library, toolchain and runtime powered by CO-RE(Compile Once \u2013 Run Everywhere) libbpf. It can help you build almost every eBPF programs or usecases to <code>Wasm</code> with nearly zero modification, and run them cross platforms with Wasm sandbox.</p>"},{"location":"wasm-bpf/wasm-bpf/#introduction","title":"Introduction","text":"<p><code>WebAssembly</code> (Wasm) is a portable binary format for executable code. The code is executed at a nearly-native speed in a memory-safe (for host) sandbox, with clearly defined resource constraints, and APIs for communicating with the embedding host environment (eg. proxy).The <code>wasm-bpf</code> project combines Wasm and eBPF technologies to enhance the performance and programmability of eBPF applications.</p> <p>With <code>wasm-bpf</code>, users can dynamically load and securely execute user-defined or community-contributed Wasm-eBPF codes as <code>plug-ins</code> in their software products, such as observability platforms or service proxy. This enables efficient and scalable data collection, while also allowing for advanced processing and analysis of that data.</p> <p>It also enables developers to write eBPF programs in familiar languages like <code>C/C++</code>, <code>Rust</code>, <code>Go</code>, and more than 30 other programming languages, and deploy them easily across different Linux distributions. Additionally, cloud providers can leverage wasm-bpf to offer a <code>secure</code> and <code>high-performance</code> environment for their customers to develop and deploy eBPF applications in their cloud environments.</p>"},{"location":"wasm-bpf/wasm-bpf/#features","title":"Features","text":"<ul> <li><code>General purpose</code>: provide most abilities from eBPF to Wasm, <code>polling</code> from the ring buffer or perf buffer, bidirectional communications between <code>kernel</code> eBPF and <code>userspace</code> Wasm using <code>maps</code>, dynamically <code>loading</code>, <code>attaching</code> or <code>detaching</code>, etc. Supports a large number of eBPF program types and map types.</li> <li><code>High performance</code>: No <code>serialization</code> overhead for complex data types, using <code>shared memory</code> to avoid copy overhead between host and Wasm.</li> <li><code>Easy to use</code>: provide a similar developing experience as the libbpf-bootstrap, <code>auto generate</code> the Wasm-eBPF skeleton headers and type definitions for bindings. Write your eBPF programs in <code>C/C++</code>, <code>Rust</code>, <code>Go</code> and compile to Wasm.</li> <li><code>Ultralightweight</code>: the minimal runtime has only <code>1.5 MB</code> in binary size. Compiled Wasm module would be only <code>~90K</code>. With the same toolchain, you can easily build your own Wasm-eBPF runtime in any languages and platforms!</li> </ul> <p>See the examples directory for examples of eBPF programs written in C, Rust, Go and compiled to Wasm, covering the use cases from <code>tracing</code>, <code>networking</code> to <code>security</code>.</p> <p>For tools to distribute Wasm-eBPF programs in <code>OCI</code> images, please refer to eunomia-bpf repo.</p>"}]}